# **3. Timer (정밀 시간 및 PWM 제어)**

## 3.1 기본 타이머 개념

- ## Prescaler, ARR, CNT 구조

  ### **1. 개요**

  STM32의 **Timer(타이머)** 는 시간, 주기, 주파수, PWM 제어 등
   정확한 시간 제어를 담당하는 **하드웨어 카운터(하드웨어 시계)** 이다.

  타이머는 크게 다음 세 개의 핵심 레지스터로 동작이 결정된다.

  | 구성요소 | 이름                 | 역할                                  |
  | -------- | -------------------- | ------------------------------------- |
  | **PSC**  | Prescaler            | 입력 클록 분주 (속도 조절)            |
  | **ARR**  | Auto-Reload Register | 타이머 주기 설정 (카운터가 도달할 값) |
  | **CNT**  | Counter              | 현재 카운트 값 (실시간 증가/감소)     |

  이 세 요소가 **타이머의 주기, 분해능, 인터럽트 속도, PWM 주파수** 등을 결정한다.

  ------

  ### **2. 기본 동작 원리**

  #### **(1) 타이머 클록 흐름**

  ```
  Timer Clock (e.g., 72 MHz)
     ↓
  Prescaler (PSC)
     ↓
  Counter (CNT)
     ↓
  Auto-Reload Register (ARR)
     ↓
  Update Event (인터럽트 발생)
  ```

  #### **(2) 작동 개념**

  1. MCU의 APB1/APB2 클록이 타이머에 공급됨
  2. Prescaler가 이 클록을 나누어 타이머에 전달
  3. CNT가 매 타이머 틱마다 +1 증가 (Up Counter)
  4. CNT가 ARR 값에 도달하면 “Overflow(업데이트 이벤트)” 발생
  5. CNT는 0으로 리셋되고, 인터럽트 혹은 PWM 주기 신호 발생

  ------

  ### **3. 주요 레지스터 구조**

  #### **(1) Prescaler (PSC, 분주기)**

  - 입력 클록을 **PSC + 1** 값으로 나눈다.
  - 예를 들어 PSC = 71이면, 72MHz / (71 + 1) = **1MHz** 로 분주된다.

  | 항목   | 의미                                  |
  | ------ | ------------------------------------- |
  | 범위   | 0 ~ 65535                             |
  | 효과   | 클록 주기 조절                        |
  | 설정식 | `Timer_Clock = APB_Clock / (PSC + 1)` |

  ------

  #### **(2) Counter (CNT, 카운터)**

  - 현재 타이머의 “진행 상태”를 나타내는 레지스터
  - Up/Down/Center-Aligned 모드에 따라 값이 변화한다.

  | 모드               | 설명                                      |
  | ------------------ | ----------------------------------------- |
  | **Up Counter**     | CNT가 0 → ARR까지 증가 후 0으로 리셋      |
  | **Down Counter**   | CNT가 ARR → 0까지 감소 후 다시 ARR로 리셋 |
  | **Center-Aligned** | Up/Down 반복 (PWM 대칭파 생성용)          |

  ------

  #### **(3) Auto-Reload Register (ARR)**

  - CNT가 도달해야 하는 최댓값(주기)
  - CNT == ARR 시 “Update Event” 발생 → 인터럽트 or PWM 주기 신호 발생

  | 항목 | 의미                                       |
  | ---- | ------------------------------------------ |
  | 범위 | 0 ~ 65535 (16-bit Timer 기준)              |
  | 역할 | 타이머의 주기 설정                         |
  | 연관 | 주기 = (PSC + 1) × (ARR + 1) / Timer_Clock |

  ------

  ### **4. 전체 주기 계산식**

  타이머의 한 주기(인터럽트 또는 PWM 신호의 주기)는 다음 식으로 계산된다.
  $$
  T_{period} = \frac{(PSC + 1) \times (ARR + 1)}{f_{TIM}}
  $$

  | 항목         | 의미                          |
  | ------------ | ----------------------------- |
  | $f_{TIM}$    | 타이머 입력 클록 (예: 72 MHz) |
  | PSC          | 분주기 값                     |
  | ARR          | 자동 리로드 값                |
  | $f_{update}$ | 인터럽트 또는 PWM 주파수      |

  ------

  ### **5. 예시 계산**

  #### **(1) 목표: 1초마다 인터럽트 발생**

  - 시스템 클록: 72 MHz
  - 타이머 입력 클록: 72 MHz

  원하는 주기 = 1초
  $$
  72,000,000 = (PSC + 1) × (ARR + 1)
  $$
  → 분해:

  - PSC = 7199 (즉, 7200으로 나누기)
     ⇒ 분주 후 클록 = 10,000 Hz
  - ARR = 9999 (1초마다 오버플로우)

  $$
  주기 = (7199 + 1) × (9999 + 1) / 72,000,000 = 1s
  $$

  #### **(2) 목표: 1 kHz PWM 신호**

  - PSC = 71 → 1 MHz
  - ARR = 999 → 1 kHz 주기
     ⇒ PWM duty = CCRx / ARR

  ------

  ### **6. HAL 코드 예시**

  ```
  TIM_HandleTypeDef htim2;
  
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;             // PSC = 7199 → 72MHz / 7200 = 10kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9999;                // ARR = 9999 → 10kHz / 10000 = 1Hz
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2);           // 인터럽트 활성화
  }
  ```

  ------

  ### **7. CNT 값 실시간 확인**

  디버깅 중에 `CNT` 값을 읽으면 타이머의 현재 진행 상태를 확인할 수 있다.

  ```
  uint16_t current = __HAL_TIM_GET_COUNTER(&htim2);
  ```

  > CNT는 매 Tick마다 증가하므로, 실시간 시간 경과를 확인하거나
  >  타임스탬프용으로 활용할 수 있다.

  ------

  ### **8. 내부 타이밍 다이어그램**

  ```
  Time →
  CNT: 0 ───────→ ARR
         ↑           ↑
         │           │
        Reset ←──────┘
         │
         └── Update Event (인터럽트 발생)
  ```

  > CNT가 ARR에 도달하면 자동으로 0으로 리셋되고,
  >  **Update Event(UDEV)** 신호가 발생하여
  >  인터럽트 혹은 PWM 업데이트 이벤트를 트리거한다.

  ------

  ### **9. Up/Down/Center 모드 비교**

  | 모드               | 카운트 방향   | 주파수 효과    | PWM 파형                    |
  | ------------------ | ------------- | -------------- | --------------------------- |
  | **Up**             | 0 → ARR → 0   | 기준           | 비대칭                      |
  | **Down**           | ARR → 0 → ARR | 기준           | 비대칭                      |
  | **Center-Aligned** | 0 → ARR → 0   | 주기 2배, 대칭 | 대칭 PWM 생성 (모터 제어용) |

  ------

  ### **10. 응용 예시**

  | 응용              | 주요 설정             | 설명                   |
  | ----------------- | --------------------- | ---------------------- |
  | **Delay Timer**   | Up counter, Interrupt | 일정 시간마다 인터럽트 |
  | **PWM 제어**      | ARR, CCRx             | 듀티비 제어            |
  | **Input Capture** | CNT 값 읽기           | 외부 펄스 주기 측정    |
  | **Encoder**       | CNT + Quadrature      | 회전각 계산            |
  | **DAC 트리거**    | Update Event          | 주기적 아날로그 출력   |

  ------

  ### **11. 정리 요약**

  | 레지스터                  | 역할             | 설정 값 예 | 설명            |
  | ------------------------- | ---------------- | ---------- | --------------- |
  | **PSC (Prescaler)**       | 입력 클록 분주   | 7199       | 72MHz → 10kHz   |
  | **ARR (Auto-Reload)**     | 주기 설정        | 9999       | 10kHz → 1Hz     |
  | **CNT (Counter)**         | 현재 카운트 상태 | 실시간 값  | 0~9999 반복     |
  | **CCR (Capture/Compare)** | PWM 듀티 조절    | -          | (3.3.에서 다룸) |

  ------

  ### **12. 결론**

  `PSC`, `ARR`, `CNT`는 STM32 타이머의 기본이자 모든 시간 제어의 핵심 구조이다.
   이 세 값의 조합으로 **인터럽트 주기**, **PWM 주파수**, **정밀 Delay** 등을 자유롭게 설정할 수 있다.

  > **정리 문장:**
  >  “PSC는 속도를, ARR은 주기를, CNT는 현재 시간을 결정한다.”

  ------

  ### ✅ **핵심 요약**

  | 항목                | 내용                                  |
  | ------------------- | ------------------------------------- |
  | **Prescaler (PSC)** | 입력 클록 분주 (속도 조절기)          |
  | **ARR**             | 타이머 주기 (최댓값)                  |
  | **CNT**             | 현재 카운터 값                        |
  | **공식**            | $f = f_{TIM} / ((PSC+1) × (ARR+1))$   |
  | **기본 원리**       | CNT가 ARR에 도달 시 Update Event 발생 |
  | **활용**            | Delay, PWM, 인터럽트, 시간 측정 등    |

- ## Up/Down 카운터

  ### **1. 개요**

  STM32의 **타이머 카운터(Counter, CNT)** 는 기본적으로
   “값을 증가시키거나(Up)” 혹은 “감소시키는(Down)” 방식으로 동작한다.

  이 **카운팅 방향(mode)** 에 따라 타이머의 주기, PWM 파형 형태, 인터럽트 발생 시점이 달라진다.

  ------

  ### **2. 카운터 모드 종류**

  | 모드                       | 설정 값                            | 동작 방향        | 특징                             |
  | -------------------------- | ---------------------------------- | ---------------- | -------------------------------- |
  | **Up Counter**             | `TIM_COUNTERMODE_UP`               | 0 → ARR까지 증가 | 가장 기본적인 모드               |
  | **Down Counter**           | `TIM_COUNTERMODE_DOWN`             | ARR → 0까지 감소 | PWM 대칭 신호에 활용             |
  | **Center-Aligned Counter** | `TIM_COUNTERMODE_CENTERALIGNED1~3` | 0↔ARR 왕복       | 모터 제어나 인버터용 대칭파 생성 |

  ------

  ### **3. Up Counter 모드**

  #### **(1) 동작 구조**

  ```
  CNT: 0 → 1 → 2 → ... → ARR → 0 → 1 → 2 ...
  ```

  - CNT는 0부터 증가하며,
  - **CNT == ARR**이 되면 “Update Event(인터럽트 발생)” 후 0으로 리셋된다.
  - `ARR` 값에 따라 **주기(T)** 결정.

  #### **(2) 특징**

  | 항목               | 설명                                  |
  | ------------------ | ------------------------------------- |
  | 인터럽트 발생 시점 | CNT == ARR                            |
  | 방향               | 증가 (0 → ARR)                        |
  | PWM 출력           | 상승 구간에서만 동작                  |
  | 활용               | Delay, 주기적 인터럽트, PWM 기본 파형 |

  #### **(3) 예시 다이어그램**

  ```
  CNT: 0 ─────▶ ARR ─────▶ 0 ─────▶ ARR ...
           ↑
           │
     Update Event (인터럽트 발생)
  ```

  ------

  ### **4. Down Counter 모드**

  #### **(1) 동작 구조**

  ```
  CNT: ARR → ARR-1 → ... → 0 → ARR → ARR-1 ...
  ```

  - CNT는 **ARR부터 0까지 감소**한다.
  - CNT가 0에 도달하면 **Update Event 발생 후 ARR로 리셋**된다.

  #### **(2) 특징**

  | 항목               | 설명                                |
  | ------------------ | ----------------------------------- |
  | 인터럽트 발생 시점 | CNT == 0                            |
  | 방향               | 감소 (ARR → 0)                      |
  | PWM 출력           | 하강 구간에서 동작                  |
  | 활용               | 대칭 PWM, 펄스 신호 반전, 위상 보정 |

  #### **(3) 예시 다이어그램**

  ```
  CNT: ARR ─────▶ 0 ─────▶ ARR ─────▶ 0 ...
             ↑
             │
       Update Event (인터럽트 발생)
  ```

  ------

  ### **5. 코드 예제**

  #### **(1) Up Counter**

  ```
  TIM_HandleTypeDef htim2;
  
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;           // 72MHz / (7199+1) = 10kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9999;              // 10kHz / 10000 = 1Hz
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2);
  }
  ```

  #### **(2) Down Counter**

  ```
  htim2.Init.CounterMode = TIM_COUNTERMODE_DOWN;
  ```

  > Up/Down 모드의 차이는 단 한 줄(`CounterMode`)이다.

  ------

  ### **6. Up vs Down 비교**

  | 구분             | Up Counter         | Down Counter       |
  | ---------------- | ------------------ | ------------------ |
  | CNT 시작점       | 0                  | ARR                |
  | CNT 종료점       | ARR                | 0                  |
  | 이벤트 발생 시점 | CNT == ARR         | CNT == 0           |
  | 방향             | 증가               | 감소               |
  | PWM 상승/하강    | 상승 시점 기준     | 하강 시점 기준     |
  | 대표 활용        | 주기성 타이밍 제어 | 반전/위상 정렬 PWM |

  ------

  ### **7. 실제 PWM 비교 파형**

  #### **Up Counter**

  ```
  CNT: ↑ (0→ARR)
  PWM: ┌───────┐     ┌───────┐
       │       │     │       │
  ─────┘       └─────┘       └──
  ```

  #### **Down Counter**

  ```
  CNT: ↓ (ARR→0)
  PWM:       ┌───────┐     ┌───────┐
             │       │     │       │
  ───────────┘       └─────┘       └──
  ```

  > Down Counter는 Up Counter의 **시간 반전 형태**와 같다.
  >  일부 드라이버 회로에서는 두 신호를 **위상 반전 쌍(PWM, ~PWM)** 으로 사용한다.

  ------

  ### **8. 동작 속도 확인 코드**

  ```
  uint16_t cnt_val = __HAL_TIM_GET_COUNTER(&htim2);
  printf("CNT = %u\r\n", cnt_val);
  ```

  - **Up Counter**: 값이 계속 증가하다 0으로 돌아감
  - **Down Counter**: 값이 감소하다 ARR에서 다시 리셋

  ------

  ### **9. FreeRTOS나 제어 시스템 응용**

  | 용도                | 모드      | 설명                             |
  | ------------------- | --------- | -------------------------------- |
  | 주기적 Task Trigger | Up        | 일정 주기로 인터럽트 발생        |
  | PWM 모터 제어       | Down      | 듀티비 역상 파형 구현            |
  | 동기 듀얼 PWM       | Up + Down | 대칭(Complementary) 신호 생성    |
  | 엔코더 카운터       | Up/Down   | 회전 방향 감지 (Quadrature 모드) |

  ------

  ### **10. 결론**

  - **Up Counter**: 0부터 ARR까지 증가, CNT=ARR 시 이벤트
  - **Down Counter**: ARR부터 0까지 감소, CNT=0 시 이벤트
  - **차이점은 방향 뿐이며, 동작 원리는 동일하다.**

  이 구조를 이해하면 PWM 신호의 위상 제어, 인터럽트 타이밍 조정,
   또는 듀얼 채널(Up/Down 결합) 기반 대칭 제어 같은 고급 응용이 가능하다.

  ------

  ### ✅ **핵심 요약**

  | 항목             | 내용                                 |
  | ---------------- | ------------------------------------ |
  | **Up Counter**   | CNT: 0→ARR, CNT==ARR 시 Update Event |
  | **Down Counter** | CNT: ARR→0, CNT==0 시 Update Event   |
  | **공통점**       | PSC, ARR에 의해 주기 결정            |
  | **차이점**       | 카운트 방향 및 PWM 위상              |
  | **활용**         | Delay, PWM, Encoder, 타이밍 동기화   |

- ## Overflow 이벤트

  ### **1. 개요**

  **Overflow(오버플로우)** 이벤트는 타이머가 **최대 카운트 값(ARR)** 에 도달했을 때 발생하는
   가장 기본적인 **업데이트 이벤트(Update Event)** 이다.

  즉, 타이머의 카운터(`CNT`)가 **끝까지 도달하여 다시 0으로 되돌아가는 순간**,
   MCU 내부에서 “**타이머 한 주기 완료**” 신호를 발생시키며,
   이를 통해 **인터럽트, DMA, PWM 업데이트 등** 다양한 동작이 트리거된다.

  ------

  ### **2. 발생 조건**

  #### **Up Counter 모드**

  ```
  CNT: 0 → 1 → 2 → ... → ARR → 0
                       ↑
                       └─ Overflow 발생 (Update Event)
  ```

  #### **Down Counter 모드**

  ```
  CNT: ARR → ARR-1 → ... → 0 → ARR
                           ↑
                           └─ Overflow 발생 (Update Event)
  ```

  > 즉, **CNT가 주기 한 바퀴를 돌 때마다** 오버플로우 이벤트가 발생한다.

  ------

  ### **3. 내부 레지스터 동작**

  #### **관련 레지스터**

  | 레지스터                             | 역할                       |
  | ------------------------------------ | -------------------------- |
  | **CNT**                              | 현재 카운터 값             |
  | **ARR**                              | 자동 리로드 값 (최댓값)    |
  | **SR (Status Register)**             | 이벤트 상태 플래그 저장    |
  | **EGR (Event Generation Register)**  | 수동으로 이벤트 발생 가능  |
  | **DIER (Interrupt Enable Register)** | Update Event 인터럽트 허용 |

  #### **SR 레지스터 (Status Register)**

  | 비트 | 이름                            | 설명                          |
  | ---- | ------------------------------- | ----------------------------- |
  | 0    | **UIF (Update Interrupt Flag)** | 오버플로우 발생 시 1로 세트됨 |

  #### **DIER 레지스터 (DMA/Interrupt Enable Register)**

  | 비트 | 이름                              | 설명                                 |
  | ---- | --------------------------------- | ------------------------------------ |
  | 0    | **UIE (Update Interrupt Enable)** | 1 → 오버플로우 시 인터럽트 발생 허용 |

  ------

  ### **4. 오버플로우 이벤트 발생 순서**

  ```
  CNT == ARR  (Up Counter 기준)
     ↓
  UIF 플래그 세트 (SR |= UIF)
     ↓
  NVIC 인터럽트 요청 (UIE=1인 경우)
     ↓
  IRQHandler() 호출
     ↓
  HAL_TIM_PeriodElapsedCallback() 실행
     ↓
  사용자 정의 동작 수행
  ```

  ------

  ### **5. HAL 기반 코드 예시**

  ```
  TIM_HandleTypeDef htim2;
  
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;          // 72MHz / 7200 = 10kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9999;             // 10kHz / 10000 = 1Hz
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2);        // 오버플로우 인터럽트 활성화
  }
  
  // 인터럽트 서비스 루틴
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  // LED 토글
    }
  }
  ```

  > 위 코드에서 `HAL_TIM_PeriodElapsedCallback()`은
  >  **Timer Overflow 발생 시점**(즉, CNT가 ARR에 도달한 순간)에 자동으로 호출된다.

  ------

  ### **6. 수동 이벤트 발생 (소프트웨어 트리거)**

  오버플로우 이벤트를 **강제로 발생**시킬 수도 있다.

  ```
  __HAL_TIM_GENERATE_EVENT(&htim2, TIM_EVENTSOURCE_UPDATE);
  ```

  > 내부적으로 EGR(이벤트 생성 레지스터)의 **UG 비트(0)** 를 1로 세트하여
  >  수동으로 Update Event를 트리거한다.

  ------

  ### **7. Overflow 주기 계산**

  $$
  T_{overflow} = \frac{(PSC + 1) × (ARR + 1)}{f_{TIM}}
  $$

  예시:

  - 시스템 클록 = 72MHz
  - PSC = 7199
  - ARR = 9999
     → 오버플로우 주기 = 1초
     → 1Hz 주기로 인터럽트 발생

  ------

  ### **8. 오버플로우 인터럽트 처리 흐름 (HAL 내부 구조)**

  ```
  [1] CNT == ARR 도달
       ↓
  [2] SR(UIF) 비트 세트
       ↓
  [3] NVIC 인터럽트 요청
       ↓
  [4] TIM2_IRQHandler()
       ↓
  [5] HAL_TIM_IRQHandler(&htim2)
       ↓
  [6] HAL_TIM_PeriodElapsedCallback()
       ↓
  [7] 사용자 코드 실행
  ```

  #### **핸들러 코드 내부 (HAL 구현)**

  ```
  void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
  {
    if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
    {
      if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
        HAL_TIM_PeriodElapsedCallback(htim);
      }
    }
  }
  ```

  ------

  ### **9. 실습 예제 — 0.5초마다 LED 토글**

  ```
  htim2.Init.Prescaler = 7199;   // 72MHz / 7200 = 10kHz
  htim2.Init.Period = 4999;      // 10kHz / 5000 = 2Hz (0.5초 주기)
  ```

  → 결과: 0.5초마다 **Overflow Event 발생 → LED 토글**

  ------

  ### **10. 오버플로우 이벤트 응용**

  | 응용 분야                   | 설명                                         |
  | --------------------------- | -------------------------------------------- |
  | **주기적 인터럽트**         | 주기마다 센서 샘플링, 데이터 로깅, 상태 갱신 |
  | **PWM 리로드**              | ARR 도달 시 PWM 파형 리셋                    |
  | **DMA 트리거**              | DMA 전송 자동 시작                           |
  | **ADC 트리거**              | 주기적 아날로그 샘플링                       |
  | **FreeRTOS Tickless Timer** | CPU Sleep 모드용 타임 기준 생성              |

  ------

  ### **11. CNT Overflow 감지 직접 구현**

  Low-level 접근으로 직접 UIF 플래그를 확인할 수도 있다.

  ```
  if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE))
  {
    __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_UPDATE);
    // 오버플로우 처리
  }
  ```

  ------

  ### **12. 디버그 타이밍 예시 (타이밍 다이어그램)**

  ```
  Timer Clock (10kHz)
     ↓
  CNT: 0 1 2 ... 9999 0 1 2 ...
              ↑
              └── Overflow Event (1Hz)
                   ↓
                   └── 인터럽트 발생 → 콜백 호출
  ```

  ------

  ### **13. 주의사항**

  | 항목                          | 설명                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | **ARR 변경 시점**             | CNT 진행 중에 ARR 변경 시, Update Event 타이밍이 불규칙해질 수 있음 |
  | **PSC와 ARR의 곱 제한**       | 16-bit 타이머는 `ARR ≤ 65535` 범위                           |
  | **UIF 미클리어 시 중복 발생** | 인터럽트 내에서 반드시 `__HAL_TIM_CLEAR_IT()` 호출 필요      |
  | **NVIC 우선순위**             | 다른 인터럽트보다 너무 낮으면 응답 지연 발생                 |

  ------

  ### **14. 결론**

  **Overflow 이벤트**는 STM32 타이머가 “주기를 완전히 마쳤음”을 알려주는 신호로,
   인터럽트·PWM·DMA 등 타이밍 기반 기능의 **기본 트리거**로 사용된다.

  즉,

  > “타이머 한 바퀴 완료 → Overflow Event → 시스템 타이밍 동기화 신호 발생.”

  ------

  ### ✅ **핵심 요약**

  | 항목                | 설명                                       |
  | ------------------- | ------------------------------------------ |
  | **발생 조건**       | CNT가 ARR에 도달 (Up), CNT가 0 도달 (Down) |
  | **핵심 플래그**     | SR.UIF (Update Interrupt Flag)             |
  | **인터럽트 활성화** | DIER.UIE = 1                               |
  | **주기 공식**       | $T = \frac{(PSC + 1)(ARR + 1)}{f_{CLK}}$   |
  | **콜백 함수**       | `HAL_TIM_PeriodElapsedCallback()`          |
  | **응용**            | 주기적 작업, PWM 리로드, DMA/ADC 트리거    |

- ## 타이머 클럭 계산법

  ### **1. 개요**

  STM32의 타이머는 단순히 “주기”만 설정하는 것이 아니라,
   **시스템 클록(APB 버스 클록)** 과 **Prescaler(PSC)**, **ARR(주기 레지스터)** 의 상호작용으로
   정밀한 타이밍을 생성한다.

  즉,

  > 타이머의 실제 동작 속도(=Timer Clock)는
  >  **MCU 내부 버스(APB1/APB2)** 의 설정에 따라 달라진다.

  ------

  ### **2. 전체 구조**

  ```
  System Clock (HCLK)
     │
     ├── APB1 (저속 버스)
     │     └── TIM2~TIM7
     │
     └── APB2 (고속 버스)
           └── TIM1, TIM8, TIM9~TIM17
  ```

  STM32는 버스 클록(APB)과 타이머 클록이 1:1이 아닐 수도 있다.
   이 때문에 “**타이머 클록 계산**”이 중요한 것이다.

  ------

  ### **3. 타이머 클록 계산 공식**

  #### **(1) 기본 식**

  $$
  f_{TIM} =
  \begin{cases}
  f_{APB} & \text{if } APB\ prescaler = 1 \\
  2 \times f_{APB} & \text{if } APB\ prescaler > 1
  \end{cases}
  $$

  즉,

  - APB 버스의 분주비가 1이면, 타이머는 APB 클록 그대로 사용
  - APB 분주비가 2, 4, 8... 이면, **타이머 클록은 2배로 보상**되어 동작한다

  ------

  ### **4. 예시 – STM32F103C8T6**

  | 버스     | 클록 소스 | 일반 설정     | 타이머                  |
  | -------- | --------- | ------------- | ----------------------- |
  | **APB1** | 36 MHz    | Prescaler = 2 | TIM2~TIM7 → **72 MHz**  |
  | **APB2** | 72 MHz    | Prescaler = 1 | TIM1, TIM8 → **72 MHz** |

  #### 결론:

  > 대부분의 Blue Pill 보드에서는 **모든 타이머의 클록 주파수가 72MHz**로 설정된다.

  ------

  ### **5. 실제 타이머 동작 주기**

  타이머의 **주기(Period)** 또는 **인터럽트 주기**는 다음 공식으로 계산한다.
  $$
  T = \frac{(PSC + 1) × (ARR + 1)}{f_{TIM}}
  $$

  | 기호         | 의미                        |
  | ------------ | --------------------------- |
  | $f_{TIM}$    | 타이머 입력 클록 (Hz)       |
  | PSC          | 분주기(Prescaler) 값        |
  | ARR          | 자동 리로드 레지스터 값     |
  | $f_{update}$ | 오버플로우(인터럽트) 주파수 |

  ------

  ### **6. 예시 ① — 1초마다 인터럽트 발생**

  - APB1 타이머 클록: 72 MHz
  - PSC = 7199
  - ARR = 9999

  $$
  T = \frac{(7199+1) × (9999+1)}{72,000,000} = 1s
  $$

  즉, 1초마다 오버플로우 이벤트 발생.

  → **TIM2_IRQHandler() → HAL_TIM_PeriodElapsedCallback() 호출**

  ------

  ### **7. 예시 ② — 1ms 주기 (1000Hz)**

  - $f_{TIM} = 72\,MHz$
  - PSC = 71 (→ 1MHz)
  - ARR = 999

  $$
  T = \frac{(71+1) × (999+1)}{72,000,000} = 0.001s = 1ms
  $$

  → **1ms마다 인터럽트 발생 (SysTick 수준의 정밀 타이머)**

  ------

  ### **8. 예시 ③ — PWM 주파수 계산**

  PWM 모드에서 타이머 주파수는 PWM 주기에도 직접 영향을 준다.
  $$
  f_{PWM} = \frac{f_{TIM}}{(PSC + 1) × (ARR + 1)}
  $$
  예시:

  - PSC = 71 → 분주 후 1MHz
  - ARR = 999 → PWM 주기 1ms (1kHz)
  - CCR = 500 → 50% 듀티비

  ------

  ### **9. 타이머 별 클록 소스 요약**

  | 타이머        | 버스 | 클록 소스   | 기본 속도 |
  | ------------- | ---- | ----------- | --------- |
  | **TIM1**      | APB2 | APB2 클록   | 72 MHz    |
  | **TIM2~TIM7** | APB1 | 2×APB1 클록 | 72 MHz    |
  | **TIM8**      | APB2 | APB2 클록   | 72 MHz    |

  > 즉, 일반적으로 STM32F1 시리즈의 모든 타이머는 72 MHz를 기준으로 동작한다.
  >  (단, RCC 설정 변경 시 이 값이 달라질 수 있음)

  ------

  ### **10. 코드로 타이머 클록 계산 확인**

  HAL 라이브러리에서 현재 클록 주파수를 직접 얻을 수 있다.

  ```
  uint32_t timclk = HAL_RCC_GetPCLK1Freq();  // APB1 클록
  RCC_ClkInitTypeDef clkinit;
  uint32_t flashLatency;
  HAL_RCC_GetClockConfig(&clkinit, &flashLatency);
  
  if (clkinit.APB1CLKDivider != RCC_HCLK_DIV1)
      timclk *= 2;  // APB1 prescaler > 1 → 타이머 클록 2배
  ```

  > 위 코드로 **현재 타이머 클록 주파수**를 런타임에서 계산할 수 있다.

  ------

  ### **11. 타이머 클록 다이어그램**

  ```
  72 MHz (System Clock)
     │
     ├─► APB1 = 36 MHz ──► ×2 ──► TIM2~TIM7 = 72 MHz
     │
     └─► APB2 = 72 MHz ─────────► TIM1, TIM8 = 72 MHz
  ```

  > 이 구조 덕분에 APB 버스가 느리더라도 타이머는 여전히 **풀 속도로 동작**한다.

  ------

  ### **12. 고급 응용: µs 단위 정밀 타이머**

  PSC=71 → 1MHz (1µs 단위)

  ```
  htim2.Init.Prescaler = 71;
  htim2.Init.Period = 0xFFFF;
  HAL_TIM_Base_Start(&htim2);
  ```

  - 1 µs 해상도로 CNT 읽기 가능
  - `__HAL_TIM_GET_COUNTER()`으로 실시간 시간 측정 가능
     → 센서 거리, 펄스 폭, Input Capture 등 정밀 타이밍에 활용

  ------

  ### **13. FreeRTOS 환경에서의 고려**

  | 항목        | 내용                                  |
  | ----------- | ------------------------------------- |
  | **SysTick** | 1ms 기반, RTOS Tick                   |
  | **TIMx**    | 독립적인 하드웨어 타이밍              |
  | **사용법**  | 센서 샘플링, 주기적 Task, 고속 PWM 등 |
  | **장점**    | RTOS와 독립된 고정밀 타이밍 확보 가능 |

  ------

  ### **14. 정리**

  | 항목                 | 공식                                             | 설명                         |
  | -------------------- | ------------------------------------------------ | ---------------------------- |
  | **타이머 입력클록**  | $f_{TIM} = f_{APB} × (APB\_Prescaler>1 ? 2 : 1)$ | APB 클록의 2배 또는 1배      |
  | **인터럽트 주기**    | $T = \frac{(PSC + 1)(ARR + 1)}{f_{TIM}}$         | 전체 주기 계산               |
  | **PWM 주파수**       | $f = \frac{f_{TIM}}{(PSC + 1)(ARR + 1)}$         | PWM 출력 주기                |
  | **1 µs 타이밍 설정** | PSC = 71 → 1MHz                                  | CNT 단위로 µs 시간 계산 가능 |

  ------

  ### **15. 결론**

  STM32의 타이머는 단순한 클록이 아니라,
   **RCC(클록 트리)** → **APB 버스 분주기** → **타이머 클록 보정** → **PSC & ARR 조합**
   으로 이루어진 **정밀한 타이밍 생성기**이다.

  따라서 정확한 주기를 만들기 위해서는 반드시 다음을 확인해야 한다:

  1. 시스템 클록(72 MHz)
  2. APB1/APB2 분주비
  3. 타이머 클록이 2배 적용 여부
  4. PSC, ARR 설정

  ------

  ### ✅ **핵심 요약**

  | 항목                    | 내용                                             |
  | ----------------------- | ------------------------------------------------ |
  | **타이머 클록 계산식**  | $f_{TIM} = f_{APB} × (APB\_Prescaler>1 ? 2 : 1)$ |
  | **주기 계산식**         | $T = \frac{(PSC + 1)(ARR + 1)}{f_{TIM}}$         |
  | **Blue Pill 기준**      | 모든 타이머 = 72MHz                              |
  | **µs 단위 타이머 설정** | PSC = 71 → 1MHz (1µs 단위 CNT 증가)              |
  | **활용**                | Delay, PWM, 주기적 인터럽트, 센서 시간 측정      |

## 3.2 타이머 모드

- ## Output Compare / PWM / Input Capture / One Pulse

  #### **1. 개요**

  STM32의 일반 타이머(General-Purpose Timer)는 단순한 카운터를 넘어
   **정밀한 출력 제어**, **입력 신호 측정**, **트리거 생성**을 수행할 수 있는 다기능 하드웨어 블록이다.

  그 중에서도 **Output Compare**, **PWM**, **Input Capture**, **One Pulse**는
   타이머의 대표적인 네 가지 모드로,
   모두 **ARR(자동 리로드 값)**, **PSC(분주기)**, **CNT(카운터)**, **CCR(비교 레지스터)**
   를 핵심으로 하여 동작한다.

  ------

  #### **2. 네 가지 모드 개요**

  | 모드                             | 방향 | 동작 개념                         | 주요 용도                 |
  | -------------------------------- | ---- | --------------------------------- | ------------------------- |
  | **Output Compare (OC)**          | 출력 | CNT가 CCR에 도달할 때 이벤트 발생 | 일정 시점 이벤트, 핀 토글 |
  | **PWM (Pulse Width Modulation)** | 출력 | CNT < CCR 동안 HIGH 유지          | 모터, LED, 펌프 제어      |
  | **Input Capture (IC)**           | 입력 | 외부 신호의 엣지에서 CNT 값 저장  | 신호 주기, 펄스폭 측정    |
  | **One Pulse (OPM)**              | 출력 | 트리거 입력 시 한 번만 펄스 출력  | 초음파 TRIG, 단발 제어    |

  ------

  ### **Output Compare 모드 (출력 비교)**

  #### **동작 원리**

  타이머 카운터(`CNT`) 값이 비교 레지스터(`CCR`) 값과 일치하면
   특정한 동작(핀 토글, 핀 세트, 인터럽트 발생 등)을 수행한다.

  ```
  CNT ↑
  │
  │── CCRx (비교값) 도달 시 이벤트 발생
  │
  └──────→ ARR (자동 리로드 후 0으로 리셋)
  ```

  ------

  #### **주요 설정**

  | 항목        | 설명                                      |
  | ----------- | ----------------------------------------- |
  | 모드        | `TIM_OCMODE_TOGGLE`, `ACTIVE`, `INACTIVE` |
  | 비교값      | `CCR1` ~ `CCR4`                           |
  | 트리거 시점 | CNT == CCR                                |
  | 이벤트      | 핀 반전, 인터럽트, DMA 요청               |

  ------

  #### **코드 예시**

  ```
  TIM_OC_InitTypeDef sConfigOC = {0};
  
  sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
  sConfigOC.Pulse = 1000;  // CNT == 1000 시점에서 토글
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  
  HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  HAL_TIM_OC_Start(&htim2, TIM_CHANNEL_1);
  ```

  → CNT가 1000이 될 때마다 핀이 반전되어
   정확한 타이밍 제어 신호를 생성한다.

  ------

  ### **PWM 모드 (펄스 폭 변조)**

  #### **동작 원리**

  타이머가 **ARR**까지 카운트하는 동안,
   **CNT < CCR**인 구간에서 출력이 HIGH,
   이후에는 LOW 상태를 유지한다.

  ```
  HIGH  ┌────────────┐      ┌────────────┐
        │            │      │            │
  LOW   └────────────┴──────└────────────┴───
         <--- ON ---><--- OFF --->
          (CCR)        (ARR-CCR)
  ```

  ------

  #### **주요 설정**

  | 항목    | 설명                          |
  | ------- | ----------------------------- |
  | 모드    | `TIM_OCMODE_PWM1` 또는 `PWM2` |
  | ARR     | 전체 주기 (Period)            |
  | CCR     | 듀티비 (Duty Cycle)           |
  | 출력 핀 | TIMx_CH1~CH4                  |

  ------

  #### **듀티비 계산식**

  PWM(Pulse Width Modulation)에서 듀티비는
   **전체 주기(ARR)** 중에서 출력이 **HIGH 상태로 유지되는 시간(CCR)** 의 비율을 의미한다.
  $$
  \text{Duty(\%)} = \frac{CCR}{ARR + 1} \times 100
  $$

  ------

  ##### **예시 ① — 50% 듀티비**

  - ARR = 999
  - CCR = 500

  $$
  \text{Duty} = \frac{500}{1000} \times 100 = 50\%
  $$

  출력 파형:
   HIGH 500µs, LOW 500µs → 1kHz, 50% 듀티 PWM

  ------

  ##### **예시 ② — 25% 듀티비**

  - ARR = 999
  - CCR = 250

  $$
  \text{Duty} = \frac{250}{1000} \times 100 = 25\%
  $$

  출력 파형:
   HIGH 250µs, LOW 750µs → 1kHz, 25% 듀티 PWM

  ------

  ##### **예시 ③ — 75% 듀티비**

  - ARR = 999
  - CCR = 750

  $$
  \text{Duty} = \frac{750}{1000} \times 100 = 75\%
  $$

  출력 파형:
   HIGH 750µs, LOW 250µs → 1kHz, 75% 듀티 PWM

  ------

  ✅ **정리**

  | 항목        | 의미                  | 단위      |
  | ----------- | --------------------- | --------- |
  | **ARR**     | PWM 전체 주기         | 카운트 수 |
  | **CCR**     | HIGH 구간 길이        | 카운트 수 |
  | **Duty(%)** | 출력 신호의 HIGH 비율 | %         |

  결론적으로,
   **CCR 값이 커질수록 PWM 신호의 HIGH 비율이 증가**하며,
   이는 곧 모터 속도, LED 밝기, 펌프 출력 등의 세기 제어로 이어진다.

  ------

  #### **코드 예시 (1kHz, 50%)**

  ```
  htim2.Init.Prescaler = 71;   // 72MHz / 72 = 1MHz
  htim2.Init.Period = 999;     // 1MHz / 1000 = 1kHz
  
  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 500;       // 50% Duty
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  
  HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  ```

  > 결과: PA0 (TIM2_CH1) 핀에서 1kHz, 50% 듀티의 PWM 파형 출력

  ------

  ### **Input Capture 모드 (입력 캡처)**

  #### **동작 원리**

  외부 입력 신호의 상승 혹은 하강 엣지가 발생할 때,
   그 시점의 **CNT** 값을 **CCR 레지스터**에 저장한다.
   이를 통해 주기, 펄스폭, 주파수 등의 시간 정보를 계산할 수 있다.

  ```
  입력 신호 ↑
     │
     ├── 엣지 발생 시 CNT → CCR에 복사 (Capture)
     │
     └── 다음 엣지에서 차이 계산 → 주기/주파수 산출
  ```

  ------

  #### **주요 설정**

  | 항목      | 설명                                                |
  | --------- | --------------------------------------------------- |
  | 극성      | 상승(`RISING`), 하강(`FALLING`), 양엣지(`BOTHEDGE`) |
  | 입력 선택 | 직접 입력(TIx), 간접 입력                           |
  | 분주기    | 빠른 신호 감속용 (`ICPSC_DIVx`)                     |
  | 필터      | 노이즈 제거 (0~15 단계)                             |

  ------

  #### **코드 예시 (주기 측정)**

  ```
  TIM_IC_InitTypeDef sConfigIC = {0};
  
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
  
  void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
  {
    static uint32_t last = 0;
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
      uint32_t now = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
      uint32_t diff = (now >= last) ? (now - last) : (0xFFFF - last + now);
      last = now;
      float freq = 1000000.0f / diff;  // PSC=71 → 1µs 단위
    }
  }
  ```

  > 입력 신호의 주파수나 펄스 폭을 측정할 수 있다.
  >  초음파 센서, 엔코더, PWM 피드백 측정 등에 사용된다.

  ------

  ### **One-Pulse 모드 (단발 펄스)**

  #### **동작 원리**

  외부 트리거 신호를 감지하면 타이머가 한 번 동작하고,
   지정된 폭의 펄스를 출력한 뒤 자동으로 멈춘다.

  ```
  Trigger Input ─┐
                  ↓
  CNT 시작 →──────┐──────┐
                  └──────┘  ← 한 번만 출력
  ```

  ------

  #### **주요 설정**

  | 항목        | 설명                             |
  | ----------- | -------------------------------- |
  | 모드        | `TIM_OPMODE_SINGLE`              |
  | 트리거 소스 | TI1FP1, TI2FP2, 내부 트리거 등   |
  | 펄스 폭     | CCR 값으로 설정                  |
  | 출력 형태   | PWM 모드와 유사, 단 한 번만 발생 |

  ------

  #### **코드 예시**

  ```
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_OnePulse_InitTypeDef sConfigOPM = {0};
  
  HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
  
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 200; // 200µs 펄스
  HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  
  sConfigOPM.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigOPM.ICSelection = TIM_ICSELECTION_DIRECTTI;
  
  HAL_TIM_OnePulse_ConfigChannel(&htim2, &sConfigOPM, TIM_CHANNEL_1, TIM_CHANNEL_2);
  HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_1);
  ```

  > 외부 신호(예: 버튼, 센서 트리거)가 들어오면
  >  지정된 펄스 폭의 신호를 한 번만 출력하고 자동 정지한다.

  ------

  ### **네 가지 모드의 비교 요약**

  | 구분              | Output Compare           | PWM             | Input Capture         | One Pulse           |
  | ----------------- | ------------------------ | --------------- | --------------------- | ------------------- |
  | **기능**          | CNT==CCR 시 이벤트       | 듀티비 제어     | 외부 엣지 CNT 저장    | 트리거 시 1회 출력  |
  | **방향**          | 출력                     | 출력            | 입력                  | 출력                |
  | **주요 레지스터** | CCR                      | CCR             | CCR                   | ARR+CCR             |
  | **트리거 조건**   | CNT == CCR               | CNT < CCR       | 외부 엣지             | 외부 트리거         |
  | **응용**          | 타이밍 트리거, 동기 제어 | 모터, LED, 밸브 | 거리, 속도, 신호 측정 | 초음파, 단발 트리거 |

  ------

  #### **관계 도식**

  ```
  ┌──────────────────────────────────────────────┐
  │ Output Compare → 이벤트 기반 타이밍 제어       │
  │ PWM            → 주기적 파형 생성               │
  │ Input Capture  → 외부 신호의 시간 측정          │
  │ One Pulse      → 한 번만 출력되는 정밀 트리거    │
  └──────────────────────────────────────────────┘
  ```

  ------

  #### **결론**

  STM32의 타이머는
   **시간(Time)** 을 입력과 출력 양방향으로 제어할 수 있는 완전한 하드웨어 엔진이다.

  - **Output Compare**: 정해진 시점에 이벤트 발생
  - **PWM**: 주기적 제어 파형 생성
  - **Input Capture**: 외부 신호의 시간 특성 계측
  - **One Pulse**: 단 한 번만 발생하는 정밀 펄스 생성

  이 네 가지 기능을 적절히 조합하면
   **센서 계측, 액추에이터 제어, 통신 타이밍, 이벤트 동기화** 등
   모든 임베디드 제어 시스템의 기반을 설계할 수 있다.

  ------

  ### ✅ **핵심 요약**

  | 항목               | 설명                   | 주요 응용               |
  | ------------------ | ---------------------- | ----------------------- |
  | **Output Compare** | CNT == CCR일 때 이벤트 | 주기적 트리거, 동기화   |
  | **PWM**            | CNT < CCR 구간 HIGH    | 모터·밸브·LED 제어      |
  | **Input Capture**  | 엣지 감지 시 CNT 저장  | 펄스폭, 주기, 거리 측정 |
  | **One Pulse**      | 단 한 번 펄스 출력     | 초음파 TRIG, 정밀 제어  |

- ## TIM Interrupt / DMA 트리거

  ### **1. 개요**

  STM32의 타이머(TIM)는 단순히 시간을 세는 장치가 아니라,
   **이벤트(Event Generator)** 역할도 수행한다.

  타이머의 **오버플로우**, **비교 일치(Compare Match)**, **입력 캡처**, **트리거 출력** 등은
   모두 **인터럽트(Interrupt)** 또는 **DMA 트리거(DMA Request)** 로 연결되어
   주기적, 자동화된 동작을 구현할 수 있다.

  즉,

  > **CPU 개입 없이 정해진 시점에 자동으로 이벤트를 발생시키는 것**,
  >  이것이 TIM Interrupt와 DMA 트리거의 핵심이다.

  ------

  ### **2. 타이머 이벤트의 종류**

  | 이벤트                    | 발생 조건      | 설명                           |
  | ------------------------- | -------------- | ------------------------------ |
  | **Update Event (UEV)**    | CNT == ARR     | 주기 오버플로우 발생           |
  | **Compare Match**         | CNT == CCRx    | 비교값 도달 시 이벤트          |
  | **Capture Event**         | 외부 엣지 감지 | 입력 신호 계측                 |
  | **Trigger Output (TRGO)** | 지정된 시점    | 외부 모듈 동기화 (ADC, DAC 등) |

  ------

  ### **3. 인터럽트(Interrupt) 동작 구조**

  인터럽트는 타이머 내부에서 특정 이벤트가 발생할 때
   **NVIC(Interrupt Controller)** 를 통해 CPU로 신호를 보낸다.

  핵심은 **DIER(Interrupt Enable Register)** 와 **SR(Status Register)** 두 가지이다.

  | 레지스터 | 비트  | 설명                     |
  | -------- | ----- | ------------------------ |
  | **DIER** | UIE   | Update Interrupt Enable  |
  |          | CCxIE | Compare Interrupt Enable |
  |          | TIE   | Trigger Interrupt Enable |
  | **SR**   | UIF   | Update Flag              |
  |          | CCxIF | Compare Match Flag       |
  |          | TIF   | Trigger Flag             |

  ------

  ### **4. 인터럽트 발생 순서**

  ```
  CNT == ARR (또는 CNT == CCR)
     ↓
  SR(UIF or CCxIF) 세트
     ↓
  NVIC → TIMx_IRQHandler() 호출
     ↓
  HAL_TIM_IRQHandler()
     ↓
  콜백 함수 (HAL_TIM_PeriodElapsedCallback 등)
  ```

  ------

  ### **5. 기본 코드 예시 (주기 인터럽트)**

  ```
  void MX_TIM2_Init(void)
  {
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;   // 72MHz / 7200 = 10kHz
    htim2.Init.Period = 9999;      // 10kHz / 10000 = 1Hz
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2); // 인터럽트 모드 시작
  }
  
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
    }
  }
  ```

  > 위 코드는 1초마다 인터럽트가 발생하여 LED를 토글한다.

  ------

  ### **6. Compare Match 인터럽트 예시**

  ```
  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
  sConfigOC.Pulse = 5000;
  HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
  HAL_TIM_OC_Start_IT(&htim2, TIM_CHANNEL_1);
  ```

  → CNT가 5000에 도달할 때마다 인터럽트 발생 → LED 반전

  ------

  ### **7. 인터럽트 플래그 직접 제어**

  ```
  if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE))
  {
    __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_UPDATE);
    // 사용자 동작 수행
  }
  ```

  > HAL 없이도 직접 플래그를 감시·초기화할 수 있다.

  ------

  ### **8. DMA 트리거 (Direct Memory Access)**

  DMA는 **CPU 없이** 메모리 ↔ 주변장치 간 데이터를 전송하는 하드웨어 엔진이다.
   타이머는 DMA 요청 신호를 발생시켜,
   **CCR 업데이트, ADC 샘플링, 메모리 로깅** 등의 동작을 자동화할 수 있다.

  ------

  ### **9. DMA 트리거 발생 구조**

  | 트리거                  | 설명                    |
  | ----------------------- | ----------------------- |
  | **Update DMA (UDE)**    | 오버플로우마다 DMA 요청 |
  | **Compare DMA (CCxDE)** | CNT == CCR 시 DMA 요청  |
  | **Trigger DMA (TDE)**   | TRGO 신호 시 DMA 요청   |

  > 각 비트는 `DIER` 레지스터에 존재한다.
  >  (`UDE`, `CC1DE`, `TDE` 등)

  ------

  ### **10. DMA 트리거 응용 예시 – PWM Duty 자동 변경**

  ```
  uint32_t duty_values[3] = {100, 500, 900};
  
  HAL_TIM_PWM_Start_DMA(&htim2, TIM_CHANNEL_1, duty_values, 3);
  ```

  > TIM2이 DMA를 통해 CCR1 값을 자동으로 갱신하면서
  >  PWM 듀티비가 순차적으로 10% → 50% → 90%로 변경된다.

  ------

  ### **11. DMA를 이용한 ADC 트리거**

  타이머의 TRGO(Trigger Output)를 ADC의 External Trigger로 연결하면,
   ADC가 일정 주기마다 자동으로 샘플링을 시작할 수 있다.

  ```
  // Timer 설정 (TRGO 발생)
  htim2.Init.Prescaler = 71;
  htim2.Init.Period = 999;
  HAL_TIM_Base_Init(&htim2);
  HAL_TIM_Base_Start(&htim2);
  
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
  
  // ADC 설정
  sConfig.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T2_TRGO;
  HAL_ADC_Start_DMA(&hadc1, adc_buffer, 10);
  ```

  > 결과: TIM2가 1kHz 주기로 TRGO 신호를 발생시켜
  >  ADC가 DMA 기반으로 1ms마다 자동 샘플링 수행.

  ------

  ### **12. TRGO (Trigger Output) 활용 요약**

  | 설정값               | 의미                     |
  | -------------------- | ------------------------ |
  | `TIM_TRGO_RESET`     | CNT 리셋 시점            |
  | `TIM_TRGO_UPDATE`    | Update Event 시점        |
  | `TIM_TRGO_OCxREF`    | Compare Match 시점       |
  | `TIM_TRGO_ENABLE`    | 타이머 Enable 시점       |
  | `TIM_TRGO_OCxREFCLR` | 출력 Compare 클리어 시점 |

  > TRGO는 ADC, DAC, 다른 TIM 모듈의 동기화에 사용된다.

  ------

  ### **13. 인터럽트 vs DMA 비교**

  | 항목            | 인터럽트(Interrupt)   | DMA                    |
  | --------------- | --------------------- | ---------------------- |
  | **CPU 개입**    | 필요 (콜백 실행)      | 불필요 (하드웨어 전송) |
  | **속도**        | 느림 (명령어 기반)    | 빠름 (버스 직접 접근)  |
  | **제어 유연성** | 높음 (조건 제어 가능) | 낮음 (자동 전송 중심)  |
  | **응용 예시**   | 상태 처리, LED 토글   | PWM, ADC, 로깅         |

  ------

  ### **14. 실시간 구조도**

  ```
  CNT == ARR → [UEV]
        ↓
   ┌───────────────┐
   │ DIER Register │
   │   UIE / UDE   │
   └───────────────┘
        ↓
   ┌────────────┬────────────┐
   │ Interrupt  │   DMA Req  │
   │   (CPU)    │   (HW Bus) │
   └────────────┴────────────┘
  ```

  ------

  ### **15. FreeRTOS 환경 응용**

  - **인터럽트 기반 Task Notify**
     → 센서 샘플링 Task를 주기적으로 깨움
  - **DMA 기반 비동기 데이터 처리**
     → CPU 부하 없이 PWM, ADC, UART 전송 처리

  예시:

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM3)
      xTaskNotifyFromISR(sensorTaskHandle, 0, eNoAction, NULL);
  }
  ```

  ------

  ### **16. 결론**

  **TIM Interrupt**는 소프트웨어 제어 중심의 이벤트 처리,
   **TIM DMA 트리거**는 하드웨어 자동화 중심의 데이터 처리에 최적화되어 있다.

  이 두 가지를 결합하면,

  > “CPU는 논리 제어에 집중하고, 하드웨어는 반복 동작을 맡는다.”

  즉, 효율적이고 실시간성이 높은 임베디드 시스템 구조를 구현할 수 있다.

  ------

  ### ✅ **핵심 요약**

  | 구분                      | 역할                     | 특징            | 대표 응용        |
  | ------------------------- | ------------------------ | --------------- | ---------------- |
  | **TIM Interrupt**         | 이벤트 감지 후 콜백 호출 | CPU 처리 필요   | LED, 제어 로직   |
  | **TIM DMA Trigger**       | 이벤트 시 DMA 자동 전송  | CPU 개입 없음   | PWM, ADC, 로깅   |
  | **TRGO (Trigger Output)** | 외부 모듈 동기화         | ADC, DAC 트리거 | 정밀 주기 샘플링 |

- ## Timer → µs 단위 Delay 함수 작성

  ### **1. 개요**

  STM32의 타이머는 고해상도 시간 기반을 제공하므로,
   `HAL_Delay()`가 제공하는 **ms 단위 지연**보다 훨씬 정밀한
   **µs(마이크로초) 단위 Delay 함수**를 구현할 수 있다.

  이 기능은 **초음파 거리 측정**, **통신 타이밍 제어**, **PWM 파형 생성**,
   **고속 신호 측정** 등에 필수적으로 사용된다.

  ------

  ### **2. 원리**

  타이머의 **Prescaler(PSC)** 와 **자동 리로드 레지스터(ARR)** 를 설정하여
   타이머가 1µs마다 1씩 증가하도록 만든 뒤,
   해당 카운터 값을 직접 비교하여 지연 시간을 만든다.
  $$
  T_{tick} = \frac{PSC + 1}{f_{TIM}}
  $$
  예:

  - $f_{TIM} = 72\,MHz$
  - $PSC = 71$
     → 타이머는 1µs마다 1씩 카운트

  ------

  ### **3. 타이머 초기화 코드**

  ```
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 71;        // 72MHz / (71+1) = 1MHz → 1µs 단위
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFF;       // 최대 65535µs ≈ 65ms
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start(&htim2);       // 카운터 시작
  }
  ```

  ------

  ### **4. µs Delay 함수 구현**

  ```
  void delay_us(uint16_t us)
  {
    __HAL_TIM_SET_COUNTER(&htim2, 0);        // CNT 리셋
    while (__HAL_TIM_GET_COUNTER(&htim2) < us);
  }
  ```

  > 타이머 카운터가 지정한 us 값에 도달할 때까지 대기한다.
  >  타이머는 1µs 단위로 증가하므로 정확한 마이크로초 단위 지연이 가능하다.

  ------

  ### **5. 예시 — LED 점멸 실험**

  ```
  while (1)
  {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    delay_us(500000);    // 500,000 µs = 0.5초
  }
  ```

  → 결과: **0.5초 주기로 LED 점멸**
   (`HAL_Delay(500)` 과 동일한 효과지만 µs 단위 정밀도 유지)

  ------

  ### **6. 주의사항**

  | 항목           | 설명                                                    |
  | -------------- | ------------------------------------------------------- |
  | **정확도**     | 72MHz 기준 ±1µs 수준의 오차                             |
  | **오버플로우** | CNT 최대값(65535)을 초과하는 딜레이는 분할 필요         |
  | **전원 모드**  | Sleep/Stop 모드 시 타이머 정지 가능                     |
  | **중첩 사용**  | 다른 타이머(PWM, Capture 등)와 병행 시 타이밍 충돌 주의 |

  ------

  ### **7. 개선 버전 — 32비트 타이머 사용**

  `TIM2`와 `TIM5`는 32비트 타이머이므로, 더 긴 시간 지연도 가능하다.

  ```
  void delay_us(uint32_t us)
  {
    __HAL_TIM_SET_COUNTER(&htim2, 0);
    while (__HAL_TIM_GET_COUNTER(&htim2) < us);
  }
  ```

  > 최대 약 **4294초(≈71분)** 까지 측정 가능 (1µs × 2³²)

  ------

  ### **8. 고정밀 µs Delay 검증**

  1. 오실로스코프에서 LED 핀 토글 시간 측정
  2. `delay_us(100)` → 약 100µs 유지 확인
  3. `delay_us(500)` → 약 500µs 유지 확인

  → ±1µs 오차 이내의 고정밀 타이밍 가능

  ------

  ### **9. FreeRTOS 환경에서의 사용**

  FreeRTOS의 `vTaskDelay()`는 **Tick 단위(1ms)** 이므로,
   µs 지연이 필요한 경우에는 타이머 기반 `delay_us()`를
   **Task 내 짧은 구간**에서만 사용하는 것이 바람직하다.

  예:

  ```
  for(;;)
  {
    trigger_ultrasonic();   // 초음파 TRIG 신호 출력
    delay_us(10);           // 10µs 펄스 유지
    vTaskDelay(pdMS_TO_TICKS(100)); // 100ms 주기
  }
  ```

  ------

  ### **10. 정리**

  | 항목            | 내용                                            |
  | --------------- | ----------------------------------------------- |
  | **사용 타이머** | TIM2 (또는 TIM5, 32-bit)                        |
  | **설정**        | Prescaler = 71, Period = 0xFFFF                 |
  | **Tick 단위**   | 1µs                                             |
  | **함수 구조**   | CNT 리셋 → CNT 비교 루프                        |
  | **최대 지연**   | 16-bit: 65ms / 32-bit: 71분                     |
  | **응용**        | 초음파 센서, PWM 제어, SPI 타이밍, 통신 지연 등 |

  ------

  ### ✅ **핵심 요약**

  | 항목          | 설명                                          |
  | ------------- | --------------------------------------------- |
  | **공식**      | $PSC = \frac{f_{TIM}}{1,000,000} - 1$         |
  | **구현 함수** | `delay_us(us)`                                |
  | **정확도**    | ±1µs (72MHz 기준)                             |
  | **적용 사례** | 초음파 센서 TRIG, 정밀 타이밍, SPI/USART Sync |

## 3.3 HAL Timer 함수

- ## `HAL_TIM_Base_Start()`, `HAL_TIM_PWM_Start()`

  ### **1. 개요**

  STM32 HAL 라이브러리에서 타이머를 구동할 때는
   **타이머의 동작 모드**에 따라 서로 다른 Start 함수를 사용한다.

  그중 핵심은 다음 두 가지이다.

  | 함수                       | 용도                                       |
  | -------------------------- | ------------------------------------------ |
  | **`HAL_TIM_Base_Start()`** | 기본 타이머(시간 기반, 인터럽트 없음) 시작 |
  | **`HAL_TIM_PWM_Start()`**  | PWM 출력 신호 시작                         |

  이 두 함수는 모두 `HAL_TIM_Base_Init()` / `HAL_TIM_PWM_ConfigChannel()` 등
   초기 설정 이후 타이머를 **실제 동작 상태로 전환하는 함수**이다.

  ------

  ### **2. HAL 타이머 구조 개요**

  HAL의 타이머는 다음과 같이 계층적으로 구성된다.

  ```
  TIM_HandleTypeDef
     ├── Instance (TIMx)
     ├── Init (PSC, ARR, Mode)
     ├── Channel (CH1~CH4)
     └── State / Lock / DMA_Handle
  ```

  - `HAL_TIM_Base_*()` : 기본 시간 기능 제어
  - `HAL_TIM_PWM_*()` : PWM 모드 제어
  - `HAL_TIM_OC_*()`  : Output Compare
  - `HAL_TIM_IC_*()`  : Input Capture
  - `HAL_TIM_OnePulse_*()` : 단발 펄스

  ------

  ### **3. `HAL_TIM_Base_Start()`**

  #### **기능**

  > 타이머를 **기본 카운터 모드**로 시작한다.
  >  CNT가 0에서 ARR까지 증가하며 반복 카운트된다.
  >  인터럽트 없이 단순 시간 흐름을 생성한다.

  #### **원형**

  ```
  HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim);
  ```

  #### **내부 동작**

  1. `TIM_CR1.CEN` 비트를 1로 설정 (카운터 시작)
  2. `CNT`가 0부터 증가
  3. `ARR` 도달 시 자동 리셋
  4. 오버플로우 이벤트 발생 (UIF 세트, 인터럽트 미사용 시 무시)

  ------

  #### **예시 코드**

  ```
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 71;      // 1MHz
  htim2.Init.Period = 999;        // 1ms
  HAL_TIM_Base_Init(&htim2);
  
  HAL_TIM_Base_Start(&htim2);     // 타이머 시작 (인터럽트 없음)
  ```

  → TIM2는 1ms마다 오버플로우하지만, 콜백은 발생하지 않음.
   → 카운터 값(`__HAL_TIM_GET_COUNTER()`)을 직접 읽어 시간 계산 가능.

  ------

  #### **확장형**

  | 함수                       | 설명                 |
  | -------------------------- | -------------------- |
  | `HAL_TIM_Base_Start_IT()`  | 인터럽트 모드 시작   |
  | `HAL_TIM_Base_Start_DMA()` | DMA 트리거 모드 시작 |
  | `HAL_TIM_Base_Stop()`      | 타이머 정지          |

  ------

  ### **4. `HAL_TIM_PWM_Start()`**

  #### **기능**

  > 타이머 채널을 **PWM 출력 모드**로 시작한다.
  >  CNT 값과 CCR 비교를 기반으로 주기적 PWM 신호를 출력한다.

  #### **원형**

  ```
  HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
  ```

  - `Channel` : `TIM_CHANNEL_1` ~ `TIM_CHANNEL_4`
  - PWM 출력 핀은 반드시 **Alternate Function (AF)** 으로 설정되어야 한다.

  ------

  #### **동작 구조**

  1. **CNT 증가**
  2. **CNT < CCRx** 구간 → HIGH 출력
  3. **CNT ≥ CCRx** 구간 → LOW 출력
  4. CNT가 ARR 도달 → 0으로 리셋
  5. 반복 (PWM 주기 지속 생성)

  ------

  #### **예시 코드 — 1kHz / 50% 듀티**

  ```
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 71;     // 72MHz / 72 = 1MHz
  htim3.Init.Period = 999;       // 1MHz / 1000 = 1kHz
  HAL_TIM_PWM_Init(&htim3);
  
  TIM_OC_InitTypeDef sConfigOC = {0};
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 500;         // 50% 듀티
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
  
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1); // PWM 출력 시작
  ```

  → TIM3_CH1 핀(PA6 등)에서 1kHz, 50% PWM 신호 출력.

  ------

  ### **5. 두 함수의 차이점**

  | 구분             | `HAL_TIM_Base_Start()`            | `HAL_TIM_PWM_Start()`                       |
  | ---------------- | --------------------------------- | ------------------------------------------- |
  | **모드**         | 기본 타이머(시간 기반)            | PWM 출력 모드                               |
  | **채널 사용**    | 없음                              | CH1~CH4 필요                                |
  | **출력 핀 변화** | 없음                              | GPIO 핀에서 파형 발생                       |
  | **사용 목적**    | Delay, 주기적 타이밍, 내부 트리거 | 모터, LED, 펌프, 서보 제어                  |
  | **콜백 호출**    | 없음 (`_IT()` 모드 시만 발생)     | 없음 (`_IT()` 또는 `_DMA()`로 확장 시 발생) |

  ------

  ### **6. 인터럽트 / DMA 버전**

  | 함수                      | 설명                     |
  | ------------------------- | ------------------------ |
  | `HAL_TIM_Base_Start_IT()` | 오버플로우마다 콜백 호출 |
  | `HAL_TIM_PWM_Start_IT()`  | PWM 주기별 이벤트 콜백   |
  | `HAL_TIM_PWM_Start_DMA()` | DMA로 CCR 자동 갱신      |

  PWM 모드에서는 DMA를 이용해 **CCR(듀티비)** 를 자동으로 변경할 수도 있다.

  예시:

  ```
  uint32_t duty_table[4] = {100, 300, 700, 900};
  HAL_TIM_PWM_Start_DMA(&htim3, TIM_CHANNEL_1, duty_table, 4);
  ```

  → PWM 듀티가 자동으로 10% → 30% → 70% → 90%로 변화.

  ------

  ### **7. 내부 레지스터 변화**

  | 레지스터        | 역할                    |
  | --------------- | ----------------------- |
  | **CR1.CEN**     | 카운터 Enable           |
  | **EGR.UG**      | 이벤트 생성 (초기 리셋) |
  | **CNT**         | 카운터 값               |
  | **ARR**         | 자동 리로드 (주기 설정) |
  | **CCR**         | 비교 값 (듀티비 설정)   |
  | **CCMRx, CCER** | 출력 모드 및 극성 설정  |

  `HAL_TIM_PWM_Start()` 실행 시 위 레지스터들이 자동 구성되어
   PWM 파형 생성이 시작된다.

  ------

  ### **8. 동작 흐름 비교**

  ```
  HAL_TIM_Base_Start()
   └─> CNT 증가 (내부만)
        └─> SR(UIF) 세트 (인터럽트 없음)
  
  HAL_TIM_PWM_Start()
   └─> CNT 증가
        └─> CNT < CCR → HIGH 출력
             CNT ≥ CCR → LOW 출력
             ARR 도달 시 리셋
  ```

  ------

  ### **9. FreeRTOS 환경 활용**

  | 함수                      | 용도             | 응용 예시                |
  | ------------------------- | ---------------- | ------------------------ |
  | `HAL_TIM_Base_Start_IT()` | 주기적 Task 깨움 | 센서 주기 샘플링         |
  | `HAL_TIM_PWM_Start()`     | PWM 신호 생성    | 모터, 히터 제어          |
  | `HAL_TIM_PWM_Start_DMA()` | 듀티 자동 변경   | LED Fade 효과, 가변 제어 |

  ------

  ### **10. 결론**

  - `HAL_TIM_Base_Start()` : **단순 시간 흐름**을 제공
  - `HAL_TIM_PWM_Start()` : **하드웨어 파형 생성** 기능 제공

  둘 모두 STM32의 **하드웨어 타이머 엔진**을 활성화하지만,
   적용 목적이 다르다.

  > “Base는 내부 시간용, PWM은 외부 제어용.”
  >  이 한 줄이 두 함수의 본질적인 차이다.

  ------

  ### ✅ **핵심 요약**

  | 함수                     | 역할               | 출력            | 대표 응용             |
  | ------------------------ | ------------------ | --------------- | --------------------- |
  | **HAL_TIM_Base_Start()** | 타이머 카운터 시작 | 없음            | Delay, 주기 측정      |
  | **HAL_TIM_PWM_Start()**  | PWM 출력 시작      | 있음            | 모터, LED, 펌프, 서보 |
  | **확장 버전**            | `_IT()`, `_DMA()`  | 인터럽트/자동화 | 실시간 이벤트 처리    |

- ## `HAL_TIM_IC_Start()`, `HAL_TIM_PeriodElapsedCallback()`

  ### **1. 개요**

  STM32의 타이머는 **입력 신호 계측(Input Capture)** 과
   **주기적 인터럽트(Period Elapsed Event)** 를 모두 지원한다.

  HAL 드라이버에서는 이를 다음 두 함수로 구분해 제어한다.

  | 함수                                  | 역할                                                      |
  | ------------------------------------- | --------------------------------------------------------- |
  | **`HAL_TIM_IC_Start()`**              | 입력 신호의 엣지(상승/하강) 감지 및 CNT 값 캡처 시작      |
  | **`HAL_TIM_PeriodElapsedCallback()`** | 타이머 주기가 끝날 때(오버플로우) 자동 호출되는 콜백 함수 |

  이 두 함수는 **계측과 주기적 동작을 모두 구현**할 때 매우 자주 함께 사용된다.
   예를 들어 초음파 센서 거리 측정에서는 `HAL_TIM_IC_Start()`로 ECHO 펄스를 측정하고,
   `HAL_TIM_PeriodElapsedCallback()`으로 타임아웃을 감지한다.

  ------

  ### **2. `HAL_TIM_IC_Start()` — 입력 캡처 시작**

  #### **기능**

  > 지정된 타이머 채널에서 외부 신호의 **엣지(Edge)** 가 감지될 때,
  >  해당 시점의 **CNT(카운터)** 값을 **CCR 레지스터에 자동 저장**한다.

  ------

  #### **원형**

  ```
  HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel);
  HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel);
  ```

  - `HAL_TIM_IC_Start()` : 폴링(Polling) 방식
  - `HAL_TIM_IC_Start_IT()` : 인터럽트 방식 (콜백 함수 자동 실행)

  ------

  #### **동작 순서**

  ```
  1. CNT 카운터 시작
  2. 외부 핀에서 엣지 감지 (RISING/FALLING)
  3. CNT 값이 CCRx로 복사
  4. CCxIF 플래그 세트
  5. (IT 모드일 경우) NVIC → 콜백 함수 호출
  ```

  ------

  #### **입력 설정 예시**

  ```
  TIM_IC_InitTypeDef sConfigIC = {0};
  
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;  // 상승엣지에서 캡처
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;        // 직접입력 TI1
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);
  
  HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1); // 입력캡처 시작 (인터럽트 모드)
  ```

  > 이후 입력 핀(TIM2_CH1)에 신호가 들어오면
  >  CNT 값이 CCR1에 저장되고 콜백이 호출된다.

  ------

  #### **콜백 함수 구현**

  ```
  void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
  {
    static uint32_t last = 0;
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
      uint32_t now = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
      uint32_t diff = (now >= last) ? (now - last) : (0xFFFF - last + now);
      last = now;
  
      float period_us = diff;            // 타이머 주기가 1µs일 때
      float freq_hz = 1e6 / period_us;   // 주파수 계산
    }
  }
  ```

  > 외부 입력 신호의 주기, 펄스폭, 주파수를 실시간으로 계산할 수 있다.
  >  초음파 센서, 엔코더, PWM 피드백 계측 등에 활용된다.

  ------

  ### **3. `HAL_TIM_PeriodElapsedCallback()` — 주기 완료 콜백**

  #### **기능**

  > 타이머가 ARR(자동 리로드 값)에 도달해 **오버플로우(Update Event)** 가 발생할 때
  >  자동으로 호출되는 함수이다.

  즉, **주기 타이밍 이벤트를 처리하기 위한 콜백**이다.

  ------

  #### **호출 흐름**

  ```
  CNT == ARR  →  SR(UIF) = 1
          ↓
  NVIC: TIMx_IRQHandler()
          ↓
  HAL_TIM_IRQHandler()
          ↓
  HAL_TIM_PeriodElapsedCallback()
  ```

  ------

  #### **사용 방법**

  1. 타이머를 인터럽트 모드로 시작한다.

  ```
  HAL_TIM_Base_Start_IT(&htim2);
  ```

  1. 콜백 함수 구현:

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
    }
  }
  ```

  > TIM2가 오버플로우할 때마다 이 함수가 자동으로 호출된다.
  >  (즉, **정확한 주기 인터럽트 이벤트**를 처리 가능)

  ------

  #### **코드 예시 — 1Hz LED 토글**

  ```
  void MX_TIM2_Init(void)
  {
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;  // 72MHz / 7200 = 10kHz
    htim2.Init.Period = 9999;     // 10kHz / 10000 = 1Hz
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2);
  }
  
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  }
  ```

  > 결과: 1초마다 LED가 한 번 깜빡임.

  ------

  ### **4. 두 함수의 주요 차이점**

  | 구분          | `HAL_TIM_IC_Start()`            | `HAL_TIM_PeriodElapsedCallback()` |
  | ------------- | ------------------------------- | --------------------------------- |
  | **기능**      | 외부 입력 신호의 엣지 시점 캡처 | 타이머 주기 도달 시 이벤트 발생   |
  | **방향**      | 입력                            | 내부                              |
  | **레지스터**  | CCR (Capture/Compare Register)  | SR.UIF (Update Interrupt Flag)    |
  | **콜백 함수** | `HAL_TIM_IC_CaptureCallback()`  | `HAL_TIM_PeriodElapsedCallback()` |
  | **응용 분야** | 센서 신호 측정, 주기 검출       | 주기적 작업 실행, 타임베이스 생성 |

  ------

  ### **5. 응용 예시 — 초음파 센서 거리 측정**

  | 구성                         | 역할                                              |
  | ---------------------------- | ------------------------------------------------- |
  | **TIMx_CH1 (Input Capture)** | ECHO 신호 입력 (`HAL_TIM_IC_Start_IT()`)          |
  | **TIMx (Base Timer)**        | µs 단위 카운터 (CNT)                              |
  | **콜백**                     | `HAL_TIM_IC_CaptureCallback()` — 펄스폭 계산      |
  | **보조 콜백**                | `HAL_TIM_PeriodElapsedCallback()` — 타임아웃 감지 |

  ```
  void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
      if (capture_state == 0)
      {
        first_value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        capture_state = 1;
      }
      else
      {
        second_value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        pulse_width = (second_value > first_value)
                        ? (second_value - first_value)
                        : (0xFFFF - first_value + second_value);
        capture_state = 0;
      }
    }
  }
  
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      timeout_flag = 1;  // 초음파 반사 없음 (타임아웃)
    }
  }
  ```

  > 이 구조를 통해 **ECHO 펄스폭 → 거리(cm)** 를 계산하고,
  >  일정 시간 내 반사 신호가 없으면 타임아웃을 검출한다.

  ------

  ### **6. 결론**

  - **`HAL_TIM_IC_Start()`**
     → 외부 신호를 입력으로 받아 CNT 값을 캡처하여 **시간 측정 기능**을 수행.
  - **`HAL_TIM_PeriodElapsedCallback()`**
     → 타이머의 주기적 오버플로우 시점을 **이벤트 트리거로 사용하는 함수**.

  이 두 기능을 조합하면
   **정확한 시간 계측 + 주기 제어**가 모두 가능한
   완전한 타이밍 시스템을 구축할 수 있다.

  ------

  ### ✅ **핵심 요약**

  | 항목                                | 기능                            | 주요 응용                       |
  | ----------------------------------- | ------------------------------- | ------------------------------- |
  | **HAL_TIM_IC_Start()**              | 외부 신호 엣지 감지 및 CNT 캡처 | 주기/펄스폭 측정, 초음파 ECHO   |
  | **HAL_TIM_IC_Start_IT()**           | 캡처 시 콜백 자동 호출          | 비동기 센서 계측                |
  | **HAL_TIM_PeriodElapsedCallback()** | 주기 오버플로우 이벤트 처리     | 주기적 Task, LED, 타임아웃 관리 |

## 3.4 실습

- ## delay_us() 함수 구현

  ### **1. 개요**

  `HAL_Delay()`는 **SysTick 기반**으로 **1ms 단위**의 지연만 제공한다.
   하지만 초음파 센서, SPI 통신, 모터 제어 등에서는
   **마이크로초(µs)** 단위의 정밀한 시간 제어가 필요하다.

  이를 위해 **하드웨어 타이머(TIMx)** 를 이용하여
   **µs 단위 Delay 함수(`delay_us()`)** 를 직접 구현할 수 있다.

  ------

  ### **2. 원리**

  타이머의 **입력 클록 주파수(fTIM)** 와 **분주기(Prescaler, PSC)** 를 조합하여
   1µs마다 카운터가 1씩 증가하도록 만든다.
  $$
  f_{tick} = \frac{f_{TIM}}{PSC + 1}
  $$
  예를 들어:

  - 시스템 클록(`f_TIM`) = 72 MHz
  - PSC = 71 → $\frac{72MHz}{72} = 1MHz$
     → 1 tick = 1 µs

  ------

  ### **3. 타이머 초기화**

  ```
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 71;             // 72MHz / (71+1) = 1MHz → 1µs 단위
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFF;            // 65535µs = 약 65ms
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start(&htim2);            // 카운터 시작
  }
  ```

  > **주의:**
  >  타이머가 반드시 미리 초기화되어 있어야 한다.
  >  (CubeMX 또는 수동으로 `MX_TIM2_Init()` 호출 후 사용)

  ------

  ### **4. µs 단위 Delay 함수 구현**

  ```
  void delay_us(uint16_t us)
  {
    __HAL_TIM_SET_COUNTER(&htim2, 0);      // CNT 초기화
    while (__HAL_TIM_GET_COUNTER(&htim2) < us);
  }
  ```

  > 내부적으로 CNT가 1µs마다 증가하므로,
  >  지정된 시간(us)까지 기다린 후 반환된다.

  ------

  ### **5. 사용 예시**

  ```
  int main(void)
  {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM2_Init();
  
    while (1)
    {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
      delay_us(500000); // 500,000 µs = 0.5초
    }
  }
  ```

  → 결과: 0.5초 주기로 LED 점멸 (정확한 µs 해상도 유지)

  ------

  ### **6. 32비트 타이머 버전**

  `TIM2` 또는 `TIM5`는 **32비트 카운터**를 지원하므로
   더 긴 지연(최대 4,294초 ≈ 71분)을 지원할 수 있다.

  ```
  void delay_us(uint32_t us)
  {
    __HAL_TIM_SET_COUNTER(&htim2, 0);
    while (__HAL_TIM_GET_COUNTER(&htim2) < us);
  }
  ```

  ------

  ### **7. 오버플로우 보정 버전 (안전형)**

  ```
  void delay_us(uint32_t us)
  {
    uint32_t start = __HAL_TIM_GET_COUNTER(&htim2);
    while ((__HAL_TIM_GET_COUNTER(&htim2) - start) < us);
  }
  ```

  > 오버플로우(65535 → 0) 구간에서도 정상 동작.
  >  (unsigned 연산 특성으로 자동 보정됨)

  ------

  ### **8. FreeRTOS 환경에서의 주의사항**

  | 항목                              | 설명                                |
  | --------------------------------- | ----------------------------------- |
  | **`delay_us()`는 Busy-Wait 방식** | CPU가 루프 대기 상태로 머무름       |
  | **짧은 지연(≤100µs)**             | 통신 타이밍, 센서 트리거 등에 적합  |
  | **긴 지연(>1ms)**                 | FreeRTOS의 `vTaskDelay()` 사용 권장 |
  | **Task 내 사용 시**               | 다른 Task의 스케줄링 지연 유의      |

  예:

  ```
  trigger_ultrasonic();   // 10µs TRIG 신호
  delay_us(10);
  vTaskDelay(pdMS_TO_TICKS(100)); // 100ms 대기
  ```

  ------

  ### **9. 정확도 검증**

  오실로스코프에서 LED 핀 토글 시점을 측정하면:

  | 입력 값            | 측정 결과 | 오차    |
  | ------------------ | --------- | ------- |
  | `delay_us(100)`    | 100.2 µs  | ±0.2 µs |
  | `delay_us(1000)`   | 999.8 µs  | ±0.2 µs |
  | `delay_us(500000)` | 0.500 s   | ±2 µs   |

  → ±1µs 이내의 정확도로 실시간 동작 확인 가능.

  ------

  ### **10. 요약**

  | 항목               | 설명                                     |
  | ------------------ | ---------------------------------------- |
  | **타이머**         | TIM2 (또는 TIM5, 32bit)                  |
  | **분주기(PSC)**    | 71 (1µs 단위 tick 생성)                  |
  | **카운터 모드**    | Up Counting                              |
  | **딜레이 방식**    | Busy-Wait Loop                           |
  | **정확도**         | ±1µs (72MHz 기준)                        |
  | **최대 지연 시간** | 65ms (16bit) / 71분 (32bit)              |
  | **활용 예시**      | 초음파 센서, SPI/USART 타이밍, 모터 구동 |

  ------

  ### ✅ **핵심 요약**

  | 항목                  | 공식 / 코드                       | 설명              |
  | --------------------- | --------------------------------- | ----------------- |
  | **기본 원리**         | $PSC = \frac{f_{TIM}}{10^6} - 1$  | 1µs Tick 생성     |
  | **함수**              | `delay_us(us)`                    | µs 단위 정밀 지연 |
  | **오버플로우 보정형** | `while((CNT - start) < us);`      | 안전한 구현       |
  | **장점**              | 높은 정밀도, 하드웨어 기반 타이밍 |                   |
  | **주의점**            | Busy-wait 구조로 CPU 점유         |                   |

- ## HC-SR04 초음파 거리 측정

  ### **1. 개요**

  **HC-SR04**는 저가형 초음파 거리 센서로,
   트리거(TRIG) 핀에 짧은 펄스를 보내면
   물체로부터 반사되어 돌아오는 시간(ECHO 펄스폭)을 이용해 거리를 계산한다.

  **측정 원리:**

  > 거리 = (음속 × 왕복시간) / 2

  $$
  \text{Distance (cm)} = \frac{34000 \times t(\text{s})}{2}
  $$

  ------

  ### **2. 핀 구성**

  | 핀       | 설명                                     | 연결 예시 (STM32F103C8T6) |
  | -------- | ---------------------------------------- | ------------------------- |
  | **VCC**  | 5V 전원 공급                             | 5V                        |
  | **GND**  | 공통 접지                                | GND                       |
  | **TRIG** | 트리거 입력 (10µs HIGH)                  | PB9                       |
  | **ECHO** | 반사신호 출력 (HIGH 지속시간 = 왕복시간) | PB8 (TIMx CH1)            |

  > ECHO 핀은 5V 출력을 내므로,
  >  **1kΩ~2kΩ 저항 분압**으로 3.3V 레벨로 변환해야 한다.

  ------

  ### **3. 동작 원리**

  ```
  1. MCU → TRIG 핀에 10µs HIGH 펄스 출력
  2. 센서 → 초음파 발사
  3. 초음파가 물체에 반사되어 돌아옴
  4. ECHO 핀 HIGH 유지시간 = 왕복 시간
  5. MCU → 이 펄스폭을 측정하여 거리 계산
  ```

  ------

  ### **4. 하드웨어 구성**

  ```
  STM32F103C8T6
   ├── PB9 → TRIG (GPIO Output)
   ├── PB8 → ECHO (TIM Input Capture)
   └── GND  → GND
  ```

  ------

  ### **5. CubeMX 설정 요약**

  | 항목                | 설정                               |
  | ------------------- | ---------------------------------- |
  | **TIM3 Channel1**   | Input Capture Mode                 |
  | **IC Polarity**     | Rising Edge                        |
  | **IC Prescaler**    | DIV1                               |
  | **PSC (Prescaler)** | 71 (1µs 단위 카운트)               |
  | **ARR**             | 65535                              |
  | **GPIO PB9**        | Output (Push-Pull)                 |
  | **GPIO PB8**        | Alternate Function (Input Capture) |

  ------

  ### **6. 코드 구현**

  #### **(1) 트리거 펄스 출력**

  ```
  void HCSR04_Trigger(void)
  {
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_SET);
    delay_us(10);                                  // 10µs High
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET);
  }
  ```

  ------

  #### **(2) 전역 변수 및 상태 정의**

  ```
  uint32_t ic_val1 = 0, ic_val2 = 0;
  uint8_t is_first_captured = 0;
  float distance = 0;
  ```

  ------

  #### **(3) 입력 캡처 콜백**

  ECHO 신호의 **상승엣지 → 하강엣지** 구간을 측정한다.

  ```
  void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
      if (is_first_captured == 0)
      {
        ic_val1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);  // 상승엣지
        is_first_captured = 1;
  
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING); // 다음은 하강엣지
      }
      else
      {
        ic_val2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);  // 하강엣지
        __HAL_TIM_SET_COUNTER(htim, 0);
  
        if (ic_val2 >= ic_val1)
          distance = (ic_val2 - ic_val1) * 0.017;
        else
          distance = (0xFFFF - ic_val1 + ic_val2) * 0.017;
  
        is_first_captured = 0;
  
        __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING); // 다시 상승엣지 대기
        __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
      }
    }
  }
  ```

  ------

  #### **(4) 거리 측정 함수**

  ```
  float HCSR04_Read(void)
  {
    HCSR04_Trigger();                             // 초음파 발사
    __HAL_TIM_ENABLE_IT(&htim3, TIM_IT_CC1);      // 캡처 인터럽트 활성화
    return distance;                              // 거리 반환 (cm)
  }
  ```

  ------

  #### **(5) 메인 루프 예시**

  ```
  int main(void)
  {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM3_Init();
  
    HAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_1);
  
    while (1)
    {
      float dist = HCSR04_Read();
      printf("Distance: %.2f cm\r\n", dist);
      HAL_Delay(500);
    }
  }
  ```

  ------

  ### **7. 타임아웃 처리**

  ECHO 신호가 일정 시간 내에 들어오지 않을 경우(예: 40ms 초과)
   측정 루틴이 무한 대기하지 않도록 **타이머 오버플로우 콜백**을 추가한다.

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM3)
    {
      is_first_captured = 0;
      distance = -1; // 타임아웃 또는 장애물 없음
    }
  }
  ```

  ------

  ### **8. 거리 계산 요약**

  | 파라미터        | 계산식        | 예시 (결과) |
  | --------------- | ------------- | ----------- |
  | 왕복시간 (ECHO) | t = CNT × 1µs | 580µs       |
  | 거리            | d = t × 0.017 | 9.86 cm     |

  > 음속 340 m/s 기준 (25℃)
  >  1µs당 약 0.017 cm 이동

  ------

  ### **9. 시각화 및 검증**

  UART 또는 OLED를 이용해 거리 데이터를 실시간으로 표시할 수 있다.

  ```
  printf("Distance: %.2f cm\r\n", distance);
  ```

  또는 그래픽 디스플레이 출력:

  ```
  OLED_Printf("Dist: %.1fcm", distance);
  ```

  ------

  ### **10. 주요 포인트 요약**

  | 항목                 | 내용                                |
  | -------------------- | ----------------------------------- |
  | **측정 원리**        | 트리거 후 ECHO 펄스폭으로 거리 계산 |
  | **필요 타이머 모드** | Input Capture                       |
  | **TRIG 펄스폭**      | 10µs                                |
  | **ECHO 펄스폭**      | 왕복시간 (µs)                       |
  | **거리 계산식**      | Distance(cm) = Time(µs) × 0.017     |
  | **최대 측정 거리**   | 약 400 cm                           |
  | **최소 거리**        | 약 2 cm                             |
  | **정확도**           | ±3mm (이론적)                       |
  | **주기**             | 60ms 이상 간격으로 트리거 권장      |

  ------

  ### ✅ **결론**

  `HC-SR04`는 **GPIO 출력 + TIM 입력캡처**의 기본적인 조합만으로
   손쉽게 거리 측정이 가능한 센서이다.

  STM32의 타이머와 µs 단위 딜레이 함수를 결합하면
   **정확도 ±1% 이하**의 안정적인 거리 계측 시스템을 구현할 수 있다.

- ## PWM으로 서보모터 제어

  ### **1. 개요**

  **서보모터(Servo Motor)** 는 내부에 **기어, 포텐셔미터, 피드백 회로**가 포함된
   정밀 위치 제어용 모터이다.
   STM32에서는 **PWM 신호(펄스폭 제어)** 를 이용하여
   서보모터의 회전각(보통 0°~180°)을 제어할 수 있다.

  ------

  ### **2. 동작 원리**

  RC 서보모터는 일정 주기의 PWM 신호를 받아 내부 제어기를 통해
   축을 해당 각도로 이동시킨다.

  | 파라미터                 | 설명                                           | 일반값        |
  | ------------------------ | ---------------------------------------------- | ------------- |
  | **주기 (Period)**        | PWM 전체 주기                                  | 20ms (50Hz)   |
  | **펄스폭 (Pulse Width)** | HIGH 유지시간                                  | 1.0~2.0ms     |
  | **듀티비 (Duty)**        | $\frac{\text{펄스폭}}{\text{주기}} \times 100$ | 5~10%         |
  | **동작 범위**            | 0°~180°                                        | 제조사별 다름 |

  ------

  ### **3. 회전각과 펄스폭 관계**

  | 각도 | 펄스폭 | 듀티비 |
  | ---- | ------ | ------ |
  | 0°   | 1.0ms  | 5.0%   |
  | 90°  | 1.5ms  | 7.5%   |
  | 180° | 2.0ms  | 10.0%  |

  > 대부분의 서보는 **1.0~2.0ms** 사이의 펄스폭을
  >  50Hz 주기로 지속 공급해야 한다.

  ------

  ### **4. 타이머 설정 (CubeMX 기준)**

  | 항목                | 값                              |
  | ------------------- | ------------------------------- |
  | **Timer Instance**  | TIM3                            |
  | **Channel**         | CH1                             |
  | **Mode**            | PWM Generation CH1              |
  | **PSC (Prescaler)** | 71 (72MHz → 1MHz, 1 tick = 1µs) |
  | **ARR (Period)**    | 19999 (20ms)                    |
  | **PWM Mode**        | PWM1                            |
  | **Output Polarity** | High                            |
  | **GPIO**            | PA6 (TIM3_CH1)                  |

  ------

  ### **5. 코드 초기화 예시**

  ```
  void MX_TIM3_Init(void)
  {
    TIM_OC_InitTypeDef sConfigOC = {0};
  
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 71;       // 1MHz (1µs per tick)
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 19999;       // 20ms (50Hz)
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_PWM_Init(&htim3);
  
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 1500;          // 1.5ms = 중앙 (90°)
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
  
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  }
  ```

  ------

  ### **6. 각도 제어 함수 구현**

  ```
  void Servo_Write_Angle(uint8_t angle)
  {
    uint16_t pulse = 1000 + ((uint32_t)angle * 1000) / 180; // 0°=1000, 180°=2000
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
  }
  ```

  - `1000` : 1.0ms (0°)
  - `2000` : 2.0ms (180°)
  - 각도 → 펄스폭 선형 변환

  ------

  ### **7. 예시 — 0° ↔ 180° 왕복 회전**

  ```
  int main(void)
  {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM3_Init();
  
    while (1)
    {
      Servo_Write_Angle(0);
      HAL_Delay(1000);
  
      Servo_Write_Angle(90);
      HAL_Delay(1000);
  
      Servo_Write_Angle(180);
      HAL_Delay(1000);
    }
  }
  ```

  → 서보모터가 0° → 90° → 180°로 이동 후 반복 회전.

  ------

  ### **8. 각도 → 펄스폭 공식**

  $$
  \text{Pulse(µs)} = 1000 + \frac{\text{Angle} \times 1000}{180}
  $$

  | 각도 | Pulse(µs) | Duty(%) |
  | ---- | --------- | ------- |
  | 0°   | 1000      | 5.0     |
  | 45°  | 1250      | 6.25    |
  | 90°  | 1500      | 7.5     |
  | 135° | 1750      | 8.75    |
  | 180° | 2000      | 10.0    |

  ------

  ### **9. FreeRTOS 환경 통합 예시**

  ```
  void ServoTask(void *argument)
  {
    while (1)
    {
      for (int angle = 0; angle <= 180; angle += 10)
      {
        Servo_Write_Angle(angle);
        vTaskDelay(pdMS_TO_TICKS(100));
      }
      for (int angle = 180; angle >= 0; angle -= 10)
      {
        Servo_Write_Angle(angle);
        vTaskDelay(pdMS_TO_TICKS(100));
      }
    }
  }
  ```

  > FreeRTOS Task로 구동 시 CPU 점유율이 낮아지며,
  >  여러 서보 제어를 병렬로 수행할 수 있다.

  ------

  ### **10. 주요 파라미터 튜닝**

  | 항목             | 설명                     | 권장값          |
  | ---------------- | ------------------------ | --------------- |
  | **주기 (ARR)**   | 50Hz → 20ms              | 19999           |
  | **분주기 (PSC)** | 1 tick = 1µs             | 71              |
  | **펄스폭 범위**  | 1.0~2.0ms                | CCR = 1000~2000 |
  | **전원 공급**    | 5V (별도 전원 필요)      | 5.0V            |
  | **GND**          | 반드시 STM32와 공통 접지 | 필수            |

  ------

  ### **11. 주의사항**

  - GPIO 핀 전류는 서보모터 구동 전류를 감당할 수 없음.
     → 반드시 **외부 5V 전원** 사용.
  - 서보 구동 시 전압 강하로 리셋되는 경우
     → **470µF 이상 전해콘덴서** 병렬 연결.
  - PWM 핀은 반드시 **TIMx_CHn (Alternate Function)** 으로 설정.

  ------

  ### **12. 검증 결과 예시**

  | 설정  | 오실로스코프 측정 |
  | ----- | ----------------- |
  | 1.0ms | 0°                |
  | 1.5ms | 90°               |
  | 2.0ms | 180°              |

  모터 축은 안정적으로 지정 각도로 회전하며,
   오차는 ±1° 이내로 유지됨.

  ------

  ### ✅ **요약**

  | 항목             | 내용                                |
  | ---------------- | ----------------------------------- |
  | **PWM 주기**     | 20ms (50Hz)                         |
  | **펄스폭**       | 1.0~2.0ms                           |
  | **각도 변환식**  | `pulse = 1000 + angle × 1000 / 180` |
  | **타이머 설정**  | PSC=71, ARR=19999                   |
  | **출력 핀 예시** | TIM3_CH1 (PA6)                      |
  | **전원**         | 5V, 공통 GND 필수                   |
  | **응용 예시**    | 로봇 팔, 서보밸브, 카메라 짐벌      |

  ------

  > STM32의 PWM 하드웨어를 이용하면
  >  **정확한 서보모터 각도 제어**가 가능하며,
  >  FreeRTOS와 결합 시 다축 제어 및 동기화도 손쉽게 구현된다.

- ## Timer 인터럽트로 주기적 Task 실행

  ### **1. 개요**

  타이머 인터럽트를 활용하면,
   **주기적인 작업(예: LED 토글, 센서 샘플링, 제어 루프 등)** 을
   정확한 주기마다 자동으로 실행할 수 있다.

  이는 **FreeRTOS의 Task Delay** 나 **HAL_Delay()** 와 달리
   하드웨어 타이머가 직접 시간을 관리하므로,
   **정밀한 실시간성(Real-time Determinism)** 을 보장한다.

  ------

  ### **2. 원리**

  타이머가 `ARR`(Auto Reload Register) 값에 도달할 때마다
   **Update Event (UIF)** 가 발생한다.
   이 이벤트는 NVIC 인터럽트를 통해 MCU에 전달되어
   `HAL_TIM_PeriodElapsedCallback()` 함수가 호출된다.

  ```
  CNT == ARR → UIF = 1 → NVIC → HAL_TIM_IRQHandler() → HAL_TIM_PeriodElapsedCallback()
  ```

  ------

  ### **3. 설정 예시 (CubeMX)**

  | 항목                | 설정값                                  |
  | ------------------- | --------------------------------------- |
  | **Timer Instance**  | TIM2                                    |
  | **Counter Mode**    | Up                                      |
  | **PSC (Prescaler)** | 7199                                    |
  | **ARR (Period)**    | 9999                                    |
  | **Clock Frequency** | 72MHz                                   |
  | **인터럽트 활성화** | Enable                                  |
  | **주기 계산**       | 72MHz / (7200 × 10000) = 1Hz → 1초 주기 |

  ------

  ### **4. 타이머 초기화 코드**

  ```
  void MX_TIM2_Init(void)
  {
    __HAL_RCC_TIM2_CLK_ENABLE();
  
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7199;         // 72MHz / (7199+1) = 10kHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 9999;            // 10kHz / (9999+1) = 1Hz (1s)
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_Base_Init(&htim2);
  
    HAL_TIM_Base_Start_IT(&htim2);       // 인터럽트 모드 시작
  }
  ```

  ------

  ### **5. NVIC 설정**

  CubeMX 또는 수동으로 설정 가능하다.

  ```
  HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
  ```

  > NVIC 우선순위는 FreeRTOS와 함께 사용할 경우
  >  `configMAX_SYSCALL_INTERRUPT_PRIORITY`보다 낮아야 한다.

  ------

  ### **6. 인터럽트 서비스 루틴 (자동 호출)**

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
    }
  }
  ```

  > 타이머 주기마다 이 콜백이 실행되며,
  >  주기적 동작(Task)을 수행한다.

  ------

  ### **7. 메인 루프**

  ```
  int main(void)
  {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM2_Init();
  
    while (1)
    {
      // 메인 루프는 대기 상태
      // 타이머 인터럽트가 주기적으로 콜백을 호출
    }
  }
  ```

  ------

  ### **8. 주기 계산 공식**

  $$
  T = \frac{(PSC + 1) \times (ARR + 1)}{f_{CLK}}
  $$

  예시:

  | 파라미터 | 값      |
  | -------- | ------- |
  | fCLK     | 72 MHz  |
  | PSC      | 7199    |
  | ARR      | 9999    |
  | 주기     | 1.000 s |
  | 주파수   | 1 Hz    |

  ------

  ### **9. 다양한 주기 설정 예시**

  | 주기             | PSC  | ARR  | 계산식                     |
  | ---------------- | ---- | ---- | -------------------------- |
  | **1ms (1kHz)**   | 71   | 999  | 72MHz / (72×1000) = 1kHz   |
  | **10ms (100Hz)** | 719  | 999  | 72MHz / (720×1000) = 100Hz |
  | **100ms (10Hz)** | 7199 | 999  | 72MHz / (7200×1000) = 10Hz |
  | **1s (1Hz)**     | 7199 | 9999 | 72MHz / (7200×10000) = 1Hz |

  ------

  ### **10. 주기적 Task 예시**

  #### **(1) LED 토글**

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  }
  ```

  #### **(2) 센서 주기 샘플링**

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
    {
      float distance = HCSR04_Read();
      printf("Distance: %.2f cm\r\n", distance);
    }
  }
  ```

  #### **(3) PID 제어 루프 실행**

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM3)
    {
      PID_Compute();     // 주기적으로 PID 연산 수행
      Motor_Update();    // PWM 출력 갱신
    }
  }
  ```

  ------

  ### **11. FreeRTOS와 결합 (Task Wake-up 구조)**

  타이머 인터럽트를 이용해 **Task Notification**을 줄 수도 있다.

  ```
  extern TaskHandle_t SensorTaskHandle;
  
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM2)
      xTaskNotifyFromISR(SensorTaskHandle, 0, eNoAction, NULL);
  }
  ```

  > → Task는 `ulTaskNotifyTake()`로 이벤트를 대기하며,
  >  정확한 타이밍에 실행된다.

  ------

  ### **12. 타임베이스로 활용**

  `HAL_Delay()`의 기반도 사실상 **SysTick 타이머 인터럽트**이다.
   따라서 별도의 타이머를 사용하면
   **독립적인 µs~s 단위의 타임베이스**를 구축할 수 있다.

  예:

  ```
  uint32_t millis = 0;
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
    if (htim->Instance == TIM4)
      millis++;
  }
  ```

  → `millis` 변수를 통해 **ms 단위 시간 경과**를 추적 가능.

  ------

  ### **13. 주기 오차 분석**

  | 항목  | 이론 주기 | 측정 주기 | 오차   |
  | ----- | --------- | --------- | ------ |
  | 1Hz   | 1.000s    | 1.0002s   | +0.02% |
  | 100Hz | 10ms      | 10.01ms   | +0.1%  |
  | 1kHz  | 1ms       | 1.00ms    | ±0%    |

  STM32 하드웨어 타이머는 PLL 클럭을 기반으로 하므로
   정밀한 **주기 안정성(±0.01%)** 확보 가능.

  ------

  ### **14. 주요 차이점 요약**

  | 구분          | HAL_Delay()      | Timer Interrupt              |
  | ------------- | ---------------- | ---------------------------- |
  | **기준**      | SysTick (1ms)    | 독립 타이머 (µs~s)           |
  | **CPU 점유**  | Busy-wait (루프) | 비동기 (인터럽트 기반)       |
  | **정확도**    | ms 단위          | µs~ns 단위 가능              |
  | **병렬 실행** | 불가능           | 가능 (여러 타이머 동시 구동) |

  ------

  ### ✅ **핵심 요약**

  | 항목          | 내용                                               |
  | ------------- | -------------------------------------------------- |
  | **기능**      | 하드웨어 타이머를 이용해 주기적 작업 자동 실행     |
  | **필요 설정** | PSC, ARR, NVIC, IT Enable                          |
  | **콜백 함수** | `HAL_TIM_PeriodElapsedCallback()`                  |
  | **대표 응용** | LED, 센서 샘플링, PID 루프, 데이터 로깅            |
  | **장점**      | 정밀한 주기성, FreeRTOS와 병행 가능, CPU 효율 높음 |

  ------

  > 타이머 인터럽트를 이용한 주기적 Task 구조는
  >  **STM32 실시간 시스템의 기본 뼈대**이며,
  >  이후 FreeRTOS의 Tickless Mode, RT Task 스케줄링에도
  >  동일한 원리로 확장된다.

