# 10. SPI

## 10.1 SPI 통신 구조 (CPOL, CPHA)

SPI(Serial Peripheral Interface)는 **고속 동기식 직렬 통신 프로토콜**로, 마스터(Master)와 슬레이브(Slave) 간에 **클록(SCK)** 신호를 기준으로 데이터를 송수신하는 구조를 가집니다.
 UART나 I²C보다 **속도가 빠르고, 전이중(Full-Duplex) 통신**이 가능하다는 장점이 있습니다.

------

### SPI 기본 개념

SPI는 4개의 기본 신호선으로 구성됩니다.

| 신호                           | 방향           | 설명                              |
| ------------------------------ | -------------- | --------------------------------- |
| **MOSI** (Master Out Slave In) | Master → Slave | 마스터가 데이터를 슬레이브로 전송 |
| **MISO** (Master In Slave Out) | Slave → Master | 슬레이브가 데이터를 마스터로 전송 |
| **SCK** (Serial Clock)         | Master → Slave | 클록 신호 제공 (동기 기준)        |
| **NSS / CS** (Chip Select)     | Master → Slave | 슬레이브 선택 신호 (Low Active)   |

> NSS (또는 CS)가 ‘Low’일 때만 슬레이브가 활성화되어 통신에 응답합니다.

------

### SPI 통신의 기본 구조

SPI는 **클록 극성(CPOL)** 과 **위상(CPHA)** 의 조합으로 동작 모드를 결정합니다.
 이 두 파라미터는 데이터 샘플링 타이밍과 클록의 기본 레벨을 정의합니다.

| 모드       | CPOL | CPHA | 설명                                          |
| ---------- | ---- | ---- | --------------------------------------------- |
| **Mode 0** | 0    | 0    | 클록 Low 유지, 첫 번째 엣지(상승)에서 샘플링  |
| **Mode 1** | 0    | 1    | 클록 Low 유지, 두 번째 엣지(하강)에서 샘플링  |
| **Mode 2** | 1    | 0    | 클록 High 유지, 첫 번째 엣지(하강)에서 샘플링 |
| **Mode 3** | 1    | 1    | 클록 High 유지, 두 번째 엣지(상승)에서 샘플링 |

#### 파형 비교 개념

- **CPOL** → 클록의 기본 상태 (Idle 시 High/Low)
- **CPHA** → 데이터가 유효해지는 시점 (1st or 2nd edge)

SPI 장치를 연결할 때는 **Master와 Slave의 CPOL/CPHA 설정이 반드시 일치해야 합니다.**

------

### SPI 통신의 데이터 흐름

- SPI는 **Shift Register 방식**으로 동작합니다.
- 마스터가 **SCK 클록**을 발생시키며, 매 클록마다 MOSI/MISO 양쪽으로 데이터가 1비트씩 이동합니다.
- 전이중(Full Duplex)이기 때문에, 마스터가 송신하면서 동시에 슬레이브의 데이터를 수신할 수 있습니다.

예시 (8비트 전송):

1. 마스터가 MOSI를 통해 1바이트 송신
2. 동시에 MISO를 통해 슬레이브로부터 1바이트 수신
3. 클록 8번 전송 후, 내부 레지스터에 각각의 데이터가 채워짐

------

### SPI 프레임 구조

| 구분                | 설명                              |
| ------------------- | --------------------------------- |
| **NSS (CS)**        | Low → 통신 시작, High → 통신 종료 |
| **SCK**             | 동기 신호 (Master에서 생성)       |
| **MOSI / MISO**     | 8/16비트 단위 전송 가능           |
| **MSB / LSB First** | 비트 전송 순서 선택 가능          |

------

### SPI의 장점

- 매우 빠른 속도 (수 MHz ~ 수십 MHz 가능)
- 전이중(Full-duplex) 통신
- 하드웨어 구성 간단 (풀업 저항 불필요)
- 동기식이므로 타이밍 오차 적음

### SPI의 단점

- 슬레이브 수가 많아지면 CS 라인이 여러 개 필요
- 통신 거리 짧음 (수십 cm 이하 권장)
- 멀티마스터 구성 어려움

------

### SPI 모드 설정 (CubeIDE 예시)

1. **CubeMX → SPI1 설정 탭**

   - Mode: Full Duplex Master
   - Hardware NSS: Disabled (수동 제어 시)
   - Prescaler: 8 (또는 원하는 클록 분주비)
   - Data Size: 8 bits
   - First Bit: MSB First
   - Clock Polarity: Low (CPOL=0)
   - Clock Phase: 1 Edge (CPHA=0)

2. **SPI 핀맵**

   - SCK → PA5
   - MOSI → PA7
   - MISO → PA6
   - NSS → PA4 (수동 제어 시 GPIO로 설정)

3. **자동 생성 코드**

   ```
   hspi1.Instance = SPI1;
   hspi1.Init.Mode = SPI_MODE_MASTER;
   hspi1.Init.Direction = SPI_DIRECTION_2LINES;
   hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
   hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
   hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
   hspi1.Init.NSS = SPI_NSS_SOFT;
   hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
   hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
   hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
   HAL_SPI_Init(&hspi1);
   ```

------

### SPI 클록 속도 계산

SPI 클록 주파수는 다음과 같이 계산됩니다:
$$
f_{SPI} = \frac{f_{PCLK}}{Prescaler}
$$
예를 들어, PCLK = 72MHz, Prescaler = 8 → SPI 클록 = 9MHz
 너무 빠른 속도에서는 일부 슬레이브가 응답하지 않으므로
 데이터시트의 **최대 SPI 주파수(Fmax)** 를 반드시 확인해야 합니다.

------

### 실제 예제: SPI 통신 루프백 테스트

```
uint8_t txData[4] = {0xAA, 0xBB, 0xCC, 0xDD};
uint8_t rxData[4] = {0};

HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); // NSS Low
HAL_SPI_TransmitReceive(&hspi1, txData, rxData, 4, 100);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);   // NSS High
```

> 실제 통신 장비가 없을 경우 MOSI와 MISO를 점퍼로 연결하여 루프백 테스트를 수행할 수 있습니다.

------

### SPI 슬레이브 예시 디바이스

| 디바이스               | 설명                           |
| ---------------------- | ------------------------------ |
| **W25Q64 Flash**       | 외부 데이터 저장용 SPI Flash   |
| **MAX6675 / MAX31855** | 열전대(Thermocouple) 온도 센서 |
| **NRF24L01**           | 무선 송수신 모듈               |
| **ILI9341 LCD**        | SPI 기반 TFT 디스플레이        |
| **ADS1256 / MCP3208**  | 고정밀 ADC 칩                  |

------

### 실습 과제

1. SPI1을 마스터로 설정 후 MOSI ↔ MISO 루프백 테스트 수행
2. CPOL/CPHA 조합 변경에 따른 데이터 수신 타이밍 비교
3. SPI 클록 분주비 변경에 따른 통신 속도 측정
4. W25Qxx SPI Flash 연결 후 “Device ID 읽기” 명령 실습
5. LCD 또는 OLED와 SPI 통신으로 텍스트 출력

## 10.2 Master/Slave 설정

SPI(Serial Peripheral Interface)는 기본적으로 **하나의 Master**와 **하나 이상의 Slave**가 동일한 버스(SCK, MOSI, MISO, NSS)를 공유하는 **동기식 직렬 통신 구조**를 갖는다.
 Master는 **클록 신호(SCK)**를 생성하고, Slave는 이 클록에 동기되어 데이터를 송수신한다.
 따라서 SPI 통신을 올바르게 수행하기 위해서는 Master/Slave 간의 역할 구분과 설정이 필수적이다.

------

### SPI 시스템 구조

하나의 SPI 버스에는 보통 다음과 같은 라인이 존재한다:

| 신호                                | 방향           | 설명                         |
| ----------------------------------- | -------------- | ---------------------------- |
| **SCK (Serial Clock)**              | Master → Slave | Master가 생성하는 클록 신호  |
| **MOSI (Master Out Slave In)**      | Master → Slave | Master → Slave 데이터 송신   |
| **MISO (Master In Slave Out)**      | Slave → Master | Slave → Master 데이터 송신   |
| **NSS (Slave Select, Chip Select)** | Master → Slave | Slave 선택 신호 (Low Active) |

> 하나의 Master가 여러 Slave를 제어할 경우, 각 Slave는 고유한 NSS 라인을 가진다.

------

### Master의 역할

Master 장치는 SPI 통신의 **주도권을 가지며**, 다음 기능을 수행한다.

- 클록(SCK) 신호 발생
- 데이터 전송 순서 제어 (MOSI ↔ MISO)
- 슬레이브 선택 (NSS Low)
- 데이터 송수신 동기 제어

즉, 모든 통신은 **Master의 명령**에 따라 시작되고 종료된다.

------

### Slave의 역할

Slave 장치는 Master의 클록과 NSS 신호를 기준으로 동작한다.

- 클록에 맞춰 데이터 수신/송신
- NSS Low 상태에서만 통신 응답
- 자신의 주소나 NSS 신호에 의해 활성화됨
- Master의 클록이 없으면 동작하지 않음

> Slave는 클록을 생성하지 않으므로 **비동기 전송 불가**.

------

### CubeIDE에서 Master 설정

#### (1) CubeMX Configuration

1. **Peripherals → SPI1 → Mode: Master**
2. Hardware NSS → Disable (소프트웨어 제어 시)
3. Clock Polarity / Phase 설정 (CPOL=0, CPHA=0)
4. Baud Rate Prescaler 설정 (예: ÷8)
5. Data Size = 8-bit, MSB First 선택

#### (2) 자동 생성 코드 예시

```
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
HAL_SPI_Init(&hspi1);
```

------

### CubeIDE에서 Slave 설정

#### (1) CubeMX Configuration

1. **Peripherals → SPI2 → Mode: Slave**
2. Hardware NSS → Enable (CS 신호 자동 처리)
3. Clock Polarity / Phase → Master와 동일하게 설정
4. Data Size / Bit Order 동일하게 설정 (예: 8-bit, MSB First)

#### (2) 자동 생성 코드 예시

```
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_SLAVE;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_HARD_INPUT;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
HAL_SPI_Init(&hspi2);
```

------

### Master–Slave 간 하드웨어 연결 예시

| SPI Signal | Master Pin | Slave Pin |
| ---------- | ---------- | --------- |
| SCK        | PA5        | PB13      |
| MOSI       | PA7        | PB15      |
| MISO       | PA6        | PB14      |
| NSS        | PA4        | PB12      |

> Master의 NSS 핀을 Low로 내리면 Slave가 통신 준비 상태로 전환된다.

------

### 동작 순서 예시

1. Master가 **NSS = Low**로 설정 → Slave 활성화
2. Master가 **SCK 클록**을 발생시키며 MOSI로 데이터 송신
3. Slave는 클록의 엣지에 맞춰 데이터 수신
4. 동시에 MISO로 Slave → Master 데이터 전송
5. 전송 완료 후 Master가 **NSS = High**로 변경 → 통신 종료

------

### 전이중(Full Duplex) 구조

SPI는 한 번의 클록 사이클에 MOSI와 MISO가 동시에 데이터 전송을 수행한다.
 따라서 Master는 데이터를 보내면서 동시에 Slave의 응답을 수신할 수 있다.

> UART는 반이중(Half Duplex), SPI는 전이중(Full Duplex) 통신임을 기억할 것.

------

### 실습 코드 예제

#### Master 전송 코드

```
uint8_t txData[] = {0xAB, 0xCD, 0xEF};
uint8_t rxData[3];

HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); // NSS Low
HAL_SPI_TransmitReceive(&hspi1, txData, rxData, sizeof(txData), 100);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);   // NSS High
```

#### Slave 수신 코드

```
uint8_t rxBuffer[3];
HAL_SPI_Receive(&hspi2, rxBuffer, 3, HAL_MAX_DELAY);
```

------

### 통신 검증 방법

1. **Logic Analyzer**를 사용해 SCK, MOSI, MISO, NSS 신호 확인
2. CPOL/CPHA가 일치하지 않으면 데이터가 1비트씩 밀리거나 깨짐
3. MISO 라인에 풀업 저항을 추가하면 노이즈 억제에 유리
4. 통신 실패 시 SPI Prescaler 값을 높여 속도를 낮춰 테스트

------

### 실습 과제

1. SPI1(Master) ↔ SPI2(Slave) 연결 후 루프백 통신 테스트
2. NSS 신호를 GPIO로 직접 제어하며 통신 상태 관찰
3. CPOL/CPHA 설정 변경 시 신호 파형 비교
4. SPI 클록 속도 변화에 따른 데이터 손상 여부 확인

## 10.3 HAL_SPI Transmit/Receive

이 절에서는 STM32 HAL 라이브러리를 이용해 SPI 통신에서 송수신 기능을 구현하는 방법을 학습한다. SPI는 **전이중(Full-Duplex)** 통신이 가능하며, 데이터 송신과 수신이 동시에 이루어진다. HAL에서는 `HAL_SPI_Transmit()`, `HAL_SPI_Receive()`, `HAL_SPI_TransmitReceive()` 함수가 제공된다.

------

#### SPI 데이터 송신 (HAL_SPI_Transmit)

- **함수 프로토타입**

  ```
  HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
  ```

- **매개변수 설명**

  - `hspi`: SPI 핸들 구조체 포인터 (`SPI_HandleTypeDef`)
  - `pData`: 송신할 데이터 버퍼의 포인터
  - `Size`: 전송할 데이터 개수 (byte 단위)
  - `Timeout`: 타임아웃 시간(ms)

- **반환값**

  - `HAL_OK`, `HAL_TIMEOUT`, `HAL_ERROR`, `HAL_BUSY`

- **예제 코드**

  ```
  uint8_t txData[2] = {0xA5, 0x5A};
  HAL_SPI_Transmit(&hspi1, txData, 2, 100);
  ```

------

#### SPI 데이터 수신 (HAL_SPI_Receive)

- **함수 프로토타입**

  ```
  HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout);
  ```

- **설명**

  - 마스터는 클록을 발생시켜야만 Slave로부터 데이터를 읽을 수 있다.
  - 단순 수신 시에는 Dummy 데이터 전송이 필요할 수 있다.

- **예제 코드**

  ```
  uint8_t rxData[2];
  HAL_SPI_Receive(&hspi1, rxData, 2, 100);
  ```

------

#### SPI 동시 송수신 (HAL_SPI_TransmitReceive)

- **함수 프로토타입**

  ```
  HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout);
  ```

- **특징**

  - SPI는 전이중 통신이므로 송신과 수신이 동시에 수행됨.
  - 마스터에서 보낸 클록에 맞춰 수신이 동시에 진행됨.

- **예제 코드**

  ```
  uint8_t txBuf[2] = {0x01, 0x02};
  uint8_t rxBuf[2];
  HAL_SPI_TransmitReceive(&hspi1, txBuf, rxBuf, 2, 100);
  ```

------

#### SPI 상태 확인 및 디버깅

- **SPI 상태 체크**

  ```
  if (HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_READY)
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  ```

- **에러 코드 확인**

  ```
  uint32_t errorCode = HAL_SPI_GetError(&hspi1);
  ```

------

#### 송수신 타이밍 다이어그램 분석

| Signal       | 설명                         |
| ------------ | ---------------------------- |
| **SCK**      | 클록 신호 (마스터에서 생성)  |
| **MOSI**     | Master Out Slave In          |
| **MISO**     | Master In Slave Out          |
| **NSS (CS)** | Slave 선택 신호 (Active Low) |

- SPI의 CPOL/CPHA 설정에 따라 MOSI/MISO 데이터 샘플링 타이밍이 달라진다.
- **CubeMX**에서 SPI Mode (0~3) 설정을 반드시 확인해야 한다.

------

#### SPI 통신 시 주의점

1. **NSS 관리**

   - 수동 제어 시 GPIO로 직접 Low/High 제어해야 함.

   - 예:

     ```
     HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); // CS Low
     HAL_SPI_TransmitReceive(&hspi1, txBuf, rxBuf, 2, 100);
     HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);   // CS High
     ```

2. **클록 속도(BaudRatePrescaler)**

   - Slave의 최대 SPI 속도보다 느리게 설정.
   - `hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;`

3. **데이터 정렬 / 비트 순서**

   - `SPI_FIRSTBIT_MSB` 또는 `SPI_FIRSTBIT_LSB`로 설정.

4. **풀업/풀다운**

   - MISO 라인은 풀업 저항이 필요할 수 있음 (floating 방지).

------

#### 실습 예제 – SPI EEPROM (25LC256) 통신

```
uint8_t cmd = 0x9F;     // JEDEC ID 읽기 명령
uint8_t id[3];

HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi1, &cmd, 1, 100);
HAL_SPI_Receive(&hspi1, id, 3, 100);
HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET);
```

**결과**

- `id[]` 배열에 Manufacturer ID, Memory Type, Capacity 값이 저장됨.
- SPI 모듈이 정상적으로 작동하면 UART 콘솔에 ID 출력 가능.

------

#### 요약

| 구분     | 함수                        | 특징                 |
| -------- | --------------------------- | -------------------- |
| 송신     | `HAL_SPI_Transmit()`        | 데이터 전송만 수행   |
| 수신     | `HAL_SPI_Receive()`         | Dummy 클록 발생 필요 |
| 송수신   | `HAL_SPI_TransmitReceive()` | Full-Duplex 통신용   |
| 인터럽트 | `HAL_SPI_Transmit_IT()` 등  | 비동기 통신          |
| DMA      | `HAL_SPI_Transmit_DMA()` 등 | CPU 부하 최소화      |

## 10.4 DMA 기반 SPI

DMA(Direct Memory Access)를 이용한 SPI 통신은 CPU가 직접 데이터를 송수신하지 않고, DMA 컨트롤러가 **메모리와 SPI 주변장치 간 전송을 자동으로 처리**하도록 하는 방식이다.
 이를 통해 **CPU 부하 감소**, **전송 속도 향상**, **실시간 응답성 유지** 등의 장점이 있다.

------

#### DMA 기반 SPI의 동작 원리

1. **DMA 채널 설정**
   - CubeMX 또는 코드에서 SPI의 TX/RX에 해당하는 DMA 채널을 연결한다.
   - 예: `DMA1_Channel3` → SPI1_TX, `DMA1_Channel2` → SPI1_RX
2. **DMA 초기화**
   - 전송할 버퍼 주소, 크기, 방향(Memory → Peripheral 또는 반대)을 설정.
   - `HAL_SPI_Transmit_DMA()`, `HAL_SPI_Receive_DMA()`, `HAL_SPI_TransmitReceive_DMA()` 사용 시 HAL이 자동 설정.
3. **DMA 요청 발생**
   - SPI 주변장치가 TXE 또는 RXNE 이벤트 발생 시 DMA에 요청 신호(DRQ) 발생.
   - DMA 컨트롤러가 버스에 직접 접근해 데이터 전송.
4. **전송 완료**
   - DMA는 지정된 데이터 크기만큼 전송 후 **Transfer Complete Interrupt (TCIF)** 발생.
   - HAL의 `HAL_SPI_TxCpltCallback()` 또는 `HAL_SPI_RxCpltCallback()`이 호출됨.

------

#### 주요 HAL 함수

| 함수명                          | 설명                                |
| ------------------------------- | ----------------------------------- |
| `HAL_SPI_Transmit_DMA()`        | DMA를 통한 송신 시작                |
| `HAL_SPI_Receive_DMA()`         | DMA를 통한 수신 시작                |
| `HAL_SPI_TransmitReceive_DMA()` | 전이중(Full-Duplex) DMA 송수신 시작 |
| `HAL_SPI_DMAStop()`             | DMA 송수신 중단                     |
| `HAL_SPI_TxCpltCallback()`      | 송신 완료 시 호출되는 콜백          |
| `HAL_SPI_RxCpltCallback()`      | 수신 완료 시 호출되는 콜백          |
| `HAL_SPI_ErrorCallback()`       | DMA 또는 SPI 에러 발생 시 호출      |

------

#### 예제 1 – DMA 기반 SPI 송신

```
uint8_t txData[10] = {0xA1, 0xB2, 0xC3, 0xD4, 0xE5, 0xF6, 0x11, 0x22, 0x33, 0x44};

// DMA 송신 시작
if (HAL_SPI_Transmit_DMA(&hspi1, txData, sizeof(txData)) != HAL_OK)
{
    Error_Handler();
}
```

**콜백 함수 예시**

```
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi->Instance == SPI1)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 전송 완료 시 LED 토글
    }
}
```

------

#### 예제 2 – DMA 기반 SPI 송수신 (Full-Duplex)

```
uint8_t txBuf[5] = {0x9F, 0x00, 0x00, 0x00, 0x00};
uint8_t rxBuf[5];

// DMA 기반 SPI 송수신 시작
HAL_SPI_TransmitReceive_DMA(&hspi1, txBuf, rxBuf, 5);
```

**콜백 처리**

```
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi->Instance == SPI1)
    {
        printf("SPI DMA Rx: %02X %02X %02X %02X %02X\r\n",
               rxBuf[0], rxBuf[1], rxBuf[2], rxBuf[3], rxBuf[4]);
    }
}
```

------

#### DMA 전송 중 상태 확인

```
if (HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_BUSY_TX_RX)
{
    // SPI 전송 중
}
else if (HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_READY)
{
    // SPI 유휴 상태
}
```

------

#### DMA 설정 시 유의사항

1. **DMA 버퍼는 SRAM에 존재해야 함**
   - `const` 플래시 데이터 전송 시 문제 발생 가능.
2. **NSS 신호 수동 제어**
   - DMA는 SPI 통신 종료 시점을 인식하지 못함 → 전송 완료 콜백에서 NSS를 High로 복원.
3. **버스 충돌 방지**
   - DMA가 전송 중일 때 SPI를 수동으로 다시 Start하지 않도록 주의.
4. **캐시 일관성 문제**
   - Cortex-M7 계열(H7 등)에서는 DCache Clean/Invalidate 필요.
5. **전송 크기 제한**
   - 일부 DMA 컨트롤러는 16비트 단위까지만 전송 가능.

------

#### CubeMX 설정 요약

| 설정 항목             | 값 / 예시                                        |
| --------------------- | ------------------------------------------------ |
| SPI Mode              | Master                                           |
| Direction             | 2Lines (Full-Duplex)                             |
| Data Size             | 8-bit                                            |
| Clock Polarity/Phase  | Mode 0                                           |
| NSS                   | Software                                         |
| DMA Settings          | SPI1_TX → DMA1_Channel3, SPI1_RX → DMA1_Channel2 |
| NVIC Interrupt Enable | DMA1 Channel2/3                                  |

------

#### DMA Interrupt 루틴 예시

```
void DMA1_Channel2_3_IRQHandler(void)
{
    HAL_DMA_IRQHandler(hspi1.hdmarx);
    HAL_DMA_IRQHandler(hspi1.hdmatx);
}
```

이 핸들러는 DMA 인터럽트 발생 시 HAL 내부에서 자동으로 SPI DMA 완료 콜백을 호출하게 한다.

------

#### 디버깅 포인트

| 증상                 | 원인                 | 해결 방법                 |
| -------------------- | -------------------- | ------------------------- |
| DMA 전송 중 멈춤     | `NSS` 신호 조기 High | CS 신호를 콜백에서만 복원 |
| 콜백이 호출되지 않음 | NVIC 우선순위 미설정 | DMA 인터럽트 활성화 확인  |
| 일부 데이터 누락     | Buffer 크기 불일치   | Tx/Rx 배열 크기 일치 확인 |
| 데이터가 깨짐        | SPI 모드 불일치      | CPOL/CPHA 재확인          |

------

#### DMA 기반 SPI의 장점 요약

| 항목                | 효과                           |
| ------------------- | ------------------------------ |
| CPU 부하 감소       | DMA가 데이터 전송 처리         |
| 빠른 전송 속도      | Polling/Interrupt 대비 효율적  |
| 실시간성 향상       | CPU는 다른 작업 수행 가능      |
| 긴 데이터 전송 유리 | 대용량 데이터 버퍼 처리에 최적 |

------

#### 실습 확장 – SPI + DMA로 OLED 화면 전송

- **SSD1306 OLED**는 SPI 인터페이스를 지원하며,
   DMA를 사용하면 픽셀 버퍼 전체를 빠르게 전송 가능.
- `HAL_SPI_Transmit_DMA()`를 이용하여 프레임 버퍼를 전송하고,
   DMA 완료 콜백에서 `display_ready_flag = 1;` 설정 후 다음 프레임 전송.

## 10.5 센서 (MPU9250, Flash Memory) 실습

SPI를 통해 센서 및 외부 메모리를 제어하는 대표적인 예제로는 **MPU9250(IMU 센서)** 및 **SPI Flash Memory (예: W25Q64, AT25 시리즈)**가 있다.
 이 장에서는 두 장치의 SPI 기반 통신 구조, HAL 함수 활용, 데이터 해석 및 저장 구조를 실습 중심으로 상세히 다룬다.

------

#### MPU9250 개요

MPU9250은 **3축 가속도계(Accelerometer)**, **3축 자이로스코프(Gyroscope)**, **3축 자기센서(Magnetometer, AK8963 내장)**를 하나의 칩에 통합한 **9축 IMU (Inertial Measurement Unit)**이다.
 SPI 또는 I²C 인터페이스로 MCU와 통신할 수 있으며, SPI는 더 빠른 데이터 전송(최대 10MHz)을 지원한다.

------

#### SPI 연결 구성 예시

| MPU9250 Pin | STM32 Pin (SPI1 기준) | 기능                      |
| ----------- | --------------------- | ------------------------- |
| VCC         | 3.3V                  | 전원                      |
| GND         | GND                   | 공통 접지                 |
| SCL/SCLK    | PA5                   | SPI1_SCK                  |
| SDA/SDI     | PA7                   | SPI1_MOSI                 |
| AD0/SDO     | PA6                   | SPI1_MISO                 |
| NCS         | PA4                   | SPI1_NSS (수동 제어 권장) |

------

#### MPU9250 SPI 통신 기본 원리

1. **Slave Select (NSS)** 핀을 Low로 설정하여 SPI 통신 시작.
2. **Register Address (R/W bit 포함)** 전송.
3. **데이터 읽기 또는 쓰기 수행.**
4. 전송 완료 후 NSS를 High로 복원.

MPU9250은 MSB 비트가 **R/W 플래그**로 동작한다.

- `0x80` → Read 명령
- `0x00` → Write 명령

예를 들어, WHO_AM_I 레지스터(0x75)를 읽을 때는 `0x75 | 0x80 = 0xF5`를 전송한다.

------

#### MPU9250 WHO_AM_I 읽기 예제

```
#define MPU9250_CS_LOW()    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET)
#define MPU9250_CS_HIGH()   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET)

uint8_t MPU9250_ReadReg(uint8_t reg)
{
    uint8_t tx = reg | 0x80;
    uint8_t rx = 0;

    MPU9250_CS_LOW();
    HAL_SPI_Transmit(&hspi1, &tx, 1, HAL_MAX_DELAY);
    HAL_SPI_Receive(&hspi1, &rx, 1, HAL_MAX_DELAY);
    MPU9250_CS_HIGH();

    return rx;
}
```

**WHO_AM_I 확인**

```
uint8_t id = MPU9250_ReadReg(0x75); // Expected: 0x71
printf("MPU9250 ID = 0x%02X\r\n", id);
```

------

#### 가속도/자이로 데이터 읽기

```
void MPU9250_ReadAccelGyro(int16_t *accel, int16_t *gyro)
{
    uint8_t tx = 0x3B | 0x80;  // ACCEL_XOUT_H register
    uint8_t rx[14];

    MPU9250_CS_LOW();
    HAL_SPI_Transmit(&hspi1, &tx, 1, HAL_MAX_DELAY);
    HAL_SPI_Receive(&hspi1, rx, 14, HAL_MAX_DELAY);
    MPU9250_CS_HIGH();

    accel[0] = (rx[0] << 8) | rx[1];
    accel[1] = (rx[2] << 8) | rx[3];
    accel[2] = (rx[4] << 8) | rx[5];
    gyro[0]  = (rx[8] << 8) | rx[9];
    gyro[1]  = (rx[10] << 8) | rx[11];
    gyro[2]  = (rx[12] << 8) | rx[13];
}
```

**출력 예시**

```
int16_t accel[3], gyro[3];
MPU9250_ReadAccelGyro(accel, gyro);
printf("Accel: %d %d %d | Gyro: %d %d %d\r\n",
       accel[0], accel[1], accel[2], gyro[0], gyro[1], gyro[2]);
```

------

#### Flash Memory (W25Q64) 개요

W25Q64는 **64Mbit(8MB)** 용량의 SPI NOR Flash 메모리로,
 비휘발성 데이터 저장(센서 로그, 보정값, 설정 등)에 널리 사용된다.
 명령 기반 구조로, Read / Write / Erase 명령을 SPI를 통해 전송한다.

------

#### 주요 명령어

| 명령          | 코드 | 바이트 수 | 설명                       |
| ------------- | ---- | --------- | -------------------------- |
| READ ID       | 0x9F | 3         | 제조사 및 디바이스 ID 읽기 |
| READ DATA     | 0x03 | 4 + n     | 메모리 데이터 읽기         |
| PAGE PROGRAM  | 0x02 | 4 + n     | 1~256바이트 쓰기           |
| SECTOR ERASE  | 0x20 | 4         | 4KB 섹터 삭제              |
| WRITE ENABLE  | 0x06 | 1         | 쓰기 허용                  |
| WRITE DISABLE | 0x04 | 1         | 쓰기 비활성화              |

------

#### Flash ID 읽기 예제

```
uint32_t W25Q64_ReadID(void)
{
    uint8_t tx[4] = {0x9F, 0x00, 0x00, 0x00};
    uint8_t rx[4];

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
    HAL_SPI_TransmitReceive(&hspi1, tx, rx, 4, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

    uint32_t id = (rx[1] << 16) | (rx[2] << 8) | rx[3];
    return id; // Manufacturer + Device ID
}
```

**출력 예시**

```
uint32_t id = W25Q64_ReadID();
printf("W25Q64 ID = 0x%06lX\r\n", id);  // Expected: 0xEF4017
```

------

#### Flash 데이터 읽기/쓰기

```
void W25Q64_WriteEnable(void)
{
    uint8_t cmd = 0x06;
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}

void W25Q64_PageProgram(uint32_t addr, uint8_t *data, uint16_t len)
{
    W25Q64_WriteEnable();
    uint8_t cmd[4] = {0x02, addr >> 16, addr >> 8, addr};
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hspi1, cmd, 4, HAL_MAX_DELAY);
    HAL_SPI_Transmit(&hspi1, data, len, HAL_MAX_DELAY);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}
```

------

#### Flash에 센서 데이터 저장 예제

```
typedef struct {
    int16_t accel[3];
    int16_t gyro[3];
} IMU_Data_t;

IMU_Data_t imuData;

MPU9250_ReadAccelGyro(imuData.accel, imuData.gyro);
W25Q64_PageProgram(0x000000, (uint8_t*)&imuData, sizeof(IMU_Data_t));
```

------

#### 실습 확장

1. **DMA 기반 SPI 통신으로 전송 속도 향상**
   - MPU9250의 고속 샘플링(1kHz 이상)을 DMA로 버퍼링.
2. **Flash Memory에 로그 저장 및 재전송**
   - 실시간 데이터 → Flash 저장 → UART 전송으로 데이터 로거 구성.
3. **전원 차단 후 데이터 유지 확인**
   - 비휘발성 저장 기능 검증 실험 수행.
4. **MPU9250 + Flash + FreeRTOS**
   - 센서 Task / Logging Task / UART Task로 병렬 처리.

------

#### 디버깅 및 문제 해결 포인트

| 증상                 | 원인                            | 해결 방법                       |
| -------------------- | ------------------------------- | ------------------------------- |
| WHO_AM_I 응답 없음   | CS 핀 미설정 또는 SPI 모드 오류 | CPOL/CPHA 재확인, NSS 수동 제어 |
| Flash ID 값 0xFFFFFF | 전원 핀 또는 CS 불량            | SPI 배선 확인                   |
| 쓰기 불가            | Write Enable 미전송             | 0x06 명령 추가                  |
| 데이터 일부 손실     | DMA 전송 중 단절                | DMA 완료 콜백 동기화            |
| 센서 데이터 불안정   | SPI 속도 과도                   | 1~4MHz로 낮춰 테스트            |

------

#### 정리

| 항목          | MPU9250                     | W25Q64                                    |
| ------------- | --------------------------- | ----------------------------------------- |
| 인터페이스    | SPI / I²C                   | SPI                                       |
| 동작 전압     | 3.3V                        | 3.3V                                      |
| 주요 기능     | 가속도, 자이로, 자기장 측정 | 비휘발성 데이터 저장                      |
| 데이터 크기   | 14바이트(1샘플)             | 최대 8MB 저장 가능                        |
| HAL 주요 함수 | `HAL_SPI_TransmitReceive()` | `HAL_SPI_Transmit()`, `HAL_SPI_Receive()` |
| 실습 응용     | 모션 로거, 자세 추정        | 로그 저장, 부트 설정 저장                 |

------

이 실습을 통해 **SPI 기반 외부 센서 및 저장장치 제어의 전체 흐름**을 이해할 수 있으며, 이후 FreeRTOS 환경이나 IoT 데이터 로거 프로젝트의 기반으로 확장 가능하다.

## 10.6 TFT LCD / OLED 구동

**목표:**
 SPI 기반 TFT LCD 및 OLED 디스플레이를 STM32 HAL로 제어하는 방법을 익히고, 문자/그래픽/이미지 출력까지 구현한다.
 TFT(ILI9341)와 OLED(SSD1306) 모듈을 중심으로, 하드웨어 연결, 초기화, 프레임 버퍼 처리, 글꼴 렌더링, 이미지 전송 등의 핵심 내용을 다룬다.

------

### 주요 학습 내용

- SPI 인터페이스를 통한 그래픽 디스플레이 제어 원리
- ILI9341 (TFT) 및 SSD1306 (OLED) 제어 명령어 구조
- Display 초기화 순서와 Register 세팅
- HAL_SPI를 이용한 데이터 전송 최적화 (DMA / Polling)
- 프레임 버퍼 기반 화면 갱신 구조
- 텍스트 / 이미지 / 도형 출력 실습

------

### 하드웨어 구성

| 항목    | 내용                                                       |
| ------- | ---------------------------------------------------------- |
| MCU     | STM32F103C8T6 (Blue Pill)                                  |
| TFT LCD | ILI9341 (240x320, SPI)                                     |
| OLED    | SSD1306 (128x64, SPI or I²C)                               |
| 연결    | SPI1: SCK (PA5), MOSI (PA7), CS (PA4), DC (PB0), RST (PB1) |

------

### ILI9341 TFT LCD 제어 개요

#### 1. SPI 핀 구성

- **CS (Chip Select)** : 장치 활성화 신호 (LOW 활성)
- **DC (Data/Command)** : 명령/데이터 구분
- **RST (Reset)** : 하드웨어 초기화
- **SCK/MOSI** : SPI 데이터 전송선

#### 2. 초기화 명령 시퀀스

LCD 컨트롤러는 전원 인가 후 내부 레지스터 초기화가 필요하다.
 아래 순서로 SPI를 통해 명령을 전송한다.

1. 하드웨어 Reset (RST LOW → HIGH)
2. `0x01` : Software Reset
3. `0x11` : Sleep Out
4. `0x29` : Display ON
5. 픽셀 포맷, 감마 커브, 프레임레이트 등 설정

```
void ILI9341_Init(void) {
    ILI9341_Reset();
    ILI9341_WriteCommand(0x01); // Software Reset
    HAL_Delay(10);
    ILI9341_WriteCommand(0x11); // Sleep Out
    HAL_Delay(120);
    ILI9341_WriteCommand(0x29); // Display ON
}
```

#### 3. 픽셀 데이터 쓰기

- LCD 메모리 주소 설정 후 RGB565 데이터를 연속 전송
- 좌표 설정: `0x2A` (Column), `0x2B` (Page)
- 메모리 쓰기: `0x2C` 명령 이후 픽셀 스트림 전송

```
void ILI9341_DrawPixel(uint16_t x, uint16_t y, uint16_t color) {
    ILI9341_SetAddress(x, y, x, y);
    ILI9341_WriteCommand(0x2C);
    uint8_t data[] = { color >> 8, color & 0xFF };
    HAL_SPI_Transmit(&hspi1, data, 2, HAL_MAX_DELAY);
}
```

#### 4. DMA 활용

대용량 이미지 전송 시 DMA를 사용하면 CPU 부하를 줄일 수 있다.

```
HAL_SPI_Transmit_DMA(&hspi1, frame_buffer, sizeof(frame_buffer));
```

DMA 완료 콜백에서 다음 프레임 갱신을 수행하면 부드러운 화면 전환이 가능하다.

------

### SSD1306 OLED 제어 개요

#### 1. 초기화 과정

SSD1306은 SPI 또는 I²C로 제어 가능하다.
 전원 인가 후 명령어를 순서대로 전송한다.

```
void SSD1306_Init(void) {
    SSD1306_SendCommand(0xAE); // Display OFF
    SSD1306_SendCommand(0xD5); // Set Clock Divide Ratio
    SSD1306_SendCommand(0x80);
    SSD1306_SendCommand(0xA8); // Set Multiplex Ratio
    SSD1306_SendCommand(0x3F);
    SSD1306_SendCommand(0xAF); // Display ON
}
```

#### 2. 버퍼 기반 화면 갱신

- OLED는 Page(8px 높이) 단위로 업데이트됨.
- 버퍼를 메모리에 유지한 뒤, 변경된 부분만 전송한다.

```
uint8_t OLED_Buffer[128 * 8];

void SSD1306_UpdateScreen(void) {
    for (uint8_t i = 0; i < 8; i++) {
        SSD1306_SendCommand(0xB0 + i);
        SSD1306_SendCommand(0x00);
        SSD1306_SendCommand(0x10);
        SSD1306_SendData(&OLED_Buffer[128 * i], 128);
    }
}
```

#### 3. 문자 출력

폰트 배열(`font5x7.h`)을 참조해 문자 단위로 픽셀을 기록한다.

```
void SSD1306_DrawChar(char c, uint8_t x, uint8_t y) {
    for (uint8_t i = 0; i < 5; i++) {
        uint8_t line = font5x7[c - 32][i];
        for (uint8_t j = 0; j < 8; j++) {
            if (line & (1 << j))
                OLED_DrawPixel(x + i, y + j, 1);
        }
    }
}
```

------

### 프레임 버퍼 및 그래픽 렌더링

- 프레임 버퍼를 RAM에 유지하여 도형/문자/이미지 병합
- 오프스크린 렌더링 후 한 번에 DMA 전송으로 플리커 방지

#### 주요 함수 예시

```
void DrawLine(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color);
void DrawRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color);
void FillScreen(uint16_t color);
void DrawImage(const uint8_t *img, uint16_t w, uint16_t h);
```

------

### 이미지 출력 예제

```
extern const uint8_t logo[240*320*2]; // RGB565 format

void DisplayLogo(void) {
    ILI9341_SetAddress(0, 0, 239, 319);
    HAL_SPI_Transmit_DMA(&hspi1, (uint8_t*)logo, sizeof(logo));
}
```

BMP, RAW, 또는 자체 압축 포맷을 사용할 수 있으며, 이미지 데이터를 Flash 또는 SD카드에서 읽어 전송 가능하다.

------

### 성능 개선 팁

- SPI Clock을 36MHz 이상으로 설정 (APB2 Clock 기준)
- DMA 사용 시 HAL_BUSY 플래그 처리 주의
- HAL 함수 오버헤드가 큰 경우 직접 레지스터 접근으로 최적화
- 반복 전송 구조 시 HAL_SPI_Transmit 대신 HAL_SPI_Transmit_DMA 권장

------

### 과제

1. ILI9341을 이용해 **온도/습도 센서 값 시각화 GUI** 제작
2. SSD1306에 **실시간 UART 데이터 표시**
3. 두 디스플레이를 동시에 제어하여 **멀티 디스플레이 출력 시스템** 구현

------

이 항목은 STM32 HAL 그래픽 제어의 핵심 실습으로,
 SPI 통신 이해, DMA 활용, 프레임 버퍼 구조, 그리고 하드웨어 초기화 순서를 모두 종합적으로 다루는 고급 단원이다.

