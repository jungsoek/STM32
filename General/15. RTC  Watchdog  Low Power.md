# 15. RTC / Watchdog / Low Power

## 15.1 RTC 구성 및 타임베이스

RTC(Real-Time Clock)는 시스템 전원이 꺼져도 시간을 유지할 수 있는 독립적인 하드웨어 타이머로, **날짜(Date), 시각(Time), 요일(Weekday)** 정보를 초 단위까지 유지·갱신한다.
 STM32의 RTC는 백업 도메인(Backup Domain)에 포함되어 있으며, 메인 전원(VDD)과는 별도의 **VBAT 전원**으로 유지된다. 이 영역은 MCU의 리셋과는 독립적으로 동작하므로, 전원이 재인가되어도 시간 데이터가 유지된다.

RTC는 저속 클록 소스를 기반으로 동작하며, 알람(Alarm), 웨이크업 타이머(Wakeup Timer), 타임스탬프(Timestamp) 등의 기능을 통해 **저전력 동작 및 시간 기반 이벤트 처리**에 활용된다.

------

### RTC의 기본 구성 요소

RTC는 다음 주요 하위 블록으로 구성된다.

| 구성 요소                    | 설명                                               |
| ---------------------------- | -------------------------------------------------- |
| **Prescaler (전치분주기)**   | 입력 클록을 1Hz 기준 타임베이스로 나누는 분주기    |
| **Counter (카운터)**         | 초 단위로 증가하는 카운터 (0~86399, 1일 단위)      |
| **Calendar (달력 레지스터)** | 연, 월, 일, 요일 등의 날짜 정보 저장               |
| **Time Register**            | 시, 분, 초 등의 시간 정보 저장                     |
| **Alarm Register**           | 특정 시각에 인터럽트 발생을 설정하는 알람 기능     |
| **Wakeup Timer**             | 일정 주기마다 이벤트 발생 (저전력 모드 복귀용)     |
| **Backup Registers**         | 소량의 비휘발성 데이터 저장 공간 (보정값, 설정 등) |

------

### 클록 소스

RTC는 **저속 클록(LSI 또는 LSE)** 중 하나를 사용하여 동작한다.

| 클록 소스                    | 주파수                   | 특징                            | 권장 용도                   |
| ---------------------------- | ------------------------ | ------------------------------- | --------------------------- |
| **LSE (Low-Speed External)** | 32.768 kHz               | 외부 크리스털 기반, 정확도 높음 | 실시간 시계용 (정밀도 중요) |
| **LSI (Low-Speed Internal)** | 약 37 kHz (MCU마다 다름) | 내부 RC 오실레이터, 오차 큼     | 저전력 타이밍용, 대체 수단  |

LSE는 정확도가 높지만 외부 크리스털이 필요하고, LSI는 부품 없이 내부적으로 동작 가능하나 온도와 전압에 따른 오차가 크다.
 정확한 시간 유지가 필요한 경우 반드시 **LSE 크리스털(32.768kHz)** 사용을 권장한다.

------

### RTC 초기화 절차

RTC를 초기화하려면 **백업 도메인 접근 허용 → 클록 소스 선택 및 활성화 → RTC 클록 설정 → 초기 시간 설정** 순으로 진행한다.

```
void RTC_Init(void)
{
    RTC_TimeTypeDef sTime = {0};
    RTC_DateTypeDef sDate = {0};

    __HAL_RCC_PWR_CLK_ENABLE();
    HAL_PWR_EnableBkUpAccess();

    __HAL_RCC_LSE_CONFIG(RCC_LSE_ON);
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET);

    __HAL_RCC_RTC_CONFIG(RCC_RTCCLKSOURCE_LSE);
    __HAL_RCC_RTC_ENABLE();

    hrtc.Instance = RTC;
    hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
    hrtc.Init.AsynchPrediv = 127;
    hrtc.Init.SynchPrediv = 255;   // LSE: 32768 / ((127+1)*(255+1)) ≈ 1Hz
    hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
    HAL_RTC_Init(&hrtc);

    sTime.Hours = 0x12;
    sTime.Minutes = 0x00;
    sTime.Seconds = 0x00;
    HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD);

    sDate.WeekDay = RTC_WEEKDAY_MONDAY;
    sDate.Month = RTC_MONTH_JANUARY;
    sDate.Date = 0x01;
    sDate.Year = 0x24;
    HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD);
}
```

------

### 타임베이스 계산

RTC의 타임베이스는 입력 클록(`RTCCLK`)을 전치분주기(Asynch, Synch)로 나눈 결과로 1Hz 기준으로 설정한다.
 즉, 타이머가 **1초에 한 번씩 증가하도록** 설계된다.

#### 계산식

$$
f_{RTC} = \frac{f_{RTCCLK}}{(AsynchPrediv + 1) \times (SynchPrediv + 1)}
$$

예시:

- RTCCLK = 32768 Hz (LSE 사용)
- AsynchPrediv = 127
- SynchPrediv = 255

$$
f_{RTC} = \frac{32768}{(127+1)\times(255+1)} = 1.000 Hz
$$

이 경우, 카운터는 정확히 **1초마다 증가**한다.

------

### 시간/날짜 설정 및 읽기

HAL 드라이버는 `HAL_RTC_SetTime()`, `HAL_RTC_SetDate()`, `HAL_RTC_GetTime()`, `HAL_RTC_GetDate()` API를 제공한다.

```
void Set_RTC_Time(uint8_t hour, uint8_t minute, uint8_t second)
{
    RTC_TimeTypeDef sTime = {0};

    sTime.Hours = hour;
    sTime.Minutes = minute;
    sTime.Seconds = second;

    HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
}

void Read_RTC_Time(void)
{
    RTC_TimeTypeDef gTime;
    RTC_DateTypeDef gDate;

    HAL_RTC_GetTime(&hrtc, &gTime, RTC_FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &gDate, RTC_FORMAT_BIN);

    printf("Time: %02d:%02d:%02d  Date: %02d-%02d-%02d\n",
           gTime.Hours, gTime.Minutes, gTime.Seconds,
           gDate.Year + 2000, gDate.Month, gDate.Date);
}
```

------

### RTC 타임베이스 활용

RTC 타임베이스는 단순한 시간 기록 외에도 다양한 응용에 사용된다.

- **알람 기능 (Alarm A/B)**
   특정 시각에 인터럽트 발생 (예: 매일 09:00:00)
- **웨이크업 타이머 (Wakeup Timer)**
   일정 주기로 저전력 모드에서 MCU를 깨우기
- **타임스탬프 기능 (Timestamp)**
   외부 이벤트 발생 시 시간 자동 기록
- **시간기반 데이터 로깅**
   센서 측정, 로그 기록, 통신 패킷 타임스탬프 등
- **전원 복구 시 시간 유지**
   백업 배터리를 통한 지속 시간 관리

------

### 저전력 모드에서의 RTC 동작

RTC는 **Stop / Standby / Shutdown 모드**에서도 계속 동작할 수 있다.
 이때 VBAT 핀에 전원이 공급되고 RTC 클록이 유지되어야 한다.

- LSE 또는 LSI가 유지되면 RTC는 계속 동작
- Wakeup 타이머를 설정해 일정 주기로 MCU 복귀 가능
- 전력 소비량은 수 µA 수준으로 매우 낮음

------

### RTC 설정 시 주의사항

- 백업 도메인은 리셋과 별도로 보호됨 → 새로 설정 시 `HAL_PWR_EnableBkUpAccess()` 필요
- LSE 크리스털은 구동 안정까지 수백 ms 지연 발생
- `HAL_RTC_Init()` 호출 시 기존 RTC 설정이 초기화될 수 있음
- 시간 설정 후 반드시 `HAL_RTC_GetDate()`를 **즉시 호출해야 시간 갱신 레지스터가 잠김 해제됨**

------

### RTC 실습 아이디어

- LSE 크리스털을 이용하여 정확한 시간 유지 테스트
- Stop 모드 진입 후 Wakeup Timer로 주기적 복귀 확인
- UART를 통해 현재 시각 실시간 출력
- 전원 리셋 후에도 시간 유지되는지 VBAT 연결 상태로 확인
- RTC Alarm을 이용한 정시 이벤트 트리거 구현

------

### 요약

RTC는 STM32의 **저속 독립 타이밍 시스템**으로, 전원 차단 시에도 지속적인 시간 유지가 가능하다.
 LSE를 기반으로 1Hz 타임베이스를 구성하며, HAL API를 통해 손쉽게 시간/날짜를 설정하고 읽을 수 있다.
 정확한 시간 기반 이벤트 처리가 필요한 모든 임베디드 시스템(예: 데이터 로거, 저전력 장치, IoT 노드)에서 RTC는 필수적으로 활용된다.

## 15.2 날짜/시간 설정 및 유지

STM32의 RTC(Real-Time Clock)는 **날짜(Date)와 시간(Time)** 정보를 초 단위까지 유지·갱신하는 하드웨어 모듈로, 메인 전원이 차단되어도 **VBAT 백업 전원**을 통해 계속 동작할 수 있다.
 정확한 날짜/시간 유지 기능은 **데이터 로깅, 이벤트 타임스탬프, 저전력 모드 스케줄링** 등 실시간 기반 애플리케이션에서 핵심적인 역할을 한다.

------

### RTC의 날짜/시간 레지스터 구조

RTC는 내부적으로 날짜와 시간을 별도의 레지스터에 저장한다.

| 레지스터                   | 설명                  | 비트 구성                                              |
| -------------------------- | --------------------- | ------------------------------------------------------ |
| **RTC_TR (Time Register)** | 시, 분, 초 정보 저장  | Hours(6비트), Minutes(7비트), Seconds(7비트)           |
| **RTC_DR (Date Register)** | 연, 월, 일, 요일 저장 | Year(8비트), Month(5비트), Date(6비트), WeekDay(3비트) |

- 시각은 24시간 또는 12시간 형식으로 설정 가능 (`RTC_HOURFORMAT_24` / `RTC_HOURFORMAT_12`)
- 날짜는 2000년 기준 오프셋으로 표현됨 (예: 0x24 → 2024년)
- 월과 일은 BCD(Binary Coded Decimal) 형태로 저장됨
- 요일(WeekDay)은 1~7(월~일)로 표현됨

------

### 날짜 및 시간 설정 절차

RTC 설정은 **시간 → 날짜 순서**로 진행해야 한다.
 HAL 드라이버의 `HAL_RTC_SetTime()`, `HAL_RTC_SetDate()` 함수를 사용한다.

```
RTC_TimeTypeDef sTime = {0};
RTC_DateTypeDef sDate = {0};

sTime.Hours = 14;     // 오후 2시
sTime.Minutes = 30;
sTime.Seconds = 0;
HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN);

sDate.WeekDay = RTC_WEEKDAY_TUESDAY;
sDate.Month = RTC_MONTH_NOVEMBER;
sDate.Date = 11;
sDate.Year = 25;      // 2025년
HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
```

RTC 설정은 백업 도메인 보호를 해제한 상태에서 수행되어야 한다.
 따라서 RTC 초기화 이전에 반드시 아래 단계를 수행해야 한다.

```
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWR_EnableBkUpAccess();
```

------

### 날짜 및 시간 읽기

RTC의 현재 날짜와 시간을 읽을 때는 반드시 **`HAL_RTC_GetTime()` → `HAL_RTC_GetDate()` 순서로 호출**해야 한다.
 이 순서가 어긋나면 내부 섀도 레지스터가 갱신되지 않아 잘못된 데이터를 읽게 된다.

```
RTC_TimeTypeDef gTime;
RTC_DateTypeDef gDate;

HAL_RTC_GetTime(&hrtc, &gTime, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&hrtc, &gDate, RTC_FORMAT_BIN);

printf("Time: %02d:%02d:%02d | Date: 20%02d-%02d-%02d (Weekday %d)\n",
       gTime.Hours, gTime.Minutes, gTime.Seconds,
       gDate.Year, gDate.Month, gDate.Date, gDate.WeekDay);
```

------

### 시간 유지 메커니즘

RTC는 **전원 공급 구조에 따라 시간 유지 여부**가 결정된다.

| 전원 상태             | RTC 동작 상태                       |
| --------------------- | ----------------------------------- |
| VDD + VBAT 둘 다 공급 | 정상 동작                           |
| VDD 차단, VBAT 유지   | 시간 유지 (RTC 및 백업 영역 유지됨) |
| VDD, VBAT 모두 차단   | RTC 리셋 (데이터 소실)              |

- VBAT은 **전용 핀**으로 연결되어야 하며, 코인 셀(3V)이나 슈퍼커패시터로 백업 가능
- VBAT이 유지되면 RTC, Backup Register 모두 정상적으로 유지됨
- VBAT이 없을 경우 전원 복구 시 RTC 초기화 필요

------

### 전원 복구 후 시간 유지 검증

아래 코드는 전원 재인가 후 RTC 데이터가 유지되었는지를 확인하고, 유지되지 않은 경우 기본 시간으로 재설정한다.

```
void RTC_CheckAndInit(void)
{
    if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
    {
        // 전원 재인가로 인한 리셋 발생 → 시간 초기화 필요
        printf("Power-On Reset detected. Reinitializing RTC...\n");
        RTC_Init();
    }
    else
    {
        printf("RTC data retained. Current time will be used.\n");
    }

    __HAL_RCC_CLEAR_RESET_FLAGS();
}
```

또는 백업 도메인의 특정 Register에 “RTC 초기화 완료” 플래그를 기록해두고, 이를 통해 시간 설정 여부를 판단할 수도 있다.

```
#define BKP_RTC_INIT_FLAG RTC_BKP_DR1
#define RTC_FLAG_MAGIC    0x32F2

if (HAL_RTCEx_BKUPRead(&hrtc, BKP_RTC_INIT_FLAG) != RTC_FLAG_MAGIC)
{
    RTC_Init();  // 초기화 및 기본 시간 설정
    HAL_RTCEx_BKUPWrite(&hrtc, BKP_RTC_INIT_FLAG, RTC_FLAG_MAGIC);
}
```

------

### 시각 자동 보정 기능

RTC는 장시간 동작 시 오차가 누적될 수 있으며, 이를 보정하기 위한 **Digital Calibration** 기능을 제공한다.
 이는 `HAL_RTCEx_SetSmoothCalib()` 함수를 통해 일정 주기마다 보정 펄스를 삽입하거나 생략하여 시간 정확도를 향상시킨다.

```
// 1초당 2ppm 보정 예시 (RTC 초 미세 조정)
HAL_RTCEx_SetSmoothCalib(&hrtc,
                         RTC_SMOOTHCALIB_PERIOD_32SEC,
                         RTC_SMOOTHCALIB_PLUSPULSES_SET,
                         2);
```

이 기능은 LSI 기반 RTC 사용 시 필수적이며, LSE 사용 시에도 미세 보정용으로 유용하다.

------

### 시간 형식 변환 (BCD ↔ Binary)

RTC 하드웨어는 BCD(Binary Coded Decimal) 형식을 기본으로 사용하므로, Binary ↔ BCD 변환이 필요할 수 있다.

```
uint8_t BCD2BIN(uint8_t val) { return ((val >> 4) * 10 + (val & 0x0F)); }
uint8_t BIN2BCD(uint8_t val) { return (((val / 10) << 4) | (val % 10)); }
```

HAL 함수는 `RTC_FORMAT_BCD` 또는 `RTC_FORMAT_BIN` 모드 중 선택 가능하며, 일반적으로 `BIN` 모드를 사용하는 것이 편리하다.

------

### 시간 유지 테스트 절차

1. LSE 크리스털(32.768kHz) 장착 후 RTC 정상 동작 확인
2. 날짜/시간 설정 후 UART를 통해 현재 시간 출력
3. VDD 전원 차단, VBAT만 유지 (3V 코인셀 연결)
4. 일정 시간 후 전원 재인가 → 기존 시간과 비교
5. 오차 발생 시 보정 기능 테스트 (`HAL_RTCEx_SetSmoothCalib`)

------

### 실습 예제

#### 실습 1: 초기화 및 시간 표시

- 시스템 초기화 시 RTC가 설정되어 있지 않다면 현재 시간을 “2025-01-01 00:00:00”으로 설정하고 UART로 표시한다.
- 이후 1초마다 시간을 읽어 터미널에 갱신 출력한다.

#### 실습 2: VBAT 시간 유지 검증

- 코인셀 연결 후 VDD 제거 → 일정 시간 대기
- 전원 복구 후 이전 시간과의 차이를 확인
- RTC Backup Register에 유지된 보정값도 함께 확인

------

### 요약

RTC는 VBAT 영역의 독립 전원으로 지속적으로 동작하며, 날짜와 시간을 정확하게 유지할 수 있다.
 `HAL_RTC_SetTime()`, `HAL_RTC_SetDate()`를 통해 설정하고, `HAL_RTC_GetTime()`, `HAL_RTC_GetDate()`로 읽는다.
 VBAT이 유지되는 한 데이터는 손실되지 않으며, 백업 도메인 플래그를 통해 재설정 여부를 판단할 수 있다.
 시간 보정 기능과 함께 사용하면, 장기 동작 시스템에서도 안정적인 **실시간 시간 유지(Timekeeping)** 가 가능하다.

## 15.3 백업 배터리 연결

STM32의 RTC(Real-Time Clock)는 외부 전원이 차단되어도 시간을 유지할 수 있도록 백업 배터리(Backup Battery) 또는 슈퍼커패시터(Super Capacitor)를 연결할 수 있는 구조를 갖는다. 이 기능은 전원이 꺼져도 RTC 레지스터와 백업 도메인 데이터를 유지해야 하는 시스템에서 필수적이다.

------

### 백업 전원 영역 (VBAT) 구조

STM32 마이크로컨트롤러는 RTC, 백업 레지스터, 그리고 일부 LSE 관련 회로를 전원 차단 시에도 유지하기 위해 **VBAT 핀**을 별도로 제공한다.

- **VBAT 핀 역할**
  - RTC, LSE(Low-Speed External) 오실레이터, 백업 레지스터에 전원을 공급한다.
  - 메인 전원(VDD)이 꺼져도 VBAT 전원이 공급되면 시간 정보 및 데이터가 유지된다.
- **VBAT 전원 전환 조건**
  - VDD가 살아 있을 경우: 시스템은 VDD에서 전원을 공급받음.
  - VDD가 꺼지고 VBAT가 연결된 경우: 자동으로 VBAT 전원으로 전환됨.
  - 전환은 하드웨어적으로 수행되어 소프트웨어 개입이 필요 없다.

------

### 배터리 연결 방식

VBAT 핀에는 리튬 코인셀(예: CR2032) 또는 슈퍼커패시터를 주로 연결한다.
 연결 회로는 다음과 같이 구성된다.

- **구성 예시**
  - VBAT ↔ 다이오드 ↔ 배터리(3V)
  - 필요 시 저항(수십 Ω) 및 캐패시터(수 µF) 추가로 전류 급변 완화
  - 일부 보드는 다이오드 대신 MOSFET 스위칭 회로를 사용하여 전압 강하를 최소화
- **배터리 전압 범위**
  - 일반적으로 1.65V ~ 3.6V
  - 권장 전압은 3V (CR2032 기준)
  - VBAT가 1.65V 이하로 떨어지면 RTC 동작이 불안정해질 수 있음

------

### LSE 오실레이터와의 관계

RTC는 보통 **LSE(32.768 kHz 크리스털)** 을 타임베이스로 사용한다.
 LSE 오실레이터는 VBAT 전원 영역에 포함되어 있으므로,
 VDD가 꺼져도 LSE 클록은 유지되며 RTC 카운터가 계속 동작한다.

- **LSE 관련 레지스터 유지**
  - `RCC_BDCR` 레지스터 내 LSEON, LSEBYP, RTCSEL 등은 백업 도메인에 속한다.
  - VBAT가 유지되는 한 이 설정값들은 전원 복귀 후에도 그대로 유지된다.

------

### 백업 도메인 보호

백업 영역은 실수로 덮어쓰지 않도록 **백업 도메인 보호 기능**이 활성화되어 있다.
 VBAT 영역을 초기화하거나 새로운 RTC 클록 소스를 설정하기 위해서는
 백업 도메인 보호를 해제해야 한다.

- **보호 해제 절차**

  ```
  HAL_PWR_EnableBkUpAccess();  // 백업 도메인 접근 허용
  __HAL_RCC_BKP_CLK_ENABLE();  // BKP 클록 활성화
  ```

- **백업 도메인 리셋**

  - 필요 시 `__HAL_RCC_BACKUPRESET_FORCE()` → `__HAL_RCC_BACKUPRESET_RELEASE()`로 초기화 가능
  - 이 경우 RTC와 백업 레지스터 데이터가 모두 초기화됨

------

### 전원 복귀 시 동작

메인 전원이 복구되면 VDD가 우선 공급되며, RTC는 중단 없이 동작을 이어간다.
 이 과정에서 RTC 레지스터를 다시 설정할 필요는 없다.
 단, MCU가 리셋되었더라도 RTC 백업 도메인은 리셋되지 않는다.

- **RTC 재초기화 조건 확인 예시**

  ```
  if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET) {
      // 전원 리셋 발생 → RTC 초기화 필요
  } else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET) {
      // 핀 리셋 → RTC 유지됨
  }
  ```

------

### 배터리 소모 및 수명

RTC의 전력 소모는 매우 작으며, 일반적으로 수백 nA 수준이다.

- CR2032(약 220mAh) 사용 시 수년간 유지 가능
- 슈퍼커패시터 사용 시 수일~수주 수준의 유지 가능 (용량 및 누설전류에 따라 다름)

**소모 전류 예시:**

- LSE 사용 + RTC 활성화 시 약 600~800 nA
- LSI 사용 시 약 1~2 µA (정확도는 낮음)

------

### 실습 예시

#### 회로 연결

- VBAT 핀 → CR2032 (+), GND → CR2032 (–)
- LSE 크리스털 → PC14, PC15 핀에 연결

#### 코드 예시

```
// RTC 초기화 코드 (한 번만 수행)
RTC_HandleTypeDef hrtc;

void RTC_Init(void) {
    __HAL_RCC_PWR_CLK_ENABLE();
    HAL_PWR_EnableBkUpAccess();
    __HAL_RCC_LSE_CONFIG(RCC_LSE_ON);
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET);

    __HAL_RCC_RTC_CONFIG(RCC_RTCCLKSOURCE_LSE);
    __HAL_RCC_RTC_ENABLE();

    hrtc.Instance = RTC;
    hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
    hrtc.Init.AsynchPrediv = 127;
    hrtc.Init.SynchPrediv = 255;
    hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
    HAL_RTC_Init(&hrtc);
}
```

전원이 차단되더라도 VBAT가 연결되어 있으면 `HAL_RTC_GetTime()` 및 `HAL_RTC_GetDate()`를 통해 정상적으로 시간 정보를 복원할 수 있다.

------

### 요약

- VBAT 핀은 RTC, LSE, 백업 레지스터 전원 공급용으로 사용된다.
- VDD 전원이 차단되어도 VBAT가 유지되면 시간 및 데이터는 보존된다.
- 리튬 코인셀 또는 슈퍼커패시터를 사용하여 전원 백업 가능하다.
- LSE 오실레이터는 VBAT 전원 영역에 속하므로 RTC의 지속성을 보장한다.
- 백업 도메인 보호 해제 및 초기화 절차를 숙지해야 한다.
- 배터리 용량 및 전류 소모를 고려하여 장기 운용 시 전력 설계를 최적화해야 한다.

## 15.4 Independent Watchdog (IWDG)

Independent Watchdog(IWDG)는 시스템 오작동 시 자동으로 MCU를 리셋시켜 복구를 수행하는 하드웨어 안전 메커니즘이다. 전원 불안정, 무한 루프, 비정상적인 코드 실행 등의 상황에서도 MCU가 자동으로 재시작되어 시스템이 복원되도록 보장한다.
 IWDG는 메인 시스템 클록(HSE, HSI 등)과 독립된 **LSI(Low-Speed Internal) 오실레이터(약 32 kHz)** 를 사용하므로, 시스템 클록이 고장나더라도 동작을 계속 유지할 수 있다.

------

### IWDG의 주요 특징

- **독립적인 클록 소스(LSI) 기반 동작**
  - 시스템 클록이 멈추거나 PLL이 비정상이어도 감시 기능 유지
- **하드웨어적으로 비활성화 불가**
  - 한 번 활성화되면 소프트웨어로 해제 불가 (리셋만이 초기화 수단)
- **내장 12비트 다운카운터**
  - 프리스케일러 및 리로드 값에 따라 감시 타임아웃을 설정
- **비정상 상황에서 자동 시스템 리셋**
  - 지정된 시간 내 “갱신(Refresh)”되지 않으면 자동으로 MCU 리셋 발생

------

### 내부 동작 구조

IWDG는 LSI 클록을 입력받아 **프리스케일러(Prescaler)** 와 **리로드 카운터(Reload Counter)** 를 통해 감시 주기를 설정한다.

- **LSI 클록 주파수**: 약 32 kHz (MCU에 따라 약간의 편차 존재)

- **타이머 구성**:
  $$
  T_{timeout} = \frac{Prescaler \times Reload}{f_{LSI}}
  $$

- **프리스케일러 값 선택 (IWDG_PR 레지스터)**

  - 4, 8, 16, 32, 64, 128, 256 중 선택 가능

- **리로드 값(IWDG_RLR 레지스터)**: 0 ~ 0xFFF (4095)

------

### 기본 동작 절차

1. **IWDG 활성화**
   - `IWDG->KR`에 0xCCCC를 기록하면 활성화됨.
   - 이후 비활성화 불가.
2. **프리스케일러 및 리로드 값 설정**
   - 활성화 후 초기 설정 가능 (0x5555 키 입력 후 값 기록).
3. **정기적 Refresh**
   - `IWDG->KR`에 0xAAAA를 기록하면 카운터가 초기화되어 리셋 방지.
   - 일정 주기마다 Refresh하지 않으면 시스템 리셋 발생.

------

### 주요 레지스터 요약

| 레지스터 | 기능               | 비고                        |
| -------- | ------------------ | --------------------------- |
| `KR`     | Key Register       | 보호 및 제어용 키 입력      |
| `PR`     | Prescaler Register | 분주비 설정                 |
| `RLR`    | Reload Register    | 타임아웃 기준 값            |
| `SR`     | Status Register    | 업데이트 상태 플래그        |
| `WINR`   | Window Register    | (일부 MCU) 윈도우 모드 제어 |

**Key Register 명령어**

| 키 값  | 기능                    |
| ------ | ----------------------- |
| 0x5555 | PR/RLR 갱신 허용        |
| 0xCCCC | IWDG 시작               |
| 0xAAAA | 카운터 리로드 (Refresh) |

------

### 타임아웃 계산 예시

LSI = 32 kHz, Prescaler = 64, Reload = 4095인 경우:
$$
T_{timeout} = \frac{64 \times 4095}{32000} ≈ 8.19초
$$
즉, 약 8초마다 Refresh가 수행되지 않으면 MCU는 자동으로 리셋된다.

------

### CubeIDE에서 HAL 초기화 예시

```
IWDG_HandleTypeDef hiwdg;

void IWDG_Init(void)
{
    hiwdg.Instance = IWDG;
    hiwdg.Init.Prescaler = IWDG_PRESCALER_64;
    hiwdg.Init.Reload = 4095;    // 최대 약 8초
    if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
    {
        Error_Handler();
    }
}
```

**갱신(Refresh)**

```
HAL_IWDG_Refresh(&hiwdg);
```

이 함수는 내부적으로 `IWDG->KR = 0xAAAA`를 수행한다.
 일반적으로 메인 루프나 주기적 타이머 콜백에서 주기적으로 호출한다.

------

### IWDG 초기화 절차 요약

1. LSI 클록 활성화 (`__HAL_RCC_LSI_ENABLE()`)
2. IWDG 인스턴스 설정 (프리스케일러, 리로드)
3. `HAL_IWDG_Init()` 호출로 시작
4. 주기적 Refresh 수행

------

### 실습 예제

```
int main(void)
{
    HAL_Init();
    SystemClock_Config();

    __HAL_RCC_LSI_ENABLE();
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET);

    IWDG_Init();

    while (1)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        HAL_Delay(1000);  // 1초마다 점멸
        HAL_IWDG_Refresh(&hiwdg); // Watchdog 갱신
    }
}
```

이 예제는 LED를 1초마다 점멸시키며 IWDG를 Refresh한다.
 만약 `HAL_IWDG_Refresh()` 호출이 누락되면 약 8초 후 MCU가 자동 리셋된다.

------

### 주의사항

- IWDG는 **디버그 모드 중에도 동작**할 수 있다.
  - 디버깅 중 리셋을 방지하려면 `HAL_DBGMCU_EnableDBGStopMode()` 또는
     `__HAL_DBGMCU_FREEZE_IWDG()` 등을 이용해 일시 정지 가능 (MCU별 지원 여부 상이).
- 타임아웃 설정이 너무 짧으면 부팅 중 초기화 과정에서 리셋 루프 발생 가능.
- 보안 및 안정성 요구사항이 높은 시스템에서는 **IWDG와 WWDG(윈도우 워치독)** 을 병행 사용하기도 한다.

------

### 실무 적용 사례

- **무인장비/IoT 기기:** 장시간 무응답 방지
- **산업 제어 시스템:** 통신 이상 또는 소프트웨어 교착 감시
- **배포용 제품:** 예상치 못한 오류 발생 시 자동 복구

------

### 요약

- IWDG는 LSI 클록 기반 독립 감시 타이머이다.
- 시스템 이상 시 자동으로 리셋을 수행하여 안정성을 보장한다.
- 활성화 후 비활성화 불가하며, 정기적 Refresh가 필수이다.
- HAL 또는 레지스터 레벨에서 간단히 구성 가능하다.
- 디버깅, 타임아웃 설정, 초기화 루프에 대한 주의가 필요하다.

## 15.5 Window Watchdog (WWDG)

Window Watchdog(WWDG)는 MCU의 비정상적인 동작을 감시하는 하드웨어 보호 장치로, 정해진 “윈도우(window) 구간” 내에서만 카운터를 갱신(Refresh)할 수 있도록 제한하는 점이 특징이다.
 즉, 너무 늦게 Refresh하거나, 반대로 너무 일찍 Refresh할 경우 모두 리셋이 발생한다.
 이 메커니즘은 프로그램이 예기치 않게 루프나 타이밍 오류에 빠졌을 때 시스템을 복원하는 데 유용하다.

------

### 개요 및 동작 원리

WWDG는 **APB1 버스 클록(PCLK1)** 을 기준으로 동작하며, IWDG와 달리 **시스템 클록에 종속적**이다.
 타이머가 주기적으로 감소하며, 특정 카운트 값 이하가 되기 전에 Refresh가 수행되지 않으면 시스템이 리셋된다.
 또한 설정된 “윈도우 값(Window)”보다 **너무 일찍** Refresh를 시도해도 리셋이 발생한다.

**요약 동작 흐름**

1. WWDG 활성화 → 카운터가 시작 (127 → 63까지 감소)
2. 카운터가 0x3F 이하로 내려가면 하드웨어 리셋 발생
3. 설정된 “윈도우 값”보다 **크거나 같을 때** Refresh 수행해야 함
4. 너무 일찍 Refresh(카운터 > 윈도우 값) → 즉시 리셋

------

### 주요 레지스터

| 레지스터   | 설명                                        |
| ---------- | ------------------------------------------- |
| `WWDG_CR`  | 카운터 값 및 WWDG 활성화 제어               |
| `WWDG_CFR` | 프리스케일러, 윈도우 값, 조기 인터럽트 설정 |
| `WWDG_SR`  | 조기 경고 인터럽트 플래그 (EWI)             |

------

### 내부 클록 및 타임아웃 계산

WWDG의 카운터 클록은 아래 수식으로 계산된다.
$$
f_{WWDG} = \frac{PCLK1}{4096 \times Prescaler}
$$
카운터는 7비트(0x7F)이며, 각 클록마다 1씩 감소한다.
 타임아웃 시간은 다음과 같다.
$$
T_{timeout} = \frac{(Counter_{start} - 0x3F)}{f_{WWDG}}
$$
예를 들어,

- PCLK1 = 36 MHz
- Prescaler = 8
- Counter = 127
   이면

$$
f_{WWDG} = \frac{36,000,000}{4096 \times 8} ≈ 1098 Hz
$$

즉, 약 58 ms 안에 Refresh가 이루어져야 리셋이 방지된다.

------

### 초기화 및 설정 절차

WWDG 설정은 크게 3단계로 구성된다.

#### 1. 클록 활성화

```
__HAL_RCC_WWDG_CLK_ENABLE();
```

#### 2. 프리스케일러, 윈도우, 카운터 설정

```
WWDG_HandleTypeDef hwwdg;
hwwdg.Instance = WWDG;
hwwdg.Init.Prescaler = WWDG_PRESCALER_8;
hwwdg.Init.Window = 80;   // 윈도우 값
hwwdg.Init.Counter = 127; // 초기 카운터 값
hwwdg.Init.EWIMode = WWDG_EWI_ENABLE; // 조기 인터럽트 활성화
HAL_WWDG_Init(&hwwdg);
```

#### 3. 정기적 Refresh

```
HAL_WWDG_Refresh(&hwwdg);
```

- Refresh 시점은 `Counter` 값이 `Window` 이하일 때 수행해야 한다.
- 너무 빨리 Refresh하면 즉시 시스템 리셋 발생.

------

### Early Wakeup Interrupt (EWI)

WWDG는 **리셋 직전에 인터럽트를 발생시킬 수 있는 기능**을 제공한다.
 이 기능은 소프트웨어가 리셋 직전 상황을 감지하여 로그를 남기거나 안전 종료 절차를 수행할 수 있도록 한다.

#### EWI 활성화

```
hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;
```

#### 콜백 함수

```
void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef *hwwdg)
{
    // 리셋 직전 실행되는 사용자 정의 코드
    Save_SystemState();
}
```

#### 인터럽트 핸들러

```
void WWDG_IRQHandler(void)
{
    HAL_WWDG_IRQHandler(&hwwdg);
}
```

------

### 동작 예제

```
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();

    __HAL_RCC_WWDG_CLK_ENABLE();

    hwwdg.Instance = WWDG;
    hwwdg.Init.Prescaler = WWDG_PRESCALER_8;
    hwwdg.Init.Window = 80;
    hwwdg.Init.Counter = 127;
    hwwdg.Init.EWIMode = WWDG_EWI_ENABLE;
    HAL_WWDG_Init(&hwwdg);

    while (1)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        HAL_Delay(40);
        HAL_WWDG_Refresh(&hwwdg); // 적절한 시점에 Refresh
    }
}
```

- Delay가 너무 길면(예: 100ms) → 리셋 발생 (Refresh 타이밍 초과)
- Delay가 너무 짧으면(예: 5ms) → 리셋 발생 (윈도우 위반)

------

### IWDG와의 비교

| 항목               | IWDG             | WWDG                 |
| ------------------ | ---------------- | -------------------- |
| 클록 소스          | LSI (독립적)     | PCLK1 (시스템 종속)  |
| Refresh 제약       | 없음             | 윈도우 구간 내에서만 |
| 비활성화           | 불가             | 리셋 후만 가능       |
| 조기 경고 인터럽트 | 지원 안 함       | 지원 (EWI)           |
| 주 사용 목적       | 시스템 전체 감시 | 타이밍 이상 감시     |

WWDG는 시스템의 “타이밍 오류” 감시용으로,
 IWDG는 “전체 시스템 교착 감시” 용도로 사용하는 것이 일반적이다.
 고신뢰 시스템에서는 두 워치독을 병행 구성한다.

------

### 디버깅 관련 주의사항

- WWDG는 **디버그 모드 일시정지 설정**이 가능하다.

  ```
  __HAL_DBGMCU_FREEZE_WWDG();
  ```

  이를 적용하지 않으면 디버깅 중에도 리셋이 발생할 수 있다.

- Breakpoint 사용 시 워치독이 만료되지 않도록 주의해야 한다.

------

### 실무 적용 시 고려사항

- 인터럽트 기반 Refresh 루틴은 안정적이지만,
   타이밍 오류나 Task 지연이 발생하면 리셋이 유발될 수 있다.
- FreeRTOS 환경에서는 **Watchdog 전용 Task**를 생성하여
   시스템 상태를 주기적으로 확인 후 Refresh하는 구조가 권장된다.
- 타이밍 분석 후, Window 값과 Prescaler를 정밀하게 조정해야 한다.

------

### 요약

- WWDG는 “너무 늦게” 또는 “너무 빨리” Refresh 시 리셋이 발생한다.
- APB1 클록 기반으로 동작하며, 윈도우 제약을 통해 타이밍 오류 감시를 수행한다.
- EWI 인터럽트로 리셋 직전 상황을 감지할 수 있다.
- IWDG와 병행 구성 시 시스템 안정성이 극대화된다.
- 타이밍 조정 및 디버그 시 주의가 필요하다.

## 15.6 Sleep / Stop / Standby 모드

STM32 마이크로컨트롤러는 저전력 설계를 위해 **다양한 전력 절감 모드(Sleep, Stop, Standby)** 를 제공한다.
 이들은 각각 CPU 클록, PLL, 주변장치 클록의 동작 범위가 다르며,
 응용 프로그램의 성격(센서 대기, 타이머 기반 웨이크업, 장기 절전 등)에 따라 적합한 모드를 선택해야 한다.

------

### 저전력 모드 개요

STM32의 저전력 모드는 크게 다음과 같이 구분된다.

| 모드    | CPU  | 주변장치 클록 | RAM 유지 | Wakeup 소스           | 소비전력  |
| ------- | ---- | ------------- | -------- | --------------------- | --------- |
| Sleep   | 중지 | 유지          | 유지     | 인터럽트              | 낮음      |
| Stop    | 중지 | 대부분 중지   | 유지     | 인터럽트 / RTC / EXTI | 매우 낮음 |
| Standby | 중지 | 모두 중지     | 비활성   | RTC / WKUP 핀         | 극저전력  |

이 세 모드는 **전력 소비량 ↔ 복귀 속도** 사이의 트레이드오프 관계를 가진다.
 즉, 절전 효과가 클수록 복귀 시 초기화 과정이 길어진다.

------

### Sleep 모드

#### 개요

- CPU 클록만 중지되고, 주변장치는 그대로 동작한다.
- 클록 트리(PLL, HCLK 등)는 유지되며, 인터럽트 발생 시 즉시 복귀한다.
- `HAL_SuspendTick()`를 사용하여 SysTick을 일시 중단할 수 있다.

#### 진입 및 복귀 절차

```
// Tick 중단 (선택사항)
HAL_SuspendTick();

// Sleep 진입
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);

// 인터럽트 발생 시 즉시 복귀
HAL_ResumeTick();
```

- `PWR_SLEEPENTRY_WFI` : `__WFI()` 명령어 사용 (Wait For Interrupt)
- `PWR_SLEEPENTRY_WFE` : `__WFE()` 명령어 사용 (Wait For Event)

#### 특징

- 가장 빠른 복귀 (수 µs 수준)
- 주변장치 동작 지속 가능 (UART, TIM, I²C 등)
- 클록 유지 → PLL 재구성 불필요

------

### Stop 모드

#### 개요

- **CPU, PLL, 대부분의 클록이 정지**하며, SRAM 및 레지스터 상태는 유지된다.
- 저전력으로 대기하다가 RTC, EXTI, 또는 특정 인터럽트로 복귀 가능하다.
- 복귀 시 클록 시스템 재구성이 필요하다.

#### 진입 절차

```
// Tick 중단
HAL_SuspendTick();

// Stop 모드 진입
HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFI);
```

#### 복귀 절차

Stop 모드에서 복귀하면 시스템 클록은 기본적으로 **HSI (8 MHz)** 로 설정된다.
 따라서 `SystemClock_Config()` 함수를 재호출해야 한다.

```
// 복귀 후 클록 재설정
SystemClock_Config();
HAL_ResumeTick();
```

#### 특징

- SRAM 및 주변장치 레지스터 유지
- 소비전력: 수 µA 단위
- RTC 및 EXTI를 통한 깨움 가능
- PLL 및 Flash 대기 재설정 필요

#### 예시: RTC Alarm으로 복귀

```
HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);
HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
```

------

### Standby 모드

#### 개요

- **가장 깊은 절전 상태**
- RAM, 레지스터, PLL 완전 오프
- 백업 도메인(RTC, Backup Register)만 유지됨
- 복귀 시 **리셋과 동일한 동작** (부트로더 또는 `main()`부터 시작)

#### 진입 절차

```
// Wakeup 핀 활성화 (선택)
HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);

// Standby 모드 진입
HAL_PWR_EnterSTANDBYMode();
```

#### 복귀 절차

- Wakeup 소스:
  - RTC Alarm
  - WKUP 핀 (PA0 등)
  - NRST 핀 (외부 리셋)
- 복귀 시 `__HAL_PWR_GET_FLAG(PWR_FLAG_SB)`로 이전 Standby 여부 확인 가능.

```
if (__HAL_PWR_GET_FLAG(PWR_FLAG_SB))
{
    __HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);
    // Standby 복귀 처리
}
```

#### 특징

- 소비전력: 수 백 nA ~ 수 µA 수준
- 프로그램 완전 재시작
- 백업 배터리 연결 시 RTC 지속 유지 가능

------

### 모드 간 전환 흐름

```
RUN → Sleep → Stop → Standby
      ↑        ↑        ↑
      │        │        └─ RTC/Wakeup 핀 복귀
      │        └────────── 인터럽트 복귀
      └──────────────────── 일반 인터럽트 복귀
```

각 모드는 **전력 절감률과 복귀 지연시간**의 균형을 고려하여 선택해야 한다.
 센서 노드, 데이터로거, BLE 통신기기 등에서는 Stop/Standby 모드가 자주 사용된다.

------

### 디버깅 및 주의사항

- 디버그 세션 중에는 저전력 모드 진입 시 연결이 끊길 수 있다.
   필요 시 `__HAL_DBGMCU_FREEZE_xxx()` 매크로를 사용해 특정 모듈의 정지를 방지한다.

  ```
  __HAL_DBGMCU_FREEZE_IWDG();
  __HAL_DBGMCU_FREEZE_WWDG();
  ```

- FreeRTOS와 병행 시, Idle Hook을 활용하여 Sleep 모드 진입 코드를 삽입할 수 있다.

- GPIO 입력 핀을 Wakeup 소스로 사용할 때는 EXTI 라인 설정을 선행해야 한다.

- Stop 모드 복귀 후 PLL 재설정이 누락되면 클록 이상이 발생할 수 있다.

------

### 저전력 설계 실무 팁

- 사용하지 않는 GPIO를 **Analog Input**으로 설정하여 누설전류 최소화.
- 불필요한 주변장치 클록은 RCC에서 비활성화.
- ADC, UART, I²C 등의 **DMA 비활성화 여부** 확인.
- RTC Alarm 또는 Timer 기반 웨이크업을 통해 주기적 동작 수행.
- 배터리 구동 제품에서는 Stop/Standby 모드 사용 시 수십 배 이상 수명 연장 가능.

------

### 요약

- **Sleep**: CPU만 중단, 주변장치는 유지 → 빠른 복귀.
- **Stop**: CPU 및 PLL 중지, SRAM 유지 → RTC/EXTI로 복귀 가능.
- **Standby**: 모든 전원 차단, RTC만 유지 → 리셋 수준 복귀.
- 저전력 모드 선택은 시스템 요구 사항(복귀 시간, 유지 데이터, 전력 한계)에 따라 결정한다.