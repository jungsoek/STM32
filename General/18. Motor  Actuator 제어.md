# 18. Motor / Actuator 제어

## 18.1 PWM 제어 원리

PWM(Pulse Width Modulation)은 디지털 신호를 이용하여 아날로그와 유사한 전력 제어를 수행하는 핵심 기술이다. 마이크로컨트롤러에서는 타이머(Timer) 모듈을 이용해 일정한 주기와 가변적인 듀티비(Duty Cycle)를 생성함으로써 모터 속도, LED 밝기, 서보 제어 등 다양한 응용을 수행한다.

### PWM의 기본 개념

PWM은 하나의 주기(Period) 내에서 ‘High’와 ‘Low’ 상태의 비율(Duty Cycle)을 조정함으로써 평균 전압을 제어한다.

- **주기 (Period)**: 한 번의 파형이 반복되는 시간.
- **주파수 (Frequency)**: 1초 동안 발생하는 PWM 주기의 수.
- **듀티비 (Duty Cycle)**: 한 주기 내에서 High 상태의 비율을 백분율(%)로 표현한 값.

예를 들어, 3.3V의 시스템에서 듀티비가 50%라면 평균 전압은 약 1.65V가 된다.

### PWM 파형의 수학적 표현

PWM 출력은 다음과 같이 정의할 수 있다:
$$
V_{avg} = V_{max} \times \frac{T_{on}}{T_{period}}
$$

- $V_{avg}$: 평균 전압
- $V_{max}$: 출력 신호의 최대 전압
- $T_{on}$: High 상태의 지속 시간
- $T_{period}$: 전체 주기 시간

듀티비가 높을수록 출력되는 평균 전압이 증가한다.

### 하드웨어 기반 PWM의 구조

STM32의 타이머는 하드웨어적으로 PWM 신호를 생성할 수 있다.

- **ARR (Auto Reload Register)**: PWM 주기를 결정.
- **CCR (Capture/Compare Register)**: 듀티비를 결정.
- **PSC (Prescaler)**: 입력 클럭 분주 비율.

이 세 요소를 조합하면 다음 관계로 PWM이 결정된다:
$$
f_{PWM} = \frac{f_{CLK}}{(PSC + 1)(ARR + 1)}
$$
예를 들어, 클럭이 72MHz이고 PSC = 71, ARR = 999이면, PWM 주파수는 1kHz가 된다.

### PWM 모드의 종류

STM32의 타이머는 여러 PWM 모드를 제공한다.

- **PWM Mode 1**: 타이머 카운터 값이 CCR보다 작을 때 High 출력.
- **PWM Mode 2**: 타이머 카운터 값이 CCR보다 작을 때 Low 출력.

이 모드들은 타이머의 비교 동작에 따라 출력 파형의 극성을 반전시키는 역할을 한다.

### 듀티비 변화에 따른 출력 제어

- **0% Duty** → 완전 OFF 상태
- **50% Duty** → 평균 전압의 절반 출력
- **100% Duty** → 완전 ON 상태

이 원리를 이용하면 LED 밝기 제어나 DC 모터의 속도 제어가 가능하다.

### 고속 PWM vs 저속 PWM

| 구분     | 주파수 범위      | 특징                        | 주요 응용          |
| -------- | ---------------- | --------------------------- | ------------------ |
| 저속 PWM | 100 Hz ~ 5 kHz   | 눈에 보이는 밝기, 저속 모터 | LED, 서보모터      |
| 고속 PWM | 10 kHz ~ 100 kHz | 고정밀 제어, 소음 감소      | DC 모터, 전력 제어 |

고속 PWM은 부드러운 전력 전달이 가능하나, 타이머 해상도 감소에 주의해야 한다.

### PWM의 한계와 고려사항

- **분해능 (Resolution)**: ARR 값이 작으면 듀티 조정 단위가 거칠어진다.
- **하드웨어 제한**: 특정 타이머는 특정 핀(CH1~CH4)에만 PWM 출력 가능.
- **전력 소모**: 고주파 PWM은 스위칭 손실이 증가할 수 있다.

### 응용 예시

- LED 밝기 제어: 듀티비에 따라 LED 밝기 선형 조정.
- DC 모터 제어: PWM 신호를 H-Bridge 드라이버에 입력.
- 서보모터 제어: 20ms 주기, 1~2ms 듀티비 펄스를 이용해 각도 제어.

------

이 절에서는 PWM의 **이론적 기초, 하드웨어 타이머 구성, 신호 계산 방식, 응용 예시**를 종합적으로 다루며, 다음 절에서는 CubeIDE와 HAL을 이용해 PWM을 실제로 구성하고 제어하는 방법을 다룬다.

## 18.2 DC 모터 속도 제어

DC 모터의 속도는 인가되는 전압의 평균값에 비례하여 변화한다. STM32에서는 PWM(Pulse Width Modulation)을 이용하여 디지털 신호 기반으로 평균 전압을 제어함으로써 모터의 속도를 정밀하게 조절할 수 있다. PWM의 듀티비(Duty Cycle)가 커질수록 모터의 회전 속도는 빨라지며, 반대로 듀티비가 작아지면 속도가 감소한다.

------

### DC 모터 구동 기본 원리

DC 모터의 회전 속도는 인가 전압과 토크에 의해 결정된다.

- **속도(ω)**는 인가 전압에 비례
- **토크(T)**는 전류에 비례

기본 방정식은 다음과 같다.
$$
V = E + I \cdot R
$$
여기서,

- $V$: 인가 전압
- $E$: 역기전력 (Back EMF)
- $I$: 전류
- $R$: 모터 내부 저항

PWM 제어에서는 이 $V$의 평균값을 듀티비로 제어하게 된다.

------

### 모터 드라이버를 이용한 구동

MCU의 GPIO 핀은 전류 공급 능력이 매우 제한적이므로, 모터를 직접 구동할 수 없다. 대신, **모터 드라이버(IC)**를 사용하여 MCU 신호를 증폭한다.

일반적으로 다음과 같은 드라이버가 사용된다.

- **L293D / L298N**: 양방향 DC 모터 제어 가능 (H-Bridge 구조)
- **TB6612FNG**: 고효율 MOSFET 기반 드라이버, 저발열
- **DRV8833 / BTS7960**: 고전류, 고전압 대응

PWM 신호는 드라이버의 `EN` 핀(Enable) 또는 `PWM` 입력으로 전달되어 속도를 제어한다. 방향은 `IN1`, `IN2` 핀을 통해 제어한다.

------

### H-Bridge 구성 원리

H-Bridge 회로는 네 개의 스위칭 소자(MOSFET, BJT 등)를 이용해 전류 방향을 제어한다.

| IN1  | IN2  | 출력 방향 | 동작             |
| ---- | ---- | --------- | ---------------- |
| 1    | 0    | 정방향    | 시계 방향 회전   |
| 0    | 1    | 역방향    | 반시계 방향 회전 |
| 0    | 0    | 정지      | 브레이크 해제    |
| 1    | 1    | 브레이크  | 회전 급정지      |

PWM은 주로 EN 핀에 인가되어 회전 속도를 조절한다.

------

### CubeIDE를 이용한 PWM 구성

HAL 기반으로 PWM 출력을 설정하기 위해 다음 단계를 수행한다.

1. **Timer 설정**

   - CubeMX의 *Timers* 메뉴에서 PWM Generation CH1 모드 선택
   - 주파수: 1kHz ~ 20kHz (모터 특성에 따라 조정)
   - Prescaler, ARR 계산 후 저장

2. **핀 매핑**

   - TIMx_CHy 채널을 PWM 출력 핀에 연결 (예: PA8, PB6 등)

3. **코드 생성 후 PWM 초기화**

   ```
   HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
   ```

4. **듀티비 변경으로 속도 제어**

   ```
   __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, duty);
   ```

   `duty` 값은 `0 ~ ARR` 범위로 설정하여 속도를 제어한다.

------

### 듀티비와 속도의 관계

| 듀티비 (%) | 평균 전압  | 예상 속도 |
| ---------- | ---------- | --------- |
| 0%         | 0V         | 정지      |
| 25%        | 0.25 × Vcc | 저속      |
| 50%        | 0.5 × Vcc  | 중속      |
| 75%        | 0.75 × Vcc | 고속      |
| 100%       | Vcc        | 최대속도  |

실제 속도는 부하, 베어링 마찰, 전원 전류 용량 등에 따라 달라진다.

------

### 정·역회전 제어 예제

```
void Motor_Forward(void) {
    HAL_GPIO_WritePin(IN1_GPIO_Port, IN1_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(IN2_GPIO_Port, IN2_Pin, GPIO_PIN_RESET);
}

void Motor_Backward(void) {
    HAL_GPIO_WritePin(IN1_GPIO_Port, IN1_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(IN2_GPIO_Port, IN2_Pin, GPIO_PIN_SET);
}

void Motor_Stop(void) {
    HAL_GPIO_WritePin(IN1_GPIO_Port, IN1_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(IN2_GPIO_Port, IN2_Pin, GPIO_PIN_RESET);
}
```

PWM 듀티비를 변경하면서 위 함수들과 조합하면, 속도와 방향을 모두 제어할 수 있다.

------

### 속도 피드백 제어 (선택)

정확한 속도 제어를 위해 엔코더 피드백을 사용할 수 있다.

- **Incremental Encoder**를 타이머 입력 캡처로 연결하여 실제 회전수를 측정.
- 측정 속도와 목표 속도의 차이를 PID 제어로 보정.

```
error = target_speed - measured_speed;
PWM_duty += Kp * error + Ki * sum_error + Kd * (error - prev_error);
```

이 방법을 통해 폐루프(Closed Loop) 제어를 구현할 수 있다.

------

### 보호 회로 및 고려사항

- **Flyback Diode**: 모터의 역기전력(EMF)으로부터 드라이버 보호
- **전원 필터링**: 모터의 노이즈 억제를 위한 전해/세라믹 콘덴서 병용
- **PWM 주파수 선택**: 15~20kHz 이상이면 인체 청음 대역(가청 소음) 회피 가능
- **전류 모니터링**: 과전류 보호용 션트 저항 또는 전류 센서 사용 가능

------

### 결론

PWM 기반 DC 모터 제어는 단순하지만 매우 강력한 방식으로,

- 속도 제어
- 방향 제어
- 브레이크 제어
- 피드백 기반 폐루프 제어

등을 유연하게 구현할 수 있다.
 STM32의 타이머와 HAL을 이용하면 고정밀 속도 제어 시스템을 손쉽게 구축할 수 있다.

## 18.3 서보모터 제어

서보모터(Servo Motor)는 내부에 **DC 모터**, **기어 감속기**, **위치 피드백용 포텐셔미터**, 그리고 **제어 회로**가 결합된 정밀 구동 장치다. 일반적인 RC(라디오 컨트롤)용 서보모터는 **PWM 신호의 펄스 폭(Pulse Width)**에 따라 각도를 제어한다. STM32에서는 타이머의 PWM 기능을 이용해 정확한 제어 신호를 생성할 수 있다.

------

### 서보모터의 구조

서보모터는 다음의 구성 요소로 이루어진 폐루프(Closed-loop) 제어 시스템이다.

- **DC 모터**: 회전력(토크)을 발생시킨다.
- **기어 트레인(Gear Train)**: 회전속도를 줄이고 토크를 증가시킨다.
- **포텐셔미터(Potentiometer)**: 현재 축의 각도를 아날로그 전압으로 피드백.
- **제어 회로**: 입력 PWM 신호의 펄스 폭과 포텐셔미터 피드백을 비교하여 모터를 정밀하게 구동.

이 구조 덕분에 서보모터는 각도를 일정하게 유지하거나, 지정된 위치로 빠르게 이동할 수 있다.

------

### 제어 신호의 PWM 파라미터

RC 서보모터는 일정한 주기의 PWM 신호를 필요로 한다.

- **주기 (Period)**: 약 **20ms (50Hz)**
- **펄스 폭 (Ton)**: 1.0ms ~ 2.0ms (일부 모델은 0.5~2.5ms까지 지원)
- **동작 범위**: 일반적으로 **0° ~ 180°**

| 펄스 폭 | 각도 | 설명   |
| ------- | ---- | ------ |
| 1.0 ms  | 0°   | 최좌측 |
| 1.5 ms  | 90°  | 중간   |
| 2.0 ms  | 180° | 최우측 |

PWM의 듀티비는 약 **5% ~ 10%** 범위에 해당하며, 이 미세한 펄스 폭 차이에 의해 축의 위치가 결정된다.

------

### STM32 타이머를 이용한 PWM 설정

서보 제어를 위해 타이머를 다음과 같이 구성한다.

1. **주기 설정 (20ms)**
   $$
   f_{PWM} = 50Hz \Rightarrow Period = 20ms
   $$
   예: 72MHz 클럭 기준

   - Prescaler = 71
   - ARR = 19999
      → PWM 주기 = 20ms

2. **펄스 폭 범위**

   - 1.0ms = 1000 count
   - 1.5ms = 1500 count
   - 2.0ms = 2000 count

3. **CubeMX 설정**

   - `TIMx_CHy`를 PWM Generation 모드로 설정
   - 주파수 50Hz, 채널 활성화
   - PWM Start 함수 호출

```
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
```

1. **각도에 따른 CCR 설정**

```
void Servo_SetAngle(uint8_t angle)
{
    uint16_t pulse = 1000 + ((angle * 1000) / 180); // 1.0~2.0ms
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
}
```

이 함수는 각도(0~180°)를 입력받아 대응하는 PWM 펄스 폭으로 변환한다.

------

### 서보 제어 회로 구성

서보모터는 일반적으로 **3핀** 구조다.

| 핀   | 기능      | 설명                                   |
| ---- | --------- | -------------------------------------- |
| VCC  | 전원      | 5V (일부 모델은 4.8~6V)                |
| GND  | 접지      | MCU GND와 반드시 공통                  |
| PWM  | 제어 신호 | MCU의 PWM 출력 핀 (예: TIM3_CH1 → PA6) |

주의할 점은, 서보모터가 **순간적으로 큰 전류(0.5~1A 이상)**를 소모하므로,
 MCU 보드의 5V 핀에 직접 연결하지 않고 별도의 전원(5V 레귤레이터, 배터리 등)을 사용하는 것이 바람직하다.

------

### 실습 예제

```
#include "tim.h"
#include "main.h"

void Servo_Test(void)
{
    for (int angle = 0; angle <= 180; angle += 10)
    {
        Servo_SetAngle(angle);
        HAL_Delay(200);
    }
    for (int angle = 180; angle >= 0; angle -= 10)
    {
        Servo_SetAngle(angle);
        HAL_Delay(200);
    }
}
```

위 코드는 서보모터를 0°→180°→0°로 반복 회전시키는 간단한 예제이다.

------

### 서보모터 제어 시 고려사항

- **전류 노이즈**: 서보 구동 시 전원 라인에 노이즈가 발생하므로, 100µF 이상의 전해콘덴서 병렬 연결이 필요하다.
- **지터(Jitter)**: PWM 신호의 불안정성으로 인한 미세 진동을 방지하려면 안정적인 타이머 기반 PWM을 사용해야 한다.
- **부하(Torque)**: 지정된 토크 이상으로 부하가 걸리면 모터 내부 회로가 과열되어 수명이 단축된다.
- **공유 타이머 문제**: FreeRTOS나 DMA와 함께 사용할 경우, 해당 타이머를 공유하지 않도록 주의해야 한다.

------

### 고급 제어 (선택 항목)

1. **다중 서보 제어**
    여러 개의 서보를 제어할 경우, 타이머의 여러 채널(TIMx_CH1~CH4)을 병렬로 사용한다.

2. **소프트웨어 보간 제어**
    목표 각도에 도달할 때까지 점진적으로 각도를 변경하면 부드러운 동작이 가능하다.

   ```
   void Servo_SmoothMove(uint8_t start, uint8_t end, uint8_t step)
   {
       if (start < end)
           for (int a = start; a <= end; a += step) { Servo_SetAngle(a); HAL_Delay(15); }
       else
           for (int a = start; a >= end; a -= step) { Servo_SetAngle(a); HAL_Delay(15); }
   }
   ```

3. **PID 기반 제어 (산업용 서보)**
    고급 서보모터(Encoder 내장형)는 PWM 제어 외에도 PID 루프를 통해 위치 및 속도 피드백 제어가 가능하다.

------

### 요약

| 항목          | 내용                                 |
| ------------- | ------------------------------------ |
| 제어 방식     | PWM (1.0~2.0ms, 50Hz)                |
| 각도 범위     | 약 0°~180°                           |
| 주요 구성     | DC 모터, 기어, 포텐셔미터, 제어 회로 |
| 제어 파라미터 | 펄스 폭 (Ton)                        |
| 전원          | 5V, 고전류 주의                      |
| MCU 제어 방법 | TIMx PWM CH 출력 + HAL 함수          |

------

서보모터 제어는 **PWM 신호의 정밀 제어**와 **전원 안정성 확보**가 핵심이다.
 STM32의 하드웨어 타이머와 HAL 드라이버를 이용하면 다축 서보 제어 시스템도 손쉽게 구축할 수 있다.

## 18.4 스텝모터 구동

스텝모터(Stepper Motor)는 입력되는 **펄스 신호의 개수와 순서**에 따라 일정한 각도만큼 회전하는 **정밀 위치 제어용 구동기**이다. 일반 DC 모터와 달리 피드백 센서 없이도 각도를 정밀하게 제어할 수 있어 3D 프린터, CNC, 로봇 암 등에서 널리 사용된다. STM32에서는 **GPIO 또는 Timer 기반 PWM 제어**, **드라이버 칩 제어 방식**을 통해 구동한다.

------

### 스텝모터의 기본 원리

스텝모터는 다수의 **코일(상, phase)**을 순차적으로 여자(excitation)시켜 회전력을 발생시키며,
 한 펄스 입력당 일정 각도(스텝 각도)만큼 회전한다.

| 유형                | 상수 | 스텝 각도     | 특징                     |
| ------------------- | ---- | ------------- | ------------------------ |
| 유니폴라 (Unipolar) | 4상  | 1.8°, 0.9° 등 | 제어 간단, 토크 낮음     |
| 바이폴라 (Bipolar)  | 2상  | 1.8°          | 토크 높음, 드라이버 필요 |
| 5상 하이브리드      | 5상  | 0.72°         | 정밀 제어, 고가형        |

스텝모터의 총 회전각은 다음과 같이 계산된다.
$$
\text{총 회전각} = \text{스텝 각도} \times \text{펄스 수}
$$

------

### 구동 모드

스텝모터는 코일의 여자 방식에 따라 다음과 같은 구동 모드를 가진다.

| 구동 방식      | 설명                   | 특징                     |
| -------------- | ---------------------- | ------------------------ |
| **Full Step**  | 2상 또는 4상 순차 구동 | 최대 토크, 진동 큼       |
| **Half Step**  | 1상 + 2상 교차 구동    | 해상도 2배, 부드러움     |
| **Micro Step** | PWM으로 전류 미세 제어 | 정밀 제어, 부드러운 회전 |

#### Full Step 시퀀스 (4상 모터 예시)

| 스텝 | IN1  | IN2  | IN3  | IN4  |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 0    | 1    | 0    |
| 2    | 0    | 1    | 1    | 0    |
| 3    | 0    | 1    | 0    | 1    |
| 4    | 1    | 0    | 0    | 1    |

------

### 구동 회로 구성

스텝모터는 MCU로 직접 구동할 수 없으며, 반드시 **드라이버 회로**가 필요하다.
 대표적인 드라이버는 다음과 같다.

| 드라이버            | 입력       | 특징                                     |
| ------------------- | ---------- | ---------------------------------------- |
| **ULN2003**         | 5V TTL     | 유니폴라 모터용, 저전류                  |
| **L298N / L293D**   | PWM + DIR  | 바이폴라 모터용, H-Bridge 구성           |
| **A4988 / DRV8825** | STEP + DIR | 마이크로스텝 지원, 1/16~1/32 세분화 가능 |

STM32에서는 **GPIO 핀으로 STEP/DIR 신호를 출력**하여 드라이버를 제어한다.

------

### STM32 제어 기본 구조

#### 하드웨어 구성 예 (A4988 기반)

| 핀명       | 연결 대상       | 설명                       |
| ---------- | --------------- | -------------------------- |
| STEP       | TIM PWM or GPIO | 펄스 신호 (스텝 수 제어)   |
| DIR        | GPIO            | 회전 방향 설정 (CW/CCW)    |
| EN         | GPIO            | 드라이버 활성/비활성       |
| VDD / VMOT | 3.3V / 12V      | 논리 전원 / 모터 전원 분리 |

------

### 기본 제어 코드 예제

```
#define DIR_PIN     GPIO_PIN_1
#define STEP_PIN    GPIO_PIN_2
#define DIR_PORT    GPIOA
#define STEP_PORT   GPIOA

void StepMotor_SetDir(uint8_t dir)
{
    HAL_GPIO_WritePin(DIR_PORT, DIR_PIN, dir ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

void StepMotor_StepPulse(void)
{
    HAL_GPIO_WritePin(STEP_PORT, STEP_PIN, GPIO_PIN_SET);
    HAL_Delay(1);
    HAL_GPIO_WritePin(STEP_PORT, STEP_PIN, GPIO_PIN_RESET);
    HAL_Delay(1);
}
```

------

### 지정 각도 회전 함수

```
void StepMotor_Rotate(float angle, float step_angle, uint8_t dir)
{
    int steps = (int)(angle / step_angle);
    StepMotor_SetDir(dir);
    for (int i = 0; i < steps; i++)
    {
        StepMotor_StepPulse();
    }
}
```

예를 들어 1.8° 스텝 모터를 90° 회전시키려면
$$
steps = 90 / 1.8 = 50
$$
이므로 50개의 펄스를 인가한다.

------

### PWM 기반 스텝 속도 제어

지속적인 회전(연속 펄스)을 위해 **타이머 PWM 출력**을 사용하면 CPU 부하를 줄일 수 있다.

```
void StepMotor_Start(uint16_t freq)
{
    TIM_OC_InitTypeDef sConfigOC = {0};
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = (HAL_RCC_GetPCLK1Freq() / freq) / 2;
    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
}
```

PWM 주파수 = 회전 속도(스텝 속도)에 대응하며,
 `DIR` 핀의 상태로 CW(시계 방향) 또는 CCW(반시계 방향)를 결정한다.

------

### 속도 및 가속 제어

스텝모터는 갑작스러운 속도 변화 시 스텝 손실(Step loss)이 발생할 수 있으므로,
 **가속/감속 프로파일**을 적용해야 한다.

```
void StepMotor_Accel(uint16_t startFreq, uint16_t endFreq, uint16_t step)
{
    for (uint16_t f = startFreq; f <= endFreq; f += step)
    {
        StepMotor_Start(f);
        HAL_Delay(5);
    }
}
```

가속 후 일정 주파수로 유지하고, 정지 시 반대로 감속하는 형태로 제어한다.

------

### Half Step 제어 예시

| 스텝 | IN1  | IN2  | IN3  | IN4  |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 0    | 0    | 0    |
| 2    | 1    | 1    | 0    | 0    |
| 3    | 0    | 1    | 0    | 0    |
| 4    | 0    | 1    | 1    | 0    |
| 5    | 0    | 0    | 1    | 0    |
| 6    | 0    | 0    | 1    | 1    |
| 7    | 0    | 0    | 0    | 1    |
| 8    | 1    | 0    | 0    | 1    |

이 방식은 해상도를 두 배로 늘리고, 진동과 소음을 줄일 수 있다.

------

### 마이크로스텝 제어

A4988, DRV8825 등은 내부 전류 제어를 통해 한 스텝을 **16~32단계로 세분화(microstepping)** 할 수 있다.
 이 경우 MCU는 단순히 **STEP 신호의 펄스 주파수**만 제어하면 되며, 정밀한 위치 이동이 가능하다.

| Microstep 설정 | 분해능 향상 | DIP 스위치 (예시) |
| -------------- | ----------- | ----------------- |
| 1/1            | 기본        | M0=0, M1=0, M2=0  |
| 1/2            | 2배         | M0=1, M1=0, M2=0  |
| 1/8            | 8배         | M0=1, M1=1, M2=0  |
| 1/16           | 16배        | M0=1, M1=1, M2=1  |

------

### 스텝모터 제어 시 주의사항

- **전원 분리**: 논리 전원(3.3V)과 모터 전원(12~24V)을 분리해야 MCU가 보호된다.
- **토크 손실 방지**: 과도한 속도 상승 시 회전이 멈추는 현상(Rotor Stall)이 발생한다.
- **발열 관리**: 지속 구동 시 코일 과열이 발생하므로 드라이버의 전류 제한 기능을 활성화해야 한다.
- **노이즈 필터링**: EMF(역기전력)으로 인한 리셋 방지를 위해 다이오드나 콘덴서를 병렬로 추가한다.

------

### 요약

| 항목          | 내용                                 |
| ------------- | ------------------------------------ |
| 제어 신호     | STEP (펄스), DIR (방향), EN (활성)   |
| 구동 주기     | 펄스 주파수에 비례한 회전 속도       |
| 제어 방식     | Full / Half / Micro Step             |
| 주요 드라이버 | ULN2003, L298N, A4988, DRV8825       |
| 제어 핵심     | 타이밍 제어, 가속/감속 프로파일      |
| 응용 예       | CNC, 3D 프린터, 로봇 제어, 밸브 구동 |

------

스텝모터 구동의 핵심은 **정확한 펄스 타이밍**과 **전류 제어 안정성**이다.
 STM32의 하드웨어 타이머를 활용하면 CPU 부하 없이 일정 주기의 STEP 신호를 생성할 수 있으며,
 가속 제어 알고리즘을 결합하면 정밀하고 부드러운 위치 제어 시스템을 구현할 수 있다.

## 18.5 모터드라이버 (L298N, TB6612FNG)

모터드라이버는 MCU의 제어 신호(GPIO, PWM 등)를 **고전류·고전압 구동 신호**로 변환하여 DC 모터, 스텝모터, 서보모터 등을 실제로 구동하는 회로 소자이다.
 STM32에서는 **PWM 제어 + 방향 제어(DIR)** 조합으로 속도와 방향을 정밀하게 제어하며,
 대표적으로 **L298N**, **TB6612FNG**와 같은 H-Bridge 기반 드라이버를 많이 사용한다.

------

### H-Bridge 기본 원리

모터 양단의 전압 방향을 제어하기 위해 **4개의 스위치(트랜지스터)**를 교차 배치한 회로 구조를 H-Bridge라 한다.
 이를 통해 **정/역회전** 및 **정지/브레이크** 동작을 구현한다.

| 동작 모드 | IN1  | IN2  | 결과                   |
| --------- | ---- | ---- | ---------------------- |
| 정회전    | 1    | 0    | 전류 정방향            |
| 역회전    | 0    | 1    | 전류 역방향            |
| 정지      | 0    | 0    | 모터 단락 없음 (Coast) |
| 브레이크  | 1    | 1    | 단락 상태 (빠른 정지)  |

MCU에서는 일반적으로 PWM 신호를 IN1 또는 IN2에 인가하여 **속도 제어**를 수행한다.

------

## L298N 드라이버

### 개요

L298N은 STMicroelectronics의 **듀얼 H-Bridge 모터드라이버**로, DC 모터 2개 또는 스텝모터 1개를 구동할 수 있다.
 최대 **전압 46V**, **전류 2A(채널당)**까지 지원한다.

### 주요 특징

- 동작 전압: 5V(논리) / 7~46V(모터 전원)
- 채널 수: 2채널 (OUT1~OUT4)
- 제어 입력: IN1, IN2, ENA (채널 A), IN3, IN4, ENB (채널 B)
- PWM 속도 제어 및 방향 제어 가능
- 내부 프리휠 다이오드 내장

------

### 핀 구성

| 핀명      | 기능              | 설명                 |
| --------- | ----------------- | -------------------- |
| ENA / ENB | PWM 입력          | 모터 속도 제어       |
| IN1~IN4   | 방향 제어         | H-Bridge 스위칭      |
| OUT1~OUT4 | 모터 출력         | 모터 양단 연결       |
| Vcc       | 논리 전원 (5V)    | MCU 입력 전원        |
| Vs        | 모터 전원 (7~46V) | 모터 전원            |
| GND       | 공통 접지         | MCU와 공통 접지 필요 |

------

### STM32 연결 예시

| L298N 핀 | STM32 핀       | 설명      |
| -------- | -------------- | --------- |
| ENA      | TIMx_CH1 (PWM) | 속도 제어 |
| IN1      | GPIO           | 방향 제어 |
| IN2      | GPIO           | 방향 제어 |
| ENB      | TIMx_CH2 (PWM) | 속도 제어 |
| IN3      | GPIO           | 방향 제어 |
| IN4      | GPIO           | 방향 제어 |

------

### 기본 제어 코드 예제

```
#define IN1_PIN GPIO_PIN_0
#define IN2_PIN GPIO_PIN_1
#define ENA_CH  TIM_CHANNEL_1

void Motor_SetDir(uint8_t dir)
{
    if (dir == 0) { // 정방향
        HAL_GPIO_WritePin(GPIOA, IN1_PIN, GPIO_PIN_SET);
        HAL_GPIO_WritePin(GPIOA, IN2_PIN, GPIO_PIN_RESET);
    } else { // 역방향
        HAL_GPIO_WritePin(GPIOA, IN1_PIN, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(GPIOA, IN2_PIN, GPIO_PIN_SET);
    }
}

void Motor_SetSpeed(uint16_t duty)
{
    __HAL_TIM_SET_COMPARE(&htim2, ENA_CH, duty);
}
```

**속도 제어**는 PWM 듀티비로, **방향 제어**는 IN1/IN2 조합으로 수행한다.

------

## TB6612FNG 드라이버

### 개요

TB6612FNG는 Toshiba의 고효율 **MOSFET H-Bridge 드라이버**로, L298N보다 발열이 적고 전력 효율이 높다.
 로직 전압 2.7~5.5V, 모터 전압 최대 13.5V, 채널당 1.2A까지 구동 가능하다.

### 주요 특징

- 동작 전압: VM(모터) = 2.5~13.5V, VCC(로직) = 2.7~5.5V
- 최대 전류: 1.2A(연속), 3.2A(피크)
- 스탠바이 모드(STBY) 지원
- PWM 입력으로 속도 제어 가능
- 전류 손실이 작아 저발열

------

### 핀 구성

| 핀명             | 기능                  | 설명                 |
| ---------------- | --------------------- | -------------------- |
| PWMA / PWMB      | PWM 입력              | 속도 제어            |
| AIN1 / AIN2      | 방향 제어             | 채널 A               |
| BIN1 / BIN2      | 방향 제어             | 채널 B               |
| STBY             | 활성 신호             | HIGH 시 동작         |
| VM               | 모터 전원 (2.5~13.5V) |                      |
| VCC              | 로직 전원 (3.3~5V)    |                      |
| GND              | 접지                  | MCU와 공통 접지 필요 |
| AO1/AO2, BO1/BO2 | 모터 출력             |                      |

------

### STM32 연결 예시

| TB6612 핀 | STM32 핀       | 설명               |
| --------- | -------------- | ------------------ |
| PWMA      | TIMx_CH1 (PWM) | 속도 제어          |
| AIN1      | GPIO           | 방향 제어          |
| AIN2      | GPIO           | 방향 제어          |
| STBY      | GPIO           | 드라이버 활성 제어 |
| PWMB      | TIMx_CH2 (PWM) | 속도 제어          |
| BIN1      | GPIO           | 방향 제어          |
| BIN2      | GPIO           | 방향 제어          |

------

### 기본 제어 코드 예제

```
#define AIN1_PIN GPIO_PIN_2
#define AIN2_PIN GPIO_PIN_3
#define PWMA_CH  TIM_CHANNEL_1
#define STBY_PIN GPIO_PIN_5

void TB6612_Enable(void)
{
    HAL_GPIO_WritePin(GPIOA, STBY_PIN, GPIO_PIN_SET);
}

void TB6612_SetDir(uint8_t dir)
{
    if (dir == 0) {
        HAL_GPIO_WritePin(GPIOA, AIN1_PIN, GPIO_PIN_SET);
        HAL_GPIO_WritePin(GPIOA, AIN2_PIN, GPIO_PIN_RESET);
    } else {
        HAL_GPIO_WritePin(GPIOA, AIN1_PIN, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(GPIOA, AIN2_PIN, GPIO_PIN_SET);
    }
}

void TB6612_SetSpeed(uint16_t duty)
{
    __HAL_TIM_SET_COMPARE(&htim3, PWMA_CH, duty);
}
```

------

### L298N vs TB6612FNG 비교

| 항목        | L298N        | TB6612FNG             |
| ----------- | ------------ | --------------------- |
| 구동 방식   | BJT H-Bridge | MOSFET H-Bridge       |
| 논리 전압   | 5V           | 2.7~5.5V              |
| 모터 전압   | 7~46V        | 2.5~13.5V             |
| 최대 전류   | 2A           | 1.2A (3.2A 피크)      |
| 효율 / 발열 | 낮음 / 높음  | 높음 / 낮음           |
| STBY 기능   | 없음         | 있음                  |
| 크기        | 큼           | 작음                  |
| 추천 용도   | 고전압 모터  | 저전압, 저발열 시스템 |

------

### 응용 회로 예시

- **DC 모터 제어 (PWM + DIR)**
  - `PWM` 핀으로 속도 제어
  - `IN1/IN2`로 회전 방향 제어
  - `STBY`는 MCU 초기화 시 활성화
- **스텝모터 제어 (Dual H-Bridge 구성)**
  - 두 채널을 각각 상(Phase)으로 사용
  - A/B 코일에 번갈아 PWM 신호 인가

------

### 전류 보호 및 발열 대책

- 모터 구동 시 **EMF(역기전력)**에 의해 전류 피크가 발생할 수 있으므로,
   드라이버 입력단에 **470µF 이상 전해 콘덴서**를 병렬로 추가한다.
- L298N은 내부 손실이 커서 **히트싱크 부착**이 필수이다.
- TB6612FNG는 발열이 적지만, **전류 제한 회로** 또는 **PWM 소프트 스타트** 적용이 권장된다.

------

### 요약

| 구분          | 내용                                  |
| ------------- | ------------------------------------- |
| 제어 방식     | PWM 속도 + DIR 방향 제어              |
| 주요 드라이버 | L298N (고전압), TB6612FNG (고효율)    |
| 제어 신호     | EN/PWM, IN1/IN2                       |
| 보호 기능     | 전류 제한, STBY, 다이오드 보호        |
| 권장 회로     | 모터 전원 별도 공급, 공통 GND 연결    |
| 응용 예       | 로봇 구동, RC 차량, 펌프, 컨베이어 등 |

------

모터드라이버는 단순한 출력 증폭 회로를 넘어 **전류 제어, 보호, 효율 관리**의 핵심 요소이다.
 STM32의 타이머 기반 PWM을 조합하면 **정확한 속도 제어**, **부드러운 가속/감속**, **효율적 전력 제어**가 가능하다.

## 18.6 센서 피드백 기반 제어 (PID 기본)

센서 피드백 기반 제어는 시스템의 **출력 결과를 실시간으로 측정하고, 목표값(Target)과 비교하여 오차(Error)를 줄이는 제어 방식**이다.
 이 과정에서 가장 널리 사용되는 제어 알고리즘이 **PID(Proportional-Integral-Derivative)** 제어이다.
 PID 제어는 단순한 오픈루프(open-loop) PWM 제어보다 정밀하고 안정적인 동작을 보장한다.

------

### 제어 시스템 기본 구조

센서 피드백 제어의 일반적인 블록 다이어그램은 다음과 같다.

```
   ┌────────────┐     ┌──────────────┐     ┌────────────┐
   │  목표값(R)  │  →  │  PID 제어기   │  →  │ 구동부(MCU) │
   └────────────┘     └──────────────┘     └────────────┘
           ↑                                       │
           └─────────── 피드백(센서 출력 Y) ─────────┘
```

- **R (Reference)** : 목표값 (예: 목표 속도, 목표 온도 등)
- **Y (Output)** : 센서로부터 측정된 현재값
- **E (Error)** : R - Y
- **PID Controller** : E를 기반으로 보정값(U)을 계산
- **Actuator** : U에 따라 시스템을 조정 (모터, 히터 등)

------

### PID 제어의 수학적 모델

PID 제어는 다음의 수식으로 표현된다.
$$
U(t) = K_p e(t) + K_i \int e(t) dt + K_d \frac{de(t)}{dt}
$$

| 항목                   | 의미                 | 역할                               |
| ---------------------- | -------------------- | ---------------------------------- |
| $K_p e(t)$             | 비례항(Proportional) | 오차에 비례한 즉각적인 제어량      |
| $K_i \int e(t) dt$     | 적분항(Integral)     | 누적 오차 제거, 장기적 안정성 확보 |
| $K_d \frac{de(t)}{dt}$ | 미분항(Derivative)   | 오차 변화율 반영, 진동 억제        |

------

### 각 항의 효과

| 제어항   | 설명                                   | 효과                             |
| -------- | -------------------------------------- | -------------------------------- |
| P (비례) | 현재 오차의 크기에 따라 제어 출력 생성 | 빠른 응답, 그러나 잔류 오차 존재 |
| I (적분) | 누적된 오차를 점진적으로 보상          | 잔류 오차 제거, 느린 응답        |
| D (미분) | 오차 변화율에 따른 보정                | 진동 억제, 안정성 향상           |

------

### 이산화된 PID 식 (MCU 구현용)

STM32와 같은 MCU에서는 이산 시간에서 PID를 계산한다.
 주기적 타이머 인터럽트 또는 RTOS 태스크에서 수행되며, 다음 식을 사용한다.
$$
U[n] = K_p e[n] + K_i \sum_{k=0}^{n} e[k] \Delta t + K_d \frac{e[n] - e[n-1]}{\Delta t}
$$
단순화된 구현 형태:

```
float PID_Compute(float setpoint, float measured)
{
    static float prev_error = 0;
    static float integral = 0;
    float error = setpoint - measured;

    integral += error;
    float derivative = error - prev_error;

    float output = Kp * error + Ki * integral + Kd * derivative;
    prev_error = error;

    return output;
}
```

------

### PID 제어 예시 — DC 모터 속도 제어

#### 구성 요소

- **센서**: 엔코더 또는 홀센서로 실제 RPM 측정
- **입력**: 목표 속도 (setpoint, 예: 1000 RPM)
- **출력**: PWM 듀티비 (0~100%)

#### 제어 흐름

1. 엔코더를 이용하여 일정 주기마다 실제 회전수를 계산
2. 목표 속도와 비교하여 오차 계산
3. PID 연산 수행 → 보정된 PWM 듀티비 생성
4. 모터에 PWM 신호 출력

#### 코드 예시

```
float target_speed = 1000.0f;   // 목표 속도 (RPM)
float measured_speed = 0.0f;    // 센서 입력값
float Kp = 0.4f, Ki = 0.05f, Kd = 0.2f;

void Control_Loop(void)
{
    measured_speed = Get_Encoder_Speed(); // 실제 속도 측정
    float control = PID_Compute(target_speed, measured_speed);

    if (control < 0) control = 0;
    if (control > 100) control = 100;

    Set_PWM_Duty(control); // 모터 속도 제어
}
```

------

### 튜닝 방법

PID 제어 성능은 **Kp, Ki, Kd의 비율 조정**에 따라 크게 달라진다.

#### Ziegler–Nichols 초기 튜닝법

1. **I, D를 0으로 설정**
2. **Kp를 점차 증가시켜** 시스템이 진동하기 시작하는 임계점 찾기
3. 임계 이득 $K_u$과 진동 주기 $T_u$를 기록
4. 아래 표를 기반으로 PID 계수 설정

| 제어 형태 | Kp     | Ki       | Kd         |
| --------- | ------ | -------- | ---------- |
| P         | 0.5Ku  | 0        | 0          |
| PI        | 0.45Ku | 1.2Kp/Tu | 0          |
| PID       | 0.6Ku  | 1.2Kp/Tu | 0.075Kp·Tu |

------

### 노이즈와 안정화 고려

- **센서 필터링**: 이동 평균(Moving Average), 저역통과 필터(LPF) 적용

- **출력 제한(Saturation)**: PWM 출력 0~100% 범위 유지

- **적분 포화(Anti-windup)**: 적분 항이 과도하게 누적되지 않도록 제한

  ```
  if (integral > 1000) integral = 1000;
  if (integral < -1000) integral = -1000;
  ```

- **D항 노이즈 대응**: 미분 항은 고주파 노이즈에 민감하므로 LPF 적용

------

### 실시간 모니터링

PID 성능 분석을 위해 다음 항목을 UART 또는 OLED로 출력한다.

- 현재 속도
- 목표 속도
- PID 출력 (PWM Duty)
- 오차(Error)

이 데이터를 기반으로 MATLAB, Python, Excel 등에서 그래프 분석 가능하다.

------

### 응용 예시

| 대상          | 측정 센서     | 제어 대상   | 목표값         |
| ------------- | ------------- | ----------- | -------------- |
| DC 모터       | 엔코더        | PWM Duty    | 목표 RPM       |
| 온도 제어     | NTC / DS18B20 | 히터 / 팬   | 목표 온도      |
| 압력 제어     | 압력 센서     | 밸브 / 펌프 | 목표 압력      |
| 라인 트레이서 | IR 센서       | DC 모터     | 중심 궤도 유지 |

------

### 결론

PID 제어는 센서 피드백을 이용한 **폐루프(Closed-loop)** 제어의 핵심이다.

- 비례(P) → 즉각적인 반응
- 적분(I) → 잔류 오차 제거
- 미분(D) → 안정화 및 진동 억제

STM32에서는 타이머 기반 주기적 PID 연산으로 **속도, 온도, 위치 등 모든 연속 제어 시스템**을 안정적이고 정밀하게 구현할 수 있다.