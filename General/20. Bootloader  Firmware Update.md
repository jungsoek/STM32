# 20. Bootloader / Firmware Update

## 20.1 Bootloader 개념

### 개요

Bootloader는 마이크로컨트롤러가 **전원을 인가받은 직후 가장 먼저 실행되는 코드**로, **사용자 애플리케이션을 로드하고 실행하는 역할**을 한다.
 STM32 시리즈에서는 **내장 부트로더(System Bootloader)** 와 **사용자 정의 부트로더(User Bootloader)** 두 가지 형태로 구분된다.

### 부트로더의 주요 역할

- **펌웨어 업데이트(Firmware Upgrade)**: UART, USB, CAN, I²C, SPI, BLE, Wi-Fi 등 다양한 인터페이스를 통해 신규 펌웨어를 수신 및 플래시 메모리에 저장.
- **시스템 초기화(System Initialization)**: 클럭, 메모리, 인터럽트 벡터 등 시스템 기본 설정 수행.
- **보안 관리(Security Control)**: 암호화/서명 검증을 통한 펌웨어 무결성 확인.
- **애플리케이션 점프(Application Jump)**: 부트로더 실행 후 사용자 영역(Application Section)으로 제어를 전달.

### STM32의 부트 모드 구조

STM32 MCU는 내부적으로 다음 3가지 부트 모드를 제공한다.

| 부트모드      | 설명                                                         | 부트 주소  |
| ------------- | ------------------------------------------------------------ | ---------- |
| System Memory | ST에서 제공하는 내장 부트로더. UART/USB/I²C 등으로 펌웨어 다운로드 가능 | 0x1FFFxxxx |
| User Flash    | 일반적인 사용자 코드가 저장된 영역                           | 0x0800xxxx |
| SRAM          | 디버깅 또는 테스트용 코드 실행에 사용                        | 0x2000xxxx |

**BOOT0 / BOOT1 핀 설정** 또는 **옵션 바이트(Option Bytes)** 조합을 통해 어떤 영역에서 부팅할지 결정된다.

### 부트 시퀀스 (부트 절차)

1. **리셋(Reset) 발생** → CPU가 벡터 테이블 초기화
2. **BOOT 핀 판독** → 부트 모드 결정
3. **해당 영역의 Stack Pointer 초기화 및 Reset Handler 호출**
4. **부트로더 실행 (System 또는 User Bootloader)**
5. **애플리케이션 코드 점프 (0x0800xxxx)**

### 사용자 부트로더(User Bootloader) 구조

사용자 정의 부트로더는 일반적으로 다음과 같이 구성된다.

```
+-----------------------------+
| Bootloader (16~32KB)        | → 펌웨어 수신 / 검증 / Flash Write
+-----------------------------+
| Application (나머지 영역)   | → 실제 사용자 프로그램
+-----------------------------+
| Flash Memory                |
```

- **부트로더**는 항상 Flash의 시작 주소(예: 0x08000000)에 위치한다.
- **애플리케이션 코드**는 별도의 오프셋(예: 0x08008000)에서 시작한다.
- 부트로더는 펌웨어 업데이트 요청(버튼, 명령어, 플래그 등)을 감지하여 업데이트 절차를 수행하거나, 정상 부팅으로 점프한다.

### 애플리케이션 점프 예시 코드

```
typedef void (*pFunction)(void);
#define APP_ADDRESS 0x08008000

void JumpToApplication(void)
{
    uint32_t appStack = *(volatile uint32_t*)APP_ADDRESS;
    pFunction appEntry = (pFunction)*(volatile uint32_t*)(APP_ADDRESS + 4);

    __set_MSP(appStack);             // 메인 스택 포인터 초기화
    SCB->VTOR = APP_ADDRESS;         // 벡터 테이블 오프셋 설정
    appEntry();                      // 애플리케이션 실행
}
```

### 부트로더 설계 시 고려사항

- **Flash Write 보호**: 부트로더 영역은 Write/Erase 방지 설정 권장.
- **통신 프로토콜 설계**: UART, CAN, USB 등 인터페이스에 따라 명령 프레임 구조 정의 필요.
- **업데이트 안정성**: 중단된 업데이트 상황에서 복구 가능한 구조(이중 이미지, CRC 검사 등).
- **보안 부트(Secure Boot)**: 펌웨어 서명 검증 및 암호화 기능 포함 가능.

### 내장(System) 부트로더와의 차이점

| 구분                | System Bootloader          | User Bootloader                       |
| ------------------- | -------------------------- | ------------------------------------- |
| 제공 주체           | STMicroelectronics         | 사용자 정의                           |
| 위치                | System Memory (ROM)        | User Flash                            |
| 수정 가능 여부      | 불가                       | 가능                                  |
| 업데이트 기능       | UART/USB/I²C/CAN 기본 지원 | 인터페이스 및 프로토콜 자유 구성 가능 |
| 보안 / 커스터마이즈 | 제한적                     | 완전 커스터마이즈 가능                |

### 실습 예시

- UART 기반 부트로더 + Flash Write API(`HAL_FLASH_Program`) 구현
- 버튼 입력을 통해 **업데이트 모드 ↔ 일반 실행 모드 전환**
- 펌웨어 전송 툴(STM32CubeProgrammer, TeraTerm XMODEM, Python 스크립트 등) 활용

이 절에서는 STM32의 부트 절차를 구조적으로 이해하고, **사용자 부트로더 설계의 기본 개념 및 구조**를 확립하는 것을 목표로 한다.

## 20.2 Flash Partition 및 Application 영역 분리

### 개요

STM32 마이크로컨트롤러에서 **Flash Memory Partition**은 펌웨어 구조를 논리적으로 구분하여 **부트로더(bootloader)** 와 **애플리케이션(application)** 을 독립적으로 관리하기 위한 핵심 개념이다.
 이 구조는 펌웨어 업데이트, 안정성 확보, 보안성 강화에 필수적이며, 특히 **OTA(Over-The-Air)** 또는 **UART/USB 기반 펌웨어 업그레이드**를 구현할 때 반드시 필요하다.

Flash 메모리는 보통 다음과 같이 구성된다.

```
+------------------------------+
|  Bootloader Section (16~32KB)|
|  - 통신 및 펌웨어 수신       |
|  - Flash Write/Erase 관리    |
|  - CRC / Signature 검증      |
+------------------------------+
|  Application Section         |
|  - 사용자 애플리케이션 코드  |
|  - 센서, 통신, 제어 로직 등 |
+------------------------------+
|  Optional Backup / OTA Slot  |
|  - 펌웨어 임시 저장 공간     |
+------------------------------+
```

이러한 파티션 구조를 통해 시스템은 **독립적인 펌웨어 갱신, 복원, 보안 부팅 절차**를 구현할 수 있다.

------

### Flash 메모리 구조

STM32F103C8T6을 예시로 할 때, Flash Memory 용량은 64KB이며, 일반적인 배치는 다음과 같다.

| 영역            | 시작 주소  | 크기 | 설명                |
| --------------- | ---------- | ---- | ------------------- |
| Bootloader      | 0x08000000 | 16KB | 부트로더 코드 저장  |
| Application     | 0x08004000 | 48KB | 사용자 코드 저장    |
| Backup / Config | 0x0800FC00 | 1KB  | 보정값, 설정값 저장 |

이 구조는 MCU 모델별로 다르며, STM32F4/F7/G4/H7 시리즈에서는 Sector 단위(16KB~128KB)로 나누어 관리한다.

------

### 벡터 테이블 오프셋 변경

애플리케이션이 부트로더 이후 영역(예: `0x08004000`)에서 시작할 경우, **벡터 테이블(Vector Table)** 위치를 반드시 변경해야 한다.
 이는 인터럽트 핸들러의 참조 주소를 새 Application 영역에 맞추기 위함이다.

#### 코드 예시

```
#define APP_START_ADDRESS  0x08004000

int main(void)
{
    HAL_Init();
    SystemClock_Config();

    // Application의 인터럽트 벡터 테이블 위치 변경
    SCB->VTOR = APP_START_ADDRESS;

    while (1)
    {
        // 사용자 코드 실행
    }
}
```

부트로더가 애플리케이션으로 점프할 때도 동일한 조치를 수행해야 한다.

------

### 링커 스크립트(Linker Script) 수정

애플리케이션이 부트로더 이후 주소에서 시작되도록 하려면, **링커 스크립트(.ld 파일)** 의 Flash 영역 시작 주소를 변경해야 한다.

#### 기본 (기존 프로젝트)

```
FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
```

#### 변경 (부트로더 이후부터 시작)

```
FLASH (rx) : ORIGIN = 0x08004000, LENGTH = 48K
```

또한, `MEMORY` 정의 외에도 `VECT_TAB_OFFSET` 매크로를 `system_stm32f1xx.c` 또는 `startup_stm32f1xx.s`에서 조정해야 한다.

#### 예시:

```
#define VECT_TAB_OFFSET  0x4000U  // 16KB offset (Application start)
```

------

### Application Jump 절차

부트로더에서 Application으로 점프할 때는 다음 순서로 제어권을 전달한다.

#### 점프 코드 예시

```
#define APP_START_ADDR  0x08004000
typedef void (*pFunction)(void);

void JumpToApplication(void)
{
    uint32_t appStack = *(volatile uint32_t*)APP_START_ADDR;
    pFunction appEntry = (pFunction)*(volatile uint32_t*)(APP_START_ADDR + 4);

    __disable_irq();                  // 인터럽트 비활성화
    __set_MSP(appStack);              // 스택 초기화
    SCB->VTOR = APP_START_ADDR;       // 벡터 테이블 위치 변경
    __enable_irq();                   // 인터럽트 복구
    appEntry();                       // 애플리케이션 실행
}
```

이 코드는 애플리케이션이 독립적으로 실행될 수 있도록 환경을 완전하게 초기화한 뒤, 진입점(Reset_Handler)으로 점프한다.

------

### CRC / Signature 검증을 통한 안전 부팅

부트로더는 Application 영역의 무결성을 검증하여 손상된 펌웨어 실행을 방지해야 한다.
 가장 간단한 방법은 CRC-32를 계산하고 Flash 마지막 부분에 저장하는 것이다.

#### 구조 예시

```
Application (0x08004000 ~ 0x0800FBFF)
CRC Value (0x0800FC00 ~ 0x0800FC03)
```

#### 검증 코드

```
uint32_t calc_crc = HAL_CRC_Calculate(&hcrc, (uint32_t*)APP_START_ADDR, app_size/4);
uint32_t stored_crc = *(uint32_t*)(0x0800FC00);

if (calc_crc == stored_crc)
    JumpToApplication();
else
    Error_Handler();  // 손상된 펌웨어
```

------

### Flash 파티션 설계 시 고려사항

| 항목             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| Flash 크기       | Bootloader + Application + Config 영역 총합은 Flash 용량 이내여야 함 |
| 섹터 크기        | Flash Erase 단위가 섹터 크기보다 작을 수 없음 (STM32F4: 16KB~128KB) |
| Write Protection | 부트로더 영역은 `OB_WRP` 설정을 통해 쓰기 보호               |
| Double Buffering | OTA 또는 안정성 향상을 위해 A/B 영역 구성 가능               |
| Config 분리      | 설정값, 보정값은 별도의 마지막 섹터에 저장 권장              |

------

### 예시: Dual Application 구조

이중 펌웨어 구조를 구현하면 업데이트 중 오류가 발생해도 시스템이 복구 가능하다.

```
+------------------------------+
| Bootloader (16KB)            |
|   - 펌웨어 수신/검증            |
+------------------------------+
| Application A (48KB)         |
|   - 현재 실행중인 펌웨어        |
+------------------------------+
| Application B (48KB)         |
|   - 대기 펌웨어 (업데이트용)    |
+------------------------------+
| Config / CRC (1KB)           |
+------------------------------+
```

부트로더는 부팅 시 CRC를 비교하여 A/B 중 유효한 펌웨어를 선택적으로 실행한다.

------

### 요약

- 부트로더와 애플리케이션은 Flash Memory를 **명확히 분리**하여 관리해야 한다.
- 링커 스크립트 수정, 벡터 테이블 재배치, CRC 검증이 핵심 요소이다.
- 안정성과 보안을 위해 **Write Protection, Double Buffering, Signature 인증**을 고려한다.
- 이러한 구조는 **안전한 펌웨어 업데이트 및 유지보수 가능한 시스템 설계**의 기반이 된다.

## 20.3 UART / USB DFU 업데이트

### 개요

펌웨어 업데이트(Firmware Update)는 임베디드 시스템에서 **기능 개선, 버그 수정, 보안 패치**를 위해 반드시 필요한 절차이다.
 STM32 시리즈는 기본적으로 **UART, USB DFU(Device Firmware Upgrade)**, **CAN**, **I²C**, **SPI** 등 다양한 인터페이스를 통한 부트로더 기반 펌웨어 업데이트를 지원한다.
 본 절에서는 UART와 USB DFU 기반 펌웨어 업데이트 방식을 다룬다.

------

### STM32의 System Bootloader 지원 인터페이스

STM32 MCU에는 ST에서 제공하는 **ROM 내장(System Bootloader)** 가 포함되어 있으며, 별도의 사용자 코드 없이도 다음 인터페이스를 통해 펌웨어 다운로드가 가능하다.

| 인터페이스 | 지원 MCU               | 비고                        |
| ---------- | ---------------------- | --------------------------- |
| UART       | 대부분의 STM32 시리즈  | 기본 인터페이스             |
| USB DFU    | STM32F4/F7/H7, 일부 L4 | USB Full-Speed DFU 프로토콜 |
| CAN        | STM32F1/F2/F4 일부     | 산업용 통신 업데이트용      |
| I²C / SPI  | 저용량 시리즈 일부     | 제한적 사용                 |

**BOOT0 핀 = 1 (High)** 상태로 리셋하면 System Memory의 부트로더 코드가 실행된다.

------

### UART 기반 펌웨어 업데이트

UART를 사용하는 펌웨어 업데이트는 가장 단순하고 안정적인 방식으로, **ST의 STM32CubeProgrammer** 또는 **Flash Loader Demonstrator**를 사용하여 수행할 수 있다.

#### 부트로더 동작 절차

1. **BOOT0 = High**, 리셋 → System Bootloader 진입
2. PC 측에서 **UART TX/RX 연결**
3. **STM32CubeProgrammer** 실행 → “UART” 선택
4. Baudrate 설정 (기본 115200bps)
5. **Connect → Erase → Download new firmware → Start execution**

#### UART 연결 예시

| STM32 핀 | USB-UART 변환기 | 설명      |
| -------- | --------------- | --------- |
| PA9      | TXD             | MCU → PC  |
| PA10     | RXD             | PC → MCU  |
| GND      | GND             | 공통 접지 |

#### UART 부트로더 프로토콜 개요

ST의 내장 부트로더는 **텍스트 기반이 아닌 바이너리 프로토콜**을 사용하며, 다음 명령 구조를 따른다.

| 명령 코드 | 설명         |
| --------- | ------------ |
| 0x7F      | 초기 동기화  |
| 0x00      | Get 명령     |
| 0x31      | Write Memory |
| 0x11      | Read Memory  |
| 0x44      | Erase Memory |

이 명령들은 CubeProgrammer가 자동으로 처리하며, 사용자는 단순히 UART 포트를 통해 펌웨어를 전송하면 된다.

------

### 사용자 정의 UART 부트로더 구조

UART 기반 부트로더를 직접 구현할 수도 있다.
 이 경우, MCU 전원을 켤 때 UART에서 특정 명령(예: “UPDATE\r\n”)을 수신하면 펌웨어 수신 루틴으로 진입하고, 그렇지 않으면 Application으로 점프한다.

#### 구조 예시

```
+----------------------------------+
| Bootloader (UART Command Parser) |
|  - "UPDATE" 수신 → Flash Write   |
|  - Timeout 발생 → App 실행       |
+----------------------------------+
| Application                      |
|  - 사용자 코드 실행              |
+----------------------------------+
```

#### 간단한 수신 루틴 예제

```
void Bootloader_Task(void)
{
    uint8_t cmd[8];
    HAL_UART_Receive(&huart1, cmd, 6, 2000);

    if (strncmp((char*)cmd, "UPDATE", 6) == 0)
    {
        Receive_Firmware_UART();
    }
    else
    {
        JumpToApplication();
    }
}
```

------

### USB DFU(Device Firmware Upgrade)

DFU는 **USB 표준 클래스(DFU Class)** 로 정의된 펌웨어 업데이트 방식이며, ST의 **DFU Bootloader** 또는 **DFU Mode가 포함된 사용자 부트로더**를 통해 수행할 수 있다.

#### DFU의 주요 특징

- 별도의 전용 핀 조작 없이 USB 연결만으로 업데이트 가능
- 펌웨어 파일(`.dfu` 형식)을 통해 Flash에 직접 기록
- STM32CubeProgrammer 또는 **DFUSe Demo Tool**로 제어 가능
- 애플리케이션에서 소프트웨어적으로 DFU 모드 진입 가능

#### DFU 펌웨어 형식

- `.dfu` 파일은 ST의 `DFU File Manager`를 통해 생성한다.
- 내부 구조는 다음과 같이 구성된다.

| 필드       | 설명                        |
| ---------- | --------------------------- |
| DFU Prefix | ‘DfuSe’ 헤더                |
| Target     | Flash Address 및 크기 정보  |
| Image      | 실제 펌웨어 바이너리 데이터 |
| CRC        | 데이터 무결성 검증용        |

#### DFU 업데이트 절차

1. STM32를 **BOOT0=1** 상태로 리셋 → System Bootloader 진입
2. PC에서 **STM32CubeProgrammer** 또는 **DFUSe Demo** 실행
3. “USB” 인터페이스 선택
4. `.dfu` 파일 지정 후 “Download” 실행
5. 완료 후 BOOT0=0 → 리셋

------

### 소프트웨어 기반 DFU 진입

DFU 모드 진입을 위해 항상 BOOT 핀을 물리적으로 조작할 필요는 없다.
 애플리케이션 내부에서 System Memory로 직접 점프하는 방식으로 구현 가능하다.

#### 예제 코드

```
#define SYSTEM_MEMORY_ADDRESS  0x1FFFF000  // MCU 모델에 따라 다름

void JumpToSystemBootloader(void)
{
    typedef void (*pFunction)(void);
    uint32_t sysMemAddr = SYSTEM_MEMORY_ADDRESS;

    __disable_irq();
    __set_MSP(*(uint32_t*)sysMemAddr);
    pFunction SysMemBootJump = (pFunction)*(uint32_t*)(sysMemAddr + 4);
    SysMemBootJump();
}
```

이 함수를 호출하면 MCU는 USB DFU 모드로 진입하며, PC에서 DFU 장치로 인식된다.

------

### 사용자 정의 DFU 부트로더 설계

내장 DFU 대신 **사용자 부트로더에 DFU Class 구현**도 가능하다.
 STM32CubeMX의 **USB Device → Communication Device → DFU Class** 구성을 통해 생성할 수 있으며,
 `usbd_dfu_if.c` 파일에서 Flash 쓰기/삭제 루틴을 HAL API로 직접 구현한다.

#### DFU 인터페이스 구조

| 함수             | 역할                  |
| ---------------- | --------------------- |
| `DFU_Init()`     | DFU 환경 초기화       |
| `DFU_Erase()`    | 지정 주소 영역 Erase  |
| `DFU_Write()`    | Flash Write           |
| `DFU_Read()`     | Flash Read            |
| `DFU_Manifest()` | 다운로드 완료 후 실행 |

------

### UART vs USB DFU 비교

| 구분              | UART                         | USB DFU                    |
| ----------------- | ---------------------------- | -------------------------- |
| 속도              | 115200bps 수준               | 최대 12Mbps (Full-Speed)   |
| 하드웨어 연결     | USB-UART 필요                | USB Micro/Type-C 직결      |
| 지원 도구         | CubeProgrammer, Flash Loader | CubeProgrammer, DFUSe Demo |
| 펌웨어 포맷       | .bin                         | .dfu                       |
| 내장 지원 여부    | 전 시리즈 공통               | 일부 MCU 전용              |
| 사용자 인터페이스 | 단순, 범용                   | 속도 빠름, 설정 복잡       |

------

### 안정적 업데이트 설계 고려사항

- **전원 유지**: 업데이트 중 전원 손실 시 Flash 손상 방지 회로 설계 필요
- **CRC / Signature 검증**: 수신 완료 후 무결성 확인 필수
- **이중 이미지 구조**: 업데이트 실패 시 기존 펌웨어 복구
- **Watchdog 관리**: 부트로더 구간에서는 Watchdog 정지 또는 리셋 관리 필요
- **USB DFU PID/VID**: 커스텀 DFU 구현 시 올바른 PID/VID 등록 필요

------

### 요약

- **UART** 부트로더는 단순하고 범용성이 높으며 대부분의 STM32 시리즈에서 사용 가능하다.
- **USB DFU** 부트로더는 빠르고 편리한 업그레이드를 제공하지만 MCU가 DFU Class를 지원해야 한다.
- 펌웨어 업데이트 루틴은 CRC 검증, Flash 보호, 점프 절차를 반드시 포함해야 한다.
- 실무에서는 **UART 기반 기본 부트로더 + USB DFU 확장 지원 구조**가 가장 보편적이다.

## 20.4 OTA 펌웨어 업데이트 구조

### 개요

OTA(Over-The-Air) 펌웨어 업데이트는 유선 연결 없이 무선 통신(Wi-Fi, BLE, LTE 등)을 통해 MCU의 펌웨어를 원격으로 업데이트하는 기술이다. 이 방식은 현장 장비의 유지보수 비용을 줄이고, 실시간으로 기능 개선이나 보안 패치를 배포할 수 있다는 장점이 있다. STM32 기반 시스템에서는 주로 **ESP8266/ESP32 Wi-Fi 모듈** 또는 **BLE 모듈(HM-10, nRF52 등)**을 통해 OTA 업데이트를 수행한다.

------

### OTA 업데이트 구조 개요

OTA 업데이트는 일반적으로 다음의 단계로 구성된다.

1. **네트워크 연결**
    MCU 또는 외부 통신 모듈이 서버와 연결 (Wi-Fi / BLE / GSM 등)
    → 펌웨어 파일 다운로드를 위한 통신 채널 확보
2. **업데이트 파일 수신**
    서버에서 펌웨어 바이너리(`.bin`)를 전송받아 MCU의 Flash 중 **임시 저장 영역(Secondary Bank)**에 저장
    → UART, SPI, I²C, Wi-Fi 등 다양한 인터페이스를 사용 가능
3. **무결성 검증 (Checksum / CRC / SHA)**
    수신된 펌웨어의 데이터 무결성 검증 수행
    → CRC32, MD5, SHA256 등을 이용하여 손상 여부 확인
4. **부트로더 전환**
    기존 애플리케이션이 부트로더로 제어를 넘겨 업데이트 수행
    → 부트로더는 새로운 펌웨어를 Application 영역으로 복사
5. **플래시 갱신 및 리부팅**
    Flash Erase → Write 순서로 신규 펌웨어 기록
    → 완료 후 MCU 리셋 및 신규 펌웨어 실행

------

### OTA 메모리 구조 예시

| 구분          | 주소 범위               | 크기   | 설명                           |
| ------------- | ----------------------- | ------ | ------------------------------ |
| Bootloader    | 0x08000000 ~ 0x08003FFF | 16 KB  | OTA 및 업데이트 제어 코드      |
| App Slot #1   | 0x08004000 ~ 0x0801FFFF | 112 KB | 현재 실행 중인 애플리케이션    |
| App Slot #2   | 0x08020000 ~ 0x0803BFFF | 112 KB | 다운로드 받은 신규 펌웨어 저장 |
| EEPROM / Data | 0x0803C000 ~ 0x0803FFFF | 16 KB  | 설정값, Checksum 저장 영역     |

------

### OTA 펌웨어 다운로드 흐름 (Wi-Fi 예시)

1. ESP8266이 Wi-Fi 연결 및 HTTP 요청 수행
2. 서버에서 최신 펌웨어 버전 정보 확인 (`version.json`)
3. 신규 버전 발견 시 펌웨어 파일(`firmware_v2.1.bin`) 다운로드
4. MCU로 UART 전송
5. MCU 부트로더가 수신 데이터를 Flash 임시 영역에 저장
6. 완료 후 CRC 검증 → 성공 시 App 영역에 복사 → 재부팅

------

### BLE 기반 OTA 흐름

1. BLE Central(스마트폰 앱)이 최신 펌웨어를 BLE 패킷으로 전송
2. Peripheral(STM32)이 수신 데이터를 Flash에 순차 저장
3. CRC 검증 후 업데이트 승인
4. 부트로더에서 기존 펌웨어 삭제 및 신규 펌웨어 복사
5. 리부팅 및 정상 동작 확인

------

### 무결성 및 보안 고려 사항

- **암호화 전송**: HTTPS, AES 암호화 등으로 펌웨어 파일 보호
- **서명 검증**: RSA/ECDSA 기반 서명 검증으로 위조 방지
- **롤백 보호**: 이전 버전 펌웨어로의 강제 복귀 방지 로직 구현
- **CRC/SHA 검증**: Flash Write 전후로 데이터 무결성 검증

------

### STM32 예시 코드 구조 (의사 코드)

```
void OTA_Update_Process(void) {
    if (OTA_CheckForNewFirmware()) {
        OTA_DownloadFirmware();
        if (OTA_VerifyIntegrity()) {
            Bootloader_RequestUpdate();
        }
    }
}
```

부트로더 측:

```
void Bootloader_Main(void) {
    if (Check_UpdateFlag()) {
        Flash_Erase(APP_AREA);
        Flash_Copy(OTA_AREA, APP_AREA, FW_SIZE);
        Verify_NewFirmware();
    }
    JumpToApplication();
}
```

------

### 실습 예제 구성

- **실습 보드**: STM32F103C8T6 + ESP8266 Wi-Fi 모듈
- **통신 인터페이스**: UART2 (TX/RX)
- **서버 구성**: Python Flask 기반 HTTP 서버
- **펌웨어 파일 예시**: `/firmware/firmware_v1.1.bin`
- **검증 방식**: CRC32 + 버전 비교 (`version.txt`)

------

### 고급 주제

- **이중 펌웨어 구조 (Dual-Bank Flash)** 활용
- **OTA 실패 시 자동 롤백 메커니즘**
- **펌웨어 다운로드 중 전원 차단 대응**
- **FATFS 기반 펌웨어 저장 및 업데이트 병행**
- **MQTT 기반 OTA 분산 업데이트 (IoT 클러스터용)**

## 20.5 Boot Flag / Version 관리

### 개요

Boot Flag와 Version 관리는 부트로더 기반 시스템에서 **펌웨어의 상태, 실행 대상, 업데이트 여부**를 구분하기 위한 핵심 메커니즘이다.
 OTA나 DFU 같은 업데이트 방식에서는, 부트로더가 단순히 “어떤 코드로 점프할지”를 판단하기 위해 **Flash의 특정 영역(메타데이터)**을 이용한다.
 이 영역에는 펌웨어 버전, 무결성 정보, 업데이트 플래그, 상태 코드 등이 기록된다.

------

### Boot Flag의 역할

Boot Flag는 MCU가 부팅 시 어떤 영역(App Slot #1 / #2)을 실행할지를 결정하기 위한 플래그이다.
 다음은 일반적으로 사용되는 Boot Flag 구조 예시이다.

| 필드            | 크기(Byte) | 설명                                                 |
| --------------- | ---------- | ---------------------------------------------------- |
| `BOOT_FLAG`     | 4          | 0xA5A5A5A5: 정상 실행, 0x5A5A5A5A: 업데이트 요청     |
| `UPDATE_STATUS` | 1          | 0: 없음, 1: 수신 중, 2: 완료 대기                    |
| `APP_VALID`     | 1          | 0: 무효, 1: 유효                                     |
| `CRC32`         | 4          | 펌웨어 무결성 검증용 CRC                             |
| `APP_VERSION`   | 4          | 현재 실행 중인 펌웨어 버전 (예: 0x00010200 → v1.2.0) |

------

### Boot Flag 저장 위치

Boot Flag는 Flash 상의 별도 페이지나 EEPROM에 저장한다.
 다음은 STM32F103C8T6 기준의 예시이다.

| 항목        | 주소       | 용도                                   |
| ----------- | ---------- | -------------------------------------- |
| Bootloader  | 0x08000000 | 부트로더 코드 영역                     |
| App Slot #1 | 0x08004000 | 정상 실행 펌웨어                       |
| App Slot #2 | 0x08020000 | OTA 임시 저장 영역                     |
| Boot Flag   | 0x0803FC00 | 플래그 및 버전 정보 저장 (마지막 섹터) |

Flash의 마지막 섹터(혹은 Page)는 일반적으로 설정 데이터 및 메타정보를 저장하는 데 사용된다.

------

### 부트로더 동작 흐름 예시

```
void Bootloader_Main(void)
{
    BootInfo info = ReadBootInfo();

    if (info.BOOT_FLAG == BOOT_FLAG_UPDATE) {
        if (VerifyFirmware(APP_SLOT_2)) {
            CopyFirmware(APP_SLOT_2, APP_SLOT_1);
            UpdateBootFlag(BOOT_FLAG_RUN);
        } else {
            UpdateBootFlag(BOOT_FLAG_RUN); // 오류 시 기존 앱으로 복귀
        }
    }

    if (VerifyFirmware(APP_SLOT_1)) {
        JumpToApplication(APP_SLOT_1);
    } else {
        System_Reset(); // 비정상 시 재부팅
    }
}
```

이 흐름을 통해 시스템은 OTA나 DFU 중단, 손상 등 비정상 상황에서도 자동 복구가 가능하다.

------

### Version 관리 구조

Version 관리의 목적은 현재 MCU 내부의 펌웨어 버전과 서버 혹은 외부 저장소의 버전을 비교하여
 **업데이트 필요 여부**를 결정하는 것이다.

| 필드         | 설명                              | 예시       |
| ------------ | --------------------------------- | ---------- |
| `MAJOR`      | 주요 기능 단위 변경 (비호환 가능) | 1          |
| `MINOR`      | 기능 추가 또는 개선               | 3          |
| `PATCH`      | 버그 수정, 미세 변경              | 2          |
| `BUILD_DATE` | 빌드 시각 정보                    | 20251111   |
| `CRC`        | 펌웨어 데이터 검증용              | 0xF2A43C1D |

버전 정보는 헤더(`version.h`) 또는 Flash 상의 고정 오프셋에 저장된다.

------

### Version 비교 알고리즘 예시

```
bool CheckForUpdate(uint32_t localVersion, uint32_t remoteVersion)
{
    return (remoteVersion > localVersion);
}
```

혹은 세부 필드를 비교할 수도 있다.

```
if (major_remote > major_local) update = true;
else if (major_remote == major_local && minor_remote > minor_local) update = true;
else if (minor_remote == minor_local && patch_remote > patch_local) update = true;
```

------

### Boot Flag 갱신 절차

1. **업데이트 시작 시**
   - `BOOT_FLAG = UPDATE_REQUESTED`
   - `UPDATE_STATUS = RECEIVING`
2. **펌웨어 수신 완료 후**
   - `UPDATE_STATUS = READY_TO_APPLY`
   - `CRC = calculate_crc32(new_firmware)`
3. **부트로더 실행 후 정상 복사 완료 시**
   - `BOOT_FLAG = RUN_NORMAL`
   - `APP_VALID = 1`
   - `APP_VERSION` 업데이트
4. **무결성 실패 시**
   - `APP_VALID = 0`
   - 이전 Slot으로 롤백

------

### Version 정보의 유지 및 표시

- **시리얼 콘솔 출력 예시**

  ```
  Bootloader v1.0.3
  App Version: 1.2.4
  Update Flag: 0xA5A5A5A5
  CRC32: OK
  ```

- **FATFS / Config 파일 동기화**

  - `/version.txt`에 현재 펌웨어 버전 기록
  - OTA 서버의 `latest_version.txt`와 비교

------

### 실습 예시

- **환경**: STM32F103 + ESP8266 OTA 구조
- **Boot Flag 저장 위치**: Flash Page 63 (0x0803FC00)
- **테스트 시나리오**
  1. App v1.0 실행 중
  2. ESP8266이 서버의 v1.1.bin 감지
  3. `BOOT_FLAG`를 `UPDATE_REQUESTED`로 설정
  4. OTA 완료 후 Bootloader에서 복사 수행
  5. 정상 부팅 및 `APP_VERSION = 0x00010100` 적용 확인

------

### 추가 고려사항

- Flash 쓰기 시 전원 차단 대응
- Boot Flag 영역 이중화(Primary/Backup)
- Version Rollback 보호(Older firmware 차단)
- CRC/SHA256 기반의 펌웨어 검증

------

### 요약

| 항목           | 역할                                 |
| -------------- | ------------------------------------ |
| Boot Flag      | 실행/업데이트 상태를 나타내는 플래그 |
| Version Info   | 펌웨어의 버전 및 무결성 정보         |
| Flash Metadata | 부트로더 판단의 근거 데이터 저장     |
| 자동 복구      | 업데이트 실패 시 이전 앱 복귀        |
| 무결성 검증    | CRC/SHA를 통한 신뢰성 확보           |