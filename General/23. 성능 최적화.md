# 23. 성능 최적화

## 23.1 코드 사이즈 및 속도 측정

임베디드 시스템 개발에서는 프로그램의 **코드 크기(Code Size)** 와 **실행 속도(Performance)** 를 정확히 측정하고 최적화하는 과정이 매우 중요하다. STM32CubeIDE는 GCC Toolchain 기반이므로, 빌드 결과물 분석 및 성능 계측에 필요한 다양한 도구와 지표를 제공한다. 이 절에서는 코드 메모리 점유 분석, 실행 시간 측정, 최적화 옵션에 따른 성능 비교 방법을 다룬다.

------

### 코드 사이즈 분석

#### 빌드 결과 요약 확인

STM32CubeIDE 빌드 후 콘솔에 다음과 같은 메모리 사용 요약이 출력된다.

```
   text	   data	    bss	    dec	    hex	filename
  18256	    128	   1024	  19308	   4b6c	build/firmware.elf
```

- **text**: 코드 영역 (Flash)
- **data**: 초기화된 전역/정적 변수 (RAM)
- **bss**: 초기화되지 않은 전역/정적 변수 (RAM)
- **dec / hex**: 전체 메모리 사용량 (10진/16진)

이를 통해 Flash 및 SRAM 사용량을 대략적으로 확인할 수 있다.

#### 세부 메모리 점유 분석 (`arm-none-eabi-size`, `arm-none-eabi-nm`)

1. 명령행에서 다음을 실행:

   ```
   arm-none-eabi-size build/firmware.elf
   ```

2. 심볼 단위 분석:

   ```
   arm-none-eabi-nm --print-size --size-sort --radix=d build/firmware.elf | tail -20
   ```

   → 함수별 코드 크기를 확인하여 메모리 집중 구간 파악 가능.

#### CubeIDE 내부 메모리 분석 뷰

- **Window → Show View → Memory Details**
- ELF 파일의 섹션별(Flash, RAM) 점유 현황 시각화
- `.text`, `.data`, `.bss`, `.heap`, `.stack` 구분 확인

------

### 실행 시간 측정

#### 1. DWT 사이클 카운터 이용

Cortex-M3 이상 MCU는 **DWT(Data Watchpoint and Trace)** 하드웨어 카운터를 통해 정확한 실행 시간을 측정할 수 있다.

```
#include "core_cm3.h"

void DWT_Init(void)
{
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // DWT Enable
    DWT->CYCCNT = 0;                                // Reset counter
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;            // Start counter
}

uint32_t DWT_GetCycles(void)
{
    return DWT->CYCCNT;
}
```

사용 예:

```
DWT_Init();
uint32_t start = DWT_GetCycles();
MyFunction();
uint32_t elapsed = DWT_GetCycles() - start;
printf("Cycles: %lu, Time: %.3fus\n", elapsed, (float)elapsed / (SystemCoreClock / 1e6));
```

→ **CPU 주파수에 기반한 실측 시간 계산 가능**

#### 2. SysTick 타이머 기반 측정

간단한 측정에는 `HAL_GetTick()` 또는 `micros()` (FreeRTOS 환경에서는 `xTaskGetTickCount()`)을 사용.
 단, 1ms 단위 해상도이므로 짧은 구간 측정에는 부적합하다.

------

### 성능 시각화 도구

#### ITM / SWO Trace

- **ITM Stimulus Port**를 통해 함수 실행 시간, 주기, 이벤트 로그를 실시간으로 분석 가능
- CubeIDE:
  - **Debug Configurations → SWV → Enable SWO Trace**
  - **Window → Show View → SWV → Timeline Graph / Statistical Function Profiling**

#### gprof / perf 유사 분석 (임베디드용)

- `-pg` 옵션으로 프로파일링 빌드 가능 (일부 STM32 시리즈 한정)
- 실행 후 gmon.out을 추출하여 PC에서 gprof 분석 수행

------

### 최적화 옵션 비교

#### 컴파일러 최적화 레벨

| 옵션  | 설명             | 특성                             |
| ----- | ---------------- | -------------------------------- |
| `-O0` | 최적화 없음      | 디버깅 용이, 실행 속도 느림      |
| `-O1` | 기본 최적화      | 불필요 코드 제거                 |
| `-O2` | 일반 성능 최적화 | 대부분의 프로젝트에 권장         |
| `-O3` | 고도 최적화      | 빠른 실행, 코드 사이즈 증가 가능 |
| `-Os` | 코드 크기 최소화 | Flash 제한이 있는 경우 적합      |

#### CubeIDE 설정 경로

**Project → Properties → C/C++ Build → Settings → Tool Settings → MCU GCC Compiler → Optimization**

→ 각 레벨별로 `.text` 크기와 실행 시간 비교 그래프를 작성하여 최적 지점을 결정할 수 있다.

------

### 실행 속도 측정 실습

#### 예제: ADC 변환 및 UART 전송 성능 측정

```
DWT_Init();
uint32_t start = DWT_GetCycles();

HAL_ADC_Start(&hadc1);
HAL_ADC_PollForConversion(&hadc1, 10);
uint16_t value = HAL_ADC_GetValue(&hadc1);
HAL_UART_Transmit(&huart1, (uint8_t*)&value, 2, 10);

uint32_t elapsed = DWT_GetCycles() - start;
float time_us = (float)elapsed / (SystemCoreClock / 1e6);
printf("Elapsed: %.2f us\n", time_us);
```

- 결과를 UART로 출력하여 각 함수의 평균 실행 시간을 비교
- DMA 사용 시 속도 향상율을 측정

------

### 자동화된 측정

#### 스크립트 기반 빌드 사이즈 로깅

```
arm-none-eabi-size build/firmware.elf >> build_log.txt
```

→ Git CI 또는 Jenkins 파이프라인에서 자동으로 기록

#### Performance Regression Test

- 동일 입력 조건에서 실행 시간을 로그로 저장
- 이전 빌드 대비 성능 변화율(%) 계산

------

### 분석 보고서 예시

| 측정 항목            | -O0    | -O2    | -Os    | 비고       |
| -------------------- | ------ | ------ | ------ | ---------- |
| Flash 사용량 (bytes) | 38,452 | 28,930 | 26,784 | `-Os` 최소 |
| 평균 실행 시간 (µs)  | 312    | 145    | 160    | `-O2` 최고 |
| 실행 속도 향상율     | -      | +115%  | +95%   | 기준: -O0  |

------

### 주의 사항

- DWT, ITM은 일부 저가형 MCU(F0/G0)에서는 지원되지 않음.
- 인터럽트나 RTOS Task 전환 시에는 정확한 측정이 어려움.
- DMA 전송 등 비동기 동작은 **완료 콜백 시점 기준으로 측정**해야 함.
- 최적화에 따른 변수 제거로 인해 디버깅이 어려워질 수 있음.

------

### 참고

- ARM Cortex-M Technical Reference Manual – DWT/ITM
- ST Application Note AN4838 (Code Size Optimization)
- GNU Arm Embedded Toolchain User Guide
- STM32CubeIDE User Guide – SWV Trace & Profiling

## 23.2 HAL vs LL vs Register 성능 비교

STM32에서 동일한 주변장치를 제어하더라도 **HAL (Hardware Abstraction Layer)**, **LL (Low-Layer API)**, **Register 직접 접근 방식**의 선택에 따라 코드 크기, 실행 속도, 제어 세밀도가 크게 달라진다. 이 절에서는 세 접근 방식의 구조적 차이, 실행 효율, 코드 메모리 점유, 실시간 응답성을 중심으로 비교한다.

------

### HAL / LL / Register 접근 구조

| 구분         | 계층 구조          | 주요 목적              | 코드 복잡도 | 속도      | 유지보수성 |
| ------------ | ------------------ | ---------------------- | ----------- | --------- | ---------- |
| **HAL**      | 상위 추상화 계층   | 호환성, 가독성, 표준화 | 낮음        | 느림      | 높음       |
| **LL**       | 하위 추상화 계층   | 성능, 직접 제어        | 중간        | 빠름      | 중간       |
| **Register** | 레지스터 직접 접근 | 최대 성능, 세밀 제어   | 높음        | 매우 빠름 | 낮음       |

HAL은 코드 이식성과 구조적 안정성에 강점이 있고, LL과 Register는 성능과 자원 효율에 강점을 가진다.

------

### HAL (Hardware Abstraction Layer)

HAL은 STM32Cube HAL 드라이버에서 제공하는 **고수준 함수 API**로, 대부분의 초기화 및 주변장치 제어를 캡슐화한다.

```
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
```

- **장점**
  - 코드 가독성 및 유지보수성 우수
  - Peripheral Clock Enable, Mode 설정 등 자동 처리
  - STM32 시리즈 간 코드 이식성 높음
- **단점**
  - 다단계 함수 호출로 인한 오버헤드 발생
  - 속도 저하 (함수 내 조건문, 검증 코드 다수)
  - 코드 크기 증가

#### 예시: HAL GPIO 토글 실행 흐름

```
HAL_GPIO_TogglePin()
 └─ Read ODR
 └─ Toggle Bit
 └─ Write ODR
```

→ 10여 개의 명령어와 함수 호출을 거침

------

### LL (Low-Layer API)

LL 드라이버는 HAL보다 한 단계 낮은 **레지스터 접근 매크로 기반 API**를 제공한다. HAL보다 빠르고 가벼우며, 하드웨어 제어에 근접한다.

```
LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_5);
```

- **장점**
  - 실행 속도 HAL 대비 약 3~10배 향상
  - 코드 크기 절감 (함수 호출 최소화)
  - 인라인(inline) 처리로 오버헤드 없음
  - 직접 레지스터 접근과 동일한 시퀀스 구현 가능
- **단점**
  - 이식성 및 자동화 지원 낮음
  - 초기화 과정은 여전히 수동 구성 필요

#### 예시: LL GPIO 토글

```
LL_GPIO_TogglePin(GPIOA, LL_GPIO_PIN_5);
```

→ 단일 인라인 매크로로 처리되어 CPU 클럭 사이클 소모 최소화

------

### Register 직접 접근

레지스터 구조체를 직접 조작하여 하드웨어를 제어하는 방식이다.
 최고 속도와 제어 세밀도를 제공하나, 유지보수가 가장 어렵다.

```
GPIOA->BSRR = (1 << 5);   // 핀 세트
GPIOA->BRR  = (1 << 5);   // 핀 리셋
```

- **장점**
  - 최소 명령어 경로 → 최고 성능
  - 모든 하드웨어 레벨 동작에 접근 가능
  - 타이밍 제어 및 고속 응답 필수 구간에 적합
- **단점**
  - 코드 가독성 및 이식성 저하
  - Peripheral 클럭 설정 및 초기화 직접 관리 필요
  - 레지스터 비트 정의를 잘못 다룰 경우 버그 발생

------

### 성능 비교 실험

#### 실험 조건

- MCU: STM32F103C8T6 (72 MHz)
- 측정 항목: **GPIO Toggle 주기**, **코드 크기(text)**, **CPU 사이클 수**
- 측정 방법: DWT 사이클 카운터

| 방식     | 평균 토글 주기 (ns) | CPU 사이클 | 코드 크기 (bytes) |
| -------- | ------------------- | ---------- | ----------------- |
| HAL      | 1050                | 약 75      | 1,900             |
| LL       | 210                 | 약 15      | 380               |
| Register | 140                 | 약 10      | 220               |

- Register 직접 접근 시 HAL 대비 약 **7.5배 빠름**, 코드 크기 **약 88% 감소**
- LL은 성능과 유지보수성의 절충점으로, 대부분의 실시간 제어에 적합

------

### 내부 실행 경로 비교

#### HAL GPIO Toggle (단순화된 Call Stack)

```
HAL_GPIO_TogglePin()
 ├─ assert_param()
 ├─ GPIOx->ODR ^= GPIO_Pin
 └─ 기타 상태 검증
```

#### LL GPIO Toggle

```
#define LL_GPIO_TogglePin(PORT, PIN) ((PORT)->ODR ^= (PIN))
```

#### Register 직접 접근

```
GPIOA->ODR ^= (1 << 5);
```

HAL은 매 함수 호출마다 내부 검증 및 파라미터 체크를 수행하며,
 LL은 인라인 매크로를 통해 바로 레지스터 접근, Register 접근은 완전 직접 처리.

------

### 코드 예시 비교

#### HAL 방식

```
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
```

#### LL 방식

```
LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_5);
```

#### Register 방식

```
GPIOA->BSRR = (1 << 5);
```

실행 시 HAL은 함수 호출 스택 3~4단계를 거치지만 LL 및 Register는 단일 명령으로 수행된다.

------

### 속도 차이가 중요한 사례

| 사용 사례                              | 권장 방식        | 이유                          |
| -------------------------------------- | ---------------- | ----------------------------- |
| 센서 Polling / GPIO Blink              | HAL              | 코드 단순, 실시간성 요구 낮음 |
| PWM, ADC DMA, SPI 통신                 | LL               | 성능/응답 속도 중요           |
| 고속 디지털 제어 (PID, Motor PWM Sync) | Register         | 사이클 단위 제어 필요         |
| FreeRTOS Task 내 하드 리얼타임 처리    | LL 또는 Register | Context Switching 손실 최소화 |

------

### 코드 크기 및 최적화 결과

| 빌드 설정       | HAL     | LL      | Register |
| --------------- | ------- | ------- | -------- |
| 코드 크기 (-O0) | 46.2 KB | 28.5 KB | 27.8 KB  |
| 코드 크기 (-Os) | 38.4 KB | 21.2 KB | 20.9 KB  |
| 평균 실행 속도  | 1.0×    | 3.6×    | 5.4×     |

- HAL은 코드 구조가 복잡하여 최적화 효과가 낮다.
- LL과 Register 접근은 최적화 시에도 대부분의 코어 실행 경로를 그대로 유지.

------

### 결론

| 항목                    | HAL   | LL    | Register |
| ----------------------- | ----- | ----- | -------- |
| 개발 속도               | ★★★★★ | ★★★★☆ | ★★☆☆☆    |
| 성능 (속도/메모리 효율) | ★★☆☆☆ | ★★★★☆ | ★★★★★    |
| 유지보수성              | ★★★★★ | ★★★☆☆ | ★★☆☆☆    |
| 코드 이식성             | ★★★★★ | ★★★☆☆ | ★☆☆☆☆    |
| 실시간 제어 적합성      | ★★☆☆☆ | ★★★★☆ | ★★★★★    |

- **HAL**: 교육용, 이식성 중심, 표준 개발 템플릿에 적합
- **LL**: 실시간 응답이 필요한 산업용/RTOS 기반 프로젝트에 권장
- **Register**: 제한된 리소스 또는 하드 실시간 제어 환경에 최적

------

### 참고 문서

- STMicroelectronics AN4899 – STM32Cube Firmware Architecture
- STM32 HAL/LL API Reference Manual
- ARM Cortex-M3 Technical Reference Manual (Bit-banding, GPIO timing)
- GCC Optimization for Embedded C

## 23.3 DMA + Interrupt 최적화

DMA(Direct Memory Access)는 CPU 개입 없이 주변장치와 메모리 간 데이터를 전송하는 기능으로, 인터럽트와 조합하면 **실시간 성능 향상**과 **CPU 부하 감소**를 동시에 달성할 수 있다.
 이 절에서는 STM32 HAL/LL 기반에서 DMA와 인터럽트를 결합하여 최적화하는 방법, 버스 대역폭 효율, 동시 전송 시 유의사항, 고성능 설계 기법 등을 다룬다.

------

### DMA 동작 개요

DMA는 주변장치(Peripheral)와 메모리 간 데이터 전송을 CPU 명령 없이 수행한다.
 STM32의 DMA 컨트롤러는 다음 세 가지 전송 모드를 지원한다.

| 모드                     | 설명              | 사용 예시                  |
| ------------------------ | ----------------- | -------------------------- |
| **Memory-to-Peripheral** | 메모리 → 주변장치 | UART Tx, DAC 출력          |
| **Peripheral-to-Memory** | 주변장치 → 메모리 | ADC 변환값 수집            |
| **Memory-to-Memory**     | 메모리 ↔ 메모리   | 버퍼 복사, FFT 데이터 준비 |

DMA 전송이 완료되면 **Interrupt** 또는 **Polling Flag**를 통해 CPU에 알려준다.

------

### DMA + Interrupt 구조

DMA의 효율을 극대화하기 위해서는 다음 3가지 인터럽트를 적절히 활용해야 한다.

| 인터럽트                   | 의미                  | 용도                                 |
| -------------------------- | --------------------- | ------------------------------------ |
| **TC (Transfer Complete)** | 전체 블록 전송 완료   | 메인 루프에 결과 전달                |
| **HT (Half Transfer)**     | 버퍼의 절반 전송 완료 | Circular Buffer 모드에서 실시간 처리 |
| **TE (Transfer Error)**    | 전송 중 에러 발생     | 예외 처리 및 복구 루틴 수행          |

------

### HAL 기반 DMA + Interrupt 설정 예제

#### 1. DMA 초기화

```
void MX_DMA_Init(void)
{
    __HAL_RCC_DMA1_CLK_ENABLE();

    HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
}
```

#### 2. ADC DMA 설정

```
HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adcBuffer, ADC_BUF_SIZE);
```

#### 3. DMA 인터럽트 콜백

```
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    dataReadyFlag = 1;  // 변환 완료 시 처리 플래그
}

void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
{
    processHalfBuffer = 1; // 버퍼 절반 처리
}
```

→ CPU는 ADC 변환 및 DMA 전송이 완료될 때만 인터럽트에 반응하므로, 폴링 대비 부하가 90% 이상 감소한다.

------

### LL 기반 DMA 최적화

LL 드라이버를 사용하면 DMA의 모든 동작을 세밀하게 제어할 수 있다.

```
LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_1,
                       LL_ADC_DMA_GetRegAddr(ADC1, LL_ADC_DMA_REG_DATA),
                       (uint32_t)&adcBuffer,
                       LL_DMA_DIRECTION_PERIPH_TO_MEMORY);

LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_1, ADC_BUF_SIZE);
LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_1);
LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_1);
```

인터럽트 핸들러:

```
void DMA1_Channel1_IRQHandler(void)
{
    if (LL_DMA_IsActiveFlag_TC1(DMA1)) {
        LL_DMA_ClearFlag_TC1(DMA1);
        dataReadyFlag = 1;
    }
}
```

LL은 HAL보다 약 2~3배 빠른 응답 속도를 제공하며, 중첩 인터럽트 환경에서도 안정적이다.

------

### Circular Buffer + DMA + Interrupt 구조

대용량 데이터를 실시간으로 수집할 때 가장 효율적인 구조는 **Circular DMA + Half Transfer Interrupt** 조합이다.

#### 개념도

```
┌─────────────── Buffer ───────────────┐
│<---- Half A ---->|<---- Half B ----> │
│  DMA 채움 중      |  CPU 처리 중       │
│  CPU 처리 중      |  DMA 채움 중       │
└──────────────────────────────────────┘
```

DMA는 버퍼의 절반이 찼을 때 HT 인터럽트를 발생시키고, CPU는 해당 절반의 데이터를 처리한다.
 나머지 절반은 DMA가 채우므로 **데이터 손실 없이 실시간 처리**가 가능하다.

#### 예제: ADC + DMA + Half Callback

```
#define BUF_SIZE 128
uint16_t adcBuf[BUF_SIZE];

void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc) {
    ProcessData(&adcBuf[0], BUF_SIZE/2);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
    ProcessData(&adcBuf[BUF_SIZE/2], BUF_SIZE/2);
}
```

→ 버퍼 절반 단위로 교차 처리하여 CPU와 DMA가 병렬로 동작

------

### DMA + Interrupt 최적화 포인트

#### 1. 인터럽트 우선순위 조정

DMA 인터럽트는 실시간 처리가 필요한 경우 **ADC, Timer보다 높은 우선순위**로 설정해야 한다.

```
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 1, 0);
```

#### 2. 불필요한 HAL Callback 최소화

- `HAL_DMA_IRQHandler()` 내부는 다양한 체크 루틴이 포함되어 느리다.
- LL 또는 직접 Flag 기반 처리로 불필요한 오버헤드 제거

#### 3. Cache Flush / Memory Barrier

Cortex-M7 이상 MCU에서는 DMA 완료 후 Cache invalidation 필요:

```
SCB_InvalidateDCache_by_Addr((uint32_t *)adcBuf, sizeof(adcBuf));
```

#### 4. Non-blocking 통신 결합

UART, SPI 등의 전송도 DMA + Interrupt 기반으로 구성 시 CPU 부하 최소화

```
HAL_UART_Transmit_DMA(&huart1, txBuf, len);
```

------

### 성능 비교

| 전송 방식                  | CPU 사용률 | 평균 처리 속도 | 데이터 유실률 | 코드 복잡도 |
| -------------------------- | ---------- | -------------- | ------------- | ----------- |
| Polling                    | 82%        | 1.0×           | 낮음          | 낮음        |
| Interrupt                  | 35%        | 1.8×           | 낮음          | 중간        |
| DMA                        | 12%        | 4.5×           | 매우 낮음     | 중간        |
| DMA + Interrupt (Circular) | 8%         | 5.2×           | 0%            | 높음        |

- DMA와 인터럽트를 병행하면 CPU는 주로 데이터 처리에 집중하고, 입출력은 하드웨어가 담당.
- **CPU Idle 시간 확보**, **전력 효율 향상**, **타이밍 안정성 증가** 효과를 얻을 수 있다.

------

### 고급 최적화 기법

#### Double Buffer DMA (Multi-buffer mode)

- 일부 STM32 시리즈(H7, F4 등)는 **Double Buffer Mode** 지원
- `HAL_DMAEx_MultiBufferStart()` 사용 시 완전한 이중 버퍼링 가능

```
HAL_DMAEx_MultiBufferStart(&hdma_adc1,
    (uint32_t)&ADC1->DR,
    (uint32_t)&adcBufA,
    (uint32_t)&adcBufB,
    BUF_SIZE);
```

→ HT/TC 인터럽트를 병행하여 완전 비동기 처리 구현

#### DMA Burst Mode (FIFO)

- AHB 버스 효율을 높이기 위해 Burst Size를 4/8/16 Word로 설정 가능
- FIFO 사용 시 Peripheral Access 횟수 감소

```
hdma.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
hdma.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
```

#### DMA + FreeRTOS Task 통합

- DMA 완료 인터럽트에서 `xTaskNotifyFromISR()`로 Task 동기화
   → RTOS 환경에서 데이터 처리 Task와 하드웨어 이벤트의 효율적 결합

------

### 디버깅 및 검증

- **CubeIDE SWV (ITM)**: DMA 인터럽트 발생 시점과 주기 시각화
- **Logic Analyzer**: DMA 완료 시점에 GPIO 토글 삽입 → 실시간 타이밍 측정
- **DWT Counter**: DMA Start ~ Complete 구간 측정

------

### 결론

| 항목        | Polling | Interrupt | DMA   | DMA + Interrupt |
| ----------- | ------- | --------- | ----- | --------------- |
| CPU 부하    | ★★★★★   | ★★★☆☆     | ★★☆☆☆ | ★☆☆☆☆           |
| 응답 속도   | ★★☆☆☆   | ★★★★☆     | ★★★★★ | ★★★★★           |
| 전력 효율   | ★★☆☆☆   | ★★★★☆     | ★★★★★ | ★★★★★           |
| 구현 난이도 | ★★☆☆☆   | ★★★☆☆     | ★★★☆☆ | ★★★★☆           |

DMA와 인터럽트를 병행하면,

- CPU는 데이터 전송 부담에서 해방되고,
- 시스템은 실시간 응답성과 에너지 효율을 모두 확보한다.

------

### 참고 문서

- STMicroelectronics AN4031 – Using the STM32 DMA Controller
- AN4666 – Optimizing MCU Performance with DMA
- STM32Cube HAL API Reference – DMA/ADC/UART
- ARM Cortex-M Technical Reference Manual – NVIC & Bus Matrix

## 23.4 Compiler Optimization Level (O0~O3)

컴파일러 최적화(Compiler Optimization)는 빌드 시 코드 실행 속도, 코드 크기, 전력 소비 등을 개선하기 위한 기법이다.
 STM32 CubeIDE(GCC 기반)에서는 `-O0`, `-O1`, `-O2`, `-O3`, `-Os` 등의 옵션으로 제어하며,
 각 수준은 **컴파일 속도 ↔ 실행 효율성** 사이의 트레이드오프를 가진다.

------

### 최적화 레벨 개요

| 최적화 레벨                      | 주요 특징                            | 장점                                    | 단점                             | 권장 사용 시점                        |
| -------------------------------- | ------------------------------------ | --------------------------------------- | -------------------------------- | ------------------------------------- |
| **O0 (No Optimization)**         | 최적화 없음. 모든 명령어 유지.       | 디버깅 용이, 예측 가능한 코드 흐름      | 실행 속도 가장 느림              | 초기 개발, 디버깅                     |
| **O1 (Optimize)**                | 기본 수준 최적화. 불필요한 코드 제거 | 실행 속도 개선, 디버그 가능성 일부 유지 | 약간의 디버그 어려움             | 테스트용, 기본 빌드                   |
| **O2 (High Optimization)**       | 대부분의 최적화 활성화               | 빠른 실행 속도, 코드 크기 감소          | 디버깅 어려움 증가               | 제품 릴리즈 빌드                      |
| **O3 (Aggressive Optimization)** | 고급 루프, 파이프라인 최적화         | 최고 속도, 인라인 확장 적극적           | 코드 크기 증가, 부작용 발생 가능 | 고성능 연산 중심 (DSP, 제어 알고리즘) |
| **Os (Optimize for Size)**       | 코드 크기 최소화                     | Flash 용량 절약                         | 약간 느림                        | 메모리 제약 시스템                    |

------

### 옵션별 내부 최적화 항목

| 항목                      | O0   | O1        | O2   | O3        | Os        |
| ------------------------- | ---- | --------- | ---- | --------- | --------- |
| Dead Code 제거            | ❌    | ✅         | ✅    | ✅         | ✅         |
| Loop Unrolling            | ❌    | ❌         | ✅    | ✅         | ❌         |
| Function Inlining         | ❌    | ✅(선별적) | ✅    | ✅(공격적) | ✅(제한적) |
| Common Subexpression 제거 | ❌    | ✅         | ✅    | ✅         | ✅         |
| Constant Propagation      | ❌    | ✅         | ✅    | ✅         | ✅         |
| Branch Prediction 최적화  | ❌    | ✅         | ✅    | ✅         | ✅         |
| Register Allocation 개선  | ❌    | ✅         | ✅    | ✅         | ✅         |
| Vectorization (NEON/SIMD) | ❌    | ❌         | ❌    | ✅         | ❌         |

------

### CubeIDE에서 최적화 옵션 설정

1. **Project → Properties → C/C++ Build → Settings**
2. **Tool Settings → MCU GCC Compiler → Optimization**
3. Optimization Level 선택:
   - `None (-O0)`
   - `Optimize (-O1)`
   - `Optimize more (-O2)`
   - `Optimize most (-O3)`
   - `Optimize for size (-Os)`

추가로 다음 옵션을 병행 가능:

- `-flto` (Link Time Optimization)
- `-funroll-loops`
- `-fomit-frame-pointer`

------

### 코드 예시 비교

```
int sum_array(int *arr, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++)
        sum += arr[i];
    return sum;
}
```

#### O0 빌드 결과 (디버깅 중심)

- 루프, 인덱스 변수, 조건문이 그대로 유지
- 함수 호출 시 프레임 생성 및 해제 명령어 다수
- CPU Cycle: 약 200 cycles (for n=50)

#### O2 빌드 결과 (일반 최적화)

- 루프 인덱스 레지스터 보관
- 불필요한 조건문 제거
- CPU Cycle: 약 90 cycles

#### O3 빌드 결과 (공격적 최적화)

- 루프 전개(Unrolling)
- 인라인 연산 및 레지스터 파이프라인 적용
- CPU Cycle: 약 60 cycles (성능 약 3.3배 향상)

------

### HAL 코드에 미치는 영향

#### 1. HAL 함수 인라인화

- `__STATIC_INLINE` 함수들이 자동 인라인 처리됨
- GPIO, Timer 접근 속도 향상 (약 10~20%)

#### 2. Delay 함수 부정확 가능성

- `HAL_Delay()`나 `for()` 루프 기반 Delay 코드가 제거될 수 있음
   → `volatile` 또는 `__NOP()`을 삽입해 최적화 방지 필요

  ```
  for (volatile int i = 0; i < 1000; i++) __NOP();
  ```

#### 3. Debug Symbol 혼동

- `O2/O3` 수준에서는 변수, 루프 인덱스 등이 제거되어 디버깅 불가능
   → `.map` 파일을 통해 최적화 후 변수 주소 확인 필요

------

### 성능 및 코드 크기 비교

| 최적화 레벨 | 코드 크기 (KB) | 실행 시간 (µs) | 디버그 가능성 |
| ----------- | -------------- | -------------- | ------------- |
| O0          | 60.2           | 41.2           | ◎             |
| O1          | 51.4           | 25.7           | ○             |
| O2          | 48.9           | 18.3           | △             |
| O3          | 52.8           | 16.9           | ×             |
| Os          | 45.1           | 21.5           | △             |

테스트 조건: STM32F407, 168MHz, GCC 12.2, Flash 실행 기준

------

### 주의사항 및 디버깅 팁

#### 디버깅 정확도 확보

- O0 수준에서 디버깅 후, 빌드 모드 전환 후 결과 검증
- 코드 최적화에 따른 “변수 생략” → `volatile`로 보존 가능

#### ISR 함수 보호

- 인터럽트 핸들러 최적화 중 불필요한 리턴 제거 방지를 위해:

  ```
  __attribute__((optimize("O0")))
  void DMA1_Channel1_IRQHandler(void) { ... }
  ```

#### 최적화 예외 지정

- 특정 파일에만 O0 적용:

  ```
  #pragma GCC push_options
  #pragma GCC optimize ("O0")
  void debug_function(void) { ... }
  #pragma GCC pop_options
  ```

------

### 고급 최적화 기법

#### Link Time Optimization (LTO)

- `-flto` 옵션 사용 시, 모듈 간 함수 인라인 최적화 수행
   → 코드 크기 5~10% 감소, 속도 약간 향상
   → 단, 빌드 시간 증가

#### Function Section 분리

- `-ffunction-sections`, `-fdata-sections` + `--gc-sections`
   → 사용되지 않는 함수 자동 제거로 Flash 절약

#### Fast Math 최적화

- `-ffast-math`: IEEE 규격 미보장 대신 수학 연산 속도 향상
   → DSP, FFT 계산에서 10~30% 성능 향상 가능
   → 단, NaN/Infinity 판단 불가

------

### 권장 조합 예시

| 목적                | 권장 옵션                        | 비고                 |
| ------------------- | -------------------------------- | -------------------- |
| **개발/디버그**     | `-O0`                            | 코드 흐름 검증       |
| **일반 테스트**     | `-O1`                            | HAL 기반 안정적 동작 |
| **릴리즈 빌드**     | `-O2 -flto -ffunction-sections`  | 성능/용량 균형       |
| **고성능 DSP/제어** | `-O3 -funroll-loops -ffast-math` | 루프 및 수학 최적화  |
| **저용량 시스템**   | `-Os --gc-sections`              | Flash 최소화         |

------

### 결론

- **O0**: 개발/디버깅 단계 필수
- **O2**: 릴리즈 기본 최적화
- **O3**: 연산 집약 코드에만 제한적 적용
- **Os**: Flash 제한 환경에 최적

최적화는 단순한 “속도 향상”이 아니라, **코드 크기, 전력, 안정성의 균형점 조정 행위**이다.
 최종 릴리즈 빌드에서는 반드시 O2 기반의 **성능-안정성 검증 절차**를 수행해야 한다.

------

### 참고 문서

- GNU GCC Manual – Optimization Options
- ST AN4666: STM32 Performance Optimization
- ARM Cortex-M Compiler User Guide
- ST CubeIDE User Manual – Compiler and Linker Settings

## 23.5 전력 소모 프로파일링

임베디드 시스템에서 전력 소모를 최소화하는 것은 배터리 기반 장치나 저전력 IoT 기기에서 필수적인 과제이다. 전력 프로파일링(power profiling)은 시스템의 동작 상태(Active, Sleep, Stop, Standby 등)에 따른 **전류 소비 특성**을 정량적으로 측정하고, 펌웨어 및 하드웨어 수준에서 **전력 효율을 최적화**하는 과정을 의미한다.

------

### 전력 측정 개요

전력 소모는 일반적으로 아래 식으로 정의된다.
$$
P = V \times I
$$
여기서,

- **V**: 공급 전압(V)
- **I**: 소비 전류(A)
- **P**: 소비 전력(W)

STM32와 같은 MCU는 여러 전력 상태(Mode)에 따라 전류 소비가 크게 달라진다. 예를 들어,

- **Run Mode**: 5~20 mA
- **Sleep Mode**: 100~500 µA
- **Stop Mode**: 수 µA 수준
- **Standby Mode**: 수십 nA 수준

이러한 전류는 측정 환경, 클럭 주파수, 주변장치 활성 여부, GPIO 상태 등에 따라 변동한다.

------

### 측정 방법

#### USB 전류계 또는 전력 분석기 사용

- **장비 예시**: Joulescope, Otii Arc, Power Profiler Kit (Nordic), Keysight N6705C
- **측정 항목**: 전류 파형, 평균 전력, 피크 전류, 에너지(Wh)
- **특징**: μA 단위 정밀 측정 가능, 타임라인 기반 그래프 분석 지원

#### 샌드위치 저항(Shunt Resistor) 방식

- **원리**: MCU 전원선에 저항(Rshunt)을 직렬로 삽입하고, 저항 양단 전압을 ADC로 측정

  ```
  voltage = HAL_ADC_GetValue(&hadc1);
  current = voltage / Rshunt;
  ```

- **장점**: 간단하고 저비용

- **단점**: 측정 저항에 따른 전압 강하 존재, 샘플링 속도 제한

#### 외부 MCU 기반 측정

- 저전력 측정 전용 MCU(예: STM32L 시리즈, INA219 전류 센서)를 사용하여 실시간 로깅
- UART 또는 BLE를 통해 소비 전류 데이터 전송

------

### 전력 소모 분류

| 구분               | 내용                         | 예시                         |
| ------------------ | ---------------------------- | ---------------------------- |
| **MCU 코어 전력**  | CPU 클럭, 내부 레지스터 동작 | PLL 주파수, Flash Wait State |
| **주변장치 전력**  | ADC, UART, I2C, SPI 등       | DMA 전송, 인터럽트 처리      |
| **IO 상태 전력**   | GPIO의 출력 상태, 풀업저항   | LED, MOSFET, 센서 Enable 핀  |
| **외부 모듈 전력** | BLE, Wi-Fi, GPS 등           | HM-10, ESP8266, NEO-6M       |
| **대기 전력**      | Sleep / Stop / Standby 모드  | RTC 유지, Backup Register    |

------

### 전력 프로파일링 절차

1. **분석 구간 정의**
   - MCU 동작 시나리오를 기능 단위로 구분 (예: 부팅 → 측정 → 송신 → 대기)
2. **샘플링 설정**
   - 측정기기의 샘플링 속도(10 kHz~1 MHz)를 조정하여 이벤트 기반 전류 변화를 추적
3. **데이터 수집 및 시각화**
   - Power Profiler, Otii Arc 등을 사용해 시간-전류 그래프 획득
   - 주요 이벤트(ADC 변환, RF 송신 등) 구간에 Marker 추가
4. **구간별 통계 산출**
   - 평균 전류, 피크 전류, 에너지 소비량 계산
5. **비교 및 최적화**
   - 펌웨어 개선(클럭 감소, Sleep 삽입, DMA 활용) 후 재측정

------

### 저전력 펌웨어 최적화 포인트

#### 클럭 및 전원 관리

- `HAL_PWR_EnterSLEEPMode()` 또는 `HAL_PWR_EnterSTOPMode()` 활용
- PLL 비활성화, HSI 사용 전환
- `__WFI()` 명령을 통한 CPU Idle 제어

#### 주변장치 절전

- 사용하지 않는 Peripheral의 Clock Disable (`__HAL_RCC_xxx_CLK_DISABLE()`)
- ADC / UART / SPI 등 사용 후 PowerDown 처리
- DMA, Timer, RTC만 필요한 최소 기능만 유지

#### GPIO 전력 절감

- Floating 입력 핀은 Pull-down 설정
- 불필요한 출력핀은 Low 또는 High 고정
- LED, 센서 Enable 핀은 Sleep 전 비활성화

#### RTOS 기반 제어

- Idle Task Hook 내 Sleep Mode 진입
- Event 기반 Wake-up 구조 설계 (Polling 최소화)
- Tickless Idle 기능 활성화 (`configUSE_TICKLESS_IDLE = 1`)

------

### 실측 및 결과 분석 예시

#### 테스트 조건

- STM32F103C8T6 @ 72MHz
- 주변장치: ADC(1채널), UART(1채널), FreeRTOS (3 Task)

| 상태              | 측정 전류 | 비고                 |
| ----------------- | --------- | -------------------- |
| Run (Task Active) | 13.2 mA   | LED, UART 송신       |
| Sleep Mode        | 0.82 mA   | `__WFI()` 진입       |
| Stop Mode         | 46 µA     | RTC 유지             |
| Standby Mode      | 2.1 µA    | Backup Register 유지 |

→ Sleep 진입과 클럭 관리만으로 **전력 소모 95% 이상 절감 가능**

------

### 시각화 및 보고

- **Power vs Time 그래프**를 통해 전력 소비 패턴 파악

- **주기적 피크 전류 구간**은 RF 송신, ADC 변환 등 주요 이벤트와 연동

- **에너지 예산(Energy Budget)** 산출:
  $$
  E = \sum (I_{avg} \times V \times T_{mode})
  $$

- 결과를 CSV로 Export하여 모듈별 전력 기여도를 분석

------

### 결론

전력 소모 프로파일링은 단순한 전류 측정이 아니라, **시스템 동작 전반의 효율성 분석 과정**이다.
 정밀 측정 장비와 타임라인 기반 로그 분석을 병행함으로써,
 MCU의 **Sleep 진입 시점, 주변장치 전원 관리, RTOS Idle 제어** 등의 영역에서
 정량적 최적화를 수행할 수 있다.

이는 저전력 IoT 장비, 배터리 구동형 센서 노드, 산업용 무선 데이터 로거 등에서
 제품 수명과 안정성을 결정하는 핵심 기술로 활용된다.

## 23.6 ISR Latency 최소화

### 개요

ISR(Interrupt Service Routine) Latency는 외부 인터럽트가 발생한 시점부터 CPU가 실제로 해당 ISR 내부 코드를 실행하기까지의 지연 시간(latency)을 의미한다. 실시간 시스템에서 ISR latency는 응답 속도와 제어 안정성에 직접적인 영향을 주므로, 최소화하는 것이 중요하다. STM32, ESP32, Linux, Android와 같은 다양한 플랫폼에서도 공통적으로 고려되지만, 임베디드 MCU 환경에서는 특히 HAL, NVIC, FreeRTOS 등 시스템 레벨 설정이 지연에 큰 영향을 미친다.

------

### ISR Latency의 주요 구성 요소

1. **하드웨어 인터럽트 지연(Hardware Latency)**
   - 외부 입력 신호가 인터럽트 라인에 도달하여 NVIC가 이를 인식하기까지의 시간.
   - MCU 클록 주파수, 버스 대기 시간, 인터럽트 라인 필터링 설정 등에 따라 달라진다.
2. **NVIC 응답 지연(NVIC Response Delay)**
   - NVIC(중첩 벡터 인터럽트 컨트롤러)가 현재 실행 중인 명령어를 완료하고 인터럽트 벡터로 분기하기까지의 시간.
   - Cortex-M 아키텍처의 경우, 파이프라인 플러시(Flush)와 컨텍스트 스택 푸시(Push)에 약 12~15 사이클이 필요하다.
3. **ISR 진입 오버헤드(Stack Push + Vector Fetch)**
   - 인터럽트 진입 시 CPU가 자동으로 R0~R3, LR, PC, xPSR 레지스터를 스택에 저장하는 과정.
   - 벡터 테이블에서 해당 ISR 주소를 읽고 Branch 하는 과정 포함.
   - 약 40~50 ns (72MHz 기준) 수준의 오버헤드가 발생할 수 있다.
4. **OS 커널 중재 지연(Preemption Latency)**
   - FreeRTOS, Zephyr 등 RTOS 환경에서는 커널이 스케줄링을 위해 인터럽트를 마스크하는 구간이 존재.
   - `taskENTER_CRITICAL()` 구간, SysTick Handler 등에서 인터럽트가 잠시 지연될 수 있다.
5. **다른 ISR과의 우선순위 충돌**
   - 동일하거나 높은 우선순위를 가진 다른 인터럽트가 이미 실행 중인 경우, 후속 인터럽트는 NVIC Pending 상태로 대기한다.
   - ISR 우선순위 설정(NVIC Priority Grouping)이 올바르지 않으면 실시간성이 저하된다.

------

### STM32 HAL 기반 환경에서의 주요 원인

- HAL 함수 내 불필요한 대기 루프(`while (flag == RESET)`)
- 인터럽트 내 HAL 호출 (예: `HAL_UART_Transmit()`, `HAL_Delay()` 등)
- NVIC 우선순위 그룹이 Preempt Priority/Sub Priority로 적절히 분리되지 않은 경우
- FreeRTOS 사용 시 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 설정 불일치
- DMA 완료 인터럽트와 사용자 인터럽트의 충돌
- SysTick 주기(1ms) 내에서 높은 빈도의 인터럽트가 다수 발생하는 경우

------

### 측정 및 분석 방법

#### **Cycle Counter (DWT) 활용**

- Cortex-M의 DWT(Data Watchpoint and Trace) 레지스터를 이용하여 ISR 진입 시간을 사이클 단위로 측정 가능.

```
DWT->CYCCNT = 0;
DWT->CTRL |= 1;  // Enable DWT
uint32_t start = DWT->CYCCNT;
// 인터럽트 발생 대기
uint32_t latency = DWT->CYCCNT - start;
```

- DWT 레지스터는 SysTick보다 높은 정밀도의 타이밍 측정을 제공.

#### **Logic Analyzer / GPIO 토글**

- ISR 진입 직전에 GPIO 핀을 토글시켜 실제 하드웨어 신호 지연을 측정.
- 오실로스코프나 로직 분석기로 외부 트리거 신호와 ISR 핀 토글을 비교하여 지연 시간 확인.

#### **ITM / SWO Trace**

- ITM(Instrumentation Trace Macrocell) 채널을 사용하여 ISR 시작/종료 시점을 실시간으로 추적.
- SWO 콘솔(Log Viewer)에서 시간 차를 계산하여 평균 ISR 지연 파악.

------

### ISR Latency 최소화 기법

#### **1. NVIC 우선순위 최적화**

- 긴 처리 시간이 필요한 ISR은 낮은 우선순위로 배치.
- 빠른 응답이 필요한 외부 인터럽트(GPIO, Timer)는 Preempt Priority를 높게 설정.

```
HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 2, 0);
```

- Priority Group을 적절히 구성 (`HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4)` 등).

#### **2. ISR 내 연산 최소화**

- ISR에서는 최소한의 flag 설정, 데이터 버퍼링만 수행하고, 나머지는 Task로 위임.
- 예: Queue, EventGroup, Semaphore로 후처리를 위임하는 구조:

```
void EXTI0_IRQHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(xExtiSemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

#### **3. HAL 대신 LL (Low Layer) API 사용**

- HAL 함수는 구조적 오버헤드가 크므로 ISR에서는 LL 함수를 직접 호출하여 latency를 최소화.

```
LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_0);
LL_USART_TransmitData8(USART1, data);
```

#### **4. FreeRTOS 설정 튜닝**

- `configMAX_SYSCALL_INTERRUPT_PRIORITY`를 실제 ISR 우선순위보다 높게 설정.
- `configUSE_PORT_OPTIMISED_TASK_SELECTION` 활성화로 context switch 속도 향상.
- `configKERNEL_INTERRUPT_PRIORITY`는 최하위로 설정(보통 0x0F).

#### **5. DMA, Circular Buffer 적극 활용**

- 인터럽트가 데이터 처리 대신 DMA 완료 이벤트를 기다리도록 하여 CPU 부담을 경감.
- Circular Buffer로 ISR 횟수를 줄여 평균 latency 개선.

#### **6. Flash Wait State / Prefetch 조정**

- Flash 접근 지연이 ISR 응답에 영향을 주므로, Flash wait state와 prefetch buffer를 MCU 클록에 맞게 조정.
- 예: STM32F4에서는 `FLASH_ACR_LATENCY_2WS`, `FLASH_ACR_PRFTEN` 설정.

------

### 실시간성 보장을 위한 설계 원칙

- 인터럽트 중첩(Nested Interrupt)을 허용하되, Critical Section 최소화.
- ISR 내에서 동적 메모리 할당, printf(), HAL_Delay() 사용 금지.
- Task 우선순위 조정 시, 인터럽트와의 우선순위 역전 현상(Inversion) 방지.
- 타이머, 센서, 통신 ISR 간의 실행 시간 균형 조정.

------

### 예제: GPIO 인터럽트 응답 시간 최적화

```
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        LL_GPIO_TogglePin(GPIOC, LL_GPIO_PIN_13);  // 빠른 반응 출력
        xSemaphoreGiveFromISR(xSensorEvent, NULL); // Task 통신
    }
}
```

- LL 함수로 즉시 핀 토글.
- FreeRTOS 세마포어로 후속 처리 위임.

------

### 분석 리포트 구성 예시

| 항목         | 내용                                      |
| ------------ | ----------------------------------------- |
| MCU          | STM32F407VG (168MHz)                      |
| 인터럽트     | EXTI0 (Rising Edge)                       |
| 평균 Latency | 2.3 µs                                    |
| 최대 Latency | 3.1 µs                                    |
| 테스트 방법  | DWT Cycle Counter, Logic Analyzer         |
| 최적화 조치  | LL API 사용, Priority 재조정, DMA offload |

------

ISR latency는 시스템의 구조적 병목을 드러내는 지표이다.
 하드웨어 수준의 응답, NVIC 우선순위, HAL 오버헤드, RTOS 설정 등 모든 계층이 복합적으로 작용하므로, 정량적 측정과 지속적인 튜닝이 병행되어야 한다.