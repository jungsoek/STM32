# 1. STM32 및 개발환경 개요

## 1.1 마이크로컨트롤러 개념 및 구조 (CPU, Flash, RAM, Peripheral)

### 개요

마이크로컨트롤러(MCU, Microcontroller Unit)는 **CPU 코어**, **비휘발성 메모리(Flash)**, **휘발성 메모리(SRAM)**, **주변장치(Peripheral)**, **클럭/리셋 회로**, **전원 관리 블록** 등을 하나의 실리콘 다이에 통합한 임베디드 제어용 SoC(System on Chip)이다.
 일반적인 프로세서(MPU)가 외부 메모리 및 주변 장치와 조합되어 사용되는 반면, MCU는 독립적으로 프로그램 실행과 주변장치 제어가 가능하도록 설계된다.

------

### 1. CPU Core

STM32 시리즈는 대부분 **ARM Cortex-M 계열** 코어를 사용한다.
 대표적인 코어의 특성은 다음과 같다.

| 코어          | 주요 특징            | 지원 기능                                                   |
| ------------- | -------------------- | ----------------------------------------------------------- |
| Cortex-M0/M0+ | 저전력, 저가형       | Thumb 명령어, 단순 버스 구조                                |
| Cortex-M3     | 범용형               | Nested Vectored Interrupt Controller (NVIC), SysTick 타이머 |
| Cortex-M4     | 고성능 DSP용         | FPU(Floating Point Unit), SIMD 명령                         |
| Cortex-M7     | 고속 파이프라인 구조 | Instruction/Data Cache, 분기 예측, 고성능 FPU               |
| Cortex-M33    | 보안 확장            | TrustZone, MPU(Memory Protection Unit)                      |

- **레지스터 세트**: 13개의 범용 레지스터(R0~R12), 스택 포인터(SP), 링크 레지스터(LR), 프로그램 카운터(PC), 프로그램 상태 레지스터(xPSR).
- **명령어 집합**: Thumb/Thumb-2(16/32비트 혼합) 구조로 코드 밀도와 실행 효율을 균형화.
- **인터럽트 지연(latency)**: NVIC을 통해 최소 12사이클 내 인터럽트 응답 가능.
- **예외 처리 모델**: 하드폴트(HardFault), 메모리 폴트(MemManage), 버스 폴트(BusFault), 사용 폴트(UsageFault) 등.

------

### 2. 메모리 구조 (Memory Map)

Cortex-M 기반 MCU는 주소 공간을 고정된 영역으로 분할한다. STM32F1 시리즈를 기준으로 한 예시는 다음과 같다.

| 주소 범위                 | 영역                | 주요 용도                                   |
| ------------------------- | ------------------- | ------------------------------------------- |
| 0x0000_0000 ~ 0x1FFF_FFFF | Code / Flash Memory | 프로그램 코드 및 상수 저장                  |
| 0x2000_0000 ~ 0x3FFF_FFFF | SRAM                | 변수, 스택, 힙 저장                         |
| 0x4000_0000 ~ 0x5FFF_FFFF | Peripheral          | GPIO, USART, SPI, I²C 등 주변장치 레지스터  |
| 0x6000_0000 ~ 0x9FFF_FFFF | External Memory     | FSMC/FMC를 통한 외부 SRAM, NOR/NAND Flash   |
| 0xE000_0000 ~ 0xE00F_FFFF | System              | NVIC, SysTick, SCB(System Control Block) 등 |

**Flash Memory**

- 비휘발성, 프로그램 및 상수 저장.
- 페이지 또는 섹터 단위로 Erase 수행.
- Word 또는 Half-Word 단위로 Program 수행.
- Flash erase/write 시 코드 실행 중단 주의.

**SRAM**

- 휘발성, 실행 중 데이터 저장.
- 버스 대역폭이 제한되며 DMA, CPU, Peripheral 간 충돌 방지 필요.
- Stop 모드에서 데이터 유지 가능(전력 관리 설정에 따라 다름).

------

### 3. 버스 구조 (Bus Matrix)

STM32는 내부적으로 **AHB(Advanced High-performance Bus)**, **APB(Advanced Peripheral Bus)** 로 분리된 버스 매트릭스를 사용한다.

- **AHB**: 고속 주변장치 및 메모리 접근용 (DMA, GPIO, Flash, SRAM 등).
- **APB1 / APB2**: 저속 주변장치(UART, TIM, SPI 등)용.
- AHB ↔ APB 브리지(Bridge)가 존재하며, 각 버스의 클럭은 독립적으로 분주 가능.

버스 구조 이해는 DMA 경로, 메모리 접근 지연(latency), 주변장치 간 충돌 분석에 필수적이다.

------

### 4. 주변장치 (Peripherals)

MCU 내부에는 다양한 하드웨어 주변장치가 통합되어 있으며, 각 기능은 메모리 맵으로 접근 가능하다.

#### GPIO (General Purpose Input/Output)

- 포트 단위로 구성, 각 핀은 독립적인 모드 설정 가능.
- 출력 타입: Push-Pull / Open-Drain
- 입력 옵션: Pull-Up / Pull-Down / Floating
- 기능: 일반 입출력, 외부 인터럽트(EXTI), 대체 기능(AF) 핀 할당.

#### Timer / Counter

- **Basic Timer**: 시간 기반 이벤트 생성.
- **General Purpose Timer**: PWM, Input Capture, Output Compare.
- **Advanced Timer**: 센터얼라인 PWM, 브레이크 입력, 데드타임 삽입.
- 타이머는 DMA 및 인터럽트와 연계 가능.

#### ADC (Analog-to-Digital Converter)

- 다중 채널 스캔, 싱글/연속 변환, DMA 지원.
- 내부 참조전압(Vrefint), 온도센서 사용 가능.
- 샘플링 시간 및 분해능(12비트, 16비트 등) 조정 가능.

#### DAC (Digital-to-Analog Converter)

- 디지털 데이터를 아날로그 전압으로 변환.
- 타이머 트리거 기반 파형 출력 가능.

#### USART / UART

- 비동기 직렬 통신, 하드웨어 플로우 제어(RTS/CTS) 지원.
- 송수신 인터럽트 및 DMA 모드 지원.

#### SPI / I²C / CAN / USB / Ethernet

- SPI: 동기식, 마스터/슬레이브 지원, 풀 듀플렉스.
- I²C: 다중 마스터, 주소 기반 통신, ACK/NACK 관리.
- CAN: 메시지 필터, FIFO 큐, 하드웨어 Arbitration.
- USB: Full-Speed/High-Speed 지원, Device/Host 모드 선택.
- Ethernet: PHY 인터페이스, DMA 기반 데이터 전송.

#### DMA (Direct Memory Access)

- 메모리와 주변장치 간 데이터 전송 자동화.
- CPU 부하 감소, 실시간성 향상.
- Circular 모드, Half-Transfer, Transfer-Complete 인터럽트 지원.

#### NVIC (Nested Vectored Interrupt Controller)

- 인터럽트 우선순위 관리.
- Preemption Priority / Sub Priority 분리 가능.
- 인터럽트 벡터 테이블: Reset Handler 포함, 메모리 시작 주소에 위치.

------

### 5. 클럭 및 전원 관리 (RCC / PWR)

#### 클럭 소스

- **HSE (High-Speed External)**: 외부 크리스털, 높은 정확도.
- **HSI (High-Speed Internal)**: 내부 RC 오실레이터.
- **LSE / LSI**: RTC용 저속 클럭.
- **PLL (Phase Locked Loop)**: 클럭 배수기, 시스템 클럭 생성.

#### 클럭 분배

- SYSCLK → AHB → APB1/APB2 분주.
- 각 주변장치 클럭은 RCC에서 개별 Enable/Disable 가능.

#### 전원 관리

- 동작 모드: Run / Sleep / Stop / Standby.
- Stop/Standby 모드에서 클럭, SRAM, RTC 유지 여부 설정 가능.
- 저전력 설계 시 Peripheral Clock 게이팅 필수.

------

### 6. 인터럽트 및 예외 구조

- **Exception Level**
  - Reset, NMI, HardFault, SVC, PendSV, SysTick 등.
- **ISR(Interrupt Service Routine)** 진입 시 자동 스택 프레임 저장.
- **중첩 인터럽트 처리**: NVIC 설정에 따라 고우선순위 ISR이 저우선순위 ISR을 선점 가능.
- **예외 처리 절차**
  1. 인터럽트 발생 → NVIC에서 우선순위 비교.
  2. 현재 실행 중 코드 상태 저장.
  3. ISR 주소로 PC 이동, ISR 실행.
  4. 종료 시 자동 복귀(Return from Exception).

------

### 7. 디버깅 및 시스템 제어 블록

- **SCB (System Control Block)**: 예외 관리, 시스템 리셋 제어, 벡터 테이블 오프셋 관리.
- **SysTick Timer**: 주기적 인터럽트 발생, HAL Delay 및 RTOS Tick에 사용.
- **DWT (Data Watchpoint and Trace)**: 실행 시간 측정, 사이클 카운트, 디버깅 성능 분석.
- **ITM / SWO**: 실시간 printf 대체 로깅, RTT 기반 디버깅 가능.

------

### 8. Boot / Reset 구조

- **Boot0 / Boot1 핀**: 부트 모드 선택 (Flash, System Memory, SRAM).
- **System Memory**: 내장 부트로더 존재 (UART, USB DFU, I²C 등으로 펌웨어 업로드 가능).
- **Option Bytes**: 부트 모드, Read Protection, Write Protection 등 MCU 동작 설정.

------

### 9. 종합 구조도 (논리적 블록 다이어그램)

```
 ┌────────────────────────────────────────────┐
 │                 CPU Core                   │
 │    (Cortex-Mx + NVIC + SysTick + SCB)      │
 ├────────────────────────────────────────────┤
 │ Flash  │ SRAM │ DMA │ Bus Matrix (AHB/APB) │
 ├────────────────────────────────────────────┤
 │ GPIO │ Timer │ ADC/DAC │ UART │ SPI │ I2C │
 │ CAN  │ USB   │ RTC     │ WDG  │ PWR │ RCC │
 ├────────────────────────────────────────────┤
 │          Debug (SWD, ITM, DWT, SWO)        │
 └────────────────────────────────────────────┘
```

------

### 요약

| 구성 요소  | 역할                         |
| ---------- | ---------------------------- |
| CPU        | 명령어 실행, 제어 로직 수행  |
| Flash      | 프로그램 및 상수 저장        |
| SRAM       | 실행 중 데이터 저장          |
| Peripheral | 외부와의 입출력 및 제어 수행 |
| RCC        | 클럭 및 리셋 관리            |
| NVIC       | 인터럽트 제어                |
| DMA        | 데이터 전송 가속             |
| PWR        | 전원 관리 및 저전력 제어     |

------

이 항목은 이후의 모든 STM32 학습 단원의 기반이 되는 핵심 구조로,
 HAL 드라이버 및 레지스터 접근, 인터럽트 처리, 클럭 설정의 이해를 위한 필수 전제이다.

## 1.2 STM32 제품군 개요 (F0~F7, G0, H7, L4, WB, WL)

STM32 시리즈는 **STMicroelectronics**에서 개발한 **32비트 ARM Cortex-M 기반 마이크로컨트롤러 제품군**으로, 성능, 전력 효율, 주변장치 구성에 따라 다양한 서브패밀리로 구성된다. 각 시리즈는 특정 애플리케이션 요구사항(저전력, 고성능, 아날로그 정밀도, 무선 통합 등)에 맞게 최적화되어 있으며, 공통적으로 **CMSIS 및 HAL 드라이버를 통한 소프트웨어 호환성**을 유지한다.

------

### STM32F0 시리즈 — Entry Level

- **코어:** ARM Cortex-M0 (최대 48MHz)
- **특징:** 저가형, 기본 주변장치 구성, 소형 패키지 제공
- **주요 용도:** 가전제품, 간단한 센서 제어, 저가형 산업제어
- **대표 모델:** STM32F030, STM32F070, STM32F072
- **특이사항:** 하드웨어 멀티플라이어 내장, 12비트 ADC, 기본 타이머/USART/I²C/SPI 지원

------

### STM32F1 시리즈 — Mainstream Classic

- **코어:** ARM Cortex-M3 (최대 72MHz)
- **특징:** 균형 잡힌 성능과 가격, 광범위한 생태계 지원
- **주요 용도:** 산업용 컨트롤러, 통신 장비, 교육용 MCU
- **대표 모델:** STM32F103, STM32F101
- **특이사항:** AHB 버스 기반 고속 구조, 최대 64KB RAM, 풍부한 GPIO 및 타이머 리소스

------

### STM32F3 시리즈 — Mixed-Signal Focus

- **코어:** ARM Cortex-M4 (최대 72MHz, FPU 지원)
- **특징:** 고정밀 아날로그 연산에 특화, DSP 및 FPU 내장
- **주요 용도:** 모터 제어, 전력 변환, 신호 처리
- **대표 모델:** STM32F303, STM32F334
- **특이사항:** 고속 ADC (5 MSPS), DAC 내장, 비교기(Comparator), 연산 증폭기(OPAMP) 통합

------

### STM32F4 시리즈 — High Performance

- **코어:** ARM Cortex-M4 (최대 180MHz, FPU/DSP 지원)
- **특징:** 높은 클록 속도와 대용량 메모리 제공
- **주요 용도:** 오디오 처리, 디스플레이 제어, 고성능 임베디드 애플리케이션
- **대표 모델:** STM32F407, STM32F429, STM32F446
- **특이사항:** 외부 메모리 인터페이스(FSMC), DMA2D, USB OTG, 이더넷 MAC 내장

------

### STM32F7 시리즈 — Advanced Performance

- **코어:** ARM Cortex-M7 (최대 216MHz, FPU/DSP/Cache 지원)
- **특징:** 고성능과 실시간 응답성의 조합, 캐시 및 TCM(최상위 캐시 메모리) 지원
- **주요 용도:** 멀티미디어, 산업용 제어, 고속 통신 시스템
- **대표 모델:** STM32F746, STM32F767
- **특이사항:** ART Accelerator, D-Cache/I-Cache, SDRAM/LCD 컨트롤러 통합

------

### STM32G0 시리즈 — Next-Gen Entry Level

- **코어:** ARM Cortex-M0+ (최대 64MHz)
- **특징:** F0의 차세대 버전으로, 더 낮은 전력과 향상된 주변장치 구조 제공
- **주요 용도:** 소형 IoT 장치, 저가형 산업 제어, 센서 허브
- **대표 모델:** STM32G030, STM32G070, STM32G071
- **특이사항:** 5V 내성 GPIO, 고속 ADC(2.5MSPS), 하드웨어 AES 및 RNG 지원

------

### STM32L4 시리즈 — Ultra-Low Power

- **코어:** ARM Cortex-M4 (최대 80MHz, FPU 포함)
- **특징:** 극저전력 동작과 빠른 웨이크업 결합
- **주요 용도:** 배터리 기반 IoT, 웨어러블, 센서 노드
- **대표 모델:** STM32L431, STM32L476, STM32L496
- **특이사항:** 1.8V 저전력 코어, 다양한 전원 모드(Sleep/Stop/Standby), 전력-성능 균형 우수

------

### STM32H7 시리즈 — Premium High Performance

- **코어:** ARM Cortex-M7 (최대 480MHz, 듀얼코어 버전 포함)
- **특징:** STM32 제품군 중 최고 성능, 고속 외부 버스, 고정밀 타이밍
- **주요 용도:** AI 엣지 컴퓨팅, 고속 데이터 로깅, 고해상도 UI 제어
- **대표 모델:** STM32H743, STM32H747 (M7+M4 듀얼코어)
- **특이사항:** 최대 2MB Flash, 1MB SRAM, FMC/SDRAM 인터페이스, 크롬아트(Chrom-ART) 가속기 포함

------

### STM32WB 시리즈 — Wireless BLE / Zigbee / Thread

- **코어:** ARM Cortex-M4 (애플리케이션) + Cortex-M0+ (무선 스택 전용)
- **특징:** 블루투스 5.0, Zigbee, Thread 통합 SoC
- **주요 용도:** IoT 게이트웨이, 스마트홈, 센서 네트워크
- **대표 모델:** STM32WB55, STM32WB10
- **특이사항:** 전용 무선 코프로세서, OTA 업데이트 지원, 보안 기능 (AES-256, PKA) 내장

------

### STM32WL 시리즈 — Sub-GHz Wireless (LoRa, Sigfox)

- **코어:** ARM Cortex-M4 (애플리케이션) + RF 서브시스템 통합
- **특징:** LoRa 및 FSK/PSK/OOK 지원, 초저전력 무선 통합 MCU
- **주요 용도:** 장거리 IoT 노드, 스마트 미터링, 환경 센서
- **대표 모델:** STM32WL55, STM32WLE5
- **특이사항:** Semtech SX126x 기반 무선 블록 내장, Tx 최대 +22dBm 출력, 초저전력 Sleep 모드

## 1.3 STM32 Naming Rule 해석

STM32 마이크로컨트롤러는 제품명 자체에 **시리즈, 성능, 메모리 크기, 패키지, 동작 온도, 주변장치 구성 등**의 정보를 압축하여 표현한다.
 이 명명 규칙(Naming Rule)은 데이터시트를 보기 전에 제품의 특성을 빠르게 식별할 수 있도록 설계되어 있다.

------

### ① 기본 구조

STM32 제품명은 일반적으로 다음과 같은 형식을 따른다:

```
STM32[F/G/H/L/W/B][0~7][xx][A~Z][T/R/V/Z][6~8][x]
```

예시:

> **STM32F103C8T6**

------

### ② 각 필드의 의미

| 구분 | 항목                                   | 설명                                                         | 예시 (STM32F103C8T6 기준) |
| ---- | -------------------------------------- | ------------------------------------------------------------ | ------------------------- |
| ①    | **STM32**                              | STMicroelectronics의 32비트 MCU 시리즈                       | STM32                     |
| ②    | **시리즈 문자**                        | 제품군 구분 (F: Performance, L: Low Power, H: High-End, G: Mainstream, W: Wireless 등) | F                         |
| ③    | **성능 레벨 숫자**                     | 시리즈 내 세부 등급 (0~7 등급, 숫자가 높을수록 고성능)       | 1                         |
| ④    | **서브패밀리 코드 (2~3자리)**          | 주변장치 구성 또는 세부 라인 구분                            | 03                        |
| ⑤    | **플래시 메모리 용량 코드 (A~Z)**      | 플래시 크기를 나타냄 (A=16KB, B=32KB, C=64KB, D=128KB, E=256KB, F=512KB, G=1MB 등) | C (64KB)                  |
| ⑥    | **패키지 코드 (T/R/V/Z 등)**           | 패키지 타입을 나타냄                                         | T (LQFP 패키지)           |
| ⑦    | **핀 수 및 온도/사양 코드 (6/7/8 등)** | 동작 온도 범위 및 핀 수, 전기적 등급 구분                    | 6 (−40°C~85°C 산업용)     |

------

### ③ 세부 항목 설명

#### **시리즈 문자**

| 문자 | 시리즈명                                   | 특징 |
| ---- | ------------------------------------------ | ---- |
| F    | Performance 시리즈 (범용, 성능 중심)       |      |
| L    | Low Power 시리즈 (초저전력)                |      |
| G    | Next-Gen Mainstream (성능/전력 균형)       |      |
| H    | High-End 시리즈 (고성능, 대용량)           |      |
| W    | Wireless 통합형 (BLE, Zigbee, LoRa 등)     |      |
| B    | Bluetooth 및 오디오/보안 MCU               |      |
| C    | Compact Entry 시리즈 (저가형, 소형 패키지) |      |

------

#### **성능 레벨 숫자 (Generation)**

| 숫자 | 개요                               | 코어              |
| ---- | ---------------------------------- | ----------------- |
| 0    | Entry Level                        | Cortex-M0 / M0+   |
| 1    | Mainstream (Classic)               | Cortex-M3         |
| 2~3  | Mixed Signal / Enhanced Mainstream | Cortex-M4         |
| 4    | High Performance                   | Cortex-M4         |
| 7    | Advanced Performance               | Cortex-M7         |
| G/H  | 차세대 고성능                      | Cortex-M33 / M7   |
| L    | Ultra-Low Power                    | Cortex-M4 / M0+   |
| W    | Wireless                           | Cortex-M4 + Radio |

------

#### **서브패밀리 코드 (Peripheral Set Identifier)**

- 두 자리 숫자 또는 문자로 구성되며, 동일한 코어를 사용하는 시리즈 내에서 주변장치 구성이 다를 때 구분한다.
- 예시:
  - `F103`: 표준형 (ADC, 타이머, UART, SPI 등 포함)
  - `F100`: Value Line (주변장치 단순화, 저가형)
  - `F105/F107`: USB OTG, Ethernet 내장형

------

#### **플래시 메모리 용량 코드**

| 코드 | 플래시 용량 | RAM (대략) |
| ---- | ----------- | ---------- |
| A    | 16 KB       | 4 KB       |
| B    | 32 KB       | 6 KB       |
| C    | 64 KB       | 10 KB      |
| D    | 128 KB      | 20 KB      |
| E    | 256 KB      | 32 KB      |
| F    | 512 KB      | 64 KB      |
| G    | 1 MB        | 96~128 KB  |
| H    | 2 MB 이상   | ≥192 KB    |

------

#### **패키지 코드 (Package Type)**

| 코드 | 패키지 형식                      | 설명                              |
| ---- | -------------------------------- | --------------------------------- |
| T    | LQFP (Thin Quad Flat Package)    | 일반형, 표준 개발보드에 주로 사용 |
| R    | QFP (Quad Flat Package)          | 두꺼운 형태의 QFP                 |
| V    | BGA (Ball Grid Array)            | 고밀도 실장용, 고성능 제품        |
| Z    | WLCSP (Wafer-Level CSP)          | 초소형 모바일 기기용              |
| K    | UFQFPN (Ultra-thin Flat No-lead) | 초박형 패키지, 소형 IoT 기기용    |

------

#### **핀 수 및 온도/사양 코드 (마지막 숫자)**

| 코드 | 온도 범위      | 등급                | 설명        |
| ---- | -------------- | ------------------- | ----------- |
| 4    | 0°C ~ +70°C    | Commercial          | 상용 등급   |
| 6    | −40°C ~ +85°C  | Industrial          | 산업용 등급 |
| 7    | −40°C ~ +105°C | Extended Industrial | 고온 산업용 |
| 8    | −40°C ~ +125°C | Automotive          | 차량용 등급 |

------

### ④ 예시 분석

| 제품명        | 해석                                                         | 요약                        |
| ------------- | ------------------------------------------------------------ | --------------------------- |
| STM32F103C8T6 | F1 시리즈(성능 중심), M3 코어, 64KB Flash, LQFP 패키지, 산업용 온도 | 가장 일반적인 Blue Pill MCU |
| STM32L476RG   | L4 시리즈(저전력), M4 코어, 1MB Flash, LQFP 패키지, 산업용   | 초저전력 고성능 IoT용       |
| STM32H743ZI   | H7 시리즈(고성능), M7 코어, 2MB Flash, LQFP 패키지, Extended Industrial | 고속 신호처리 및 산업 제어  |
| STM32WB55CGU6 | Wireless BLE 시리즈, M4 + M0 코어, 512KB Flash, UFQFPN 패키지 | BLE/Zigbee 통합 SoC         |

------

이 명명 규칙을 숙지하면, **데이터시트를 열지 않아도 칩의 스펙, 코어, 메모리 용량, 패키지, 온도 등급을 빠르게 파악할 수 있다.**
 다음 단원에서는 실제 예시로 **STM32F103C8T6의 데이터시트 구조 분석 및 내부 블록 다이어그램 해석**을 다룬다.

## 1.4 주요 개발 보드 (Blue Pill, Nucleo, Discovery)

STM32 마이크로컨트롤러를 학습하거나 프로토타이핑할 때 가장 널리 사용되는 대표적인 개발 보드는 **Blue Pill**, **Nucleo**, **Discovery** 시리즈이다.
 이들은 가격, 확장성, 디버깅 인터페이스, 지원 MCU에 따라 구분되며, ST 공식 및 서드파티 생태계를 통해 다양한 하드웨어와 예제가 제공된다.

------

### Blue Pill — 저가형 커뮤니티 보드

**개요:**

- 비공식 서드파티 제작 보드로, **STM32F103C8T6 (Cortex-M3)** MCU를 탑재.
- 저비용(약 $2~3)으로 제공되며, 교육용 및 실습용으로 널리 사용됨.
- 기본적인 UART, SPI, I²C, ADC, PWM 등의 기능을 모두 제공.

**하드웨어 사양:**

- MCU: STM32F103C8T6 (72MHz, 64KB Flash, 20KB RAM)
- Clock: 8MHz HSE, 32.768kHz LSE
- 전원: 3.3V / 5V (USB 또는 외부 입력)
- 인터페이스: USB mini-B, UART (PA9/PA10), SWD (SWCLK/SWDIO)
- 핀 구성: 2×20핀 헤더 (0.1” 피치), GPIO 약 37개
- LED: PC13 (기본 디버그용), RESET 버튼
- 크기: 약 53×22mm

**특징:**

- 저비용으로 STM32 아키텍처 학습 가능.
- ST-Link 또는 USB-Serial 변환기로 프로그래밍 가능.
- CubeIDE, Arduino Core(STM32duino) 등 다양한 툴 지원.

**주의사항:**

- 일부 저가형 클론 보드는 USB 회로, 크리스탈, 플래시 용량이 다를 수 있음.
- 공식 ST 보드가 아니므로, 하드웨어 품질 편차 존재.

------

### Nucleo — ST 공식 표준형 보드

**개요:**

- STMicroelectronics가 직접 설계 및 배포하는 공식 개발 보드.
- 다양한 MCU 라인을 동일한 폼팩터로 제공하여 호환성 우수.
- Arduino UNO / ST morpho 핀 호환 커넥터를 지원.

**하드웨어 사양:**

- MCU: STM32F0, F1, F3, F4, F7, L0, L4, G0 등 시리즈별 다양
- On-board Debugger: **ST-Link/V2-1** 내장 (USB 프로그래밍 및 디버깅 지원)
- 전원: USB 5V 또는 외부 VIN (7~12V)
- 인터페이스: Arduino 호환 핀, ST morpho 확장 핀
- 통신: USB-UART 브리지, Virtual COM Port 지원
- 기본 크기: Nucleo-32, Nucleo-64, Nucleo-144 (핀 수에 따라 구분)

**특징:**

- ST 공식 HAL 및 CubeMX 완벽 호환.
- 보드 상단의 ST-Link 부분을 “ST-Link only”로 분리하여 별도 디버거로 사용 가능.
- 풍부한 예제 및 펌웨어 패키지(STM32Cube HAL FW) 제공.

**예시 모델:**

- Nucleo-F103RB (F1 시리즈, 64핀, 72MHz)
- Nucleo-L476RG (L4 시리즈, 저전력형, 80MHz)
- Nucleo-H743ZI (H7 시리즈, 고성능형, 400MHz)

------

### Discovery — 고기능 통합형 보드

**개요:**

- ST에서 직접 제공하는 **기능 통합형 실습 보드**로, 고급 주변장치를 탑재.
- 센서, 디스플레이, 오디오 코덱, MEMS 마이크, 가속도계, 터치패널 등 내장.
- 고성능 MCU 테스트 및 실시간 처리, RTOS, 그래픽 UI 학습에 적합.

**하드웨어 사양 (시리즈별 상이):**

- MCU: STM32F4, F7, H7, L4, WB, WL 등
- 디버거: ST-Link/V2-1 내장
- 통신: USB OTG FS/HS, Ethernet (일부 모델), UART, I²C, SPI
- 주변장치: LCD, 터치센서, 오디오 코덱, MEMS 마이크, 가속도/자이로 센서
- 전원: USB 5V 또는 외부 입력
- 크기: 보드별 상이 (기능에 따라 확장형 구조)

**특징:**

- 그래픽 LCD 및 센서 포함으로 별도 외부 장치 없이 실습 가능.
- FreeRTOS, TouchGFX, USB, Audio Class 등 고급 예제 포함.
- 일부 보드는 외부 확장 커넥터(ST morpho, Arduino 호환) 제공.

**예시 모델:**

- STM32F4DISCOVERY — Cortex-M4 (168MHz), 오디오 코덱, MEMS 마이크 내장
- STM32F746G-DISCO — 4.3” TFT-LCD + 터치스크린 내장
- STM32H735G-DK — Ethernet, USB HS/FS, TFT-LCD, SDRAM 내장

------

### 비교 요약

| 구분          | 제조사   | MCU           | ST-Link 내장 | 특징                       | 주요 용도                         |
| ------------- | -------- | ------------- | ------------ | -------------------------- | --------------------------------- |
| **Blue Pill** | 서드파티 | STM32F103C8T6 | X            | 저가, 소형, 교육용         | 입문자, 실습용                    |
| **Nucleo**    | ST 공식  | 시리즈별 다양 | O            | 표준화된 폼팩터, 확장성    | 일반 개발, CubeIDE 학습           |
| **Discovery** | ST 공식  | 고성능 시리즈 | O            | 센서·LCD 내장, 고급 실습용 | 실무 프로토타입, RTOS·그래픽 실습 |

------

세 보드는 모두 STM32CubeIDE와 HAL 라이브러리 기반으로 완전한 호환성을 가지며, 개발 목적에 따라 선택된다.

- **Blue Pill:** 저가 실습, 회로 이해 중심
- **Nucleo:** 정석적인 CubeMX/CubeIDE 학습 및 확장성
- **Discovery:** 고성능, 실무용, 복잡한 주변장치 실습

다음 단원에서는 **CubeIDE 설치 및 설정 과정**을 다룬다.

## 1.5 CubeIDE 설치 및 설정

STM32CubeIDE는 STMicroelectronics에서 공식적으로 제공하는 통합 개발 환경(Integrated Development Environment, IDE)으로, **Eclipse CDT 기반 구조** 위에 **STM32CubeMX 코드 생성기**, **GNU Arm Embedded Toolchain(GCC)**, **GDB 디버거**, **ST-LINK 플래시 및 디버깅 툴**, **CubeMonitor 연동 인터페이스** 등이 통합되어 있다.
 STM32 전 제품군(F0~H7, G0, L0~L5, WB, WL 등)을 단일 환경에서 지원하며, CubeMX 설정과 코드 생성을 IDE 내부에서 직접 수행할 수 있다.

------

### 1.5.1 CubeIDE 다운로드 및 설치

1. **공식 다운로드 경로**
   - STMicroelectronics 공식 사이트: https://www.st.com/stm32cubeide
   - 운영체제별 지원: Windows / macOS / Linux (Ubuntu 20.04 이상)
2. **설치 구성 옵션**
   - **ST-LINK 드라이버**: USB를 통해 보드와 통신하기 위한 필수 드라이버.
   - **Java Runtime 포함 여부**: CubeIDE는 Eclipse 기반으로 Java 환경을 필요로 하며, 내장 JRE 포함 버전 선택 권장.
   - **Workspace 경로 설정**: 기본 프로젝트 저장 위치 설정 (예: `C:\STM32Projects`).
3. **설치 후 확인**
   - 최초 실행 시 **STM32CubeMX 통합 모드** 확인 창 표시.
   - `Help → About STM32CubeIDE`에서 버전 및 빌드 정보 확인 가능.

------

### 1.5.2 기본 환경 설정

1. **Toolchain 설정**
   - 내부 GCC toolchain 자동 포함 (`arm-none-eabi-gcc`).
   - `Window → Preferences → STM32Cube → Toolchain`에서 컴파일러 경로 확인 가능.
2. **ST-Link 연결 설정**
   - `Run → Debug Configurations → ST-Link GDB Server` 메뉴에서 연결 장치 선택.
   - Interface: SWD / JTAG 중 선택 (STM32 대부분은 SWD 사용).
   - Reset mode: “Connect under reset” 설정 시 초기화 후 디버깅 안정적.
3. **Editor 설정**
   - `Window → Preferences → C/C++ → Editor → Syntax Coloring`에서 코드 가독성 개선 가능.
   - 자동 완성(Autocomplete), 매크로 정의 Jump 기능 활성화.

------

### 1.5.3 프로젝트 구조 개요

CubeIDE에서 생성된 STM32 프로젝트는 다음과 같은 디렉터리 구조를 가진다:

```
ProjectName/
 ├── Core/
 │   ├── Inc/                 # 사용자 헤더 파일
 │   └── Src/                 # 사용자 소스 파일
 ├── Drivers/
 │   ├── CMSIS/               # Cortex-M 코어 및 장치별 CMSIS 헤더
 │   └── STM32F1xx_HAL_Driver # HAL 소스 코드
 ├── Middlewares/             # FATFS, FreeRTOS 등
 ├── STM32CubeMX/
 ├── .project, .cproject      # Eclipse 프로젝트 설정 파일
 └── Makefile                 # 빌드 자동화 스크립트
```

------

## 1.6 CubeMX 연동과 프로젝트 생성

STM32CubeMX는 MCU의 하드웨어 주변장치를 그래픽 기반으로 설정하고, HAL 초기화 코드를 자동 생성하는 툴이다. CubeIDE 내부에 완전히 통합되어 있어, 별도 프로그램을 실행하지 않아도 Pin 설정 및 Peripheral 초기화를 수행할 수 있다.

------

### 1.6.1 CubeMX 연동 모드

1. **Integrated Mode (통합 모드)**
   - CubeIDE 내에서 `.ioc` 파일을 열면 CubeMX UI가 직접 표시됨.
   - Pinout, Clock, Peripheral, NVIC, Middleware 설정을 동일 IDE 환경에서 처리 가능.
2. **Standalone Mode (독립 실행 모드)**
   - 별도의 CubeMX 실행 파일로 설정 후 `.ioc` 파일을 CubeIDE에 Import 가능.
   - 대규모 프로젝트나 기존 코드 베이스를 병합할 때 유용.

------

### 1.6.2 프로젝트 생성 절차

1. **New STM32 Project 선택**
   - `File → New → STM32 Project`
   - MCU 선택창에서 Part Number 또는 Board 선택 가능 (예: STM32F103C8Tx, NUCLEO-F401RE).
2. **Pinout Configuration**
   - 핀을 클릭하여 기능 지정 (예: PA9 → USART1_TX, PA10 → USART1_RX).
   - 충돌 시 CubeMX가 자동 경고 표시.
3. **Clock Configuration**
   - HSE, HSI, PLL 설정을 통해 System Clock 주파수 결정.
   - `SYSCLK`, `HCLK`, `PCLK1/2` 주파수를 그래픽으로 확인 가능.
4. **Peripherals Configuration**
   - GPIO, ADC, TIM, UART, I²C, SPI, DMA 등 모듈별 파라미터 설정.
   - NVIC Interrupt 우선순위 및 활성화 가능.
5. **Code Generator 설정**
   - `Project Manager → Code Generator`
   - “Generate peripheral initialization as a pair of .c/.h files per peripheral” 옵션 권장.
6. **Code Generation**
   - `Project → Generate Code` 실행 → CubeIDE 내 자동 컴파일 프로젝트 생성.

------

### 1.6.3 빌드 및 디버깅

1. **Build**
   - `Project → Build All` 또는 `Ctrl+B`
   - 내부 GCC toolchain으로 컴파일 및 링크 진행.
2. **Debug**
   - `Run → Debug` 선택 후 ST-Link 자동 인식.
   - 실시간 변수 확인(Expressions), 메모리 뷰, 레지스터 뷰 제공.
3. **Console Output**
   - `SWO Viewer` 또는 UART 리다이렉션을 통해 printf 디버깅 가능.

------

## 1.7 CMSIS / HAL / LL / BSP 구조 이해

STM32 펌웨어 아키텍처는 **CMSIS(Core + Device)**, **HAL(High Abstraction Layer)**, **LL(Low Layer)**, **BSP(Board Support Package)**의 네 계층으로 구성되어 있으며, 상위 계층일수록 하드웨어 추상화 수준이 높고 이식성이 향상된다.

------

### 1.7.1 CMSIS (Cortex Microcontroller Software Interface Standard)

- **정의:** ARM에서 정의한 Cortex-M 프로세서용 표준 인터페이스.
- **주요 구성 요소:**
  1. **Core Layer:** NVIC, SysTick, SCB 등의 레지스터 정의 및 코어 함수 제공 (`core_cm3.h` 등).
  2. **Device Layer:** STMicroelectronics가 MCU별로 작성한 `system_stm32f1xx.c`, `startup_stm32f1xx.s` 파일 포함.
  3. **RTOS Layer:** CMSIS-RTOS v1/v2 API 지원.
- **주요 기능:**
  - 표준화된 레지스터 명칭 및 접근 방식 제공.
  - 벡터 테이블 정의, 인터럽트 핸들러 구조 일원화.
  - HAL 및 LL 레이어의 기반 구조로 활용.

------

### 1.7.2 HAL (Hardware Abstraction Layer)

- **정의:** ST에서 제공하는 고수준 하드웨어 추상화 API 세트.

- **특징:**

  - 레지스터 직접 접근 없이 주변장치 제어 가능.
  - 코드 가독성 높고 유지보수 용이.
  - CubeMX에서 자동 생성되는 초기화 및 드라이버의 핵심.

- **예시:**

  ```
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
  HAL_ADC_Start(&hadc1);
  HAL_UART_Transmit(&huart1, data, len, 100);
  ```

- **장점:** 이식성, 구조적 코드, ST 공식 문서와 일관성 유지.

- **단점:** 함수 오버헤드 존재, 실시간 제약 시스템에서는 비효율적일 수 있음.

------

### 1.7.3 LL (Low-Layer API)

- **정의:** HAL보다 하위 수준의 API로, 레지스터 접근에 근접한 성능 중심 드라이버.

- **특징:**

  - 인라인 함수 기반, 빠른 실행 속도.
  - HAL과 병용 가능 (필요한 부분만 LL로 대체).
  - CubeMX에서 HAL 대신 LL 선택 가능.

- **예시:**

  ```
  LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_5);
  LL_TIM_EnableCounter(TIM2);
  ```

- **장점:** 성능 최적화, ISR 내에서 유용.

- **단점:** 이식성 및 유지보수성은 HAL 대비 낮음.

------

### 1.7.4 BSP (Board Support Package)

- **정의:** ST에서 제공하는 보드별 하드웨어 초기화 계층.
- **예시:** Nucleo, Discovery, Evaluation 보드용.
- **주요 기능:**
  - LED, 버튼, LCD, 센서 등의 보드 전용 핀매핑 제공.
  - `BSP_LED_On(LED2);`, `BSP_PB_GetState(BUTTON_USER);` 형태로 사용.
  - HAL 상위 계층으로 동작하며, 사용자 애플리케이션과 HAL 간의 인터페이스 역할 수행.

------

이 네 계층은 STM32 펌웨어 개발의 기반이며, **CMSIS → HAL/LL → BSP → Application** 순으로 계층화되어 있다.
 실무에서는 HAL 기반으로 전체 코드를 구성하고, 성능이 중요한 구간만 LL로 보완하는 방식이 일반적이다.

## 1.8 Toolchain 구성 (GCC ARM, Linker Script, Startup File)

STM32CubeIDE의 빌드 시스템은 **GNU Arm Embedded Toolchain (arm-none-eabi)**을 기반으로 하며, C/C++ 컴파일러, 어셈블러, 링커, 디버거로 구성된다. 빌드 과정은 Eclipse CDT의 Makefile 빌드 체계를 따르며, 프로젝트 생성 시 자동으로 `Makefile`, `linker script (.ld)`, `startup file (.s)`이 구성된다.
 Toolchain은 STM32 마이크로컨트롤러의 메모리 구조, 인터럽트 벡터, 초기화 루틴을 정확히 반영해야 하며, 각 구성 요소는 시스템 동작의 근간을 이룬다.

------

### 1.8.1 GNU Arm Embedded Toolchain 구성 요소

1. **Compiler (arm-none-eabi-gcc)**

   - C/C++ 소스 파일을 오브젝트 파일(`.o`)로 컴파일한다.

   - STM32의 Cortex-M0/M3/M4/M7 코어 아키텍처에 따라 `-mcpu=cortex-mX` 옵션이 지정된다.

   - 주요 컴파일 옵션 예시:

     ```
     -mcpu=cortex-m3 -mthumb -O2 -ffunction-sections -fdata-sections
     -Wall -Wextra -std=c11
     ```

   - `-O0 ~ -O3` : 최적화 수준 지정

   - `-g` : 디버깅 심볼 포함 (디버그 빌드용)

2. **Assembler (arm-none-eabi-as)**

   - 어셈블리 코드(`.s`)를 기계어 오브젝트로 변환.
   - Startup 파일(`startup_stm32f1xx.s`) 컴파일 시 사용된다.

3. **Linker (arm-none-eabi-ld)**

   - 오브젝트 파일을 결합하고, 메모리 주소 매핑을 수행한다.

   - 링커 스크립트(`STM32F103C8TX_FLASH.ld`)를 참조하여 FLASH, RAM, STACK 등의 위치 결정.

   - 주요 옵션:

     ```
     -TSTM32F103C8TX_FLASH.ld --gc-sections -Wl,-Map=output.map
     ```

4. **Debugger (arm-none-eabi-gdb)**

   - ST-LINK 또는 OpenOCD를 통해 MCU에 코드 다운로드 및 실시간 디버깅 수행.
   - Breakpoint, Watchpoint, Memory View 기능 제공.

------

### 1.8.2 Linker Script (.ld 파일) 구조

링커 스크립트는 **MCU 메모리 구조와 섹션 배치 정책**을 정의하는 핵심 파일이다.

```
/* Memory regions definition */
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
  RAM (xrw)  : ORIGIN = 0x20000000, LENGTH = 20K
}

/* Section mapping */
SECTIONS
{
  .isr_vector : { KEEP(*(.isr_vector)) } >FLASH
  .text       : { *(.text*) } >FLASH
  .data       : { *(.data*) } >RAM AT> FLASH
  .bss        : { *(.bss*) } >RAM
  ._user_heap_stack : { . = . + _Min_Heap_Size + _Min_Stack_Size; } >RAM
}
```

- **`.isr_vector`** : 인터럽트 벡터 테이블 (Reset_Handler 포함)
- **`.text`** : 실행 코드 영역 (함수, 상수)
- **`.data`** : 초기화된 전역 변수 (RAM에 복사됨)
- **`.bss`** : 초기화되지 않은 전역 변수 (자동 0 초기화)
- **`.heap` / `.stack`** : 동적 메모리 및 스택 영역

링커는 이러한 매핑 정보를 기준으로 프로그램의 물리적 주소를 결정한다.

------

### 1.8.3 Startup File (startup_stm32f1xx.s)

Startup 파일은 MCU 리셋 후 최초로 실행되는 코드이며, **시스템 초기화 및 C 런타임 환경 설정**을 담당한다.

주요 역할:

1. 초기 스택 포인터 설정 (`_estack` 레이블 사용).
2. 인터럽트 벡터 테이블 정의.
3. `SystemInit()` 호출 (클록 및 기본 설정).
4. `.data`, `.bss` 섹션 초기화.
5. `main()` 함수 호출.

예시 구조:

```
Reset_Handler:
  LDR R0, =_estack        ; 초기 스택 포인터 설정
  BL  SystemInit           ; 시스템 클록 초기화
  BL  __libc_init_array    ; C 런타임 초기화
  BL  main                 ; main() 함수로 이동
LoopForever:
  B LoopForever
```

**Interrupt Vector Table 예시:**

```
  .section .isr_vector
  .word _estack
  .word Reset_Handler
  .word NMI_Handler
  .word HardFault_Handler
  ...
```

모든 핸들러는 약한 심볼(weak symbol)로 정의되어 있으며, 사용자가 동일한 이름으로 함수를 정의하면 자동으로 오버라이드된다.

------

### 1.8.4 Makefile

CubeIDE는 자동으로 Makefile을 생성하며, 주요 구성 요소는 다음과 같다.

```
CC = arm-none-eabi-gcc
CFLAGS = -mcpu=cortex-m3 -mthumb -O2 -ffunction-sections
LDFLAGS = -TSTM32F103C8TX_FLASH.ld --gc-sections
SRCS = $(wildcard Core/Src/*.c)
OBJS = $(SRCS:.c=.o)
TARGET = Project.elf

$(TARGET): $(OBJS)
    $(CC) $(OBJS) $(LDFLAGS) -o $@
```

Makefile을 수정함으로써, 컴파일 옵션이나 외부 라이브러리 경로를 추가할 수 있다.

------

## 1.9 Clock Configuration (HSE, HSI, PLL 설정)

STM32의 클록 시스템은 매우 유연하며, **내부 오실레이터(HSI/LSE)**, **외부 크리스털(HSE/LSE)**, **PLL(Phase Locked Loop)** 등을 이용해 다양한 클록 도메인(HCLK, PCLK1, PCLK2)을 구성한다.
 적절한 클록 설정은 시스템 안정성과 성능, 그리고 전력 효율에 직결된다.

------

### 1.9.1 기본 클록 소스

1. **HSI (High-Speed Internal Clock)**
   - 내부 RC 오실레이터, 8MHz 또는 16MHz (시리즈별 상이).
   - 빠른 기동 속도, 외부 부품 불필요.
   - 단점: 온도 및 전압에 따른 주파수 오차 존재.
2. **HSE (High-Speed External Clock)**
   - 외부 크리스털(4~25MHz) 또는 외부 클럭 입력 사용.
   - 고정밀 시스템(USB, CAN, UART 통신)에 권장.
3. **PLL (Phase Locked Loop)**
   - HSE 또는 HSI를 입력으로 받아 배수/분주하여 시스템 클록 생성.
   - 예: 8MHz HSE ×9 = 72MHz (STM32F1 기준)
   - `PLLMUL`, `PLLSRC`, `PREDIV` 값으로 조정 가능.
4. **LSI (Low-Speed Internal Clock)**
   - 32kHz 내부 오실레이터, RTC 또는 독립 Watchdog용.
5. **LSE (Low-Speed External Clock)**
   - 32.768kHz 크리스털, RTC의 시간 기준용.

------

### 1.9.2 클록 트리 구조

STM32의 클록 트리는 다음과 같은 주요 버스로 구성된다.

```
SYSCLK → AHB (HCLK) → APB1 (PCLK1), APB2 (PCLK2)
```

- **HCLK** : CPU, DMA, AHB 버스 클록
- **PCLK1/2** : 주변장치 클록 (TIM, USART, I²C 등)
- **ADCCLK** : ADC 전용 클록

CubeMX에서는 Clock Configuration 탭에서 그래픽으로 클록 트리를 확인하고, 주파수 타당성(Clock Validity Check)을 실시간으로 검증할 수 있다.

------

### 1.9.3 클록 설정 절차 (CubeMX 기준)

1. **Clock Source 선택 (HSE/HSI)**
2. **PLL Enable 및 배수 설정 (PLLMUL)**
3. **System Clock Source를 PLL로 변경**
4. **AHB, APB Prescaler 설정 (1, 2, 4, 8 등)**
5. **Flash Latency 설정 (주파수에 따라 Wait State 지정)**

예시: STM32F103C8T6 (72MHz 구성)

```
HSE = 8MHz
PLL MUL = 9
SYSCLK = 72MHz
HCLK = 72MHz
PCLK1 = 36MHz
PCLK2 = 72MHz
```

------

### 1.9.4 SystemCoreClock 업데이트

`system_stm32f1xx.c` 파일의 `SystemCoreClockUpdate()` 함수는 현재 설정된 SYSCLK 값을 계산해 `SystemCoreClock` 변수에 저장한다.
 이 변수는 HAL 및 FreeRTOS Tick 설정 등 여러 시스템 모듈에서 참조된다.

------

## 1.10 Debug / Release Configuration 관리

CubeIDE에서는 하나의 프로젝트 안에 여러 **빌드 설정(Configuration)** 을 저장할 수 있으며, 일반적으로 **Debug**와 **Release** 두 가지 모드가 존재한다.
 각 모드는 최적화, 디버깅 심볼, 로그 출력 여부 등에서 차이를 가진다.

------

### 1.10.1 Debug Configuration

**목적:** 개발 단계에서 코드 검증 및 디버깅에 사용.

- **컴파일 옵션:**

  ```
  -O0 -g3 -Wall
  ```

  (최적화 최소화, 디버깅 정보 최대화)

- **링크 설정:**

  - 디버그 심볼 포함 (`.elf` 파일에 포함).
  - ST-LINK GDB 서버를 통한 실시간 디버깅 지원.

- **특징:**

  - Breakpoint, Watchpoint, Memory View, Variable Watch 가능.
  - `printf` 디버깅 가능 (SWO, UART, ITM).
  - 코드 실행 시간 및 스택 사용량 분석 가능.

------

### 1.10.2 Release Configuration

**목적:** 최종 제품 배포용 빌드.

- **컴파일 옵션:**

  ```
  -O3 -DNDEBUG
  ```

  (최대 최적화, 디버깅 코드 제거)

- **특징:**

  - 코드 크기 최소화, 실행 속도 최대화.
  - 디버깅 심볼 제거 (`.elf` 대신 `.bin` 또는 `.hex` 생성).
  - 불필요한 로그, assert, 테스트 코드 제거.

- **추가 설정:**

  - `Project → Properties → C/C++ Build → Settings → Tool Settings → Optimization` 에서 조정 가능.
  - 릴리즈 빌드 시, `assert_param` 매크로를 비활성화(`USE_FULL_ASSERT` undefined).

------

### 1.10.3 Build Output 관리

빌드 후 생성되는 파일은 `Debug/` 또는 `Release/` 폴더에 저장된다.

- **.elf** : 디버깅 정보 포함 실행 파일
- **.bin** : 플래시 다운로드용 순수 바이너리
- **.hex** : 인텔 HEX 형식 (대부분의 프로그래머 호환)
- **.map** : 메모리 맵 파일 (섹션별 메모리 배치 정보)

예시 구조:

```
Project/
 ├── Debug/
 │    ├── Project.elf
 │    ├── Project.bin
 │    ├── Project.map
 └── Release/
      ├── Project.elf
      ├── Project.hex
```

------

### 1.10.4 Configuration 전환

- **전환 방법:**
  - IDE 상단의 “Build Configurations” 드롭다운 메뉴에서 선택
  - 또는 `Project → Build Configurations → Set Active`
- **권장 관리 전략:**
  - Debug: 내부 로직 검증, 실시간 변수 모니터링
  - Release: 코드 크기 및 성능 검증, 전력 최적화 테스트

------

### 1.10.5 디버깅 관련 주의 사항

- **최적화와 디버깅의 상충:**
  - `-O2` 이상에서는 변수 최적화로 인해 Watch에서 값이 보이지 않을 수 있음.
- **SWO 활성화 필요:**
  - `CoreSight ITM` 및 `SWO Pin (PB3)` 활성화 시 실시간 printf 디버깅 가능.
- **Watchdog 활성화 시 디버깅 중지:**
  - 디버깅 중 WDT 비활성화(`HAL_DBGMCU_EnableDBGStopMode()`) 필요.

------

이와 같이 STM32CubeIDE의 Toolchain과 Configuration 체계를 이해하면, 프로젝트의 메모리 효율, 실행 속도, 디버깅 안정성을 정밀하게 제어할 수 있다.