# 8. UART / USART

## 8.1 ë¹„ë™ê¸° ì§ë ¬ í†µì‹  ì›ë¦¬

### ê°œìš”

ë¹„ë™ê¸° ì§ë ¬ í†µì‹ (Asynchronous Serial Communication)ì€ ì†¡ì‹  ì¸¡ê³¼ ìˆ˜ì‹  ì¸¡ì´ **ê³µìœ ëœ í´ë¡ ì‹ í˜¸ ì—†ì´** ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” ë°©ì‹ì´ë‹¤.
 UART(Universal Asynchronous Receiver/Transmitter)ëŠ” ì´ëŸ¬í•œ ë¹„ë™ê¸° í†µì‹ ì„ í•˜ë“œì›¨ì–´ ë ˆë²¨ì—ì„œ êµ¬í˜„í•˜ëŠ” ëŒ€í‘œì ì¸ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
 ì†¡ìˆ˜ì‹  ë¼ì¸ì€ ì¼ë°˜ì ìœ¼ë¡œ **TX (Transmit)**, **RX (Receive)** ë‘ ê°œë§Œ ì‚¬ìš©í•˜ë©°,
 ë³´ë“œ ê°„ ê°„ë‹¨í•œ ë°ì´í„° êµí™˜, ë””ë²„ê¹… ì½˜ì†”, ì„¼ì„œ í†µì‹  ë“± ë‹¤ì–‘í•œ ìš©ë„ë¡œ í™œìš©ëœë‹¤.

------

### ë™ì‘ ì›ë¦¬

ë¹„ë™ê¸° í†µì‹ ì€ ê° ë°”ì´íŠ¸(ë¬¸ì)ë¥¼ **Start Bit â†’ Data Bit â†’ Parity Bit â†’ Stop Bit** ìˆœìœ¼ë¡œ ì „ì†¡í•œë‹¤.
 ëª¨ë“  ë¹„íŠ¸ëŠ” ì†¡ì‹  ì¸¡ê³¼ ìˆ˜ì‹  ì¸¡ì´ ì•½ì†í•œ **ë³´ì˜¤ë ˆì´íŠ¸(baud rate)** ì— ë”°ë¼ ì¼ì •í•œ ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ì „ì†¡ëœë‹¤.

#### ì „ì†¡ í”„ë ˆì„ êµ¬ì¡° ì˜ˆì‹œ (8N1: 8-bit data, No parity, 1 stop bit)

```
Line Idle (HIGH)
     â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Start  â”‚       Data Bits (8)       â”‚  Stop  â”‚
 â”‚  (0)   â”‚  b0  b1  b2  b3  b4  b5  b6  b7   â”‚  (1)
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### íŠ¹ì§•

- **Start Bit(1ë¹„íŠ¸)**: 0(LOW)ë¡œ ì „ì†¡, ë°ì´í„° ì‹œì‘ì„ ì•Œë¦¼
- **Data Bit(5~9ë¹„íŠ¸)**: ì‹¤ì œ ì „ì†¡ ë°ì´í„° (LSBë¶€í„° ì „ì†¡)
- **Parity Bit(ì˜µì…˜)**: ì—ëŸ¬ ê²€ì¶œìš© (Even/Odd/None)
- **Stop Bit(1~2ë¹„íŠ¸)**: 1(HIGH) ìœ ì§€, í”„ë ˆì„ ì¢…ë£Œ í‘œì‹œ
- **Idle ìƒíƒœ**: ë¼ì¸ì´ HIGHë¡œ ìœ ì§€ë¨

------

### ë¹„ë™ê¸° í†µì‹ ì˜ í•µì‹¬: í´ë¡ ë™ê¸°í™” ì—†ì´ ë™ì‘

ë¹„ë™ê¸° í†µì‹ ì€ ì†¡ì‹ ê¸°ì™€ ìˆ˜ì‹ ê¸° ì‚¬ì´ì— **í´ë¡ ì‹ í˜¸ê°€ ì—†ë‹¤.**
 ë”°ë¼ì„œ ìˆ˜ì‹ ê¸°ëŠ” **Start Bitì˜ í•˜ê°• ì—ì§€(1â†’0)** ë¥¼ ê°ì§€í•œ ë’¤,
 ìì²´ í´ë¡(ë³´ì˜¤ë ˆì´íŠ¸ ê¸°ë°˜)ì„ ì´ìš©í•´ ìƒ˜í”Œë§ íƒ€ì´ë°ì„ ê²°ì •í•œë‹¤.

#### ì˜ˆì‹œ

- ë³´ì˜¤ë ˆì´íŠ¸ = 9600bps â†’ 1ë¹„íŠ¸ë‹¹ ì•½ 104.17Âµs
- ìˆ˜ì‹ ê¸°ëŠ” Start Bitì˜ í•˜ê°• ì—ì§€ ê°ì§€ í›„,
   1/2 ë¹„íŠ¸ ì‹œê°„ ë’¤ë¶€í„° ì¼ì • ê°„ê²©(104Âµs)ìœ¼ë¡œ 8íšŒ ìƒ˜í”Œë§ì„ ìˆ˜í–‰í•œë‹¤.

> ìˆ˜ì‹ ê¸°ì˜ ë‚´ë¶€ í´ë¡ ì˜¤ì°¨ê°€ Â±2%ë¥¼ ë„˜ìœ¼ë©´ í”„ë ˆì„ ê°„ ë™ê¸°ê°€ í‹€ì–´ì§ˆ ìˆ˜ ìˆë‹¤.
>  ë”°ë¼ì„œ ì–‘ìª½ ì¥ì¹˜ì˜ ë³´ì˜¤ë ˆì´íŠ¸ ì„¤ì •ì´ **ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•œë‹¤.**

------

### UARTì˜ ê¸°ë³¸ ì‹ í˜¸ êµ¬ì„±

| ì‹ í˜¸ ì´ë¦„          | ë°©í–¥   | ì„¤ëª…                                |
| ------------------ | ------ | ----------------------------------- |
| **TX**             | ì¶œë ¥   | MCUì—ì„œ ì™¸ë¶€ ì¥ì¹˜ë¡œ ë°ì´í„° ì „ì†¡     |
| **RX**             | ì…ë ¥   | ì™¸ë¶€ ì¥ì¹˜ì—ì„œ MCUë¡œ ë°ì´í„° ìˆ˜ì‹      |
| **GND**            | -      | ê³µí†µ ì ‘ì§€ (ì°¸ì¡° ì „ìœ„ ì¼ì¹˜)          |
| **RTS/CTS (ì„ íƒ)** | ì–‘ë°©í–¥ | í•˜ë“œì›¨ì–´ íë¦„ ì œì–´ (Flow Control)   |
| **DTR/DSR (ì„ íƒ)** | ì–‘ë°©í–¥ | ëª¨ë€ ì œì–´ ì‹ í˜¸ (ì¼ë¶€ í™˜ê²½ì—ì„œ ì‚¬ìš©) |

#### 3ì„  í†µì‹  (ê¸°ë³¸)

```
STM32 TX â†’ RX (PC/ëª¨ë“ˆ)
STM32 RX â† TX (PC/ëª¨ë“ˆ)
ê³µí†µ GND ì—°ê²°
```

------

### UART í†µì‹  íŒŒë¼ë¯¸í„°

| í•­ëª©             | ì˜ë¯¸                       | ì˜ˆì‹œ             |
| ---------------- | -------------------------- | ---------------- |
| **Baud Rate**    | 1ì´ˆë‹¹ ì „ì†¡ ë¹„íŠ¸ ìˆ˜         | 9600, 115200 bps |
| **Data Bits**    | í•œ í”„ë ˆì„ì˜ ë°ì´í„° ë¹„íŠ¸ ìˆ˜ | 8 bit            |
| **Parity**       | ì˜¤ë¥˜ ê²€ì¶œ ë¹„íŠ¸             | None, Even, Odd  |
| **Stop Bits**    | í”„ë ˆì„ ì¢…ë£Œ ë¹„íŠ¸ ìˆ˜        | 1 or 2           |
| **Flow Control** | ì „ì†¡ íë¦„ ì œì–´             | None, RTS/CTS    |

------

### UART ì „ì†¡ íƒ€ì´ë° ê³„ì‚°

ì „ì†¡ ì†ë„ëŠ” ë³´ì˜¤ë ˆì´íŠ¸ì™€ ë°ì´í„° í”„ë ˆì„ êµ¬ì„±ì— ë”°ë¼ ê²°ì •ëœë‹¤.

ì˜ˆì‹œ) 9600bps, 8N1 êµ¬ì„±

- 1 í”„ë ˆì„ = 1(Start) + 8(Data) + 1(Stop) = 10ë¹„íŠ¸
- 1ì´ˆ ë™ì•ˆ 960 í”„ë ˆì„ ì „ì†¡ ê°€ëŠ¥
- ì´ˆë‹¹ ì•½ 960Byte â‰ˆ 0.94KB/s ì†ë„

------

### UARTì™€ TTL, RS-232 ì „ê¸°ì  ì°¨ì´

| êµ¬ë¶„         | ì „ì•• ë ˆë²¨         | ì„¤ëª…                                           |
| ------------ | ----------------- | ---------------------------------------------- |
| **TTL UART** | 0V~3.3V (ë˜ëŠ” 5V) | MCU ê°„ ì§ì ‘ ì—°ê²°ìš©                             |
| **RS-232**   | Â±12V              | PC ì‹œë¦¬ì–¼ í¬íŠ¸ìš©, MAX232 ê°™ì€ ë ˆë²¨ ì‰¬í”„í„° í•„ìš” |
| **RS-485**   | ì°¨ë™ ì‹ í˜¸         | ì¥ê±°ë¦¬, ë‹¤ì¤‘ ë…¸ë“œ í†µì‹ ì— ì í•©                  |

#### íšŒë¡œ ì˜ˆì‹œ

```
STM32 (TX/RX 3.3V) â†” MAX232 â†” PC (RS232 í¬íŠ¸)
```

------

### ë™ì‘ ì˜ˆì‹œ

#### ì†¡ì‹  (TX)

1. UART ë“œë¼ì´ë²„ê°€ ì „ì†¡ ë²„í¼(Shift Register)ì— ë°ì´í„° ë¡œë“œ
2. Start Bit(LOW) ì¶œë ¥
3. Data Bits ìˆœì°¨ ì¶œë ¥ (LSB â†’ MSB)
4. Stop Bit(HIGH) ì¶œë ¥
5. Idle ìƒíƒœ ìœ ì§€

#### ìˆ˜ì‹  (RX)

1. Start Bit ê°ì§€ (1â†’0)
2. ë‚´ë¶€ íƒ€ì´ë¨¸ë¡œ ë¹„íŠ¸ íƒ€ì´ë° ê³„ì‚°
3. 8ê°œ ë¹„íŠ¸ë¥¼ ìˆœì°¨ ìƒ˜í”Œë§
4. Parity ê²€ì¦ (ì„ íƒì )
5. Stop Bit í™•ì¸ í›„ ë°ì´í„° ìˆ˜ì‹  ì™„ë£Œ ì¸í„°ëŸ½íŠ¸ ë°œìƒ

------

### UART í†µì‹  ì˜¤ë¥˜

| ì˜¤ë¥˜ ì¢…ë¥˜         | ì„¤ëª…               | ì›ì¸                     |
| ----------------- | ------------------ | ------------------------ |
| **Framing Error** | Stop Bit ê°ì§€ ì‹¤íŒ¨ | ë³´ì˜¤ë ˆì´íŠ¸ ë¶ˆì¼ì¹˜, ì¡ìŒ  |
| **Parity Error**  | íŒ¨ë¦¬í‹° ê²€ì¦ ì‹¤íŒ¨   | ë°ì´í„° ì „ì†¡ ì¤‘ ë¹„íŠ¸ ì†ìƒ |
| **Overrun Error** | RX ë²„í¼ ì˜¤ë²„í”Œë¡œ   | CPU ì²˜ë¦¬ ì§€ì—°            |
| **Noise Error**   | ë¼ì¸ ì „ì•• ë¶ˆì•ˆì •   | EMI, ì ‘ì§€ ë¶ˆëŸ‰           |

------

### STM32 UART í•˜ë“œì›¨ì–´ ë¸”ë¡ êµ¬ì¡°

```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚             UART              â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ TX Shift   â”‚ RX Shift         â”‚
 â”‚ Register   â”‚ Register         â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Baud Rate Generator (USART_BRR) â”‚
 â”‚ Status & Control (SR / CRx)     â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

------

### ì£¼ìš” ë ˆì§€ìŠ¤í„°

| ë ˆì§€ìŠ¤í„°      | ê¸°ëŠ¥                                |
| ------------- | ----------------------------------- |
| **USART_SR**  | ìƒíƒœ í”Œë˜ê·¸ (TXE, RXNE, ORE, FE ë“±) |
| **USART_DR**  | ë°ì´í„° ë²„í¼ (ì „ì†¡/ìˆ˜ì‹ )             |
| **USART_BRR** | ë³´ì˜¤ë ˆì´íŠ¸ ì„¤ì • (ë¶„ì£¼ê¸°)            |
| **USART_CR1** | UART í™œì„±í™”, ì¸í„°ëŸ½íŠ¸, íŒ¨ë¦¬í‹° ì„¤ì •  |
| **USART_CR2** | Stop Bit, í´ëŸ­ ê´€ë ¨ ì„¤ì •            |
| **USART_CR3** | DMA, Flow Control ì„¤ì •              |

------

### ë³´ì˜¤ë ˆì´íŠ¸ ì„¤ì • ê³µì‹

$$
USARTDIV = \frac{f_{CK}}{16 \times BaudRate}
$$

- `fCK`: UART í´ë¡ (ì˜ˆ: 72MHz)
- `USARTDIV`: BRR ë ˆì§€ìŠ¤í„°ì— ì…ë ¥ë  ê°’

ì˜ˆì‹œ
$$
USARTDIV = \frac{72,000,000}{16 \times 115200} â‰ˆ 39.0625
$$
â†’ `USART_BRR = 0x271` (ì†Œìˆ˜ì ì€ ë¶„ì£¼ê¸° ì²˜ë¦¬ë¨)

------

### ìš”ì•½

| í•­ëª©                | ë‚´ìš©                                             |
| ------------------- | ------------------------------------------------ |
| **í†µì‹  ë°©ì‹**       | í´ë¡ ì—†ì´ ë¹„ë™ê¸° í”„ë ˆì„ ì „ì†¡                     |
| **ëŒ€í‘œ ì¸í„°í˜ì´ìŠ¤** | UART                                             |
| **í•µì‹¬ ìš”ì†Œ**       | Start/Stop Bit, Baud Rate ë™ê¸°                   |
| **ì¥ì **            | íšŒë¡œ ê°„ë‹¨, MCU ë‚´ì¥ í•˜ë“œì›¨ì–´ í’ë¶€                |
| **ë‹¨ì **            | ë™ê¸° ì •í™•ë„ ì˜ì¡´, ì¥ê±°ë¦¬ ë¶ˆì•ˆì •                  |
| **ì£¼ìš” í™œìš©ì²˜**     | ë””ë²„ê¹… ì½˜ì†”, ì„¼ì„œ, ëª¨ë“ˆ í†µì‹  (GPS, BLE, LoRa ë“±) |

------

### ì°¸ê³  ë¬¸ì„œ

- RM0008 â€“ *USART (Universal Synchronous Asynchronous Receiver Transmitter)*
- AN3109 â€“ *USART communication between STM32 microcontrollers*
- UM1850 â€“ *STM32Cube HAL user manual (USART chapter)*
- ISO/IEC 8482 â€“ *Asynchronous serial communication standards*

## 8.2 Baudrate ê³„ì‚°

### ê°œìš”

Baudrate(ë³´ì˜¤ë ˆì´íŠ¸)ëŠ” **ì´ˆë‹¹ ì „ì†¡ë˜ëŠ” ë¹„íŠ¸ ìˆ˜(bps, bits per second)** ë¥¼ ì˜ë¯¸í•˜ë©°,
 UART í†µì‹ ì—ì„œ ì†¡ì‹  ì¸¡ê³¼ ìˆ˜ì‹  ì¸¡ì´ ë™ì¼í•œ íƒ€ì´ë°ìœ¼ë¡œ ë°ì´í„°ë¥¼ í•´ì„í•˜ê¸° ìœ„í•œ ê¸°ë³¸ ì†ë„ ê¸°ì¤€ì´ë‹¤.
 STM32ì˜ UART í•˜ë“œì›¨ì–´ëŠ” ë‚´ë¶€ í´ë¡(`fCK`)ì„ ë¶„ì£¼í•˜ì—¬ ì›í•˜ëŠ” Baudrateë¥¼ ìƒì„±í•œë‹¤.
 ì¦‰, í´ë¡ ì£¼íŒŒìˆ˜ì™€ ë¶„ì£¼ ë¹„ìœ¨ì˜ ì¡°í•©ì— ë”°ë¼ UART í†µì‹  íƒ€ì´ë°ì´ ê²°ì •ëœë‹¤.

------

### UART í´ë¡ ì†ŒìŠ¤

STM32 ì‹œë¦¬ì¦ˆì—ì„œ UARTì˜ í´ë¡ ì…ë ¥ì€ ë‹¤ìŒê³¼ ê°™ì´ ê²°ì •ëœë‹¤.

| MCU ì‹œë¦¬ì¦ˆ            | UART í´ë¡ ì†ŒìŠ¤                                     |
| --------------------- | -------------------------------------------------- |
| **STM32F1/F3**        | APB1 (USART2, USART3, UART4, UART5), APB2 (USART1) |
| **STM32F4/F7**        | APB1 ë˜ëŠ” APB2 í´ë¡                                |
| **STM32G/H/L ì‹œë¦¬ì¦ˆ** | ë…ë¦½ëœ USARTxCLK (PLL, HSI, LSE ë“± ì„ íƒ ê°€ëŠ¥)      |

ì˜ˆì‹œ (STM32F103 ê¸°ì¤€):

- `USART1` â†’ APB2 = 72 MHz
- `USART2` â†’ APB1 = 36 MHz
- `USART3` â†’ APB1 = 36 MHz

> UART í´ë¡ ì†ŒìŠ¤ë¥¼ ì˜ëª» ê³„ì‚°í•˜ë©´ ì‹¤ì œ Baudrateê°€ í‹€ì–´ì ¸ í†µì‹ ì´ ë¶ˆì•ˆì •í•´ì§ˆ ìˆ˜ ìˆë‹¤.

------

### Baudrate ìƒì„± ì›ë¦¬

UART ë³´ì˜¤ë ˆì´íŠ¸ ìƒì„± íšŒë¡œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë‹¤ìŒ ë¶„ì£¼ ê³µì‹ì„ ë”°ë¥¸ë‹¤.
$$
BaudRate = \frac{f_{CK}}{16 \times USARTDIV}
$$
ë”°ë¼ì„œ,
$$
USARTDIV = \frac{f_{CK}}{16 \times BaudRate}
$$

#### ì˜ˆì‹œ

- `fCK = 72 MHz`, `BaudRate = 115200 bps`

$$
USARTDIV = \frac{72,000,000}{16 \times 115,200} = 39.0625
$$

ë”°ë¼ì„œ BRR ë ˆì§€ìŠ¤í„°ì—ëŠ” ë‹¤ìŒì´ ì €ì¥ëœë‹¤.

- ì •ìˆ˜ë¶€(INT) = 39 (0x27)
- ì†Œìˆ˜ë¶€(FRAC) = 0.0625 Ã— 16 = 1 â†’ (0x1)

$$
USART_BRR = (INT << 4) + FRAC = 0x271
$$

ì¦‰, `USART_BRR = 0x271`ì´ë©´ ì•½ 115207bpsì˜ ì‹¤ì œ ì†ë„ê°€ ìƒì„±ëœë‹¤.

------

### STM32F1 ì‹œë¦¬ì¦ˆ BRR ë ˆì§€ìŠ¤í„° êµ¬ì¡°

| ë¹„íŠ¸   | ì´ë¦„           | ì„¤ëª…   |
| ------ | -------------- | ------ |
| [15:4] | `DIV_Mantissa` | ì •ìˆ˜ë¶€ |
| [3:0]  | `DIV_Fraction` | ì†Œìˆ˜ë¶€ |

UART ë‚´ë¶€ ë¶„ì£¼ê¸°ëŠ” `USART_BRR` ê°’ì„ ì½ì–´ `BaudRate Generator`ë¥¼ êµ¬ì„±í•œë‹¤.

------

### ì‹¤ì œ Baudrate ì˜¤ì°¨ ê³„ì‚°

UART í†µì‹ ì€ ì†¡ì‹ ê¸°ì™€ ìˆ˜ì‹ ê¸°ì˜ íƒ€ì´ë° ì˜¤ì°¨ê°€ ëˆ„ì ë˜ë©´ í”„ë ˆì„ ì‹±í¬ê°€ í‹€ì–´ì§„ë‹¤.
 ì˜¤ì°¨ìœ¨(Error Rate)ì€ ì•„ë˜ ì‹ìœ¼ë¡œ êµ¬í•œë‹¤.
$$
Error(\%) = \frac{|Baud_{actual} - Baud_{target}|}{Baud_{target}} \times 100
$$

#### ì˜ˆì‹œ

- ëª©í‘œ: 115200 bps
- ì‹¤ì œ: 115207 bps

$$
Error = \frac{|115207 - 115200|}{115200} \times 100 = 0.006\%
$$

â†’ **0.01% ì´í•˜**ë¡œ ë§¤ìš° ì•ˆì •ì ì¸ í†µì‹  ê°€ëŠ¥.

> ì‹¤ë¬´ì—ì„œëŠ” Â±2% ì´ë‚´ë©´ UART í”„ë ˆì„ ì‹±í¬ê°€ ìœ ì§€ëœë‹¤ê³  ë³¸ë‹¤.

------

### Baudrate ì˜¤ì°¨ì™€ í†µì‹  ì•ˆì •ì„± ê´€ê³„

| ì˜¤ì°¨ ë²”ìœ„  | í†µì‹  í’ˆì§ˆ   | ì„¤ëª…                                |
| ---------- | ----------- | ----------------------------------- |
| Â±0.5% ì´í•˜ | ë§¤ìš° ì•ˆì •ì  | ê³ ì† í†µì‹ (>1Mbps) ê°€ëŠ¥              |
| Â±1.0% ì´í•˜ | ì‹¤ìš©ì  ë²”ìœ„ | ì¼ë°˜ MCU ê°„ í†µì‹  ì í•©               |
| Â±2.0%      | ê²½ê³„ì„       | ì¼ë¶€ ì¥ë¹„ì—ì„œ í”„ë ˆì„ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥ |
| Â±5.0% ì´ìƒ | ë¶ˆì•ˆì •      | Start/Stop Bit ê°ì§€ ì‹¤íŒ¨            |

------

### ê³ ì† Baudrate (1Mbps ì´ìƒ) ì„¤ì • ì‹œ ì£¼ì˜ì‚¬í•­

1. **APB í´ë¡ê³¼ Baudrate ê°„ ì •ìˆ˜ ë°°ìˆ˜ ì—¬ë¶€ í™•ì¸**
   - 72MHz / (16Ã—115200) = 39.0625 â†’ ì •ìˆ˜ ì•„ë‹˜ â†’ ì˜¤ì°¨ ë°œìƒ
   - 72MHz / (16Ã—1,000,000) = 4.5 â†’ Fraction ì¡´ì¬ â†’ ì‹¤ì œëŠ” ì•½ê°„ ë‚®ì€ ì†ë„
2. **HSE í´ë¡ ì •ë°€ë„ ì¤‘ìš”**
   - ì™¸ë¶€ í¬ë¦¬ìŠ¤í„¸(Â±50ppm) ì‚¬ìš© ê¶Œì¥
   - ë‚´ë¶€ HSI í´ë¡(Â±1%) ì‚¬ìš© ì‹œ ì˜¤ì°¨ ëˆ„ì  ê°€ëŠ¥
3. **DMA ì‚¬ìš© ì‹œ FIFO íƒ€ì´ë° í™•ì¸**
   - Baudrate ë†’ì„ìˆ˜ë¡ DMA ì „ì†¡ ì£¼ê¸°ê°€ ì§§ì•„ì ¸ ì˜¤ë²„ëŸ°(Overrun) ìœ„í—˜ ì¦ê°€

------

### CubeMXë¥¼ í†µí•œ Baudrate ì„¤ì •

1. **Pinout & Configuration**

   - USARTx ì„ íƒ â†’ Mode: Asynchronous

2. **Parameter Settings**

   - Baud Rate: 9600, 115200 ë“± ì„¤ì •

3. **Clock Configuration**

   - APB í´ë¡ í™•ì¸ (`fCK` ê°’ì´ ì¶©ë¶„íˆ ë†’ì•„ì•¼ í•¨)

4. **Project Generation í›„ main.c í™•ì¸**

   - ìë™ ìƒì„±ëœ ì½”ë“œ ì˜ˆì‹œ:

     ```
     huart1.Init.BaudRate = 115200;
     huart1.Init.WordLength = UART_WORDLENGTH_8B;
     huart1.Init.StopBits = UART_STOPBITS_1;
     huart1.Init.Parity = UART_PARITY_NONE;
     HAL_UART_Init(&huart1);
     ```

------

### STM32 HAL ë‚´ë¶€ Baudrate ê³„ì‚° ê³¼ì •

HAL ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì´ˆê¸°í™” ì‹œ ë‹¤ìŒ ê³„ì‚° ê³¼ì •ì„ ìˆ˜í–‰í•œë‹¤.

1. `HAL_RCC_GetPCLKxFreq()` í•¨ìˆ˜ë¡œ UART í´ë¡ ì£¼íŒŒìˆ˜ íšë“

2. ë‚´ë¶€ ë§¤í¬ë¡œ `UART_BRR_SAMPLING16()` ì´ìš©

   ```
   #define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)  \
     ((uint32_t)(((_PCLK_)*25U)/(4U*(_BAUD_))))
   ```

3. ê³„ì‚°ëœ ê²°ê³¼ë¥¼ `USARTx->BRR`ì— ê¸°ë¡

> ìƒ˜í”Œë§ ëª¨ë“œì— ë”°ë¼ (16x / 8x) ê³„ì‚° ë°©ì‹ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
>  STM32F4 ì´í›„ ì¼ë¶€ ì‹œë¦¬ì¦ˆëŠ” 8ë°° ì˜¤ë²„ìƒ˜í”Œë§(`OVER8 = 1`) ê¸°ëŠ¥ì„ ì§€ì›í•œë‹¤.

------

### ì˜¤ë²„ìƒ˜í”Œë§ ëª¨ë“œ

| ëª¨ë“œ            | íŠ¹ì§•                       | BRR ê³„ì‚°ì‹                   |
| --------------- | -------------------------- | ---------------------------- |
| **16ë°° (ê¸°ë³¸)** | ì•ˆì •ì , ì¼ë°˜ì ì¸ UART      | $BRR = f_{CK} / (16 Ã— Baud)$ |
| **8ë°° (ê³ ì†)**  | 2ë°° ë¹ ë¥¸ ìƒ˜í”Œë§, ì „ë ¥ ì ˆì•½ | $BRR = f_{CK} / (8 Ã— Baud)$  |

ì˜ˆì‹œ (fCK=72MHz, Baud=921600, OVER8=1):
$$
USARTDIV = \frac{72,000,000}{8 \times 921,600} = 9.77
$$
`BRR â‰ˆ 0x9C` â†’ ì‹¤ì œ Baud â‰ˆ 921,875bps (ì˜¤ì°¨ 0.03%)

------

### ì‹¤ì „ ê³„ì‚° ìš”ì•½

| íŒŒë¼ë¯¸í„°          | ì˜ˆì‹œ                |
| ----------------- | ------------------- |
| MCU í´ë¡ (fCK)    | 72MHz               |
| ëª©í‘œ Baudrate     | 115200bps           |
| ë¶„ì£¼ê¸° (USARTDIV) | 39.0625             |
| ì‹¤ì œ Baudrate     | 115207bps           |
| ì˜¤ì°¨ìœ¨            | 0.006%              |
| ì„¤ì • ë ˆì§€ìŠ¤í„°     | `USART_BRR = 0x271` |

------

### ê³ ì† í†µì‹ (>1Mbps) ì‹¤ìŠµ íŒ

- DMA ê¸°ë°˜ ì†¡ìˆ˜ì‹  ì‚¬ìš© (`HAL_UART_Transmit_DMA`, `HAL_UART_Receive_DMA`)
- NVIC ìš°ì„ ìˆœìœ„ ì¡°ì • (TX/RX ì¸í„°ëŸ½íŠ¸ ì§€ì—° ìµœì†Œí™”)
- RX ë²„í¼ í¬ê¸° í™•ëŒ€
- HSE ê¸°ë°˜ í´ë¡ í•„ìˆ˜

------

### ì°¸ê³  ë¬¸ì„œ

- RM0008 â€“ *USART section, Baud Rate Generation*
- AN3109 â€“ *USART communication between STM32 microcontrollers*
- UM1850 â€“ *STM32Cube HAL User Manual (USART chapter)*
- ST Application Note AN2582 â€“ *USART baud rate calculation example*

## 8.3 HAL_UART Transmit/Receive

**UART ì†¡ìˆ˜ì‹  ê¸°ë³¸ ê°œë…**
 UART(Universal Asynchronous Receiver/Transmitter)ëŠ” ë¹„ë™ê¸° ì§ë ¬ í†µì‹  ë°©ì‹ìœ¼ë¡œ, MCU ê°„ ë˜ëŠ” MCU â†” PC ê°„ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ê¸° ìœ„í•´ ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë©ë‹ˆë‹¤.
 STM32ì˜ HALì—ì„œëŠ” `UART_HandleTypeDef` êµ¬ì¡°ì²´ë¥¼ í†µí•´ í•˜ë“œì›¨ì–´ ìì›ì„ ê´€ë¦¬í•˜ë©°, ì†¡ì‹ /ìˆ˜ì‹ ì€ Polling, Interrupt, DMA ì„¸ ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ì§€ì›ë©ë‹ˆë‹¤.

------

### HAL UART ì£¼ìš” í•¨ìˆ˜ ë¶„ë¥˜

| êµ¬ë¶„                         | í•¨ìˆ˜ëª…                                               | íŠ¹ì§•                                  |
| ---------------------------- | ---------------------------------------------------- | ------------------------------------- |
| **Polling (Blocking)**       | `HAL_UART_Transmit()` / `HAL_UART_Receive()`         | ì „ì†¡ì´ ì™„ë£Œë  ë•Œê¹Œì§€ CPU ëŒ€ê¸°         |
| **Interrupt (Non-blocking)** | `HAL_UART_Transmit_IT()` / `HAL_UART_Receive_IT()`   | ì¸í„°ëŸ½íŠ¸ë¥¼ í†µí•´ ì†¡ìˆ˜ì‹  ì™„ë£Œ ì‹œì  ì•Œë¦¼ |
| **DMA (High-speed)**         | `HAL_UART_Transmit_DMA()` / `HAL_UART_Receive_DMA()` | DMAë¡œ CPU ê°œì… ì—†ì´ ëŒ€ìš©ëŸ‰ ì „ì†¡       |

------

### HAL UART êµ¬ì¡° ê°œìš”

HALì˜ UART ë“œë¼ì´ë²„ëŠ” ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¡œ ë™ì‘í•©ë‹ˆë‹¤:

1. **ì´ˆê¸°í™” ë‹¨ê³„**
   - `HAL_UART_Init(&huart1);`
   - ë‚´ë¶€ì ìœ¼ë¡œ `HAL_UART_MspInit()` í˜¸ì¶œ
   - GPIO ì„¤ì • (TX/RX), Clock Enable, NVIC ì„¤ì • ìˆ˜í–‰
2. **ì†¡ìˆ˜ì‹  ë‹¨ê³„**
   - `HAL_UART_Transmit()` ë˜ëŠ” `HAL_UART_Receive()` ì‹¤í–‰
   - ìƒíƒœ êµ¬ì¡°ì²´(`huart->gState`, `huart->RxState`) ì—…ë°ì´íŠ¸
   - í•„ìš” ì‹œ ì¸í„°ëŸ½íŠ¸ í˜¹ì€ DMA ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™”
3. **ì¢…ë£Œ/ì½œë°±**
   - ì™„ë£Œ ì‹œ `HAL_UART_TxCpltCallback()` ë˜ëŠ” `HAL_UART_RxCpltCallback()` í˜¸ì¶œ

------

### HAL_UART_Transmit() â€“ Polling ê¸°ë°˜ ì†¡ì‹ 

```
uint8_t msg[] = "Hello, STM32 UART!\r\n";
HAL_UART_Transmit(&huart1, msg, sizeof(msg)-1, HAL_MAX_DELAY);
```

- ì „ì†¡ ì™„ë£Œê¹Œì§€ CPUê°€ ëŒ€ê¸° (Blocking ë°©ì‹)
- `HAL_MAX_DELAY`ëŠ” Timeoutì´ ì—†ìŒì„ ì˜ë¯¸
- ë‚´ë¶€ì ìœ¼ë¡œ `USARTx->DR` ë ˆì§€ìŠ¤í„°ì— ë°ì´í„°ë¥¼ ì“°ê³  `TXE` í”Œë˜ê·¸ë¥¼ ê°ì‹œí•¨

#### ì¥ì 

- êµ¬í˜„ì´ ê°„ë‹¨í•¨
- ë””ë²„ê¹… ì‹œ ì§ê´€ì 

#### ë‹¨ì 

- CPUê°€ ì „ì†¡ ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì„ ëª»í•¨
- ì‹¤ì‹œê°„ ì‘ë‹µì„±ì´ í•„ìš”í•œ ê²½ìš° ë¶€ì í•©

------

### HAL_UART_Receive() â€“ Polling ê¸°ë°˜ ìˆ˜ì‹ 

```
uint8_t rx_buf[10];
HAL_UART_Receive(&huart1, rx_buf, 10, HAL_MAX_DELAY);
```

- ì§€ì •ëœ ë°”ì´íŠ¸ ìˆ˜ê°€ ìˆ˜ì‹ ë  ë•Œê¹Œì§€ ëŒ€ê¸°
- `RXNE`(Receive Not Empty) í”Œë˜ê·¸ë¥¼ ê°ì‹œ
- ì‹¤ì œë¡œëŠ” `USARTx->DR` ë ˆì§€ìŠ¤í„°ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì˜´

#### ì£¼ì˜ì 

- Timeout ê°’ì´ ë„ˆë¬´ í¬ë©´ í”„ë¡œê·¸ë¨ì´ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì¼ ìˆ˜ ìˆìŒ
- ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì—ëŠ” ì í•©í•˜ì§€ ì•ŠìŒ

------

### HAL_UART_Transmit_IT() / HAL_UART_Receive_IT() â€“ ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜

```
HAL_UART_Transmit_IT(&huart1, msg, sizeof(msg)-1);
HAL_UART_Receive_IT(&huart1, rx_buf, 10);
```

- ë¹„ë™ê¸° ì†¡ìˆ˜ì‹  ê°€ëŠ¥ (Non-blocking)
- ì¸í„°ëŸ½íŠ¸ ë°œìƒ ì‹œ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë°”ì´íŠ¸ ì „ì†¡
- ì†¡ìˆ˜ì‹  ì™„ë£Œ ì‹œ ì½œë°± í•¨ìˆ˜ í˜¸ì¶œ

```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    // ì†¡ì‹  ì™„ë£Œ ì‹œ ìˆ˜í–‰
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    HAL_UART_Transmit(&huart1, rx_buf, 10, HAL_MAX_DELAY);  // Echo
    HAL_UART_Receive_IT(&huart1, rx_buf, 10);               // ë‹¤ì‹œ ìˆ˜ì‹  ëŒ€ê¸°
}
```

#### ì¥ì 

- CPU ì ìœ ìœ¨ ê°ì†Œ
- ì‹¤ì‹œê°„ ì‘ë‹µ ê°€ëŠ¥

#### ë‹¨ì 

- ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ë³µì¡ë„ ì¦ê°€
- ì½œë°± ì¬í˜¸ì¶œ ëˆ„ë½ ì‹œ ì¬ìˆ˜ì‹  ë¶ˆê°€

------

### HAL_UART_Transmit_DMA() / HAL_UART_Receive_DMA() â€“ DMA ê¸°ë°˜

```
HAL_UART_Transmit_DMA(&huart1, msg, sizeof(msg)-1);
HAL_UART_Receive_DMA(&huart1, rx_buf, 64);
```

- DMAë¥¼ í†µí•´ ë°ì´í„° ì „ì†¡ì„ í•˜ë“œì›¨ì–´ê°€ ì§ì ‘ ìˆ˜í–‰
- CPUëŠ” ë‹¤ë¥¸ ì‘ì—…ì„ ë³‘í–‰ ê°€ëŠ¥
- ëŒ€ìš©ëŸ‰, ì—°ì† ë°ì´í„° ì „ì†¡ì— ìœ ë¦¬

#### DMA ì„¤ì • íë¦„

1. CubeMXì—ì„œ UART â†’ DMA ì±„ë„ í• ë‹¹
2. DMA ì¸í„°ëŸ½íŠ¸ í™œì„±í™” (`DMAx_Streamx_IRQHandler`)
3. `HAL_UART_TxCpltCallback()`ì—ì„œ ì™„ë£Œ ì²˜ë¦¬

#### DMA ìˆ˜ì‹  ìˆœí™˜ ëª¨ë“œ ì˜ˆì œ

```
HAL_UART_Receive_DMA(&huart1, rx_buf, 64);
__HAL_DMA_ENABLE_IT(huart1.hdmarx, DMA_IT_HT);  // Half-transfer interrupt
__HAL_DMA_ENABLE_IT(huart1.hdmarx, DMA_IT_TC);  // Transfer complete
```

#### DMA ì½œë°± í•¨ìˆ˜ ì˜ˆì‹œ

```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    printf("DMA TX Complete\r\n");
}
```

------

### UART ìƒíƒœ êµ¬ì¡°ì²´

`UART_HandleTypeDef` ë‚´ë¶€ì—ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì£¼ìš” ë©¤ë²„ê°€ ìˆìŠµë‹ˆë‹¤:

| ë©¤ë²„ëª…                        | ì„¤ëª…                               |
| ----------------------------- | ---------------------------------- |
| `Instance`                    | USART1~USART6 í•˜ë“œì›¨ì–´ ì¸ìŠ¤í„´ìŠ¤    |
| `Init`                        | BaudRate, StopBits, Parity ë“± ì„¤ì • |
| `pTxBuffPtr` / `pRxBuffPtr`   | ì†¡ìˆ˜ì‹  ë²„í¼ í¬ì¸í„°                 |
| `TxXferCount` / `RxXferCount` | ë‚¨ì€ ë°ì´í„° ìˆ˜                     |
| `gState` / `RxState`          | HAL ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬                 |
| `ErrorCode`                   | ì—ëŸ¬ ìƒíƒœ ì½”ë“œ                     |

------

### UART ì—ëŸ¬ í•¸ë“¤ë§

UART ë™ì‘ ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì£¼ìš” ì—ëŸ¬:

- **Overrun Error (ORE)** : RX ë²„í¼ê°€ ê°€ë“ ì°¼ëŠ”ë° ìƒˆ ë°ì´í„°ê°€ ë“¤ì–´ì˜¨ ê²½ìš°
- **Framing Error (FE)** : Stop bit ê²€ì¶œ ì‹¤íŒ¨
- **Noise Error (NE)** : ì „ê¸°ì  ë…¸ì´ì¦ˆì— ì˜í•œ ì‹ í˜¸ ì™œê³¡

ì—ëŸ¬ ë°œìƒ ì‹œ `HAL_UART_ErrorCallback()` í˜¸ì¶œ

```
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
        printf("Overrun Error!\r\n");
    }
}
```

------

### UART ë™ì‘ í™•ì¸ ë°©ë²•

1. **í•˜ë“œì›¨ì–´ ì—°ê²°**

   - MCU TX â†’ USB-UART RX
   - MCU RX â†’ USB-UART TX
   - GND ê³µí†µ ì—°ê²°

2. **PC í„°ë¯¸ë„ ì„¤ì •**

   - Baudrate: 115200
   - Data: 8bit, Stop: 1bit, Parity: None

3. **í…ŒìŠ¤íŠ¸ ì¶œë ¥ ì½”ë“œ**

   ```
   printf("UART Test OK\r\n");
   HAL_Delay(1000);
   ```

4. **ê²°ê³¼ í™•ì¸**

   - TeraTerm, PuTTY, RealTerm ë“±ì—ì„œ ë©”ì‹œì§€ ìˆ˜ì‹ 

------

### ì‹¤ìŠµ í¬ì¸íŠ¸

- HAL ë ˆë²¨ì—ì„œ ì†¡ì‹ ì´ ë˜ì§€ ì•Šì„ ê²½ìš° `HAL_UART_Init()`ì´ ì‹¤í–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
- CubeMXì—ì„œ Clock Sourceê°€ HSI/HSEì— ë§ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ ì ê²€
- DMA ì†¡ìˆ˜ì‹  ì‹œ NVIC ìš°ì„ ìˆœìœ„ ì¶©ëŒ ì—¬ë¶€ í™•ì¸

------

### ë””ë²„ê¹… íŒ

- **Break Point** : `HAL_UART_RxCpltCallback()` ì§„ì… í™•ì¸

- **Watch Variable** : `huart1.gState`, `huart1.RxState` ìƒíƒœ í™•ì¸

- **Register View** : `USART1->SR`, `USART1->DR`, `USART1->BRR` ì§ì ‘ í™•ì¸

- **Baudrate ì˜¤ì°¨ í™•ì¸** :
  $$
  \text{Baud Error(\%)} = \frac{|ì‹¤ì œ - ì„¤ì •|}{ì„¤ì •} \times 100
  $$
  ì˜¤ì°¨ê°€ Â±2% ì´ìƒì´ë©´ í†µì‹  ë¶ˆì•ˆì • ë°œìƒ ê°€ëŠ¥

------

### ê³ ê¸‰ ì‘ìš©

- DMA + Circular Buffer ì¡°í•©ìœ¼ë¡œ **ì—°ì† ìˆ˜ì‹  ì‹œìŠ¤í…œ (UART Ring Buffer)** êµ¬í˜„ ê°€ëŠ¥
- FreeRTOS í™˜ê²½ì—ì„œëŠ” `queue` ë˜ëŠ” `stream buffer`ë¡œ UART RX ë°ì´í„° ì²˜ë¦¬
- RS-485 í†µì‹ ì—ì„œëŠ” TX/RX Enable ì œì–´ í•€ ê´€ë¦¬ í•„ìˆ˜

## 8.4 Interrupt ëª¨ë“œ ìˆ˜ì‹ 

**UART ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìˆ˜ì‹  (Interrupt Mode Receive)**
 UART ì¸í„°ëŸ½íŠ¸ ëª¨ë“œëŠ” ë¹„ë™ê¸°(Non-blocking) ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ìˆ˜ì‹ í•˜ëŠ” êµ¬ì¡°ë¡œ, CPUê°€ ì§€ì†ì ìœ¼ë¡œ ìˆ˜ì‹  ë ˆì§€ìŠ¤í„°ë¥¼ ê°ì‹œí•˜ì§€ ì•Šê³ ë„ UART ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ì¦‰ì‹œ ëŒ€ì‘í•  ìˆ˜ ìˆë‹¤. STM32 HALì—ì„œëŠ” `HAL_UART_Receive_IT()` í•¨ìˆ˜ë¡œ ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìˆ˜ì‹ ì„ í™œì„±í™”í•˜ë©°, ë°ì´í„° ìˆ˜ì‹ ì´ ì™„ë£Œë˜ë©´ `HAL_UART_RxCpltCallback()` í•¨ìˆ˜ê°€ ìë™ìœ¼ë¡œ í˜¸ì¶œëœë‹¤.

------

### HAL UART ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìˆ˜ì‹ ì˜ ë™ì‘ êµ¬ì¡°

#### 1. ì´ˆê¸°í™” ë‹¨ê³„

UART ìˆ˜ì‹  ì¸í„°ëŸ½íŠ¸ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¤ìŒ ì´ˆê¸°í™” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤.

```
MX_USART1_UART_Init();               // CubeMX ìë™ ìƒì„± ì´ˆê¸°í™” í•¨ìˆ˜
HAL_UART_Receive_IT(&huart1, buf, 1); // ìˆ˜ì‹  ì¸í„°ëŸ½íŠ¸ ì‹œì‘ (1ë°”ì´íŠ¸ ë‹¨ìœ„)
```

- `HAL_UART_Receive_IT()`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ RXNE(Receive Not Empty) ì¸í„°ëŸ½íŠ¸ë¥¼ í™œì„±í™”í•œë‹¤.
- UART ìˆ˜ì‹  ë²„í¼ í¬ì¸í„°(`pRxBuffPtr`)ì™€ ì¹´ìš´í„°(`RxXferCount`)ë¥¼ ì„¤ì •í•œ ë’¤ NVIC ì¸í„°ëŸ½íŠ¸ë¥¼ í—ˆìš©í•œë‹¤.
- ì‹¤ì œ ë°ì´í„° ìˆ˜ì‹ ì€ `USARTx_IRQHandler()` ë‚´ì—ì„œ ì²˜ë¦¬ëœë‹¤.

------

#### 2. ì¸í„°ëŸ½íŠ¸ ë°œìƒ ì¡°ê±´

UART ì¸í„°ëŸ½íŠ¸ëŠ” ë‹¤ìŒ ì´ë²¤íŠ¸ ë°œìƒ ì‹œ NVICë¥¼ í†µí•´ íŠ¸ë¦¬ê±°ëœë‹¤.

| ì´ë²¤íŠ¸   | ì„¤ëª…                                         |
| -------- | -------------------------------------------- |
| **RXNE** | ìˆ˜ì‹  ë²„í¼ì— ìƒˆ ë°ì´í„°ê°€ ë“¤ì–´ì˜¨ ê²½ìš°          |
| **TC**   | ì†¡ì‹  ì™„ë£Œ(Transmit Complete)                 |
| **ORE**  | ì˜¤ë²„ëŸ° ì—ëŸ¬ (ìƒˆ ë°ì´í„°ê°€ ê¸°ì¡´ ë°ì´í„° ë®ì–´ì”€) |
| **FE**   | í”„ë ˆì´ë° ì—ëŸ¬ (Stop bit ê²€ì¶œ ì‹¤íŒ¨)           |
| **NE**   | ë…¸ì´ì¦ˆ ì—ëŸ¬ (ì „ê¸°ì  ê°„ì„­ ë°œìƒ)               |

RXNE í”Œë˜ê·¸ëŠ” ìˆ˜ì‹  ì‹œë§ˆë‹¤ ìë™ìœ¼ë¡œ Set ë˜ë©°, `USARTx->DR`ì„ ì½ìœ¼ë©´ ìë™ìœ¼ë¡œ Clear ëœë‹¤.

------

### HAL_UART_IRQHandler() ë™ì‘ íë¦„

1. UART í•˜ë“œì›¨ì–´ ì¸í„°ëŸ½íŠ¸ ë°œìƒ
2. `USARTx_IRQHandler()` â†’ HAL ë‚´ë¶€ í•¸ë“¤ëŸ¬ `HAL_UART_IRQHandler()` í˜¸ì¶œ
3. RXNE í”Œë˜ê·¸ ê°ì§€ â†’ ìˆ˜ì‹  ë²„í¼ë¡œ ë°ì´í„° ë³µì‚¬
4. ìˆ˜ì‹  ì¹´ìš´í„°(`RxXferCount`) ê°ì†Œ
5. ëª¨ë“  ë°”ì´íŠ¸ ìˆ˜ì‹  ì™„ë£Œ ì‹œ `HAL_UART_RxCpltCallback()` ì‹¤í–‰

------

### ìˆ˜ì‹  ì½œë°± í•¨ìˆ˜

```
uint8_t rx_data;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        HAL_UART_Transmit(&huart1, &rx_data, 1, HAL_MAX_DELAY); // Echo back
        HAL_UART_Receive_IT(&huart1, &rx_data, 1);               // ë‹¤ìŒ ë°ì´í„° ìˆ˜ì‹  ëŒ€ê¸°
    }
}
```

- `HAL_UART_RxCpltCallback()`ì€ í•œ ë°”ì´íŠ¸ ìˆ˜ì‹ ì´ ì™„ë£Œë  ë•Œë§ˆë‹¤ í˜¸ì¶œëœë‹¤.
- ì½œë°± í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ë‹¤ì‹œ `HAL_UART_Receive_IT()`ë¥¼ í˜¸ì¶œí•´ì•¼ ì—°ì† ìˆ˜ì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.
- ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ ë°”ì´íŠ¸ê°€ ë“¤ì–´ì™€ë„ RX ì¸í„°ëŸ½íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.

------

### ë°˜ë³µ ìˆ˜ì‹  (ì—°ì† ìˆ˜ì‹  ë£¨í”„)

UART ìˆ˜ì‹ ì€ í•œ ë²ˆë§Œ ì„¤ì •í•˜ë©´ ëë‚˜ëŠ” êµ¬ì¡°ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì—, ë³´í†µ ë‹¤ìŒê³¼ ê°™ì´ ë°˜ë³µ ì„¤ì •ì„ ìˆ˜í–‰í•œë‹¤.

```
void UART_Start_Receive_IT(void)
{
    HAL_UART_Receive_IT(&huart1, &rx_data, 1);
}

int main(void)
{
    HAL_Init();
    MX_USART1_UART_Init();
    UART_Start_Receive_IT();

    while (1)
    {
        // ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰
    }
}
```

------

### ì¸í„°ëŸ½íŠ¸ ë²¡í„° êµ¬ì¡°

```
void USART1_IRQHandler(void)
{
    HAL_UART_IRQHandler(&huart1); // HAL ë‚´ë¶€ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬
}
```

HAL ë‚´ë¶€ì ìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ì£¼ìš” ë™ì‘:

- RXNE í”Œë˜ê·¸ ê°ì§€
- DR ë ˆì§€ìŠ¤í„°ì—ì„œ ë°ì´í„° ì½ê¸°
- DMA ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
- `HAL_UART_RxCpltCallback()` í˜¸ì¶œ

------

### ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìˆ˜ì‹ ì˜ ì¥ì 

- CPUê°€ ì§€ì†ì ìœ¼ë¡œ RX ìƒíƒœë¥¼ í™•ì¸í•  í•„ìš” ì—†ìŒ
- ì „ë ¥ íš¨ìœ¨ í–¥ìƒ (Sleep ëª¨ë“œì—ì„œë„ ì¸í„°ëŸ½íŠ¸ë¡œ ê¹¨ì›€ ê°€ëŠ¥)
- ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ëŒ€ì‘ì— ìœ ë¦¬
- DMAë³´ë‹¤ êµ¬í˜„ì´ ë‹¨ìˆœ

------

### ë‹¨ì  ë° ì£¼ì˜ì‚¬í•­

| ë¬¸ì œ ìœ í˜•             | ì„¤ëª…                                               | í•´ê²°ì±…                                              |
| --------------------- | -------------------------------------------------- | --------------------------------------------------- |
| **ë°ì´í„° ëˆ„ë½**       | ì½œë°±ì—ì„œ ì¬ìˆ˜ì‹ ì„ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒ ë°ì´í„° ì†ì‹¤ | `HAL_UART_Receive_IT()`ë¥¼ ì½œë°± ë‚´ë¶€ì— ë°˜ë“œì‹œ ì¬í˜¸ì¶œ |
| **ì˜¤ë²„ëŸ° ì—ëŸ¬ (ORE)** | RX ë²„í¼ê°€ ë¹„ì›Œì§€ì§€ ì•Šì€ ìƒíƒœì—ì„œ ìƒˆ ë°ì´í„° ìˆ˜ì‹     | `__HAL_UART_CLEAR_OREFLAG()`ë¡œ í”Œë˜ê·¸ í´ë¦¬ì–´        |
| **ë…¸ì´ì¦ˆ ê°ì§€**       | ì „ê¸°ì  ê°„ì„­ìœ¼ë¡œ ë°ì´í„° ì†ìƒ                        | GND ì‹ í˜¸ ê°•í™”, ì¼€ì´ë¸” ì§§ê²Œ ìœ ì§€                     |
| **ë²„í¼ ê´€ë¦¬ ë¬¸ì œ**    | ì—°ì† ìˆ˜ì‹  ì‹œ ìˆ˜ì‹  ë°ì´í„° ë®ì–´ì“°ê¸°                  | ë§ë²„í¼(Ring Buffer) êµ¬ì¡° ë„ì…                       |

------

### ë§ë²„í¼(Ring Buffer) ê¸°ë°˜ í™•ì¥ êµ¬ì¡°

ì‹¤ì œ ì‹œìŠ¤í…œì—ì„œëŠ” í•œ ë°”ì´íŠ¸ì”© ìˆ˜ì‹ í•˜ëŠ” ëŒ€ì‹ , ë§ë²„í¼ë¥¼ êµ¬ì„±í•˜ì—¬ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ê´€ë¦¬í•œë‹¤.

```
#define RX_BUF_SIZE 128
uint8_t rx_buf[RX_BUF_SIZE];
uint16_t rx_head = 0;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    rx_buf[rx_head++] = rx_data;
    if (rx_head >= RX_BUF_SIZE) rx_head = 0;
    HAL_UART_Receive_IT(&huart1, &rx_data, 1);
}
```

ì´ êµ¬ì¡°ëŠ” DMA ì—†ì´ë„ ì§€ì†ì ì¸ UART ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.

------

### ì¸í„°ëŸ½íŠ¸ ìˆ˜ì‹  ë””ë²„ê¹… ë°©ë²•

| ë‹¨ê³„ | í™•ì¸ í•­ëª©                                               |
| ---- | ------------------------------------------------------- |
| 1    | `USARTx_IRQn`ì´ NVICì— ë“±ë¡ë˜ì–´ ìˆëŠ”ê°€                  |
| 2    | `USARTx_IRQHandler()`ê°€ ì‹¤ì œ ì¡´ì¬í•˜ëŠ”ê°€                 |
| 3    | RX í•€ì´ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ê°€ (AF Mode í™•ì¸)            |
| 4    | Baudrate ì˜¤ì°¨ Â±2% ì´ë‚´ì¸ì§€                              |
| 5    | `HAL_UART_Receive_IT()`ê°€ ì½œë°± ë‚´ì—ì„œ ì¬í˜¸ì¶œë˜ê³  ìˆëŠ”ê°€ |

------

### ìˆ˜ì‹  ì˜¤ë²„ëŸ°(ORE) ì—ëŸ¬ ì²˜ë¦¬ ì˜ˆì‹œ

```
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->ErrorCode & HAL_UART_ERROR_ORE)
    {
        __HAL_UART_CLEAR_OREFLAG(huart);
        HAL_UART_Receive_IT(huart, &rx_data, 1);  // ì¬ì‹œì‘
    }
}
```

------

### ê³ ê¸‰ ì‘ìš©

- **ëª…ë ¹ì–´ ìˆ˜ì‹  íŒŒì„œ(Command Parser)** : UARTë¡œ ë°›ì€ ë°ì´í„°ë¥¼ ëª…ë ¹ì–´ë¡œ í•´ì„
- **BLE / Wi-Fi ëª¨ë“ˆ í†µì‹ ** : ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ì§€ì† ìˆ˜ì‹  ë° ì‘ë‹µ ì²˜ë¦¬
- **RTOS í™˜ê²½** : ìˆ˜ì‹  ì½œë°±ì—ì„œ `queue`ë‚˜ `stream buffer`ë¡œ ë°ì´í„° ì „ë‹¬

------

### ì‹¤ìŠµ ìš”ì•½

1. `HAL_UART_Receive_IT()`ë¡œ ì¸í„°ëŸ½íŠ¸ ìˆ˜ì‹  ì‹œì‘
2. ë°ì´í„° ìˆ˜ì‹  ì‹œ `HAL_UART_RxCpltCallback()` ìë™ í˜¸ì¶œ
3. ì½œë°± ë‚´ë¶€ì—ì„œ ì¬í˜¸ì¶œë¡œ ì—°ì† ìˆ˜ì‹  ìœ ì§€
4. í•„ìš” ì‹œ ë§ë²„í¼ ì ìš©ìœ¼ë¡œ ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬

## 8.5 DMA ê¸°ë°˜ UART

**UART + DMA (Direct Memory Access) êµ¬ì¡° ê°œìš”**
 DMA(Direct Memory Access)ëŠ” CPUì˜ ê°œì… ì—†ì´ ì£¼ë³€ì¥ì¹˜(UART, ADC, SPI ë“±)ê°€ ë©”ëª¨ë¦¬(RAM)ì™€ ì§ì ‘ ë°ì´í„° ì „ì†¡ì„ ìˆ˜í–‰í•˜ë„ë¡ í•˜ëŠ” í•˜ë“œì›¨ì–´ ê¸°ëŠ¥ì´ë‹¤.
 UARTì™€ DMAë¥¼ ê²°í•©í•˜ë©´ ëŒ€ìš©ëŸ‰, ê³ ì†, ì—°ì†ì ì¸ ë°ì´í„° ì†¡ìˆ˜ì‹ ì´ ê°€ëŠ¥í•˜ë©°, CPUëŠ” ë‹¤ë¥¸ ì—°ì‚°ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆì–´ íš¨ìœ¨ì ì¸ ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤.
 STM32 HALì—ì„œëŠ” `HAL_UART_Transmit_DMA()` / `HAL_UART_Receive_DMA()` í•¨ìˆ˜ë¥¼ í†µí•´ DMA ê¸°ë°˜ ì†¡ìˆ˜ì‹ ì„ ì†ì‰½ê²Œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.

------

### DMA ê¸°ë°˜ UARTì˜ ë™ì‘ íë¦„

1. **DMA ì±„ë„ ì´ˆê¸°í™”**
   - CubeMXì—ì„œ UART â†’ DMA ì„¤ì • íƒ­ì—ì„œ TX, RX ì±„ë„ì„ ê°ê° í• ë‹¹
   - DMA Direction: Peripheral to Memory (RX), Memory to Peripheral (TX)
   - Mode: Normal ë˜ëŠ” Circular
   - Increment Mode: Memory Increment Enable
   - Priority: Medium ì´ìƒ ê¶Œì¥
2. **UARTì™€ DMA ì—°ë™**
   - `HAL_UART_Init()` ìˆ˜í–‰ ì‹œ ë‚´ë¶€ì ìœ¼ë¡œ DMA í•¸ë“¤(`hdmatx`, `hdmarx`)ì„ UART í•¸ë“¤(`huart`)ì— ì—°ê²°
   - DMA ì „ì†¡ì´ ì‹œì‘ë˜ë©´ CPUëŠ” ê°œì…í•˜ì§€ ì•ŠìŒ
   - DMA ì „ì†¡ ì™„ë£Œ ì‹œ ì¸í„°ëŸ½íŠ¸ë¥¼ ë°œìƒì‹œì¼œ HAL ì½œë°± í•¨ìˆ˜ë¡œ ì œì–´ ë°˜í™˜
3. **ì†¡ìˆ˜ì‹  ì™„ë£Œ ì´ë²¤íŠ¸**
   - `HAL_UART_TxCpltCallback()` : ì†¡ì‹  ì™„ë£Œ
   - `HAL_UART_RxCpltCallback()` : ìˆ˜ì‹  ì™„ë£Œ
   - `HAL_UART_ErrorCallback()` : DMA ì „ì†¡ ì¤‘ ì—ëŸ¬ ë°œìƒ ì‹œ í˜¸ì¶œ

------

### DMA ê¸°ë°˜ ì†¡ì‹  (Transmit DMA)

```
uint8_t tx_data[] = "DMA UART Test\r\n";
HAL_UART_Transmit_DMA(&huart1, tx_data, sizeof(tx_data) - 1);
```

- DMAê°€ TX ë²„í¼ì˜ ë°ì´í„°ë¥¼ `USARTx->DR`ë¡œ ì§ì ‘ ì „ì†¡
- CPUëŠ” ë‹¤ë¥¸ ì—°ì‚°ì„ ìˆ˜í–‰ ê°€ëŠ¥
- ì „ì†¡ ì™„ë£Œ ì‹œ `HAL_UART_TxCpltCallback()` ìë™ í˜¸ì¶œ

```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
        printf("DMA TX Complete\r\n");
}
```

**ì£¼ì˜**

- DMA ì†¡ì‹  ì™„ë£Œ í›„ ë°˜ë“œì‹œ DMA ë¹„í™œì„±í™” ì²˜ë¦¬ í•„ìš” (`__HAL_DMA_DISABLE()` ë‚´ë¶€ì ìœ¼ë¡œ ìë™ ì²˜ë¦¬ë¨).
- ì†¡ì‹  ë²„í¼ëŠ” ì „ì†¡ ë„ì¤‘ ìˆ˜ì •ë˜ë©´ ì•ˆ ë¨.

------

### DMA ê¸°ë°˜ ìˆ˜ì‹  (Receive DMA)

```
uint8_t rx_buf[64];
HAL_UART_Receive_DMA(&huart1, rx_buf, sizeof(rx_buf));
```

- DMAê°€ UART RX ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ë¡œ ìë™ ë³µì‚¬
- ì§€ì •ëœ ê¸¸ì´ë§Œí¼ ìˆ˜ì‹ í•˜ë©´ `HAL_UART_RxCpltCallback()` í˜¸ì¶œ

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        printf("DMA RX Complete\r\n");
        HAL_UART_Receive_DMA(&huart1, rx_buf, sizeof(rx_buf)); // ì¬ì‹œì‘
    }
}
```

**íŠ¹ì§•**

- CPUê°€ ìˆ˜ì‹  ë£¨í”„ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•Šì•„ë„ ë¨
- ì¼ì • í¬ê¸°ì˜ ë°ì´í„° ë¸”ë¡ì„ ë°˜ë³µì ìœ¼ë¡œ ì²˜ë¦¬ ê°€ëŠ¥

------

### Circular Mode (ìˆœí™˜ ëª¨ë“œ)

ìˆœí™˜ ëª¨ë“œëŠ” DMA ìˆ˜ì‹  ë²„í¼ê°€ ê°€ë“ ì°¨ë©´ ìë™ìœ¼ë¡œ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ë©° ë°ì´í„°ë¥¼ ë®ì–´ì“°ëŠ” ë°©ì‹ì´ë‹¤.
 UART ìˆ˜ì‹ ì´ ëŠì„ì—†ì´ ë“¤ì–´ì˜¤ëŠ” ì‹œìŠ¤í…œ(ì˜ˆ: GPS, BLE, RS-485 ë“±)ì— ìœ ìš©í•˜ë‹¤.

```
HAL_UART_Receive_DMA(&huart1, rx_buf, RX_BUF_SIZE);
__HAL_DMA_ENABLE_IT(huart1.hdmarx, DMA_IT_HT); // Half Transfer
__HAL_DMA_ENABLE_IT(huart1.hdmarx, DMA_IT_TC); // Transfer Complete
```

DMA ì¸í„°ëŸ½íŠ¸ë¥¼ í†µí•´ í˜„ì¬ê¹Œì§€ ìˆ˜ì‹ ëœ ë°ì´í„° ì–‘ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆë‹¤.

------

### DMA ìˆ˜ì‹  í¬ì¸í„° ê´€ë¦¬

DMA ìˆ˜ì‹  ì¤‘ í˜„ì¬ ìœ„ì¹˜ë¥¼ í™•ì¸í•˜ë ¤ë©´ DMA ì¹´ìš´í„° ë ˆì§€ìŠ¤í„°ë¥¼ ì½ëŠ”ë‹¤.

```
uint16_t dma_pos = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart1.hdmarx);
```

- DMAëŠ” **ë‚¨ì€ ì „ì†¡ ì¹´ìš´íŠ¸**ë¥¼ ì €ì¥í•˜ë¯€ë¡œ, ì „ì²´ ë²„í¼ í¬ê¸°ì—ì„œ ëº€ ê°’ì´ í˜„ì¬ ìˆ˜ì‹ ëœ ë°ì´í„° ê°œìˆ˜ì´ë‹¤.
- ë§ë²„í¼ êµ¬ì¡°ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ëŠê¹€ ì—†ëŠ” ë°ì´í„° ìˆ˜ì‹ ì´ ê°€ëŠ¥í•˜ë‹¤.

------

### ë§ë²„í¼(Ring Buffer) + DMA êµ¬ì¡° ì˜ˆì‹œ

```
#define RX_BUF_SIZE 128
uint8_t rx_buf[RX_BUF_SIZE];
uint16_t old_pos = 0;

void DMA_UART_Process(void)
{
    uint16_t pos = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart1.hdmarx);
    if (pos != old_pos)
    {
        if (pos > old_pos)
            Process_Data(&rx_buf[old_pos], pos - old_pos);
        else
        {
            Process_Data(&rx_buf[old_pos], RX_BUF_SIZE - old_pos);
            Process_Data(&rx_buf[0], pos);
        }
        old_pos = pos;
    }
}
```

ì´ ë°©ì‹ì€ CPU ì¸í„°ëŸ½íŠ¸ ë¶€í•˜ ì—†ì´ ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

------

### DMA ê´€ë ¨ ì£¼ìš” HAL ë§¤í¬ë¡œ

| ë§¤í¬ë¡œ                               | ì„¤ëª…                         |
| ------------------------------------ | ---------------------------- |
| `__HAL_DMA_GET_COUNTER()`            | DMA ë‚¨ì€ ì „ì†¡ ì¹´ìš´íŠ¸ ì½ê¸°    |
| `__HAL_DMA_ENABLE_IT()`              | DMA ì¸í„°ëŸ½íŠ¸ í™œì„±í™”          |
| `__HAL_UART_CLEAR_IDLEFLAG()`        | IDLE ë¼ì¸ ê°ì§€ í”Œë˜ê·¸ ì´ˆê¸°í™” |
| `__HAL_UART_ENABLE_IT(UART_IT_IDLE)` | IDLE ì¸í„°ëŸ½íŠ¸ í™œì„±í™”         |

------

### UART IDLE ì¸í„°ëŸ½íŠ¸ì™€ DMA ê²°í•©

DMA ìˆœí™˜ ëª¨ë“œì—ì„œëŠ” IDLE ë¼ì¸ ê°ì§€ë¥¼ í†µí•´ íŒ¨í‚· ê²½ê³„ë¥¼ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.

```
void HAL_UART_IDLE_IRQHandler(UART_HandleTypeDef *huart)
{
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    uint16_t len = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart->hdmarx);
    Process_Packet(rx_buf, len);
    __HAL_DMA_DISABLE(huart->hdmarx);
    __HAL_DMA_SET_COUNTER(huart->hdmarx, RX_BUF_SIZE);
    __HAL_DMA_ENABLE(huart->hdmarx);
}
```

**IDLE Line Detection**

- ì†¡ì‹ ì´ ì¼ì • ì‹œê°„ ì¤‘ë‹¨ë˜ë©´ â€œIDLEâ€ ìƒíƒœë¡œ ê°ì§€
- ë¹„ê°€ë³€ ê¸¸ì´ íŒ¨í‚· ì²˜ë¦¬ì— ë§¤ìš° íš¨ê³¼ì 

------

### DMA ì „ì†¡ ì¤‘ ì—ëŸ¬ ì²˜ë¦¬

DMA ì „ì†¡ ì¤‘ ë‹¤ìŒê³¼ ê°™ì€ ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

| ì—ëŸ¬ ì¢…ë¥˜              | ì„¤ëª…               | ëŒ€ì‘ ë°©ë²•                           |
| ---------------------- | ------------------ | ----------------------------------- |
| **HAL_UART_ERROR_DMA** | DMA ì±„ë„ ì„¤ì • ì˜¤ë¥˜ | DMA ì´ˆê¸°í™” ë° í•¸ë“¤ ì¬ì—°ê²°           |
| **HAL_UART_ERROR_ORE** | ì˜¤ë²„ëŸ°             | ìˆ˜ì‹  ë²„í¼ í¬ê¸° ì¦ê°€, IDLE ê¸°ë°˜ ì²˜ë¦¬ |
| **HAL_UART_ERROR_FE**  | í”„ë ˆì´ë° ì˜¤ë¥˜      | ë³´ë“œ ê°„ Baudrate ë™ê¸°í™” í™•ì¸        |
| **HAL_UART_ERROR_NE**  | ë…¸ì´ì¦ˆ ì˜¤ë¥˜        | ë°°ì„  ì •ë¹„ ë° GND ê°•í™”               |

ì—ëŸ¬ ë°œìƒ ì‹œ `HAL_UART_ErrorCallback()`ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥í•˜ë‹¤.

```
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
    if (huart->ErrorCode & HAL_UART_ERROR_DMA)
    {
        HAL_UART_Receive_DMA(huart, rx_buf, sizeof(rx_buf));
    }
}
```

------

### DMA ê¸°ë°˜ UARTì˜ ì¥ì 

- CPU ê°œì… ìµœì†Œí™” â†’ ì‹œìŠ¤í…œ ë°˜ì‘ì„± í–¥ìƒ
- ëŒ€ìš©ëŸ‰ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ê°€ëŠ¥
- ì‹¤ì‹œê°„ ë°ì´í„° ë¡œê¹…ì— ì í•© (GPS, ì„¼ì„œ, ëª¨ë€ ë“±)
- FreeRTOSì™€ ì—°ê³„ ì‹œ íƒœìŠ¤í¬ ê°„ ë°ì´í„° ì „ì†¡ íš¨ìœ¨ ê·¹ëŒ€í™”

------

### DMA ê¸°ë°˜ UARTì˜ ë‹¨ì 

| í•­ëª©                   | ë‚´ìš©                               |
| ---------------------- | ---------------------------------- |
| **ë³µì¡ì„± ì¦ê°€**        | DMA ì„¤ì • ë° ê´€ë¦¬ ì½”ë“œ í•„ìš”         |
| **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€** | ìˆœí™˜ ë²„í¼ ë° ê´€ë¦¬ ë³€ìˆ˜ í•„ìš”        |
| **ì§€ì—° ì‘ë‹µ ê°€ëŠ¥ì„±**   | íŒ¨í‚· ë‹¨ìœ„ ì²˜ë¦¬ ì‹œ íƒ€ì´ë° ì˜¤ì°¨ ì¡´ì¬ |
| **ì—ëŸ¬ ë³µêµ¬ ì–´ë ¤ì›€**   | DMA ì¤‘ë‹¨ ì‹œ ìˆ˜ë™ ë¦¬ì…‹ í•„ìš”         |

------

### ì‹¤ìŠµ ì˜ˆì œ ìš”ì•½

```
#define RX_BUF_SIZE 64
uint8_t rx_buf[RX_BUF_SIZE];

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();
    HAL_UART_Receive_DMA(&huart1, rx_buf, RX_BUF_SIZE);

    while (1)
    {
        // ë°ì´í„° ì£¼ê¸°ì  í™•ì¸ ë° ì²˜ë¦¬
        DMA_UART_Process();
    }
}
```

------

### ë””ë²„ê¹… í¬ì¸íŠ¸

| í•­ëª©               | í™•ì¸ ë°©ë²•                                  |
| ------------------ | ------------------------------------------ |
| DMA ì±„ë„ ì—°ê²°      | `huart1.hdmarx->Instance` í™•ì¸             |
| DMA ì¸í„°ëŸ½íŠ¸ ë“±ë¡  | `DMA1_Channelx_IRQHandler()` í™œì„±í™” ì—¬ë¶€   |
| NVIC ìš°ì„ ìˆœìœ„      | UARTë³´ë‹¤ DMAê°€ ìš°ì„  ì‹¤í–‰ë˜ì–´ì•¼ í•¨          |
| Circular ëª¨ë“œ ìƒíƒœ | DMA CR ë ˆì§€ìŠ¤í„°ì˜ `CIRC` ë¹„íŠ¸ í™•ì¸         |
| ìˆ˜ì‹  ë°ì´í„° ê²€ì¦   | Logic Analyzer ë˜ëŠ” USB-UART ëª¨ë‹ˆí„°ë¡œ ê²€ì¦ |

------

### ê³ ê¸‰ ì‘ìš©

- **DMA + IDLE Line** : ë¹„ê°€ë³€ ê¸¸ì´ íŒ¨í‚· ì²˜ë¦¬
- **DMA + Circular Buffer + FreeRTOS Queue** : ë©€í‹°íƒœìŠ¤í‚¹ ë°ì´í„° ì²˜ë¦¬ êµ¬ì¡°
- **UART â†” BLE/Wi-Fi ëª¨ë“ˆ** : ê³ ì† ì–‘ë°©í–¥ í†µì‹ 
- **DMA Double Buffer** : ë‘ ê°œì˜ ë²„í¼ë¥¼ êµì°¨ ì‚¬ìš©í•´ ëŠê¹€ ì—†ëŠ” ë°ì´í„° ì²˜ë¦¬

## 8.6 Circular Buffer ê¸°ë°˜ ìˆ˜ì‹ 

UART DMA ìˆ˜ì‹ ì€ CPU ê°œì… ì—†ì´ ëŒ€ëŸ‰ì˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆì§€ë§Œ, ì¼ë°˜ì ì¸ â€œê³ ì • ê¸¸ì´ ìˆ˜ì‹ â€ êµ¬ì¡°ì—ì„œëŠ” íŒ¨í‚· ê²½ê³„ ê°ì§€ë‚˜ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ê°€ ì–´ë µë‹¤.
 ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **Circular Buffer (ìˆœí™˜ ë²„í¼)** êµ¬ì¡°ë¥¼ ì´ìš©í•˜ë©´ DMAì˜ ì¥ì ì„ ìœ ì§€í•˜ë©´ì„œë„, ëŠê¹€ ì—†ëŠ” ë°ì´í„° ìˆ˜ì‹ ê³¼ ì‹¤ì‹œê°„ ì²˜ë¦¬ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

------

### Circular Buffer ê°œë…

Circular Buffer(=Ring Buffer)ëŠ” **FIFO(First-In First-Out)** ë°©ì‹ì˜ ë©”ëª¨ë¦¬ êµ¬ì¡°ë¡œ,
 ë²„í¼ì˜ ëì— ë„ë‹¬í•˜ë©´ ìë™ìœ¼ë¡œ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ë©° ë°ì´í„°ë¥¼ ë®ì–´ì“´ë‹¤.

#### íŠ¹ì§•

- DMAê°€ ì§€ì†ì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë°›ì•„ë„ ë²„í¼ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°©ì§€
- CPUëŠ” DMA í¬ì¸í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒˆë¡œ ë“¤ì–´ì˜¨ ë°ì´í„°ë§Œ ì²˜ë¦¬
- ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼(GPS, BLE, RS-485, ì„¼ì„œ ë¡œê·¸)ì— ë§¤ìš° íš¨ê³¼ì 

#### êµ¬ì¡° ì˜ˆì‹œ

```
[0] [1] [2] [3] [4] [5] [6] [7]  (ì´ 8ë°”ì´íŠ¸)
 â†‘read_ptr         â†‘write_ptr
```

- `write_ptr`: DMAê°€ ìƒˆ ë°ì´í„°ë¥¼ ì“¸ ìœ„ì¹˜
- `read_ptr`: CPUê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ì½ì€ ìœ„ì¹˜
- `write_ptr`ê°€ `read_ptr`ë³´ë‹¤ ì•ì„œë©´ ìƒˆ ë°ì´í„° ì¡´ì¬

------

### DMA + Circular Buffer ì—°ë™ ì›ë¦¬

1. **DMA ìˆ˜ì‹  ë²„í¼ë¥¼ Circular ëª¨ë“œë¡œ ì„¤ì •**
   - DMA ì„¤ì •: Mode â†’ Circular
   - DMAëŠ” ê³„ì† ë²„í¼ì— ë°ì´í„°ë¥¼ ìˆœí™˜ ì €ì¥
2. **CPUëŠ” DMA ì¹´ìš´í„°(__HAL_DMA_GET_COUNTER)ë¡œ í˜„ì¬ ìˆ˜ì‹  ìœ„ì¹˜ ì¶”ì **
   - DMAëŠ” ë‚¨ì€ ì „ì†¡ ì¹´ìš´íŠ¸ë¥¼ ê´€ë¦¬í•˜ë¯€ë¡œ,
      `pos = buf_size - __HAL_DMA_GET_COUNTER()` ë¡œ í˜„ì¬ DMA write ìœ„ì¹˜ë¥¼ ê³„ì‚°
3. **CPUëŠ” ìƒˆ ë°ì´í„°ë§Œ ë¶„ë¦¬í•´ì„œ ì²˜ë¦¬**
   - ì´ì „ ì²˜ë¦¬ ìœ„ì¹˜(`old_pos`)ì™€ í˜„ì¬ ìœ„ì¹˜(`pos`)ë¥¼ ë¹„êµí•˜ì—¬ ìƒˆ ë°ì´í„° ë²”ìœ„ë§Œ ì¶”ì¶œ

------

### DMA + Circular Buffer ì„¤ì • (CubeMX ê¸°ì¤€)

1. **USARTx DMA ì„¤ì •**
   - DMA Direction â†’ Peripheral to Memory
   - Mode â†’ Circular
   - Memory Increment â†’ Enabled
   - Priority â†’ Medium ì´ìƒ
2. **UART ì¸í„°ëŸ½íŠ¸ í™œì„±í™”**
   - IDLE Line Interrupt Enable (`UART_IT_IDLE`)
   - NVIC â†’ USARTx global interrupt í™œì„±í™”

------

### ì½”ë“œ êµ¬ì¡° ê°œìš”

```
#define RX_BUF_SIZE 256
uint8_t rx_buf[RX_BUF_SIZE];
volatile uint16_t old_pos = 0;

void Start_DMA_UART(void)
{
    HAL_UART_Receive_DMA(&huart1, rx_buf, RX_BUF_SIZE);
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);  // IDLE interrupt enable
}

void USART1_IRQHandler(void)
{
    HAL_UART_IRQHandler(&huart1);

    // IDLE line detection
    if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE))
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart1);
        DMA_ProcessData();
    }
}
```

------

### DMA ìˆ˜ì‹  ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜

```
void DMA_ProcessData(void)
{
    uint16_t pos = RX_BUF_SIZE - __HAL_DMA_GET_COUNTER(huart1.hdmarx);

    if (pos != old_pos)
    {
        if (pos > old_pos)
        {
            // ìƒˆë¡œìš´ ë°ì´í„°: old_pos ~ pos-1
            Process_Data(&rx_buf[old_pos], pos - old_pos);
        }
        else
        {
            // ë²„í¼ ëì—ì„œ ë˜ëŒì•„ì˜¨ ê²½ìš°
            Process_Data(&rx_buf[old_pos], RX_BUF_SIZE - old_pos);
            if (pos > 0)
                Process_Data(&rx_buf[0], pos);
        }

        old_pos = pos;
        if (old_pos >= RX_BUF_SIZE) old_pos = 0;
    }
}
```

------

### ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜

```
void Process_Data(uint8_t *data, uint16_t len)
{
    for (uint16_t i = 0; i < len; i++)
    {
        uint8_t c = data[i];
        HAL_UART_Transmit(&huart1, &c, 1, 10); // echo back
    }
}
```

> ğŸ’¡ **Tip:** ì‹¤ì‹œê°„ íŒ¨í‚· í”„ë¡œí† ì½œ (ì˜ˆ: 0xAA Header, 0x0D 0x0A Tail ë“±) ë¶„ì„ë„ ì—¬ê¸°ì„œ ê°€ëŠ¥

------

### ë§ë²„í¼ DMA ìˆ˜ì‹ ì˜ ì£¼ìš” í¬ì¸íŠ¸

#### 1ï¸âƒ£ IDLE ë¼ì¸ ê°ì§€

UART ì†¡ì‹ ì´ ì¼ì • ì‹œê°„ ë©ˆì¶”ë©´ â€œIDLEâ€ ìƒíƒœë¥¼ ê°ì§€
 â†’ DMA í¬ì¸í„°ê°€ ë©ˆì¶”ì§€ ì•Šì•„ë„ íŒ¨í‚· ë‹¨ìœ„ë¡œ ì²˜ë¦¬ ê°€ëŠ¥

```
void HAL_UART_IDLE_Callback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        __HAL_UART_CLEAR_IDLEFLAG(huart);
        DMA_ProcessData();
    }
}
```

#### 2ï¸âƒ£ DMA Circular ëª¨ë“œ ìœ ì§€

DMAë¥¼ ì¤‘ì§€í•˜ì§€ ì•Šê³  ê³„ì† ìˆœí™˜ì‹œí‚¤ë©´ ë°ì´í„° ì†ì‹¤ ì—†ì´ ì§€ì† ìˆ˜ì‹  ê°€ëŠ¥

#### 3ï¸âƒ£ ì‹¤ì‹œê°„ íŒ¨í‚· ë‹¨ìœ„ ì²˜ë¦¬

DMA_ProcessData() ë‚´ë¶€ì—ì„œ header/tail êµ¬ë¶„ ê°€ëŠ¥
 ì˜ˆ: `0xAA` ~ `0x0D0A` êµ¬ê°„ë§Œ íŒŒì‹±

------

### ì‹¤ìŠµ ì˜ˆì œ: GPS NMEA ìˆ˜ì‹ 

```
uint8_t rx_buf[512];
volatile uint16_t old_pos = 0;

void HAL_UART_IDLE_Callback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART2)
    {
        __HAL_UART_CLEAR_IDLEFLAG(huart);
        DMA_ProcessData();
    }
}

void Process_Data(uint8_t *data, uint16_t len)
{
    if (memchr(data, '$', len))
    {
        // NMEA Sentence ì‹œì‘
        printf("GPS Packet: %.*s\r\n", len, data);
    }
}
```

- GPS ëª¨ë“ˆ(NMEA)ì€ `$GPGGA`, `$GPRMC` ë“± ë¬¸ìì—´ íŒ¨í‚· í˜•íƒœë¡œ ì§€ì† ì „ì†¡ë¨
- Circular Buffer + IDLE ê°ì§€ë¡œ ì™„ì „í•œ ë¬¸ìì—´ ë‹¨ìœ„ ìˆ˜ì‹  ê°€ëŠ¥

------

### ë””ë²„ê¹… í¬ì¸íŠ¸

| í™•ì¸ í•­ëª©     | ì ê²€ ë°©ë²•                               |
| ------------- | --------------------------------------- |
| DMA ëª¨ë“œ í™•ì¸ | DMA Channel â†’ Circular Mode ì„¤ì •        |
| NVIC ì¸í„°ëŸ½íŠ¸ | `USARTx_IRQn` í™œì„±í™” ë° ìš°ì„ ìˆœìœ„        |
| IDLE Line     | `UART_FLAG_IDLE` ê°ì§€ ì •ìƒ ì—¬ë¶€         |
| DMA í¬ì¸í„°    | `__HAL_DMA_GET_COUNTER()` ê°’ ë³€í™” í™•ì¸  |
| ë²„í¼ ì˜¤ë²„í”Œë¡œ | DMA CRì˜ `CIRC` ë¹„íŠ¸ì™€ Buffer í¬ê¸° ì ê²€ |

------

### Circular DMA ìˆ˜ì‹ ì˜ ì¥ì 

| í•­ëª©                           | ë‚´ìš©                                 |
| ------------------------------ | ------------------------------------ |
| **ë°ì´í„° ì†ì‹¤ ìµœì†Œí™”**         | ëŠê¹€ ì—†ëŠ” ì—°ì† ìˆ˜ì‹  ê°€ëŠ¥             |
| **CPU ë¶€í•˜ ê°ì†Œ**              | DMAê°€ ëŒ€ë¶€ë¶„ì˜ ì „ì†¡ ì²˜ë¦¬ ë‹´ë‹¹        |
| **ë¹„ë™ê¸° ìˆ˜ì‹  ìµœì í™”**         | ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼(ì„¼ì„œ, GPS, BLE)ì— ì í•© |
| **ê°€ë³€ ê¸¸ì´ ë°ì´í„° ì²˜ë¦¬ ê°€ëŠ¥** | IDLE Line ê¸°ë°˜ íŒ¨í‚· ê²½ê³„ ê²€ì¶œ        |

------

### Circular DMA ìˆ˜ì‹ ì˜ ë‹¨ì 

| í•­ëª©                   | ë‚´ìš©                                |
| ---------------------- | ----------------------------------- |
| **ë©”ëª¨ë¦¬ ì ìœ  ì¦ê°€**   | ëŒ€ìš©ëŸ‰ ìˆœí™˜ ë²„í¼ í•„ìš”               |
| **ë™ê¸°í™” ë³µì¡ë„ ì¦ê°€** | old_pos, new_pos ê´€ë¦¬ í•„ìˆ˜          |
| **íŒ¨í‚· ë¶„í•  ìœ„í—˜**     | ë²„í¼ ê²½ê³„ì—ì„œ ë°ì´í„°ê°€ ë‚˜ë‰  ìˆ˜ ìˆìŒ |
| **ë””ë²„ê¹… ì–´ë ¤ì›€**      | DMA ë‚´ë¶€ í¬ì¸í„° ì¶”ì ì´ ë³µì¡         |

------

### ê³ ê¸‰ ì‘ìš© êµ¬ì¡°

#### â‘  DMA + IDLE + FreeRTOS Queue

- DMA ISRì—ì„œ ìƒˆ ë°ì´í„° ê°ì§€ â†’ Queueë¡œ ì „ë‹¬
- ìˆ˜ì‹  Taskì—ì„œ ë°ì´í„° íŒŒì‹± ì²˜ë¦¬

#### â‘¡ Double Buffer êµ¬ì¡°

- DMA ë²„í¼ë¥¼ 2ê°œë¡œ ë¶„í• 
- ì ˆë°˜ ì±„ì›Œì§ˆ ë•Œë§ˆë‹¤ Half Transfer ì¸í„°ëŸ½íŠ¸ ë°œìƒ
- í•œìª½ ë²„í¼ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ìª½ì—ì„œ DMA ìˆ˜ì‹  ì§„í–‰

#### â‘¢ í†µì‹  ì‘ìš© ì˜ˆì‹œ

- BLE ëª¨ë“ˆ â†” MCU UART í†µì‹ 
- LoRa / RS-485 ë°ì´í„° ìˆ˜ì§‘ê¸°
- UART ê¸°ë°˜ ë¡œê·¸ ì‹œìŠ¤í…œ

------

### ì „ì²´ ì˜ˆì œ ìš”ì•½

```
#define RX_BUF_SIZE 256
uint8_t rx_buf[RX_BUF_SIZE];
volatile uint16_t old_pos = 0;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();
    Start_DMA_UART();

    while (1)
    {
        DMA_ProcessData(); // ì£¼ê¸°ì  í™•ì¸
    }
}
```

------

### í•™ìŠµ í¬ì¸íŠ¸ ìš”ì•½

âœ… DMAì™€ UARTì˜ ì—°ë™ ë°©ì‹ ì´í•´
 âœ… Circular ëª¨ë“œ ë™ì‘ê³¼ IDLE ê°ì§€ ì›ë¦¬ ìˆ™ì§€
 âœ… ë§ë²„í¼ í¬ì¸í„°(old_pos, pos) ê´€ë¦¬ êµ¬í˜„
 âœ… ì‹¤ì‹œê°„ íŒ¨í‚· ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ê¸°ë²• (NMEA, BLE ë“±)

## 8.7 PC í„°ë¯¸ë„ í†µì‹  ì‹¤ìŠµ

UARTë¥¼ ì´ìš©í•œ PC í„°ë¯¸ë„ í†µì‹ ì€ STM32 ê°œë°œ ê³¼ì •ì—ì„œ ê°€ì¥ ê¸°ë³¸ì ì´ë©´ì„œë„ í•„ìˆ˜ì ì¸ ë””ë²„ê¹… ë° í…ŒìŠ¤íŠ¸ ë°©ë²•ì´ë‹¤.
 MCUì™€ PC ê°„ì˜ ì§ë ¬ í†µì‹ ì„ í†µí•´ ë¬¸ìì—´, ì„¼ì„œ ë°ì´í„°, ë””ë²„ê·¸ ë©”ì‹œì§€ë¥¼ ì£¼ê³ ë°›ìœ¼ë©° ì‹œìŠ¤í…œ ë™ì‘ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
 ì´ ì ˆì—ì„œëŠ” **UART â†” USB ë³€í™˜ ì–´ëŒ‘í„°(FTDI, CH340, CP2102 ë“±)** ë¥¼ ì‚¬ìš©í•˜ì—¬ STM32ì™€ PC ê°„ í†µì‹ ì„ êµ¬ì„±í•˜ê³ , **TeraTerm / PuTTY / RealTerm** ë“±ì˜ í„°ë¯¸ë„ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì†¡ìˆ˜ì‹ í•˜ëŠ” ê³¼ì •ì„ ë‹¤ë£¬ë‹¤.

------

### UART â†” PC ì—°ê²° êµ¬ì¡°

UARTëŠ” **Tx(ì†¡ì‹ ), Rx(ìˆ˜ì‹ ), GND** 3ê°œì˜ ê¸°ë³¸ í•€ìœ¼ë¡œ êµ¬ì„±ëœë‹¤.
 PCëŠ” USB í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, USB-Serial ë³€í™˜ ëª¨ë“ˆì„ í†µí•´ ì „ê¸°ì  ë ˆë²¨ì„ ë§ì¶°ì•¼ í•œë‹¤.

| STM32 í•€      | USB-UART ë³€í™˜ê¸° í•€ | ì„¤ëª…                         |
| ------------- | ------------------ | ---------------------------- |
| TX (ì˜ˆ: PA9)  | RX                 | STM32ê°€ ì „ì†¡í•˜ëŠ” ë°ì´í„° ìˆ˜ì‹  |
| RX (ì˜ˆ: PA10) | TX                 | PCì—ì„œ ì†¡ì‹ í•˜ëŠ” ë°ì´í„° ìˆ˜ì‹   |
| GND           | GND                | ê¸°ì¤€ ì „ìœ„ ì¼ì¹˜               |

> âš  UARTëŠ” êµì°¨ ì—°ê²°í•´ì•¼ í•œë‹¤ (TX â†” RX).

------

### í•˜ë“œì›¨ì–´ ì¤€ë¹„

- STM32 ë³´ë“œ (Blue Pill, Nucleo, Discovery ë“±)
- USB-UART ë³€í™˜ ëª¨ë“ˆ (FTDI, CH340, CP2102, PL2303 ë“±)
- ì í¼ ì¼€ì´ë¸” 3ê°œ
- PC (Windows, Linux, macOS)
- í„°ë¯¸ë„ í”„ë¡œê·¸ë¨ (TeraTerm, PuTTY, RealTerm, CoolTerm ë“±)

------

### CubeMX ì„¤ì • ìš”ì•½

1. **USART1 / USART2 í™œì„±í™”**
   - Mode: Asynchronous
   - Baud Rate: 115200
   - Word Length: 8 Bits
   - Stop Bits: 1
   - Parity: None
   - Flow Control: None
2. **GPIO í•€ ì„¤ì •**
   - TX â†’ Alternate Function Push-Pull
   - RX â†’ Input Floating ë˜ëŠ” Pull-up
3. **NVIC (Optional)**
   - RX Interrupt í™œì„±í™” ì‹œ `USARTx global interrupt` Enable
4. **Code Generation**
   - Project Code ìƒì„± í›„, `usart.c` / `usart.h` ìë™ ìƒì„±

------

### ê¸°ë³¸ ì†¡ì‹  ì˜ˆì œ (Hello World ì¶œë ¥)

```
#include "main.h"
#include <string.h>

extern UART_HandleTypeDef huart1;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();

    char msg[] = "Hello STM32 UART!\r\n";

    while (1)
    {
        HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        HAL_Delay(1000);
    }
}
```

**ê²°ê³¼:**

- í„°ë¯¸ë„ ì°½ì—ì„œ `"Hello STM32 UART!"` ë©”ì‹œì§€ê°€ 1ì´ˆë§ˆë‹¤ ë°˜ë³µ ì¶œë ¥ëœë‹¤.

------

### ê¸°ë³¸ ìˆ˜ì‹  ì˜ˆì œ (Echo í”„ë¡œê·¸ë¨)

```
uint8_t rx_data;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();

    while (1)
    {
        if (HAL_UART_Receive(&huart1, &rx_data, 1, HAL_MAX_DELAY) == HAL_OK)
        {
            HAL_UART_Transmit(&huart1, &rx_data, 1, HAL_MAX_DELAY); // Echo back
        }
    }
}
```

**ê²°ê³¼:**

- í„°ë¯¸ë„ì—ì„œ ì…ë ¥í•œ ë¬¸ìê°€ ì¦‰ì‹œ ë™ì¼í•˜ê²Œ ë°˜ì†¡ë˜ì–´ í‘œì‹œë¨ (Echo ê¸°ëŠ¥).

------

### ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ ìˆ˜ì‹ 

ì§€ì†ì ì¸ ìˆ˜ì‹  ì²˜ë¦¬ë¥¼ ìœ„í•´ **HAL_UART_Receive_IT()** í•¨ìˆ˜ë¥¼ ì´ìš©í•œë‹¤.

```
uint8_t rx_char;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        HAL_UART_Transmit(&huart1, &rx_char, 1, 10);
        HAL_UART_Receive_IT(&huart1, &rx_char, 1);
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();

    HAL_UART_Receive_IT(&huart1, &rx_char, 1);

    while (1)
    {
        // Main loop
    }
}
```

**ë™ì‘ ì›ë¦¬:**

1. ì¸í„°ëŸ½íŠ¸ ê¸°ë°˜ìœ¼ë¡œ 1ë°”ì´íŠ¸ ìˆ˜ì‹  ì‹œ ì½œë°± ì‹¤í–‰
2. `RxCpltCallback()` ë‚´ë¶€ì—ì„œ ì¦‰ì‹œ echo ì „ì†¡
3. ë‹¤ì‹œ `Receive_IT()` í˜¸ì¶œë¡œ ë‹¤ìŒ ìˆ˜ì‹  ì¤€ë¹„

------

### DMA ê¸°ë°˜ ìˆ˜ì‹ 

ëŒ€ëŸ‰ì˜ ë°ì´í„°ë¥¼ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•  ë•Œ DMA ë°©ì‹ì´ íš¨ìœ¨ì ì´ë‹¤.

```
uint8_t rx_buf[64];

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();

    HAL_UART_Receive_DMA(&huart1, rx_buf, sizeof(rx_buf));

    while (1)
    {
        // ë°ì´í„° ì²˜ë¦¬
    }
}
```

DMAëŠ” CPU ê°œì… ì—†ì´ ìë™ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— ì±„ì›Œ ë„£ëŠ”ë‹¤.
 IDLE Line Interruptì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ íš¨ìœ¨ì ì´ë‹¤ (8.6ì ˆ ì°¸ì¡°).

------

### TeraTerm ì„¤ì •

1. **í¬íŠ¸ ì„ íƒ:** ì¥ì¹˜ ê´€ë¦¬ìì—ì„œ â€œUSB Serial (COMx)â€ í™•ì¸
2. **Baud Rate:** CubeMXì—ì„œ ì„¤ì •í•œ ì†ë„ì™€ ì¼ì¹˜ (ì˜ˆ: 115200)
3. **Data/Parity/Stop:** 8N1
4. **Newline ì„¤ì •:** CR+LF (Carriage Return + Line Feed)
5. **Local Echo:** Off
6. **Log íŒŒì¼ ì €ì¥:** â€œFile â†’ Logâ€ ë©”ë‰´ë¡œ UART ë¡œê·¸ ì €ì¥ ê°€ëŠ¥

------

### PuTTY ì„¤ì •

1. **Connection Type:** Serial
2. **Serial line:** COMx (ì˜ˆ: COM3)
3. **Speed:** 115200
4. **Data bits:** 8
5. **Stop bits:** 1
6. **Parity:** None
7. **Flow Control:** None

------

### ì‹¤ìŠµ â‘  â€” ëª…ë ¹ì–´ ì…ë ¥ ë° ì‘ë‹µ

**ê¸°ëŠ¥:** â€œonâ€, â€œoffâ€ ë¬¸ìì—´ ì…ë ¥ì— ë”°ë¼ LEDë¥¼ ì œì–´í•˜ëŠ” ê°„ë‹¨í•œ CLI(Command Line Interface)

```
uint8_t rx_buf[32];
void ProcessCommand(char *cmd)
{
    if (strcmp(cmd, "on") == 0)
    {
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
        printf("LED ON\r\n");
    }
    else if (strcmp(cmd, "off") == 0)
    {
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
        printf("LED OFF\r\n");
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();

    while (1)
    {
        memset(rx_buf, 0, sizeof(rx_buf));
        HAL_UART_Receive(&huart1, rx_buf, sizeof(rx_buf), HAL_MAX_DELAY);
        ProcessCommand((char*)rx_buf);
    }
}
```

**ê²°ê³¼:**

- PC í„°ë¯¸ë„ì— `on` ì…ë ¥ ì‹œ LED ì¼œì§
- `off` ì…ë ¥ ì‹œ LED êº¼ì§

------

### ì‹¤ìŠµ â‘¡ â€” ì„¼ì„œ ë°ì´í„° ì¶œë ¥

**ê¸°ëŠ¥:** ADCë¡œ ì¸¡ì •í•œ ì„¼ì„œ ê°’ì„ UARTë¡œ ì£¼ê¸°ì ìœ¼ë¡œ ì „ì†¡

```
char msg[64];
uint32_t adc_val;

while (1)
{
    adc_val = Read_Sensor();
    sprintf(msg, "ADC: %lu\r\n", adc_val);
    HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), 10);
    HAL_Delay(500);
}
```

**ê²°ê³¼:**

- í„°ë¯¸ë„ ì°½ì— `"ADC: 1234"` í˜•ì‹ì˜ ê°’ì´ 0.5ì´ˆë§ˆë‹¤ ì¶œë ¥ë¨

------

### ë””ë²„ê¹… íŒ

| ë¬¸ì œ             | ì›ì¸                 | í•´ê²° ë°©ë²•                          |
| ---------------- | -------------------- | ---------------------------------- |
| ì¶œë ¥ì´ ì•ˆ ë¨     | TX/RX í•€ ë°˜ëŒ€ë¡œ ì—°ê²° | TX â†” RX í™•ì¸                       |
| ë¬¸ìê°€ ê¹¨ì§      | Baud rate ë¶ˆì¼ì¹˜     | CubeMX ì„¤ì •ê°’ê³¼ í„°ë¯¸ë„ ì„¤ì • ì¼ì¹˜   |
| í„°ë¯¸ë„ ì‘ë‹µ ì—†ìŒ | COM í¬íŠ¸ ì ìœ ë¨      | ST-Link VCPë‚˜ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ ì¢…ë£Œ   |
| ë°ì´í„° ì¼ë¶€ ì†ì‹¤ | DMA ë²„í¼ ë¶€ì¡±        | ë²„í¼ í¬ê¸° ì¦ê°€, Circular ëª¨ë“œ ì‚¬ìš© |

------

### ê³ ê¸‰ í™œìš©

- **PC â†” STM32 ê°„ ëª…ë ¹ í”„ë¡œí† ì½œ êµ¬í˜„** (ì˜ˆ: AT Command)
- **UART ë°ì´í„° ë¡œê±°** (ì„¼ì„œ, ë¡œë“œì…€, GPS ë°ì´í„° ì €ì¥)
- **íŒì›¨ì–´ ë””ë²„ê·¸ ì½˜ì†”** (printf ë¦¬ë””ë ‰ì…˜)
- **FreeRTOS Queue ê¸°ë°˜ ì‹œë¦¬ì–¼ í†µì‹  Task ë¶„ë¦¬**

------

### í•™ìŠµ ìš”ì•½

âœ… UART â†” USB í†µì‹  íšŒë¡œ ì—°ê²°
 âœ… TeraTerm/PuTTYë¥¼ í†µí•œ ì§ë ¬ í¬íŠ¸ ì œì–´
 âœ… HAL UART Transmit/Receive ì‹¤ìŠµ
 âœ… ì¸í„°ëŸ½íŠ¸ / DMA ê¸°ë°˜ ìˆ˜ì‹  êµ¬ì¡° ì´í•´
 âœ… ì‹¤ì‹œê°„ ë””ë²„ê·¸ ë° ëª…ë ¹ ì²˜ë¦¬ êµ¬í˜„

## 8.8 Modbus RTU í”„ë¡œí† ì½œ ì‹¤ìŠµ

**Modbus RTU**ëŠ” ì‚°ì—… ìë™í™” ë° ì„¼ì„œ ë„¤íŠ¸ì›Œí¬ì—ì„œ ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ì§ë ¬ í†µì‹  í”„ë¡œí† ì½œ ì¤‘ í•˜ë‚˜ì´ë‹¤.
 STM32ì—ì„œ UARTë¥¼ ì´ìš©í•´ Modbus RTUë¥¼ êµ¬í˜„í•˜ë©´, PLC, HMI, ì„¼ì„œ, ì•¡ì¶”ì—ì´í„° ë“±ê³¼ì˜ í‘œì¤€ í†µì‹ ì„ ì‰½ê²Œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.
 ì´ ì ˆì—ì„œëŠ” Modbus RTUì˜ êµ¬ì¡°, í”„ë ˆì„ í˜•ì‹, CRC ê³„ì‚°, ë§ˆìŠ¤í„°/ìŠ¬ë ˆì´ë¸Œ êµ¬í˜„ ë° ì‹¤ìŠµ ì˜ˆì œë¥¼ ë‹¤ë£¬ë‹¤.

------

### Modbus RTU ê°œìš”

Modbus RTUëŠ” RS-485, RS-232, ë˜ëŠ” TTL UARTë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” **ë§ˆìŠ¤í„°-ìŠ¬ë ˆì´ë¸Œ êµ¬ì¡°ì˜ í†µì‹  í”„ë¡œí† ì½œ**ì´ë‹¤.
 ëª¨ë“  í†µì‹ ì€ ìš”ì²­(Request)ê³¼ ì‘ë‹µ(Response)ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë©°, í•˜ë‚˜ì˜ ë§ˆìŠ¤í„°ê°€ ë„¤íŠ¸ì›Œí¬ë¥¼ ì œì–´í•œë‹¤.

| í•­ëª©             | ë‚´ìš©                                           |
| ---------------- | ---------------------------------------------- |
| í†µì‹  ë°©ì‹        | Half-Duplex (RS-485) ë˜ëŠ” Full-Duplex (RS-232) |
| í”„ë ˆì„ í˜•ì‹      | Binary (RTU)                                   |
| ìµœëŒ€ ìŠ¬ë ˆì´ë¸Œ ìˆ˜ | 247ê°œ                                          |
| ì „ì†¡ ì†ë„        | 1200 ~ 115200bps                               |
| ì „ì†¡ ë‹¨ìœ„        | Byte (8N1)                                     |
| ì˜¤ë¥˜ ê²€ì¶œ        | CRC-16 (2 Bytes)                               |

------

### Modbus RTU í”„ë ˆì„ êµ¬ì¡°

| í•„ë“œ             | í¬ê¸°(Byte) | ì„¤ëª…                       |
| ---------------- | ---------- | -------------------------- |
| Slave Address    | 1          | í†µì‹  ëŒ€ìƒ ìŠ¬ë ˆì´ë¸Œ ID      |
| Function Code    | 1          | ëª…ë ¹ ìœ í˜• (Read, Write ë“±) |
| Data             | N          | ìš”ì²­ ë˜ëŠ” ì‘ë‹µ ë°ì´í„°      |
| CRC (Low + High) | 2          | CRC-16 ì˜¤ë¥˜ ê²€ì¶œ ì½”ë“œ      |

**ì˜ˆì‹œ â€” ë ˆì§€ìŠ¤í„° ì½ê¸° ìš”ì²­ (Function 0x03)**

```
01 03 00 10 00 02 C5 CD
```

| ë°”ì´íŠ¸    | ì˜ë¯¸                            |
| --------- | ------------------------------- |
| 0x01      | Slave Address                   |
| 0x03      | Function: Read Holding Register |
| 0x00 0x10 | Start Address = 0x0010          |
| 0x00 0x02 | Read 2 Registers                |
| 0xC5 0xCD | CRC-16 (Low, High)              |

------

### ì£¼ìš” Function Code ëª©ë¡

| ì½”ë“œ | ê¸°ëŠ¥                     | ì„¤ëª…                    |
| ---- | ------------------------ | ----------------------- |
| 0x01 | Read Coils               | ë””ì§€í„¸ ì¶œë ¥ ìƒíƒœ ì½ê¸°   |
| 0x02 | Read Discrete Inputs     | ë””ì§€í„¸ ì…ë ¥ ì½ê¸°        |
| 0x03 | Read Holding Registers   | ì•„ë‚ ë¡œê·¸ ë ˆì§€ìŠ¤í„° ì½ê¸°  |
| 0x04 | Read Input Registers     | ì…ë ¥ ì „ìš© ë ˆì§€ìŠ¤í„° ì½ê¸° |
| 0x05 | Write Single Coil        | ë‹¨ì¼ Coil ì œì–´          |
| 0x06 | Write Single Register    | ë‹¨ì¼ Register ì“°ê¸°      |
| 0x10 | Write Multiple Registers | ì—°ì† Register ì“°ê¸°      |

------

### CRC-16 ê³„ì‚° ë°©ì‹ (Modbus í‘œì¤€ ë‹¤í•­ì‹)

Modbus RTUëŠ” ë‹¤ìŒ ë‹¤í•­ì‹ì„ ì‚¬ìš©í•˜ëŠ” CRCë¥¼ ì ìš©í•œë‹¤:
 **Polynomial:** `0xA001`

#### CRC ê³„ì‚° ì˜ˆì œ ì½”ë“œ

```
uint16_t Modbus_CRC16(uint8_t *buf, uint16_t len)
{
    uint16_t crc = 0xFFFF;

    for (uint16_t pos = 0; pos < len; pos++)
    {
        crc ^= (uint16_t)buf[pos];
        for (int i = 0; i < 8; i++)
        {
            if (crc & 0x0001)
                crc = (crc >> 1) ^ 0xA001;
            else
                crc >>= 1;
        }
    }
    return crc;
}
```

CRC ê²°ê³¼ëŠ” **Low Byte ë¨¼ì € ì „ì†¡**, ì´í›„ **High Byte ì „ì†¡**í•œë‹¤.

------

### í•˜ë“œì›¨ì–´ êµ¬ì„±

| êµ¬ì„± ìš”ì†Œ               | ì—­í•              | ì—°ê²°                  |
| ----------------------- | ---------------- | --------------------- |
| STM32 UART (ì˜ˆ: USART1) | Modbus ì†¡ìˆ˜ì‹     | RS-485 ë³€í™˜ê¸° TX/RX   |
| RS-485 ëª¨ë“ˆ             | Half-duplex ë³€í™˜ | DE/RE í•€ ì œì–´ í•„ìš”    |
| PC / PLC                | Modbus ë§ˆìŠ¤í„°    | USB-RS485 ì–´ëŒ‘í„° ì‚¬ìš© |
| GND                     | ê¸°ì¤€ ì „ìœ„        | ê³µí†µ ì ‘ì§€ í•„ìˆ˜        |

RS-485 ëª¨ë“ˆì˜ **DE(Driver Enable)** í•€ì€ ì†¡ì‹  ì‹œ HIGH, ìˆ˜ì‹  ì‹œ LOWë¡œ ì œì–´í•´ì•¼ í•œë‹¤.

------

### ì†¡ì‹ /ìˆ˜ì‹  ì œì–´ (Half Duplex)

RS-485ëŠ” ë‹¨ì¼ ë¼ì¸ìœ¼ë¡œ ì†¡ìˆ˜ì‹ í•˜ë¯€ë¡œ ì†¡ì‹  ì „í›„ DE í•€ì„ ì œì–´í•´ì•¼ í•œë‹¤.

```
#define RS485_DE_Pin GPIO_PIN_8
#define RS485_DE_Port GPIOA

void RS485_Transmit(uint8_t *data, uint16_t len)
{
    HAL_GPIO_WritePin(RS485_DE_Port, RS485_DE_Pin, GPIO_PIN_SET);   // ì†¡ì‹  Enable
    HAL_UART_Transmit(&huart1, data, len, 100);
    HAL_GPIO_WritePin(RS485_DE_Port, RS485_DE_Pin, GPIO_PIN_RESET); // ìˆ˜ì‹  Enable
}
```

------

### Modbus ë§ˆìŠ¤í„° ìš”ì²­ í”„ë ˆì„ ì˜ˆì œ

```
uint8_t request[8];
uint16_t crc;

request[0] = 0x01;      // Slave ID
request[1] = 0x03;      // Function: Read Holding Register
request[2] = 0x00;      // Start Addr High
request[3] = 0x10;      // Start Addr Low
request[4] = 0x00;      // Quantity High
request[5] = 0x02;      // Quantity Low
crc = Modbus_CRC16(request, 6);
request[6] = crc & 0xFF;        // CRC Low
request[7] = (crc >> 8) & 0xFF; // CRC High

RS485_Transmit(request, 8);
```

**ê²°ê³¼:**

- Modbus ìŠ¬ë ˆì´ë¸Œ(ì˜ˆ: ì„¼ì„œ, MCU)ëŠ” Holding Register 0x0010~0x0011 ë°ì´í„°ë¥¼ ì‘ë‹µ í”„ë ˆì„ìœ¼ë¡œ ì „ì†¡í•œë‹¤.

------

### ìŠ¬ë ˆì´ë¸Œ ì‘ë‹µ í”„ë ˆì„ ì²˜ë¦¬

ì˜ˆì‹œ ì‘ë‹µ:

```
01 03 04 00 64 00 32 F8 25
```

| ë°”ì´íŠ¸    | ì„¤ëª…                |
| --------- | ------------------- |
| 0x01      | Slave Address       |
| 0x03      | Function Code       |
| 0x04      | Data Byte Count     |
| 0x00 0x64 | Register 0 ê°’ (100) |
| 0x00 0x32 | Register 1 ê°’ (50)  |
| 0xF8 0x25 | CRC                 |

ë°ì´í„° íŒŒì‹± ì˜ˆì œ:

```
if (response[1] == 0x03)
{
    uint16_t reg0 = (response[3] << 8) | response[4];
    uint16_t reg1 = (response[5] << 8) | response[6];
}
```

------

### ìŠ¬ë ˆì´ë¸Œ êµ¬í˜„ (STM32ì—ì„œ ì‘ë‹µ ìƒì„±)

```
void Modbus_Slave_Process(uint8_t *rx_buf)
{
    uint8_t slave_id = rx_buf[0];
    uint8_t func = rx_buf[1];

    if (slave_id != MY_SLAVE_ID) return;

    if (func == 0x03) // Read Holding Register
    {
        uint16_t start = (rx_buf[2] << 8) | rx_buf[3];
        uint16_t qty   = (rx_buf[4] << 8) | rx_buf[5];
        uint8_t tx_buf[16];
        uint16_t crc;

        tx_buf[0] = slave_id;
        tx_buf[1] = func;
        tx_buf[2] = qty * 2;

        for (int i = 0; i < qty; i++)
        {
            uint16_t val = HoldingReg[start + i];
            tx_buf[3 + i * 2] = val >> 8;
            tx_buf[4 + i * 2] = val & 0xFF;
        }

        crc = Modbus_CRC16(tx_buf, 3 + qty * 2);
        tx_buf[3 + qty * 2] = crc & 0xFF;
        tx_buf[4 + qty * 2] = crc >> 8;

        RS485_Transmit(tx_buf, 5 + qty * 2);
    }
}
```

------

### ì‹¤ìŠµ ì‹œë‚˜ë¦¬ì˜¤

| ë‹¨ê³„ | ì„¤ëª…                                                 |
| ---- | ---------------------------------------------------- |
| 1    | STM32 ë³´ë“œë¥¼ Modbus ìŠ¬ë ˆì´ë¸Œë¡œ ì„¤ì • (`Slave ID = 1`) |
| 2    | RS-485 ë³€í™˜ê¸°ë¥¼ í†µí•´ PC ì—°ê²°                         |
| 3    | PCì—ì„œ Modbus Poll í”„ë¡œê·¸ë¨ ì‹¤í–‰                     |
| 4    | Function Code 0x03ìœ¼ë¡œ Register 0x0010 ì½ê¸° ìš”ì²­     |
| 5    | STM32ê°€ ì‘ë‹µ í”„ë ˆì„ ì „ì†¡                             |
| 6    | PCì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ì„¼ì„œê°’ í™•ì¸                        |

------

### í…ŒìŠ¤íŠ¸ ë„êµ¬

- **Modbus Poll** (Windows, ë§ˆìŠ¤í„° ì‹œë®¬ë ˆì´í„°)
- **ModScan32 / ModRSsim** (RTU/ASCII í…ŒìŠ¤íŠ¸ìš©)
- **QModMaster** (Linux, ì˜¤í”ˆì†ŒìŠ¤)

------

### ë””ë²„ê¹… í¬ì¸íŠ¸

| ë¬¸ì œ               | ì›ì¸              | í•´ê²° ë°©ë²•                      |
| ------------------ | ----------------- | ------------------------------ |
| ì‘ë‹µ ì—†ìŒ          | ì†¡ì‹  DE í•€ ë¯¸ì œì–´ | ì†¡ì‹  ì „í›„ DE í•€ ì œì–´ ì½”ë“œ ì¶”ê°€ |
| CRC ì˜¤ë¥˜           | Endian ìˆœì„œ ë°˜ëŒ€  | CRC Low/High ë°”ì´íŠ¸ ìˆœì„œ í™•ì¸  |
| íƒ€ ìŠ¬ë ˆì´ë¸Œ í˜¼ì„    | ID ì¤‘ë³µ           | ìŠ¬ë ˆì´ë¸Œ ID ìœ ì¼í•˜ê²Œ ì„¤ì •      |
| ê°„í—ì  ë°ì´í„° ê¹¨ì§ | Baudrate ë¶ˆì¼ì¹˜   | PCì™€ MCU ì„¤ì • ì¼ì¹˜ í™•ì¸        |

------

### ì‘ìš© í™•ì¥

- FreeRTOS í™˜ê²½ì—ì„œ **Modbus Task** ë¶„ë¦¬
- **Modbus RTU â†’ TCP ê²Œì´íŠ¸ì›¨ì´** êµ¬í˜„
- **ì„¼ì„œ ë°ì´í„° í†µí•© ê´€ë¦¬ ì‹œìŠ¤í…œ (SCADA, HMI ì—°ë™)**
- **ì‚°ì—…ìš© ì¥ë¹„ ì œì–´, ì˜¨ë„/ì••ë ¥ ë¡œê±°** ë“±

------

### í•™ìŠµ ìš”ì•½

âœ… Modbus RTU í”„ë ˆì„ êµ¬ì¡° ì´í•´
 âœ… CRC-16 ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
 âœ… RS-485 DE í•€ ì œì–´
 âœ… ë§ˆìŠ¤í„°/ìŠ¬ë ˆì´ë¸Œ ì†¡ìˆ˜ì‹  ì½”ë“œ ì‘ì„±
 âœ… Modbus Poll íˆ´ì„ ì´ìš©í•œ ê²€ì¦