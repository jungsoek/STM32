# 2. CubeIDE 기본 사용법

## 2.1 Project 구조 및 폴더 설명

STM32CubeIDE에서 생성되는 프로젝트 구조는 **CubeMX 코드 생성 규칙**과 **Eclipse CDT 프로젝트 구조**가 결합된 형태로 구성된다.
 각 폴더와 파일은 빌드 과정, 코드 관리, 자동 생성 코드 분리, 사용자 코드 보호 등을 위한 명확한 목적을 가진다.
 아래는 STM32CubeIDE 기본 프로젝트 구조의 세부 구성이다.

------

### Core 폴더

펌웨어의 메인 애플리케이션 코드를 포함한다.

- **main.c**
   프로그램의 진입점. `HAL_Init()`, `SystemClock_Config()`, `MX_GPIO_Init()` 등의 초기화 루틴 포함.
   사용자 코드는 `/* USER CODE BEGIN */`, `/* USER CODE END */` 구역 내에 작성해야 CubeMX 재생성 시 덮어쓰이지 않는다.
- **stm32fxxx_it.c / .h**
   인터럽트 핸들러 정의 파일. 모든 `IRQHandler()` 함수가 포함되며, `startup_xxx.s`의 벡터 테이블과 연결된다.
- **system_stm32fxxx.c**
   시스템 클록 초기화 함수(`SystemInit()`, `SystemCoreClockUpdate()`) 포함.
   PLL, HSE, HSI 등의 클록 설정값을 반영.
- **startup_stm32fxxx.s**
   어셈블리 기반 스타트업 코드. 벡터 테이블, 초기 스택 포인터, `Reset_Handler`를 정의하며
   `main()`이 실행되기 전 초기화 절차를 수행한다.

------

### Drivers 폴더

STM32Cube HAL 및 CMSIS 레이어 관련 드라이버를 포함한다.

- **CMSIS/**
   ARM Cortex-M 코어용 표준 레지스터 접근 인터페이스.
   `core_cm3.h`, `core_cm4.h`, `system_stm32f1xx.h` 등 코어별 헤더 포함.
   CMSIS-Core는 HAL과 독립적이며, NVIC, SysTick, SCB 등 프로세서 레벨 접근을 제공한다.
- **STM32Fxx_HAL_Driver/**
   ST의 하드웨어 추상화 계층(HAL) 라이브러리.
   `stm32f1xx_hal_gpio.c`, `stm32f1xx_hal_tim.c`, `stm32f1xx_hal_adc.c` 등 각 주변장치별 드라이버 포함.
   HAL은 LL(Low Layer) 기반으로 구성되어 있으며, 하드웨어 레지스터 접근을 구조화된 함수로 제공한다.
- **BSP/** (Board Support Package)
   ST 공식 개발보드(Discovery, Nucleo 등)에 특화된 보드 추상화 계층.
   LED, BUTTON, LCD 등의 하드웨어 자원 초기화 및 제어 함수 제공.

------

### Middlewares 폴더

USB, FATFS, FreeRTOS 등 독립형 미들웨어 라이브러리를 포함한다.
 CubeMX 설정 시 활성화된 미들웨어만 자동으로 포함되며,
 예를 들어 FATFS를 활성화하면 `Middlewares/FatFs/` 폴더와 관련 설정이 자동 생성된다.

------

### Inc 및 Src 폴더

사용자 정의 헤더(`Inc/`)와 소스(`Src/`) 파일이 위치한다.

- `Inc/`: 프로젝트 전역 헤더 파일 관리.
   예: `main.h`, `gpio.h`, `tim.h`, `usart.h`.
- `Src/`: CubeMX에서 자동 생성된 주변장치 초기화 코드.
   예: `gpio.c`, `tim.c`, `usart.c`.

사용자 정의 모듈을 추가할 경우, 반드시 이 구조를 유지하는 것이 좋다.

------

### .ioc 파일

CubeMX의 하드웨어 설정 정보가 저장되는 XML 기반 파일.
 이 파일은 프로젝트의 “설계도” 역할을 하며, 주변장치 설정, 클록 구성, 핀 매핑 정보를 포함한다.
 `.ioc` 파일을 수정하고 저장하면 CubeMX가 자동으로 관련 초기화 코드를 재생성한다.

------

### .project / .cproject 파일

Eclipse CDT 프로젝트 메타데이터 파일.
 빌드 경로, 컴파일러 옵션, 링크 설정, 인클루드 디렉토리 등이 포함된다.
 직접 편집보다는 IDE 설정창을 통해 변경하는 것이 안전하다.

------

### STM32CubeIDE 내부 빌드 구조

CubeIDE는 **GNU Arm Embedded Toolchain**을 사용하며, 다음 순서로 빌드가 진행된다.

1. `.c` → `.o` 컴파일 (GCC)
2. `.o` → `.elf` 링킹 (ld, linker script)
3. `.elf` → `.bin` / `.hex` 변환 (objcopy)
4. `.elf` → 디버깅 정보 포함 실행파일로 사용

`Debug/` 또는 `Release/` 폴더 내에 결과물(`.elf`, `.map`, `.bin`)이 생성된다.

------

## 2.2 .ioc 설정 파일 분석

STM32CubeMX의 `.ioc` 파일은 프로젝트의 **하드웨어 설정 메타데이터**로서, XML 구조를 기반으로 각 주변장치, 핀, 클록, 미들웨어 정보를 포함한다.
 해당 파일은 CubeMX GUI의 모든 설정 상태를 반영하며, 코드 자동 생성을 위한 핵심 입력 데이터로 사용된다.

------

### .ioc 파일의 구조

#### 1. 프로젝트 기본 정보

```
#MicroXplorer Configuration settings
ProjectManager.ProjectName=STM32F103C8T6_Test
ProjectManager.FirmwarePackage=STM32Cube_FW_F1_V1.8.5
ProjectManager.Toolchain=STM32CubeIDE
```

- 프로젝트 이름, 펌웨어 버전, 타깃 MCU, 툴체인 정보를 지정한다.
- CubeIDE와 CubeMX 간의 버전 호환성을 유지해야 빌드 오류가 발생하지 않는다.

------

#### 2. 핀 설정 (Pin Configuration)

```
PA5.GPIO_Label=LED
PA5.GPIO_Mode=Output_PP
PB6.GPIO_Label=USART1_TX
PB7.GPIO_Label=USART1_RX
```

- 각 핀의 기능, 모드, 초기 상태를 정의.
- CubeMX의 “Pinout & Configuration” 탭에서 시각적으로 매핑된다.

CubeMX는 이 정보를 기반으로 `gpio.c`에서

```
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
```

과 같은 초기화 코드를 자동 생성한다.

------

#### 3. 주변장치 설정 (Peripheral Configuration)

```
USART1.IPParameters=BaudRate,Mode,WordLength,StopBits,Parity
USART1.BaudRate=115200
USART1.Mode=TX_RX
USART1.WordLength=UART_WORDLENGTH_8B
```

- 각 주변장치별 초기화 파라미터를 기록.
- 이 정보는 `MX_USART1_Init()` 등 함수 생성 시 사용된다.

------

#### 4. 클록 트리 구성 (RCC Configuration)

```
RCC.HSE_VALUE=8000000
RCC.PLLMUL=PLL_MUL_9
RCC.SYSCLKSource=PLLCLK
```

- PLL 배수, HSE/HSI 선택, APB/AHB 분주비 등 클록 트리 구조 정의.
- CubeMX의 Clock Configuration 탭에서 실시간 계산 및 시각적 검증 가능.

------

#### 5. 미들웨어 및 FreeRTOS 설정

```
FREERTOS.IPParameters=Tasks,HeapSize
FREERTOS.Tasks0.Name=Task1
FREERTOS.Tasks0.StackSize=128
```

- FreeRTOS, USB, FATFS 등 미들웨어 설정을 포함.
- 자동 생성 시 `freertos.c`, `usb_device.c` 등의 소스가 함께 추가된다.

------

### .ioc 파일 수정 시 주의사항

- 수동 편집은 가능하나, CubeMX 내부 XML 파서 구조를 손상시키지 않도록 주의해야 한다.
- CubeMX에서 다시 저장하면 수동 변경 내용이 덮어쓰기될 수 있다.
- 프로젝트 버전 관리(Git 등)에서는 `.ioc` 파일 변경 이력을 반드시 추적하는 것이 권장된다.

------

### .ioc 파일의 역할 요약

| 구성 항목           | 기능                                 | 자동 생성 대상 파일          |
| ------------------- | ------------------------------------ | ---------------------------- |
| Pin Configuration   | 핀 모드 및 기능 매핑                 | `gpio.c` / `gpio.h`          |
| Peripheral Setup    | 타이머, UART, ADC 등 초기화 파라미터 | `tim.c`, `usart.c`, `adc.c`  |
| Clock Configuration | PLL, SYSCLK, AHB/APB 설정            | `system_stm32fxxx.c`         |
| Middleware Setup    | RTOS, USB, FATFS 등                  | `freertos.c`, `usb_device.c` |
| Project Info        | 프로젝트 이름, MCU, 툴체인           | IDE 메타데이터               |

------

즉, `.ioc` 파일은 STM32Cube 프로젝트의 **하드웨어 설정 스냅샷**으로,
 **CubeMX → HAL 코드 생성 → 빌드 → 펌웨어 실행**의 전체 흐름을 제어하는 핵심 데이터이다.2.3 Peripheral Configuration

## 2.4 Pinout View / Configuration 탭 활용

STM32CubeIDE의 **Pinout & Configuration 탭**은 MCU의 모든 핀 기능을 시각적으로 구성하고, 주변장치 활성화 및 파라미터 설정을 수행하는 핵심 도구이다.
 이 탭은 CubeMX 엔진을 기반으로 동작하며, **핀 매핑(Pinout)**, **주변장치 설정(Configuration)**, **클록 트리 설정(Clock Tree)**, **프로젝트 리소스 관리**를 통합적으로 제어한다.

------

### Pinout View 개요

화면 좌측에는 MCU의 실제 패키지 형태가 표시되고, 각 핀에 대해 기능(Function) 할당 및 모드 설정을 수행할 수 있다.
 마우스 클릭으로 주변장치를 활성화하면 자동으로 해당 핀들이 점유되며, 충돌 시 경고가 표시된다.

#### 주요 인터페이스 요소

- **MCU Selector (Device Selector)**
   특정 MCU나 보드 선택 시 해당 핀맵이 자동으로 로드된다.
   예: STM32F103C8T6 → LQFP48 패키지 핀맵 표시
- **Pin Highlighting**
   선택한 주변장치(예: USART1, TIM2)에 연결된 모든 핀이 색상으로 강조 표시된다.
   기능별 색상 구분으로 SPI, I²C, ADC 등 확인이 용이하다.
- **Pin Search / Filter 기능**
   우측 “Pinout” 창에서 특정 핀명(PA5), 기능(GPIO_Output), 주변장치(USART1)로 검색 가능.

------

### Pin Configuration (핀 설정)

핀을 클릭하면 **핀 모드, 속도, Pull-Up/Pull-Down, 초기 출력 상태**를 설정할 수 있는 창이 열린다.

#### 설정 항목 예시

| 항목          | 설명                  | 예시 값                                        |
| ------------- | --------------------- | ---------------------------------------------- |
| GPIO Mode     | 핀 동작 모드          | Output Push-Pull / Alternate Function / Analog |
| GPIO Speed    | 출력 속도 (slew rate) | Low, Medium, High                              |
| Pull-up/down  | 내부 풀업/풀다운 저항 | Pull-up / Pull-down / No Pull                  |
| Default State | 초기 출력 레벨        | High / Low                                     |

예를 들어, **PA5를 LED 제어용 출력**으로 지정하면

```
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
```

와 같은 코드가 `gpio.c`에 자동 생성된다.

------

### Peripherals Configuration 탭

Pinout View에서 활성화된 주변장치(USART, TIM, ADC 등)는 “Configuration” 탭에서 세부 설정이 가능하다.
 이 영역은 CubeMX의 핵심 기능 중 하나로, 하드웨어 초기화 코드 생성의 기반이 된다.

#### 주요 설정 항목

- **USART Configuration:** Baud rate, Stop bit, Parity, Mode (TX/RX)
- **Timer Configuration:** Prescaler, Counter Mode, PWM Channel, Frequency
- **ADC Configuration:** Resolution, Sampling Time, Trigger Source
- **I²C / SPI:** Clock Speed, Duty Cycle, Data Frame Size 등

각 설정 변경 시 자동으로 `.ioc` 파일에 반영되고, “Generate Code” 시 `MX_XXXX_Init()` 함수로 코드화된다.

------

### GPIO View / System View

- **GPIO View:** 전체 핀의 기능 요약 테이블. 충돌 여부, 초기 상태, 모드 확인 가능.
- **System View:** MCU 리소스 개요(클록, 메모리, 전원, IO 포트, 인터럽트 라인 등)를 구조적으로 표시.

------

### Pinout Conflict 처리

두 개 이상의 주변장치가 동일한 핀을 사용하는 경우 CubeMX는 충돌 경고를 표시한다.
 예: USART1_TX(PA9)와 TIM1_CH2N(PA9)가 동시에 활성화될 경우 “Pin conflict” 메시지가 표시됨.
 해결 방법은 **대체 핀(Remapping)** 선택 혹은 한쪽 주변장치 비활성화이다.

------

### 실제 설계 시 주의사항

- 외부 하드웨어와의 전기적 호환성(전압, 전류, Pull-up 여부) 반드시 확인.
- 특정 핀은 부트 모드나 디버그(JTAG/SWD)로 예약되어 있으므로 변경 시 주의 필요.
- CubeMX 상의 핀 설정은 물리적 배선과 항상 일치해야 하며, 회로도 설계와 병행 검증 필수.

------

## 2.5 Middleware 추가 (FreeRTOS, USB, FATFS 등)

STM32CubeIDE는 **CubeMX 통합 구조**를 통해 FreeRTOS, USB, FATFS, LWIP, TouchGFX 등 다양한 미들웨어를 자동 통합할 수 있다.
 이들은 HAL 위에 추상화된 소프트웨어 계층으로, 복잡한 기능(파일 시스템, RTOS 스케줄링, 네트워킹 등)을 간편히 구현하게 한다.

------

### Middleware 구성 개요

CubeMX에서 “Software Packs → Middleware” 항목을 통해 활성화 가능하며,
 활성화 시 해당 모듈의 설정, 코드 템플릿, 소스 파일이 `Middlewares/` 폴더에 자동 추가된다.

------

### FreeRTOS 추가

**FreeRTOS**는 실시간 태스크 스케줄러로, 다중 작업 환경을 제공한다.
 CubeMX에서 “Middleware → FreeRTOS”를 활성화하면 다음과 같은 구조가 자동 생성된다.

#### 생성 파일

- `freertos.c`, `freertos.h`: 태스크, 큐, 세마포어 초기화 코드
- `FreeRTOSConfig.h`: 커널 설정 (Tick rate, Heap size, Priority 등)

#### 주요 설정 항목

| 설정 항목         | 설명                                            |
| ----------------- | ----------------------------------------------- |
| CMSIS-OS API      | HAL 기반 FreeRTOS 래퍼 사용 여부                |
| Tick Frequency    | OS 타이머 틱 주기 설정 (일반적으로 1ms)         |
| Memory Allocation | 동적/정적 할당 선택                             |
| Tasks / Queues    | CubeMX GUI에서 태스크 이름, 스택, 우선순위 지정 |

예시 태스크:

```
void StartDefaultTask(void *argument) {
  for(;;) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    osDelay(500);
  }
}
```

빌드 시 HAL 드라이버와 자동 연계되어 `osDelay()`가 `vTaskDelay()`로 매핑된다.

------

### FATFS 추가

**FATFS**는 SD 카드 또는 Flash 메모리 파일 시스템을 지원하는 미들웨어이다.
 CubeMX에서 “Middleware → FATFS” 활성화 후, 인터페이스(예: SDIO, SPI)를 연결해야 정상 동작한다.

#### 생성 구조

- `fatfs.c`, `fatfs.h`: 드라이브 마운트, 초기화 코드
- `ff.c`, `diskio.c`: FATFS 커널 및 하드웨어 인터페이스
- `user_diskio.c`: 사용자 정의 I/O 함수 (`disk_read`, `disk_write`, `disk_ioctl`)

#### 예시 코드

```
FATFS fs;
FIL file;
f_mount(&fs, "", 1);
f_open(&file, "test.txt", FA_WRITE | FA_CREATE_ALWAYS);
f_write(&file, "Hello STM32", 12, &bw);
f_close(&file);
```

------

### USB Device / Host

CubeMX는 USB 장치를 **Device (예: CDC, HID, MSC)** 또는 **Host (예: 키보드, 마우스 인식)** 모드로 구성할 수 있다.

#### 주요 클래스

| 클래스 | 용도                                    | 생성 파일                       |
| ------ | --------------------------------------- | ------------------------------- |
| CDC    | Virtual COM Port                        | `usbd_cdc_if.c`, `usb_device.c` |
| HID    | Human Interface Device (마우스, 키보드) | `usbd_hid.c`                    |
| MSC    | Mass Storage (USB Flash)                | `usbd_msc.c`                    |

CDC 예시:
 PC와의 가상 시리얼 통신을 통해 데이터 송수신 가능.

```
uint8_t msg[] = "USB CDC Test\r\n";
CDC_Transmit_FS(msg, sizeof(msg));
```

------

### LWIP (Ethernet TCP/IP Stack)

STM32F4 이상에서 이더넷 기능이 활성화된 MCU는 LWIP 미들웨어를 추가할 수 있다.

- `app_lwip.c`: 네트워크 인터페이스 초기화
- `ethernetif.c`: PHY / MAC 드라이버 연동
- `lwipopts.h`: 버퍼 크기, 소켓 수 등 설정 포함

------

### TouchGFX

GUI 애플리케이션용 미들웨어.
 CubeMX에서 “TouchGFX Generator”를 활성화하면, 별도의 TouchGFX Designer 프로젝트가 연동된다.
 `Core/TouchGFX/` 폴더에 그래픽 프레임워크 코드가 포함되며, CubeIDE에서 병행 빌드 가능.

------

### 미들웨어 추가 시 주의사항

1. **FreeRTOS와 HAL의 우선순위 관리** 필요 — HAL의 콜백과 태스크가 동시에 자원을 접근하지 않도록 Mutex 사용.
2. **USB, FATFS, RTOS 동시 활성화 시 스택 사용량 급증** — `heap size`와 `stack size` 조정 필수.
3. **FATFS + FreeRTOS 조합 시 reentrant 옵션**(`_FS_REENTRANT=1`)을 반드시 설정.
4. **USB MSC + SDIO 조합 시 DMA 우선순위 조정** 필요 — 전송 충돌 방지.

------

### 요약

| 미들웨어   | 주요 목적       | 생성 파일                    | 주요 의존성      |
| ---------- | --------------- | ---------------------------- | ---------------- |
| FreeRTOS   | RTOS 스케줄링   | freertos.c, FreeRTOSConfig.h | HAL, CMSIS-OS    |
| FATFS      | 파일 시스템     | fatfs.c, diskio.c            | SDIO/SPI         |
| USB Device | USB CDC/HID/MSC | usb_device.c                 | HAL PCD          |
| LWIP       | TCP/IP 스택     | app_lwip.c                   | Ethernet HAL     |
| TouchGFX   | GUI 프레임워크  | TouchGFX/*                   | HAL DMA2D / LTDC |

------

결론적으로, STM32CubeIDE의 미들웨어 관리 기능은 **RTOS, 파일 시스템, USB 통신, GUI** 등의 복잡한 기능을
 “자동 생성 + HAL 기반 통합 구조”로 구현할 수 있게 하며,
 임베디드 시스템 개발의 확장성과 유지보수성을 크게 향상시킨다.

## 2.6 Code Generation 설정 (HAL Init, User Code 영역)

STM32CubeIDE에서 코드 생성은 CubeMX의 `.ioc` 설정을 기반으로 자동 수행된다.
 이 과정에서 **HAL 초기화 루틴, 주변장치 설정 함수, 사용자 코드 보호 구역**이 함께 구성되며,
 코드 구조를 일관성 있게 유지하기 위한 자동화 규칙이 적용된다.

------

### 코드 생성 구조 개요

CubeMX의 “Project Manager → Code Generator” 탭에서 설정 가능하며, 다음 요소들이 제어된다.

- **HAL Initialization (HAL_Init)**
- **Peripheral Initialization (MX_XXX_Init)**
- **User Code Protection Blocks**
- **Function Call Order**
- **Code Regeneration Options**

------

### HAL 초기화 흐름

STM32CubeMX로 생성된 `main.c`는 기본적으로 다음 순서로 실행된다:

```
int main(void)
{
  HAL_Init();                       // HAL 레이어 초기화
  SystemClock_Config();             // 클록 설정
  MX_GPIO_Init();                   // GPIO 초기화
  MX_USART1_UART_Init();            // UART 초기화 (예시)
  MX_ADC1_Init();                   // ADC 초기화 (예시)
  while (1)
  {
    /* USER CODE BEGIN WHILE */
    /* USER CODE END WHILE */
  }
}
```

#### HAL_Init()

- NVIC 우선순위 그룹 설정 (`HAL_NVIC_SetPriorityGrouping()`)
- SysTick 타이머 구성 (`HAL_InitTick()`)
- HAL 전역 상태 초기화 (`HAL_MspInit()` 호출)
- 인터럽트 벡터 및 기본 HAL 구조 초기화 수행

`HAL_Init()` → `HAL_MspInit()` → 각 주변장치 `HAL_xxx_MspInit()` 순으로 호출되며,
 이 구조는 하드웨어 종속 초기화 코드를 분리하여 유지보수를 용이하게 한다.

------

### User Code 영역

CubeMX가 자동으로 생성하는 코드의 가장 중요한 특징은 **사용자 코드 보호 주석 블록**이다.
 이 영역 내부에 작성된 코드는 CubeMX 재생성 시 덮어쓰이지 않는다.

예시:

```
/* USER CODE BEGIN 0 */
#include "custom_sensor.h"
/* USER CODE END 0 */

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  
  /* USER CODE BEGIN 2 */
  Sensor_Init();
  /* USER CODE END 2 */

  while (1)
  {
    /* USER CODE BEGIN WHILE */
    Sensor_Update();
    /* USER CODE END WHILE */
  }
}
```

#### 주요 사용자 코드 구역

| 구역                            | 위치             | 용도                      |
| ------------------------------- | ---------------- | ------------------------- |
| `USER CODE BEGIN Includes`      | `#include` 상단  | 사용자 헤더 추가          |
| `USER CODE BEGIN 0`             | main 상단        | 전역 변수, 초기 함수 선언 |
| `USER CODE BEGIN 2`             | 초기화 완료 후   | 사용자 초기화 루틴        |
| `USER CODE BEGIN WHILE`         | 메인 루프        | 주 반복 동작 코드         |
| `USER CODE BEGIN Callback`      | 각 HAL 콜백 내부 | 사용자 인터럽트 핸들러    |
| `USER CODE BEGIN Error_Handler` | 오류 처리 루틴   | 시스템 예외 처리          |

이 구조를 통해 **자동 생성 코드와 사용자 정의 코드의 경계**를 명확히 구분할 수 있다.

------

### Code Generation 설정 옵션

CubeMX의 “Project Manager → Code Generator” 탭에서 다음 옵션들을 조정할 수 있다:

| 옵션                                                         | 설명                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| Generate peripheral initialization as a pair of `.c/.h` files per peripheral | `gpio.c/h`, `usart.c/h`처럼 주변장치별 파일 생성 |
| Keep User Code when re-generating                            | `USER CODE` 블록 내부 유지                       |
| Backup previously generated files when re-generating         | 이전 버전 백업 자동 생성                         |
| Delete previously generated files when not re-generated      | 비활성화된 주변장치 파일 삭제                    |
| Generate initialization function call in main.c              | `MX_xxx_Init()` 자동 호출 여부                   |

------

### 코드 재생성 시 동작

- `.ioc` 파일이 변경될 때마다 CubeMX가 `Src/` 및 `Inc/`를 재생성한다.
- `USER CODE` 영역은 그대로 유지되며, 블록 외부의 코드는 자동 갱신된다.
- 새로운 주변장치 추가 시 해당 `.c/.h` 쌍이 생성되고, 기존 코드는 유지된다.
- “Regenerate Code” 버튼 클릭 시 `stm32cubeide`가 내부적으로 `MX_GenerateCode()` 함수를 호출한다.

------

### 주의사항

1. **USER CODE 블록 외부 수정 금지**
    → CubeMX 재생성 시 손실될 수 있음.
2. **main.c 구조 변경 금지**
    → 초기화 순서가 변경되면 HAL 의존 코드가 정상 작동하지 않을 수 있음.
3. **HAL_Init() 생략 금지**
    → NVIC, SysTick, HAL 상태가 초기화되지 않아 비정상 동작 가능.

------

## 2.7 Build / Clean / Flash / Debug

STM32CubeIDE는 Eclipse CDT 기반으로, GCC ARM Toolchain을 통해 프로젝트를 빌드하고
 ST-LINK 또는 J-Link 디버거를 이용해 펌웨어를 MCU에 다운로드 및 디버깅한다.

------

### Build (컴파일 및 링킹)

#### 빌드 과정

1. **Preprocessing** — `#include`, `#define` 처리
2. **Compilation** — `.c` → `.o` 변환 (ARM GCC)
3. **Linking** — `.o` + 라이브러리 → `.elf` 생성 (`ld` 사용)
4. **Binary Conversion** — `.elf` → `.bin` / `.hex` (`objcopy`)

결과물은 `Debug/` 또는 `Release/` 디렉터리에 저장된다.

- `project.elf` : ELF 실행 바이너리 (디버그 정보 포함)
- `project.bin` : MCU에 직접 Flash 가능한 순수 데이터
- `project.map` : 메모리 및 심볼 맵 정보

#### 빌드 설정 변경

```
Project → Properties → C/C++ Build → Settings
```

- **MCU GCC Compiler** : Include path, define, optimization level 설정
- **MCU GCC Linker** : Linker script (`.ld`), library 경로 설정
- **MCU GDB Debugger** : 디버거 인터페이스 설정

------

### Clean (정리 빌드)

`Project → Clean…` 수행 시 이전 빌드 결과물(`.o`, `.elf`, `.bin`) 삭제 후 완전 재빌드 수행.
 빌드 환경 변경, 링커 스크립트 수정, 새 라이브러리 추가 시 반드시 Clean 빌드 권장.

------

### Flash (펌웨어 다운로드)

STM32CubeIDE는 ST-LINK를 기본 지원하며, USB로 연결된 MCU에 직접 플래시 프로그래밍을 수행한다.

#### 주요 Flash 절차

1. **Target 선택:** Run Configuration 또는 Debug Configuration에서 MCU 지정
2. **ST-LINK 연결 확인:** 하단 콘솔에서 “Connected via ST-LINK/V2” 표시
3. **Program and Verify:**
   - `project.elf` 또는 `project.bin`을 MCU Flash에 기록
   - 자동으로 CRC 검증 수행
4. **Reset After Programming:** 다운로드 후 MCU 자동 리셋 (옵션 선택 가능)

#### Flash 모드 선택

| 모드            | 설명                             |
| --------------- | -------------------------------- |
| Run             | 단순히 프로그램 다운로드 후 실행 |
| Debug           | Flash 후 GDB 세션 자동 시작      |
| External Loader | 외부 SPI Flash 사용 시           |

------

### Debug (디버깅 세션)

STM32CubeIDE의 디버거는 **GDB (GNU Debugger)** 기반으로,
 ST-LINK를 통해 MCU의 메모리, 레지스터, 스택을 실시간으로 제어한다.

#### 주요 기능

- **Step Over / Step Into / Step Return** : 명령 단위 실행 제어
- **Breakpoint** : 코드 중단점 지정
- **Watch / Expressions** : 변수 값 실시간 추적
- **Memory View** : SRAM/Flash 영역 직접 접근
- **Peripherals View** : 레지스터 상태 확인 (GPIO, USART, TIM 등)
- **RTOS View (FreeRTOS 활성화 시)** : 태스크, 스택, 우선순위 모니터링

#### 실행 예시

1. `Debug` 버튼 클릭 → `ST-LINK GDB Server` 자동 실행
2. MCU Flash 다운로드 후 프로그램 자동 중단 (`main()` 진입점)
3. F5 (Step Into), F6 (Step Over)로 단계별 실행 가능
4. Variables 창에서 변수 값 실시간 확인

------

### Debug Configuration 주요 항목

| 항목                    | 설명                            |
| ----------------------- | ------------------------------- |
| Interface               | SWD / JTAG 선택                 |
| Reset Mode              | Software / Hardware reset       |
| Download Mode           | Always / When Required          |
| Connect Under Reset     | 특정 부트 모드 MCU 연결 시 필요 |
| Enable Live Expressions | 변수 실시간 그래프 출력         |

------

### 디버깅 시 유용한 기능

- **Memory Browser:** 주소 직접 입력 후 데이터 확인 (`0x20000000` → SRAM)
- **Registers 탭:** GPIOx->ODR, TIMx->CNT 등 레지스터 실시간 추적
- **Instruction Stepping Mode:** 어셈블리 단위 디버깅
- **SWV (Serial Wire Viewer):** 실시간 로그, PC Trace, Event Counter 지원 (F4/H7 시리즈)

------

### Flash & Debug 시 주의사항

1. **ST-LINK 드라이버**가 최신 버전인지 확인 (`STM32CubeProgrammer` 패키지 포함).
2. **BOOT0 핀 상태**가 0(VSS)로 설정되어 있어야 내부 Flash 부팅 가능.
3. **Debug 세션 중 핫 언플러그 금지** — ST-LINK 세션 손상 및 MCU 리셋 불가 상태 발생 가능.
4. **Optimization Level -O2 이상** 사용 시 디버그 정보 손실 가능 → 개발 단계에서는 `-Og` 권장.

------

### 빌드 및 디버그 전체 흐름 요약

```
[.ioc 설정] 
   ↓
[CubeMX Code Generation]
   ↓
[GCC Compile & Link (Build)]
   ↓
[.elf/.bin 생성]
   ↓
[ST-LINK Flash Download]
   ↓
[GDB Debug Session (실행/중단/분석)]
```

이 과정은 STM32CubeIDE 내에서 **완전히 통합된 워크플로우**로 수행되며,
 하드웨어 구성에서 코드 생성, 빌드, 다운로드, 디버깅까지 일련의 절차를 단일 환경에서 관리할 수 있다.

## 2.8 STM32CubeProgrammer 연동 (DFU, ST-Link)

STM32CubeProgrammer(이하 **CubeProg**)는 STMicroelectronics에서 제공하는 **통합 펌웨어 다운로드 및 메모리 관리 툴**이다.
 STM32CubeIDE와 직접 연동되어 ST-Link, DFU(USB), UART, CAN 등 다양한 인터페이스로 MCU에 접근할 수 있다.

------

### CubeProgrammer 개요

- **지원 인터페이스:** ST-Link / DFU / UART / SPI / CAN / JTAG
- **기능:**
  - Flash / EEPROM 프로그래밍
  - 메모리 덤프 / 확인 / 비교
  - 옵션 바이트(Option Bytes) 설정
  - 보안 영역 관리 (RDP, WRP)
  - OTP(One Time Programmable) 메모리 접근
  - DFU 모드 진입 및 USB 부트로더 관리

------

### CubeProgrammer 설치 및 실행

1. ST 공식 사이트에서 설치 파일 다운로드
    👉 https://www.st.com/stm32cubeprog
2. 설치 시 ST-Link USB 드라이버 및 DFU 드라이버 함께 설치
3. 실행 후 인터페이스 선택 창에서 연결 방법 지정

------

### ST-Link 모드 연결

ST-Link는 STM32CubeIDE의 기본 디버그/프로그래밍 인터페이스이며,
 CubeProg에서도 동일한 방식으로 Flash 접근이 가능하다.

#### 연결 방법

1. ST-Link를 PC와 MCU에 연결 (SWDIO, SWCLK, GND, 3.3V)
2. CubeProg 실행 → “ST-Link” 선택
3. “Connect” 클릭 → Target MCU 자동 인식
4. 우측 Memory & File 탭에서 `.elf` / `.bin` / `.hex` 파일 선택
5. “Download” 클릭 → Flash 프로그래밍 수행

#### 주요 기능

| 기능                    | 설명                         |
| ----------------------- | ---------------------------- |
| **Full Chip Erase**     | 전체 Flash 영역 삭제         |
| **Sector Erase**        | 선택 영역만 삭제             |
| **Program & Verify**    | 다운로드 후 CRC 검증         |
| **Option Bytes**        | RDP, nBOOT, BOR 등 보안 설정 |
| **Memory Read / Write** | 실시간 메모리 접근           |

#### 연결 오류 시 확인

- SWD 핀 연결 확인 (SWDIO, SWCLK)
- BOOT0 핀 상태 0으로 유지
- 전원(3.3V) 안정 공급
- ST-Link 펌웨어 최신 버전 유지 (`STLinkUpgrade.exe` 사용 가능)

------

### DFU(USB Device Firmware Upgrade) 모드

STM32의 내장 USB 부트로더를 이용하여 **USB 케이블만으로 펌웨어 업로드**가 가능한 모드이다.
 개발 보드에 따라 BOOT 핀 설정만으로 진입할 수 있다.

#### DFU 모드 진입 방법

| 핀 설정              | 동작                                |
| -------------------- | ----------------------------------- |
| BOOT0 = 1, BOOT1 = 0 | System Memory (DFU Bootloader) 진입 |
| BOOT0 = 0, BOOT1 = 0 | Flash User Application 부팅         |

1. BOOT0 핀을 HIGH로 설정 후 MCU 리셋
2. PC에 USB 연결 → 장치 관리자의 “STM32 BOOTLOADER” 확인
3. CubeProg 실행 → “USB” 선택 → “Connect”
4. “Download” 버튼으로 `.bin` 또는 `.hex` 업로드

#### DFU 모드 장점

- ST-Link 없이도 펌웨어 업데이트 가능
- 생산 후 펌웨어 교체 및 OTA 업데이트용으로 활용 가능

#### 주의점

- DFU 지원 MCU만 가능 (STM32F1 일부 모델은 제외)
- `System Memory` 부트로더 주소가 제품군마다 다름 (예: F4 = 0x1FFF0000)
- USB D+ / D- 핀 연결 확인 필요

------

### CubeProgrammer CLI (명령줄 모드)

자동화 환경(빌드 후 자동 다운로드 등)에서는 CLI 명령어로 CubeProg를 실행할 수 있다.

#### 예시

```
STM32_Programmer_CLI.exe -c port=stlink -w project.bin 0x08000000 -rst
```

| 옵션                        | 설명                                    |
| --------------------------- | --------------------------------------- |
| `-c port=stlink`            | 연결 포트 지정 (stlink / usb / uart 등) |
| `-w project.bin 0x08000000` | Flash 주소에 바이너리 쓰기              |
| `-rst`                      | 프로그래밍 후 MCU 리셋                  |
| `-hardRst`                  | 하드웨어 리셋 명령                      |
| `-vb`                       | Verbose 출력 활성화                     |

#### DFU 예시

```
STM32_Programmer_CLI.exe -c port=usb1 -w firmware.bin 0x08000000 -v -rst
```

------

### STM32CubeIDE와 CubeProgrammer 연동

CubeIDE 내부에서 “Run → Run Configurations → ST-Link GDB Server” 탭의
 **External Programmer** 옵션을 사용하면 CubeProg와 직접 연동 가능하다.

#### 설정 절차

1. Run → Run Configurations
2. “Target” 탭 → “External Tools Integration” 활성화
3. “Use STM32CubeProgrammer to program device” 체크
4. Interface 선택: ST-Link / DFU / UART
5. “Apply” → “Run”

이후 IDE 빌드 후 자동으로 CubeProg가 실행되어 Flash 다운로드가 이루어진다.

------

### CubeProgrammer 주요 활용 예시

- **펌웨어 업데이트 도구**로 고객 PC에서도 사용 가능
- **생산 공정용 자동 다운로드 스크립트** 구성
- **Flash 영역 검증 / 백업** 수행
- **부트 모드 전환 자동화 (Option Bytes 조정)**

------

## 2.9 UART 콘솔 출력 확인 (TeraTerm, PuTTY)

UART는 STM32 개발 중 가장 기본적인 디버깅 및 로그 출력 수단이다.
 TeraTerm, PuTTY, RealTerm 등의 시리얼 터미널을 통해 MCU의 메시지를 실시간 확인할 수 있다.

------

### 하드웨어 연결

| MCU 핀        | USB-UART 변환기 | 설명                |
| ------------- | --------------- | ------------------- |
| TX (예: PA9)  | RXD             | MCU 송신 → PC 수신  |
| RX (예: PA10) | TXD             | MCU 수신 → PC 송신  |
| GND           | GND             | 공통 접지 필수      |
| VCC           | 3.3V            | (필요 시 전원 공급) |

> ⚠️ **주의:**
>  USB-UART 모듈의 전압 레벨이 **3.3V**인지 반드시 확인.
>  (5V 레벨 신호는 STM32 입력 핀을 손상시킬 수 있음)

------

### UART 설정 (CubeMX)

1. `.ioc` 파일에서 **USART1** 또는 **USART2** 활성화
2. Mode: Asynchronous
3. Baud rate: `115200`
4. Word length: `8 Bits`, Stop bits: `1`, Parity: None
5. NVIC → “USART global interrupt” 활성화 (필요 시)
6. Pinout 탭에서 TX/RX 핀 매핑 확인

------

### 코드 예시

```
/* USER CODE BEGIN Includes */
#include "stdio.h"
/* USER CODE END Includes */

/* printf 재지정 */
int __io_putchar(int ch)
{
  HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
  return ch;
}

void main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_USART1_UART_Init();

  printf("=== STM32 UART Console Test ===\r\n");

  while (1)
  {
    printf("Hello STM32! %lu\r\n", HAL_GetTick());
    HAL_Delay(1000);
  }
}
```

------

### TeraTerm 설정

1. USB-UART 모듈을 PC에 연결 → COM 포트 확인
   - Windows: 장치 관리자 → “포트 (COMx)” 확인
2. TeraTerm 실행 → `Serial` 선택 → 해당 COM 포트 지정
3. “Setup → Serial Port” 클릭
   - Baud rate: `115200`
   - Data: `8 bit`
   - Parity: `none`
   - Stop: `1 bit`
   - Flow control: `none`
4. “OK” 클릭 → 콘솔 창에서 메시지 출력 확인

------

### PuTTY 설정

1. Connection type → `Serial` 선택
2. Serial line: `COMx`
3. Speed: `115200`
4. Open 클릭 → 콘솔창에서 MCU 로그 출력 확인

------

### 콘솔 출력 예시

```
=== STM32 UART Console Test ===
Hello STM32! 1000
Hello STM32! 2000
Hello STM32! 3000
```

------

### 문제 해결

| 증상           | 원인 / 해결 방법                                             |
| -------------- | ------------------------------------------------------------ |
| 콘솔 출력 없음 | TX/RX 반대 연결, Baud rate 불일치                            |
| 깨진 문자 출력 | Baud rate 또는 Line ending 불일치                            |
| 포트 인식 안됨 | 드라이버 미설치 (CH340, CP2102 등)                           |
| 출력 도중 중단 | HAL_UART_Transmit() 블로킹 문제 → DMA/Interrupt 모드 사용 권장 |

------

### 고급 활용

- **DMA 전송:** 대량 데이터 처리 속도 향상
- **Interrupt 수신:** 비동기 입력 처리
- **ITM/SWV 출력:** 고속 실시간 로그 (STM32F4 이상 지원)
- **FreeRTOS + UART Queue:** 태스크 기반 로그 처리

------

이로써 STM32CubeIDE 개발 환경에서

> **[코드 생성 → 빌드/디버그 → CubeProgrammer 다운로드 → UART 콘솔 확인]**
>  의 완전한 워크플로우를 구성할 수 있다.

