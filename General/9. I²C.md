# 9. I²C

## 9.1 I²C 프로토콜 구조 (Start/Stop/Ack)

I²C (Inter-Integrated Circuit) 버스는 **양방향 직렬 통신 방식**으로, 단 2개의 신호선(SCL, SDA)만으로 다수의 장치를 연결할 수 있는 **멀티 마스터·멀티 슬레이브 구조**를 가진다.
 STM32에서는 I²C 주변장치를 통해 센서, EEPROM, RTC, OLED 등 다양한 외부 디바이스와 효율적인 통신이 가능하다.

------

### I²C 기본 개념

| 항목           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| 전송선         | SDA (Serial Data), SCL (Serial Clock)                        |
| 통신 방식      | Half-Duplex, 동기식 직렬                                     |
| 동작 전압      | 3.3V 또는 5V (풀업 저항 필수)                                |
| 통신 속도      | Standard (100 kHz), Fast (400 kHz), Fast+ (1 MHz), High Speed (3.4 MHz) |
| 구조           | Master - Slave                                               |
| 전송 단위      | Byte (8-bit)                                                 |
| 흐름 제어      | ACK/NACK 비트 사용                                           |
| 주소 지정 방식 | 7-bit / 10-bit                                               |

------

### I²C 신호선 구조

두 라인은 **Open-Drain (Open-Collector)** 방식으로 동작하며,
 풀업 저항(보통 4.7kΩ ~ 10kΩ)을 통해 HIGH 상태가 유지된다.

- SDA: 데이터 송수신용
- SCL: 클록 생성 (마스터에서 제어)

#### 논리 구조 예시

```
3.3V ---[Pull-up]--- SDA
           |
          MCU ↔ Slave
3.3V ---[Pull-up]--- SCL
           |
          MCU (Master)
```

------

### I²C 통신의 주요 시퀀스

I²C 통신은 **Start → Address → Data → Stop** 순으로 진행되며, 각 단계는 **ACK 비트**로 확인된다.

| 단계                | 설명                                          |
| ------------------- | --------------------------------------------- |
| ① Start Condition   | 통신 시작 (SDA가 HIGH → LOW, SCL은 HIGH 유지) |
| ② Address + R/W Bit | 슬레이브 주소(7비트) + R/W 비트 전송          |
| ③ ACK Response      | 슬레이브가 ACK(LOW)로 응답                    |
| ④ Data Byte 전송    | 8비트 단위 데이터 송수신                      |
| ⑤ ACK/NACK          | 각 바이트 후 슬레이브가 ACK/NACK 반환         |
| ⑥ Stop Condition    | 통신 종료 (SDA가 LOW → HIGH, SCL은 HIGH 유지) |

------

### Start / Stop / ACK 타이밍 다이어그램

#### Start Condition

- SCL이 HIGH 상태일 때, SDA가 HIGH → LOW로 전환되면 **Start 조건** 발생

#### Stop Condition

- SCL이 HIGH 상태일 때, SDA가 LOW → HIGH로 전환되면 **Stop 조건** 발생

#### ACK / NACK

- 송신된 8비트 데이터 이후, 수신 측이 **9번째 클록에서 SDA를 LOW로 유지하면 ACK**,
   HIGH로 두면 NACK을 의미한다.

```
Start → [7-bit Addr + R/W] → ACK → [Data] → ACK → Stop
```

------

### 7-bit 주소 구조

| 비트  | 의미                       |
| ----- | -------------------------- |
| [7:1] | 슬레이브 주소              |
| [0]   | R/W 비트 (0=Write, 1=Read) |

예: 슬레이브 주소가 0x50일 때

- Write 요청: `0xA0` (0x50 << 1 | 0)
- Read 요청: `0xA1` (0x50 << 1 | 1)

------

### 통신 시나리오 예시

#### (1) Write Sequence

```
Start  
→ Slave Addr + Write (ACK)  
→ Register Addr (ACK)  
→ Data Byte (ACK)  
→ Stop
```

#### (2) Read Sequence

```
Start  
→ Slave Addr + Write (ACK)  
→ Register Addr (ACK)  
→ Re-Start  
→ Slave Addr + Read (ACK)  
→ Data Byte (NACK)  
→ Stop
```

------

### I²C 표준 속도 모드

| 모드       | 주파수  | 최대 데이터 속도 | 전압      |
| ---------- | ------- | ---------------- | --------- |
| Standard   | 100 kHz | 약 12.5 kB/s     | 3.3V / 5V |
| Fast       | 400 kHz | 약 50 kB/s       | 3.3V      |
| Fast+      | 1 MHz   | 약 125 kB/s      | 3.3V      |
| High-Speed | 3.4 MHz | 약 425 kB/s      | 3.3V      |

STM32 HAL에서는 `I2C_TIMINGR` 레지스터를 통해 해당 속도를 설정한다.

------

### SDA / SCL 타이밍 제약

- SDA의 변화는 SCL이 LOW일 때만 허용된다.
- Start/Stop 조건은 SCL이 HIGH일 때 발생해야 한다.
- 클록 스트레칭(Clock Stretching):
   슬레이브가 처리 시간 확보를 위해 SCL을 LOW로 유지 가능.

------

### 통신 오류 및 예외 처리

| 오류 유형        | 원인                      | 대응                            |
| ---------------- | ------------------------- | ------------------------------- |
| NACK 발생        | 슬레이브 응답 없음        | 주소 또는 연결 확인             |
| Arbitration Lost | 멀티 마스터 충돌          | 우선순위 높은 마스터가 점유     |
| Bus Busy         | SDA, SCL 중 하나 LOW 유지 | 라인 초기화 필요                |
| Timeout          | SCL 정지                  | 하드웨어 리셋 또는 I²C 재초기화 |

------

### STM32에서 I²C 신호 확인

- **Logic Analyzer** 또는 **Oscilloscope**로 SDA/SCL 파형 확인 가능
- Start/Stop 구간, ACK 비트, Address 프레임을 통해 통신 정상 여부 판단

------

### 실습 포인트

✅ Start / Stop / ACK 시퀀스 정확히 이해
 ✅ 7-bit Address 구조 분석
 ✅ Write / Read 시나리오 직접 시뮬레이션
 ✅ SDA, SCL 오실로스코프 측정
 ✅ NACK / Timeout 예외 상황 재현

## 9.2 Master/Slave 모드

I²C 통신은 **양방향 직렬 통신**이지만, 항상 **Master**와 **Slave**의 역할이 명확히 구분된다.
 Master는 **클록(SCL)**을 제어하고 통신의 **시작(Start)** 및 **종료(Stop)** 조건을 발생시키며,
 Slave는 Master의 요청에 따라 응답하고 데이터를 전송하거나 수신한다.

STM32의 I²C 주변장치는 **하드웨어적으로 Master와 Slave 모드를 모두 지원**하며,
 하나의 MCU가 상황에 따라 두 역할을 모두 수행할 수도 있다.

------

### Master / Slave 기본 개념 비교

| 항목              | Master                 | Slave               |
| ----------------- | ---------------------- | ------------------- |
| 역할              | 통신 제어 주체         | 명령 수신 / 응답    |
| 클록 제어         | SCL 생성               | 수동 클록 수신      |
| 주소 지정         | 송신 시 대상 주소 지정 | 고정 주소 보유      |
| 데이터 송신       | Register Write         | Register Data 반환  |
| 데이터 수신       | Register Read          | 명령 및 데이터 수신 |
| Start / Stop 제어 | 직접 생성              | 수동 감지           |
| 통신 개시 권한    | 있음                   | 없음                |

------

### STM32 I²C의 Master 모드 동작

Master 모드에서 MCU는 다음과 같은 순서로 동작한다.

1. **Start Condition 생성**
   - HAL 또는 레지스터로 SCL HIGH 상태에서 SDA를 LOW로 전환
   - `I2C_CR2_START` 비트 세트
2. **슬레이브 주소 전송**
   - `I2C_CR2_SADD` 레지스터에 7-bit 주소 설정
   - R/W 비트(0: Write, 1: Read) 포함
3. **ACK 확인**
   - 슬레이브가 ACK를 반환해야 다음 단계 진행
   - NACK 발생 시 `HAL_ERROR` 또는 `HAL_TIMEOUT` 반환
4. **데이터 전송 / 수신**
   - 송신 시 `I2C_TXDR` 레지스터에 데이터 쓰기
   - 수신 시 `I2C_RXDR` 레지스터에서 읽기
5. **Stop Condition 생성**
   - `I2C_CR2_STOP` 비트 세트로 통신 종료
6. **상태 확인**
   - `I2C_ISR`의 `TXIS`, `RXNE`, `STOPF` 플래그 확인

------

### STM32 I²C의 Slave 모드 동작

Slave는 항상 **자신의 주소를 감시**하며, Master가 Start 조건과 함께 해당 주소를 전송할 때 응답한다.

1. **자신의 7-bit 주소 설정**
   - `I2C_OAR1` 레지스터에 주소 등록 (예: 0x48)
2. **Address Match 감지**
   - Master가 전송한 주소와 일치하면 `ADDR` 플래그 세트
   - 인터럽트 또는 DMA 트리거 가능
3. **데이터 수신 (Write 요청 시)**
   - Master → Slave 방향 전송
   - `I2C_RXDR`에서 데이터 읽음
4. **데이터 송신 (Read 요청 시)**
   - Slave → Master 방향 전송
   - `I2C_TXDR`에 데이터 작성
5. **Stop Condition 감지**
   - Master가 통신 종료 시 `STOPF` 플래그 세트
   - `HAL_I2C_ListenCpltCallback()` 호출

------

### HAL 함수 예시 (Master 모드)

```
// Master → Slave (Write)
uint8_t data[2] = {0x10, 0x55};
HAL_I2C_Master_Transmit(&hi2c1, 0xA0, data, 2, HAL_MAX_DELAY);

// Master ← Slave (Read)
uint8_t recv[2];
HAL_I2C_Master_Receive(&hi2c1, 0xA1, recv, 2, HAL_MAX_DELAY);
```

------

### HAL 함수 예시 (Slave 모드)

```
// Slave 수신 대기
uint8_t buffer[10];
HAL_I2C_Slave_Receive(&hi2c1, buffer, 10, HAL_MAX_DELAY);

// Slave 송신 준비
uint8_t reply[2] = {0xAB, 0xCD};
HAL_I2C_Slave_Transmit(&hi2c1, reply, 2, HAL_MAX_DELAY);
```

------

### 주소 구조 (7-bit / 10-bit)

STM32 I²C는 기본적으로 **7-bit 주소 방식**을 사용하지만, 10-bit 주소도 지원한다.
 HAL에서는 주소를 **왼쪽으로 1비트 시프트**하여 `R/W` 비트를 추가해야 한다.

| 주소 길이 | 설명              | 예시                              |
| --------- | ----------------- | --------------------------------- |
| 7-bit     | 일반적인 I²C 장치 | 0x50 → Write: 0xA0, Read: 0xA1    |
| 10-bit    | 확장 주소 장치    | 0x305 → Write: 0x610, Read: 0x611 |

------

### 통신 시퀀스 예시

#### (1) Master → Slave Write

```
Start
→ [Addr + W] (ACK)
→ [Register Addr] (ACK)
→ [Data Byte(s)] (ACK)
→ Stop
```

#### (2) Master → Slave Read

```
Start
→ [Addr + W] (ACK)
→ [Register Addr] (ACK)
→ Re-Start
→ [Addr + R] (ACK)
→ [Data Byte(s)] (NACK)
→ Stop
```

------

### 인터럽트 기반 Master/Slave

STM32 HAL은 폴링 외에도 인터럽트를 이용한 비동기 I²C 통신을 지원한다.

| 함수                           | 설명                       |
| ------------------------------ | -------------------------- |
| `HAL_I2C_Master_Transmit_IT()` | 인터럽트 기반 Master 송신  |
| `HAL_I2C_Master_Receive_IT()`  | 인터럽트 기반 Master 수신  |
| `HAL_I2C_Slave_Transmit_IT()`  | 인터럽트 기반 Slave 송신   |
| `HAL_I2C_Slave_Receive_IT()`   | 인터럽트 기반 Slave 수신   |
| `HAL_I2C_AddrCallback()`       | 슬레이브 주소 일치 시 호출 |
| `HAL_I2C_ListenCpltCallback()` | 통신 완료 시 호출          |

------

### DMA 기반 Master / Slave

DMA를 이용하면 대용량 데이터를 CPU 개입 없이 송수신할 수 있다.
 HAL에서는 다음 함수로 DMA 모드를 지원한다.

| 함수                            | 역할          |
| ------------------------------- | ------------- |
| `HAL_I2C_Master_Transmit_DMA()` | DMA 송신 시작 |
| `HAL_I2C_Master_Receive_DMA()`  | DMA 수신 시작 |
| `HAL_I2C_Slave_Transmit_DMA()`  | DMA 송신 시작 |
| `HAL_I2C_Slave_Receive_DMA()`   | DMA 수신 시작 |

------

### 디버깅 포인트

- 통신 실패 시 `HAL_I2C_GetError()`로 에러 상태 확인
  - `HAL_I2C_ERROR_AF`: ACK 실패
  - `HAL_I2C_ERROR_BERR`: Bus Error
  - `HAL_I2C_ERROR_ARLO`: Arbitration Lost
  - `HAL_I2C_ERROR_TIMEOUT`: Timeout
- SDA/SCL 라인이 LOW로 고정된 경우: 풀업 저항, 회로 쇼트 점검
- Slave가 응답하지 않으면 주소 및 R/W 비트 확인

------

### 실습 포인트

✅ Master/Slave 모드 모두 CubeMX로 설정 후 비교
 ✅ Address Matching 동작 확인
 ✅ Logic Analyzer로 Start/Stop/ACK 패턴 관찰
 ✅ 인터럽트 기반 송수신 테스트
 ✅ DMA 기반 데이터 전송 효율 측정

## 9.3 HAL I2C Read/Write 실습

이 절에서는 STM32 HAL 라이브러리를 이용해 **I²C 마스터 모드에서 슬레이브 디바이스와 데이터를 송수신하는 실습 과정**을 다룬다.
 대상 예제는 **EEPROM (AT24C02)**, **온도 센서 (LM75 / TMP102)**, 또는 **OLED (SSD1306)** 등의 표준 I²C 장치를 기준으로 한다.

------

### I²C 기본 설정

I²C 통신을 수행하기 위해서는 다음 항목이 사전에 CubeMX 또는 HAL 코드로 설정되어야 한다.

| 항목            | 설정 내용                                         |
| --------------- | ------------------------------------------------- |
| Mode            | I²C (Master)                                      |
| Timing          | 100kHz (Standard Mode)                            |
| Addressing Mode | 7-bit                                             |
| Duty Cycle      | 2                                                 |
| Pull-up         | SDA / SCL 모두 외부 4.7kΩ ~ 10kΩ 저항 필요        |
| NVIC            | I2C1_EV, I2C1_ER 인터럽트 활성화 (비동기 모드 시) |

**CubeMX 설정 경로:**
 `Connectivity → I2C1 → Mode: I2C`
 `Configuration → I2C Configuration → Timing 설정`
 `Project Manager → Generate Code`

------

### 기본 통신 원리

Master는 항상 통신을 **Start**로 시작하고, 슬레이브 주소(7-bit)와 **R/W 비트**를 전송한 뒤,
 ACK 응답을 받으면 **Register Address**와 **Data Byte**를 송수신한다.

#### 일반적인 쓰기(Write) 시퀀스

```
Start → [Slave Addr + W] → [Register Addr] → [Data Byte(s)] → Stop
```

#### 읽기(Read) 시퀀스

```
Start → [Slave Addr + W] → [Register Addr] → ReStart → [Slave Addr + R] → [Data Byte(s)] → Stop
```

------

### HAL 기반 기본 코드 구조

#### 1. 송신 (Write)

```
uint8_t devAddr = 0xA0;        // 7-bit 주소 << 1 한 값 (예: 0x50 << 1)
uint8_t regAddr = 0x10;        // 쓰기 대상 레지스터 주소
uint8_t data = 0x55;           // 전송할 데이터

uint8_t buffer[2] = { regAddr, data };  
HAL_StatusTypeDef ret;

ret = HAL_I2C_Master_Transmit(&hi2c1, devAddr, buffer, 2, HAL_MAX_DELAY);
if (ret != HAL_OK)
{
    Error_Handler();  // NACK, Timeout, Bus Error 등 예외 처리
}
```

------

#### 2. 수신 (Read)

```
uint8_t devAddr = 0xA0;
uint8_t regAddr = 0x10;
uint8_t recvData;

HAL_StatusTypeDef ret;

// 먼저 읽을 레지스터 주소 전송
ret = HAL_I2C_Master_Transmit(&hi2c1, devAddr, &regAddr, 1, HAL_MAX_DELAY);
if (ret != HAL_OK) Error_Handler();

// 실제 데이터 읽기
ret = HAL_I2C_Master_Receive(&hi2c1, devAddr, &recvData, 1, HAL_MAX_DELAY);
if (ret != HAL_OK) Error_Handler();
```

------

### 연속 데이터(버퍼) 송수신

다수의 데이터를 연속으로 송수신할 때는 버퍼 포인터와 길이를 지정한다.

#### Write (다중 바이트)

```
uint8_t dataBuf[5] = {0x00, 0x01, 0x02, 0x03, 0x04};
HAL_I2C_Master_Transmit(&hi2c1, 0xA0, dataBuf, sizeof(dataBuf), HAL_MAX_DELAY);
```

#### Read (다중 바이트)

```
uint8_t readBuf[5];
HAL_I2C_Master_Receive(&hi2c1, 0xA1, readBuf, sizeof(readBuf), HAL_MAX_DELAY);
```

------

### 실습 예시: AT24C02 EEPROM Write / Read

#### Write 예제

```
uint8_t eepAddr = 0xA0;  // AT24C02 기본 주소
uint8_t writeData[3] = {0x10, 0xDE, 0xAD}; // [Reg=0x10, Data=0xDE, 0xAD]
HAL_I2C_Master_Transmit(&hi2c1, eepAddr, writeData, 3, 100);
HAL_Delay(5); // EEPROM 내부 쓰기 완료 대기
```

#### Read 예제

```
uint8_t regAddr = 0x10;
uint8_t readData[2];

HAL_I2C_Master_Transmit(&hi2c1, eepAddr, &regAddr, 1, 100);
HAL_I2C_Master_Receive(&hi2c1, eepAddr, readData, 2, 100);
```

------

### 실습 예시: LM75 / TMP102 온도 센서 읽기

```
#define LM75_ADDR (0x48 << 1)   // 7-bit 주소를 왼쪽 시프트
uint8_t tempReg = 0x00;
uint8_t tempData[2];

HAL_I2C_Master_Transmit(&hi2c1, LM75_ADDR, &tempReg, 1, HAL_MAX_DELAY);
HAL_I2C_Master_Receive(&hi2c1, LM75_ADDR, tempData, 2, HAL_MAX_DELAY);

int16_t rawTemp = (tempData[0] << 8) | tempData[1];
float temperature = (rawTemp >> 7) * 0.5f;  // 0.5°C 단위 변환
```

------

### 오류 처리 및 예외 상황

| 오류 유형               | 설명                    | 조치                     |
| ----------------------- | ----------------------- | ------------------------ |
| `HAL_I2C_ERROR_AF`      | 슬레이브 NACK 응답      | 주소 또는 연결 확인      |
| `HAL_I2C_ERROR_ARLO`    | Arbitration Lost        | 멀티마스터 충돌          |
| `HAL_I2C_ERROR_BERR`    | Bus Error               | SDA/SCL 신호 오류        |
| `HAL_I2C_ERROR_TIMEOUT` | SCL 정지 또는 응답 없음 | 재시도 또는 I²C 재초기화 |
| `HAL_I2C_ERROR_DMA`     | DMA 오류                | DMA 설정 확인            |

오류 발생 시 다음 코드로 상태 확인 가능:

```
uint32_t err = HAL_I2C_GetError(&hi2c1);
```

------

### 인터럽트 기반 비동기 송수신

대용량 전송이나 실시간 처리 시에는 인터럽트 기반으로 동작시킬 수 있다.

```
HAL_I2C_Master_Transmit_IT(&hi2c1, devAddr, txBuf, length);
HAL_I2C_Master_Receive_IT(&hi2c1, devAddr, rxBuf, length);
```

완료 후 자동으로 호출되는 콜백:

```
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c) {
    // 송신 완료 후 처리
}
void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c) {
    // 수신 완료 후 처리
}
```

------

### 디버깅 포인트

- SDA/SCL 라인이 모두 HIGH로 풀업되어 있는지 확인
- 슬레이브 주소(7-bit / 10-bit)와 R/W 비트 구조 확인
- 논리분석기로 Start / Stop / ACK 비트 검증
- NACK 발생 시: 타이밍 문제 또는 슬레이브 응답 없음

------

### 실습 목표 요약

✅ HAL 함수를 사용한 I²C Read / Write 동작 숙지
 ✅ EEPROM 및 센서(Read/Write) 동작 검증
 ✅ 오실로스코프 또는 Logic Analyzer로 실제 파형 관찰
 ✅ 오류 발생 시 HAL_I2C_GetError() 분석

## 9.4 센서 (MPU6050, BME280, OLED) 연결

다음 내용은 **하드웨어 연결, 전력/레벨 고려, I²C 설정, 센서별 초기화·레지스터·보정·데이터 변환, OLED 표시, 통합 아키텍처, 타이밍 및 디버깅**을 가능한 한 구체적이고 실용적으로 정리한 문서다. 코드 예시는 STM32 HAL API (`HAL_I2C_*`) 기준이며, 실전에서 바로 쓸 수 있도록 핵심 레지스터·매크로·절차를 포함한다.

------

## 개요 / 준비물

### 목표

- MPU6050(6축 IMU), BME280(온·습도·압력), SSD1306 I²C OLED를 하나의 I²C 버스에 연결하고 STM32에서 안정적으로 읽고 OLED에 표시한다.

### 하드웨어

- STM32 보드 (예: Nucleo, Blue Pill)
- MPU6050 (I²C address 보통 0x68 또는 0x69)
- BME280 (I²C address 0x76 또는 0x77)
- SSD1306 OLED (I²C address 보통 0x3C)
- Pull-up 저항 4.7kΩ (SDA,SCL 각각) — 작은 버스/짧은 케이블이면 4.7k, 긴 배선이면 2.2k~4.7k 권장
- 전원선: 3.3V 공급 (센서들이 3.3V 동작인지 확인)
- (RS) 2~3개의 점퍼선

------

## I²C 버스 설계 고려사항 (기본 규칙)

### 전기적 레벨

- MCU와 센서 모두 3.3V 로직이면 직접 연결. 5V 장치가 있으면 레벨 시프터 필요.
- SDA/SCL은 open-drain. 반드시 pull-up 저항을 달 것.

### 풀업값 선택

- 보통 4.7kΩ 기본. 보드와 케이블 길이, 버스 용량(패러시턴스) 고려. 긴 케이블이면 더 작은 저항(2.2k)을 고려하되 전류 증가 확인.

### 속도

- 기본 100kHz 안전. BME280은 1MHz(Fast+) 지원, MPU6050은 Fast(400kHz)까지 동작 가능. 여러 장치가 있으면 공통속도(예: 400kHz)로 설정하되 모든 장치가 지원하는지 확인.

### 주소 충돌

- 각 장치의 I²C 주소 확인. 동일 주소 장치가 있으면 주소 변경 가능 여부(ESP 등)를 확인하거나 멀티플렉서(TCA9548A) 사용.

### 전원

- VDDA/AVDD(아날로그 전원)가 있는 센서(예: BME280)에서는 안정적인 3.3V, decoupling capacitor 권장.

------

## MPU6050 (6-axis IMU) — 연결·초기화·데이터 처리

### 개요 & 주소

- 7-bit 주소: 기본 0x68 (AD0 핀 = 0), 또는 0x69 (AD0 = 1).
- 내부: MPU6050에는 3축 가속도, 3축 자이로, 온도 센서가 포함됨.

### 주요 레지스터 (대표)

- WHO_AM_I: 0x75 (반환값 0x68)
- PWR_MGMT_1: 0x6B (전원관리, sleep 해제 등)
- SMPLRT_DIV: 0x19 (샘플레이트 분주)
- CONFIG: 0x1A (DLPF 설정)
- GYRO_CONFIG: 0x1B (gyro full-scale 선택)
- ACCEL_CONFIG: 0x1C (accel full-scale 선택)
- INT_ENABLE: 0x38 (인터럽트 설정)
- ACCEL_XOUT_H..L: 0x3B~0x40 (가속도 데이터)
- TEMP_OUT_H..L: 0x41~0x42
- GYRO_XOUT_H..L: 0x43~0x48

### 연결 (I²C)

- VCC → 3.3V, GND → GND, SDA → MCU SDA, SCL → MCU SCL, AD0 → GND 또는 VCC(주소 선택)
- 풀업: SDA/SCL에 4.7k

### 초기화 순서 (HAL 예제)

```
// hi2c : I2C 핸들
uint8_t who = 0;
HAL_I2C_Mem_Read(&hi2c, 0x68<<1, 0x75, 1, &who, 1, 100);
if (who != 0x68) /* 에러 처리 */ ;

uint8_t data;
data = 0x00; // wake up
HAL_I2C_Mem_Write(&hi2c, 0x68<<1, 0x6B, 1, &data, 1, 100);

// 샘플레이트 및 필터, FS 설정 예
data = 0x07; // SMPLRT_DIV = 7
HAL_I2C_Mem_Write(&hi2c, addr, 0x19, 1, &data, 1, 100);

data = 0x06; // DLPF_CFG 예
HAL_I2C_Mem_Write(&hi2c, addr, 0x1A, 1, &data, 1, 100);

// Full scale: gyro ±250dps, accel ±2g
data = 0x00;
HAL_I2C_Mem_Write(&hi2c, addr, 0x1B, 1, &data, 1, 100);
HAL_I2C_Mem_Write(&hi2c, addr, 0x1C, 1, &data, 1, 100);
```

### 샘플러·스케일

- 가속도: ±2g → LSB당 16384 LSB/g (12.2e-6 g/LSB)
- 자이로: ±250 dps → 131 LSB/(°/s)

정확한 변환 계수:

- accel_scale = 2 / 32768 = 0.000061035 g/LSB? (실무에서는 표준값 사용: ±2g => 16384 LSB/g)
- gyro_scale = 250 / 32768 ≈ 0.007633 °/s per LSB? (or 131 LSB/(°/s) → 1/131 °/s per LSB)

(권장: 표 데이터시트의 full-scale table 참고하여 정확 계수 사용)

### 데이터 읽기

- 연속 읽기: ACCEL_XOUT_H (0x3B)에서 14바이트 연속 읽기 (Accel(6) + Temp(2) + Gyro(6))

```
uint8_t buf[14];
HAL_I2C_Mem_Read(&hi2c, addr, 0x3B, 1, buf, 14, 100);
int16_t ax = (buf[0]<<8) | buf[1];
int16_t ay = (buf[2]<<8) | buf[3];
int16_t az = (buf[4]<<8) | buf[5];
int16_t temp = (buf[6]<<8) | buf[7];
int16_t gx = (buf[8]<<8) | buf[9];
int16_t gy = (buf[10]<<8) | buf[11];
int16_t gz = (buf[12]<<8) | buf[13];
```

### 온도 계산

- Temp(℃) = (TEMP_OUT / 340.0) + 36.53 (데이터시트 참조)

### 캘리브레이션 (간단 방법)

- **바이어스 측정**: 정지 상태에서 평균화하여 accel/gyro 바이어스 계산 → subtract
- **온도 보상**: 고급은 온도에 따라 drift 보정
- **센서 틸트 보정**: 센서 정렬이 중요하면 9DOF 보정 알고리즘(예: complementary filter, Madgwick, Mahony) 사용

### 주의사항

- INT 핀 사용 시 (데이터 준비 알림) 인터럽트 라인과 NVIC 설정 필요
- FIFO / DMP 기능 활용 가능 (복잡), 기본은 폴링/인터럽트 읽기

------

## BME280 (온도·습도·압력) — 레지스터·보정·연산

### 개요 & 주소

- I²C 주소: 0x76 또는 0x77 (SDO 핀 상태에 따라)
- 매우 정밀한 보정계수 필요 (보정 레지스터로부터 읽어 보정 알고리즘 적용)

### 주요 레지스터

- chip id: 0xD0 (읽기: 0x60)
- reset: 0xE0
- ctrl_hum: 0xF2 (습도 오버샘플)
- status: 0xF3
- ctrl_meas: 0xF4 (온도/압력 오버샘플 및 모드)
- config: 0xF5 (IIR 필터, standby)
- press_msb..lsb: 0xF7~0xF9 (압력)
- temp_msb..lsb: 0xFA~0xFC (온도)
- hum_msb..lsb: 0xFD~0xFE (습도)
- 보정 레지스터: 0x88~0xA1, 0xE1~0xE7

### 초기화

- 읽기: 보정 레지스터 모두 읽어 저장
- 설정: oversampling 및 mode 설정 (예: ctrl_hum=1, ctrl_meas=0x27 (osrs_t=1 osrs_p=1 mode=Normal))

```
// 보정 레지스터 읽기 (예시)
uint8_t calib[26];
HAL_I2C_Mem_Read(&hi2c, bme_addr, 0x88, 1, calib, 26, 100);
// 추가 보정 E1..E7 읽기
uint8_t calib2[7];
HAL_I2C_Mem_Read(&hi2c, bme_addr, 0xE1, 1, calib2, 7, 100);
```

### 보정 알고리즘 (요점)

- BME280은 raw ADC 값을 보정 레지스터의 계수로 보정하는 복잡한 수식 제공(데이터시트의 compensation formulas).
- 온도 보정 중간 계산값 `t_fine` 을 얻고, 이를 통해 압력·습도 보정 사용.
- 구현: ST나 Bosch에서 제공하는 reference implementation을 그대로 쓰는 것이 안전.

### 데이터 읽기 (예)

```
uint8_t buf[8];
HAL_I2C_Mem_Read(&hi2c, bme_addr, 0xF7, 1, buf, 8, 100);
int32_t adc_p = ( (uint32_t)buf[0] << 12 ) | ( (uint32_t)buf[1] << 4) | (buf[2] >> 4);
int32_t adc_t = ( (uint32_t)buf[3] << 12 ) | ( (uint32_t)buf[4] << 4) | (buf[5] >> 4);
int32_t adc_h = ( (uint32_t)buf[6] << 8 ) | buf[7];
// 이후 보정 알고리즘 적용 → temperature (°C), pressure (Pa), humidity (%)
```

### 설정 권장값

- 측정주기/전력: Normal 모드 vs Forced 모드 사용 결정 (배터리 환경이면 Forced)
- Oversampling: T=1~2, P=1~2, H=1 기본 권장

### 주의사항

- BME280 보정 공식은 정밀도가 높지만 연산 비용이 크므로 부하 고려
- 반드시 uint32/ int64 타입 사용 시 overflow 주의 (데이터시트 알고리즘 준수)

------

## SSD1306 (I²C OLED) — 제어·버퍼·초기화

### 개요 & 주소

- 일반적 주소: 0x3C (SA0=0) 또는 0x3D (SA0=1)
- 128×64 또는 128×32 등 해상도 다양

### I²C 통신 프레임

- 제어 바이트(명령/데이터 선택): 0x00 → command, 0x40 → data
- 명령 전송: I²C write (0x00 + 명령)
- 데이터 전송 (화면 버퍼): I²C write (0x40 + block of display bytes)

### 초기화 시퀀스 (필수 명령들 — 예)

- Display Off (0xAE)
- Set Display Clock Div (0xD5, 0x80)
- Set Multiplex (0xA8, 0x3F) // for 64 rows
- Set Display Offset (0xD3, 0x00)
- Set Start Line (0x40)
- Charge Pump (0x8D, 0x14) // enable
- Memory Mode (0x20, 0x00)
- Segment Remap (0xA1)
- COM Scan Dec (0xC8)
- Set COM Pins (0xDA, 0x12)
- Set Contrast (0x81, 0xCF)
- Precharge (0xD9, 0xF1)
- VCOM Detect (0xDB, 0x40)
- Display On (0xAF)

HAL 예시 초기화 전송:

```
uint8_t cmd[] = {0x00, 0xAE}; // first byte control=0x00 (command)
HAL_I2C_Master_Transmit(&hi2c, oled_addr, cmd, 2, 100);
```

### 화면 버퍼 & 페이지 모드

- 표준 방식: page addressing mode 사용, 8-pixel 높이 블록(페이지) 단위 전송
- 버퍼: frame buffer (128 * 64 / 8 = 1024 bytes)
- 업데이트: 각 페이지(0~7)별로 `Set Page Address`, `Set Column Address` 후 128바이트 전송

예: 페이지 단위 전송

```
uint8_t header[2];
header[0] = 0x00; header[1] = 0x22; // Set page addr (horizontal addressing set differently) - 예시는 컨트롤에 따라 달라짐
// 또는 for page in 0..7:
//  send command: 0xB0 + page
//  send command: (col & 0x0F)
//  send command: (col >> 4 | 0x10)
// then send data block with control byte 0x40 before data
uint8_t data_block[129];
data_block[0] = 0x40;
memcpy(&data_block[1], &framebuffer[page*128], 128);
HAL_I2C_Master_Transmit(&hi2c, oled_addr, data_block, 129, 100);
```

### 권장 구현

- 화면을 그리는 고수준 라이브러리(Adafruit, u8g2 등) 사용 권장. 직접 구현 시 페이지 addressing 방식, 전송 블록 크기(최대 I²C 전송 길이) 주의.

------

## 통합 아키텍처: 샘플 소프트웨어 구조

### 루프 방식 (간단)

1. I²C 스캔(초기화 시) → 장치 존재 확인
2. MPU6050: 50~200Hz 주기 폴링 (또는 INT 라인으로 데이터 준비 감지)
3. BME280: 1Hz 또는 필요 주기로 측정 (Forced 모드 권장)
4. OLED: 1Hz 또는 필요 시 화면 갱신 (변경이 있을 때만)
5. 오류/재시도 로직 포함 (I²C NACK, TIMEOUT 등)

### FreeRTOS 권장 구조 (복수 태스크)

- Task A (IMU Task): MPU 읽고 필터/데이터 합성, 큐에 게시
- Task B (Env Task): BME280 읽고 큐에 게시
- Task C (Display Task): 큐에서 최신값 뽑아 OLED 갱신 (주기 10Hz 이하 권장)
- I²C 접근은 mutex로 동기화 (한 번에 하나의 트랜잭션만)

### I²C 동시 접근 주의

- I²C 버스는 시리얼 자원. 멀티태스크 환경에서는 I²C 핸들을 사용할 때 mutex/sem 필요.
- HAL_I2C_Mem_Read/Write는 blocking이므로 RTC나 FreeRTOS에서 적절한 timeout으로 호출.

------

## 예제: 통합 초기화 + 단순 루프 (HAL, 폴링 방식 — 핵심만)

```
// 가정: hi2c, oled_addr, mpu_addr, bme_addr 정의 및 MX_I2C_Init() 호출됨

void sensors_init(void)
{
    // MPU6050 wake
    uint8_t who;
    HAL_I2C_Mem_Read(&hi2c, (mpu_addr<<1), 0x75, 1, &who, 1, 100);
    // check who==0x68...
    uint8_t v = 0x00;
    HAL_I2C_Mem_Write(&hi2c, (mpu_addr<<1), 0x6B, 1, &v, 1, 100);

    // BME280: read chip id, read calibration, set ctrl
    uint8_t id;
    HAL_I2C_Mem_Read(&hi2c, (bme_addr<<1), 0xD0, 1, &id, 1, 100);
    // read calib and set ctrl_meas etc...
}

void loop(void)
{
    while (1)
    {
        // MPU read
        uint8_t buf[14];
        HAL_I2C_Mem_Read(&hi2c, (mpu_addr<<1), 0x3B, 1, buf, 14, 50);
        // convert -> ax,ay,az,gx,gy,gz

        // BME read (maybe once per second)
        uint8_t bbuf[8];
        HAL_I2C_Mem_Read(&hi2c, (bme_addr<<1), 0xF7, 1, bbuf, 8, 100);
        // convert -> temp,press,hum

        // OLED update
        // compose text into frame buffer and send page-by-page

        HAL_Delay(10); // IMU 100Hz-ish loop
    }
}
```

------

## 오류 처리 및 디버깅 체크리스트

### I²C 관련 문제 확인

- SDA/SCL 풀업 유무 확인
- 전원(3.3V) 안정 확인
- 주소가 올바른지(I²C scanner 사용: 7-bit 주소 확인)
- 논리분석기/오실로스코프: Start/Stop/ACK 비트 확인
- `HAL_I2C_GetError()` 반환값 확인 (AF, BERR, ARLO, TIMEOUT)

### 센서별 문제

- MPU6050: WHO_AM_I 확인 → 0x68
- MPU6050: PWR_MGMT_1 reset/기다림 누락으로 데이터 0 반환
- BME280: 보정 레지스터 읽기 누락 → 값 잘못 계산
- SSD1306: 명령/data 제어바이트(0x00/0x40) 누락하면 화면 이상

### 타이밍

- EEPROM 또는 BME280 같은 장치는 내부 쓰기/측정 지연이 있음. Forced 모드 후 완료 대기 필요.
- HAL 함수 timeout 충분히 크게 설정(초기 테스트 시 HAL_MAX_DELAY 권장하되 실무에선 적절한 timeout 설정)

### 멀티스레드 (RTOS) 문제

- I²C 동시 사용시 mutex 필요
- I²C 트랜잭션이 길면 다른 태스크 지연 발생 -> 비동기/DMA로 개선

------

## 성능·전력 최적화 팁

- BME280은 Forced 모드로 측정 후 Sleep 하여 전력 절감
- MPU6050 다운샘플(DLPF/SMPLRT_DIV 조정)으로 CPU 부담 감소
- OLED 업데이트는 변경 있을 때만 partial update 수행
- DMA 사용: SSD1306 전송량이 크면 DMA로 전송(주의: I²C 전송은 Peripheral-to-memory/vice versa이므로, HAL에 따라 I²C+DMA 구현 세부사항 확인)

------

## 추가 권장자료 및 구현 팁

- MPU6050: DMP 기능(칩 내부 필터/쿼터니언 계산) 사용 고려(복잡도 ↑)
- BME280: Bosch 예제 코드(공식 보정 알고리즘)를 그대로 사용하는 것이 안전
- SSD1306: 기존의 proven 라이브러리(u8g2, Adafruit_SSD1306)를 포팅해서 쓰면 편리
- 대규모 시스템: I²C MUX(TCA9548A)로 동일 주소 장치 분리 가능

------

### 결론 요약

- 하드웨어: 3.3V, pull-up, 주소 충돌 주의
- MPU6050: WHO_AM_I 확인 → PWR_MGMT_1 클리어 → 샘플링 및 FS 설정 → 연속 14바이트 읽기 → scale 적용 + 캘리브레이션
- BME280: 보정 레지스터 읽기 → adc → 보정 수식 적용 (t_fine 사용)
- SSD1306: command/data 제어바이트, 페이지 주소 방식, framebuffer 관리
- 멀티센서 통합: I²C 버스 잠금/뮤텍스, 주기적 스케줄링, OLED 업데이트 최소화
- 디버깅: I²C 스캐너 → Logic Analyzer → HAL error 코드 확인

## 9.5 Scan All Device Address 예제

I²C 버스에는 여러 개의 슬레이브 장치가 동시에 연결될 수 있습니다. 각 슬레이브는 고유한 **7비트 주소(0x03~0x77)**를 가지며, 마스터는 이 주소를 통해 특정 장치와 통신합니다. 그러나 실제 회로에서 장치 주소가 불명확하거나 여러 장치를 동시에 연결할 때는 **전체 주소 영역(0x03~0x77)**을 스캔하여 어떤 주소에 응답이 있는지를 확인하는 과정이 필요합니다. 이를 **I²C Address Scan** 또는 **Device Discovery**라고 합니다.

------

### 9.5.1 개념 및 원리

I²C 스캔은 다음의 원리로 동작합니다.

1. 마스터가 I²C 주소 0x03부터 0x77까지 순차적으로 송신 시도
2. 각 주소에 대해 `HAL_I2C_IsDeviceReady()` 또는 `HAL_I2C_Master_Transmit()` 호출
3. 해당 주소의 장치가 응답(Ack)을 보내면 “장치 존재”로 판단
4. Ack가 없으면 Nack → 장치 없음

이 과정을 반복하여 버스에 연결된 모든 슬레이브의 주소를 확인할 수 있습니다.

------

### 9.5.2 HAL 기반 기본 코드 예제

아래는 STM32 HAL을 이용한 **I²C Device Scan** 예시 코드입니다.

```
#include "main.h"
#include <stdio.h>

extern I2C_HandleTypeDef hi2c1;

void I2C_Scan_Devices(void)
{
    printf("I2C Device Scan Start...\r\n");

    uint8_t address;
    HAL_StatusTypeDef result;

    for (address = 1; address < 128; address++)
    {
        result = HAL_I2C_IsDeviceReady(&hi2c1, (uint16_t)(address << 1), 1, 10);
        if (result == HAL_OK)
        {
            printf("Found I2C device at 0x%02X\r\n", address);
        }
        else
        {
            // No device at this address
        }
    }

    printf("Scan Complete.\r\n");
}
```

------

### 9.5.3 코드 설명

| 항목                      | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `address << 1`            | STM32 HAL은 8비트 주소(7비트 주소 + R/W 비트)를 사용하므로 왼쪽으로 1비트 시프트 |
| `HAL_I2C_IsDeviceReady()` | 지정된 주소로 Start + Address 전송 후 ACK 여부 확인          |
| `1`                       | 재시도 횟수 (기본 1회)                                       |
| `10`                      | Timeout 시간(ms)                                             |
| `HAL_OK`                  | 슬레이브가 존재함을 의미                                     |

------

### 9.5.4 출력 예시 (터미널)

```
I2C Device Scan Start...
Found I2C device at 0x27
Found I2C device at 0x68
Scan Complete.
```

위의 결과는

- **0x27 → OLED (SSD1306)**
- **0x68 → MPU6050 (IMU)**
   등이 버스에 존재함을 의미합니다.

------

### 9.5.5 주요 주의사항

1. **Pull-up 저항 확인**
    SDA, SCL 라인에 4.7kΩ~10kΩ 풀업 저항이 반드시 있어야 함.
    풀업이 없으면 장치 응답 불가.
2. **전원/그라운드 공유**
    모든 장치(VCC, GND)는 MCU와 동일한 기준 전위를 사용해야 함.
3. **Bus Error (HAL_ERROR) 발생 시**
   - SDA/SCL 단락 또는 회로 문제 가능성
   - Address 범위를 줄여서 점진적으로 테스트
4. **I²C 속도**
   - 기본: 100kHz (Standard Mode)
   - 일부 장치는 Fast Mode(400kHz) 미지원 → 통신 실패 가능
5. **I²C 라인 길이**
    너무 길면 신호 왜곡 및 ACK 인식 실패 → 노이즈 억제 필요

------

### 9.5.6 개선된 출력 포맷 예제 (Pretty Print)

```
printf("I2C Scan Result:\r\n");
printf("---------------------------\r\n");

for (uint8_t addr = 1; addr < 128; addr++)
{
    if (HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 10) == HAL_OK)
        printf("0x%02X  ", addr);
    else
        printf(". ");
    
    if (addr % 16 == 0)
        printf("\r\n");
}

printf("\r\n---------------------------\r\n");
```

출력 예:

```
I2C Scan Result:
---------------------------
. . . . 0x27 . . . . . . . 0x68 . .
---------------------------
```

------

### 9.5.7 활용 및 확장

- **센서 자동 감지 루틴**
   → 특정 센서 주소 존재 시 해당 드라이버 자동 초기화
- **장치 장애 감지 (Fault Detection)**
   → 주기적 스캔으로 센서 응답 여부 확인
- **OLED 디버깅 표시**
   → Scan 결과를 OLED에 출력해 현장 진단용으로 활용

------

### 9.5.8 실습 과제

1. MPU6050, BME280, SSD1306을 동시에 연결 후 주소 스캔
2. 각 주소별 장치명 매핑 테이블을 만들어 자동 출력
3. 응답이 사라진 주소를 주기적으로 감시해 “Sensor Disconnected!” 경고 메시지 출력

## 9.6 EEPROM(24Cxx) 데이터 저장 실습

EEPROM(24Cxx 시리즈)은 I²C 인터페이스를 이용해 데이터를 **비휘발성(Non-volatile)** 형태로 저장할 수 있는 메모리입니다.
 전원이 꺼져도 데이터가 유지되며, 센서 보정값, 사용자 설정값, 시스템 로그 등을 저장하는 데 널리 사용됩니다.

대표적인 제품은 **24C02 (2Kbit)**, **24C04 (4Kbit)**, **24C08 (8Kbit)**, **24C32 (32Kbit)** 등이며,
 모두 동일한 프로토콜을 사용하므로 코드 변경 없이 용량만 변경할 수 있습니다.

------

### 9.6.1 EEPROM 동작 원리

EEPROM은 내부에 **페이지(Page)** 단위로 데이터가 저장됩니다.
 기본 I²C 주소는 **0x50~0x57** (A0, A1, A2 핀 조합으로 결정)이며,
 각 페이지는 보통 **16~64 byte** 크기로 구성됩니다.

| 항목        | 설명                    |
| ----------- | ----------------------- |
| 인터페이스  | I²C (100kHz / 400kHz)   |
| 데이터 유지 | 수년 이상               |
| 페이지 쓰기 | 16~64 byte 단위로 가능  |
| 쓰기 시간   | 약 5ms / 페이지         |
| 주소        | 7-bit (0x50 + A2:A1:A0) |

------

### 9.6.2 하드웨어 연결

| MCU 핀 | EEPROM 핀 | 설명                       |
| ------ | --------- | -------------------------- |
| SDA    | SDA       | 데이터 라인 (Pull-up 필요) |
| SCL    | SCL       | 클록 라인 (Pull-up 필요)   |
| VCC    | VCC       | 3.3V 전원                  |
| GND    | GND       | 공통 접지                  |
| A0~A2  | GND       | 디폴트 주소 0x50 설정      |
| WP     | GND       | Write Enable (쓰기 허용)   |

> SDA, SCL 라인에는 반드시 **4.7kΩ 풀업 저항**을 추가해야 합니다.

------

### 9.6.3 기본 I²C Write/Read 함수

```
#include "main.h"
#include <stdio.h>

extern I2C_HandleTypeDef hi2c1;
#define EEPROM_ADDR 0x50 << 1 // 7-bit 주소 기준

void EEPROM_WriteByte(uint16_t MemAddress, uint8_t Data)
{
    uint8_t buf[2];
    buf[0] = (uint8_t)(MemAddress >> 8);     // 상위 주소
    buf[1] = (uint8_t)(MemAddress & 0xFF);   // 하위 주소

    HAL_I2C_Master_Transmit(&hi2c1, EEPROM_ADDR, buf, 2, 100);
    HAL_I2C_Master_Transmit(&hi2c1, EEPROM_ADDR, &Data, 1, 100);
    HAL_Delay(5);  // Write 완료 대기 (tWR)
}

uint8_t EEPROM_ReadByte(uint16_t MemAddress)
{
    uint8_t Data;
    uint8_t addr[2] = { (uint8_t)(MemAddress >> 8), (uint8_t)(MemAddress & 0xFF) };

    HAL_I2C_Master_Transmit(&hi2c1, EEPROM_ADDR, addr, 2, 100);
    HAL_I2C_Master_Receive(&hi2c1, EEPROM_ADDR, &Data, 1, 100);
    return Data;
}
```

------

### 9.6.4 페이지 단위 쓰기 (최적화 방식)

```
void EEPROM_WritePage(uint16_t MemAddress, uint8_t *Data, uint16_t Size)
{
    uint8_t buf[66]; // 최대 64바이트 페이지
    buf[0] = (uint8_t)(MemAddress >> 8);
    buf[1] = (uint8_t)(MemAddress & 0xFF);
    memcpy(&buf[2], Data, Size);

    HAL_I2C_Master_Transmit(&hi2c1, EEPROM_ADDR, buf, Size + 2, 100);
    HAL_Delay(5);
}
```

> EEPROM의 **페이지 경계를 넘으면** 다음 페이지로 덮어쓰기 되므로
>  반드시 페이지 크기(예: 16, 32, 64 byte)에 맞춰서 쓰기 단위를 나눠야 합니다.

------

### 9.6.5 전체 예제 (데이터 저장 및 읽기)

```
void EEPROM_Test(void)
{
    uint8_t write_data[16] = "STM32_HAL_TEST";
    uint8_t read_data[16] = {0};

    // Write
    EEPROM_WritePage(0x0010, write_data, sizeof(write_data));
    printf("EEPROM Write Done\r\n");

    HAL_Delay(10);

    // Read
    for (uint8_t i = 0; i < sizeof(write_data); i++)
    {
        read_data[i] = EEPROM_ReadByte(0x0010 + i);
    }

    printf("EEPROM Read Data: %s\r\n", read_data);
}
```

출력 예시:

```
EEPROM Write Done
EEPROM Read Data: STM32_HAL_TEST
```

------

### 9.6.6 검증 방법

| 테스트                 | 방법                                                      |
| ---------------------- | --------------------------------------------------------- |
| 전원 끄기 후 다시 읽기 | 비휘발성 저장 여부 확인                                   |
| 쓰기 반복              | 수만 회 반복 테스트 (내구성 확인)                         |
| 주소 확인              | 0x50 ~ 0x57 중 실제 연결된 주소 스캔                      |
| I²C Scope 확인         | Start → Device Address → MemAddress → Data 전송 파형 확인 |

------

### 9.6.7 고급 활용

- **센서 보정 데이터 저장** (Offset, Gain, Calibration Factor)
- **사용자 설정값 저장** (Threshold, Limit, Config Mode)
- **시스템 이벤트 로그 저장** (Timestamp + 상태값)
- **데이터 백업 / 리커버리 기능** (Flash 대비 안전 저장)

------

### 9.6.8 실습 과제

1. 24C02 또는 24C32 모듈을 연결 후 데이터 쓰기/읽기 실습
2. 전원을 껐다 켜도 값이 유지되는지 확인
3. 구조체 데이터를 EEPROM에 저장하는 함수 작성
4. 16바이트 단위 페이지 경계를 넘어가지 않도록 코드 개선
5. 주기적으로 센서 데이터를 EEPROM에 백업하는 예제 확장