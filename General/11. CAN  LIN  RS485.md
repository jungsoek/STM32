# 11. CAN / LIN / RS485

## 11.1 CAN 프로토콜 개요

**목표:**
 CAN(Controller Area Network) 통신의 기본 원리와 구조를 이해하고, STM32 내장 CAN 주변장치(HAL 기반)의 동작 메커니즘을 학습한다.
 이 단원에서는 CAN의 데이터 프레임 형식, Arbitration 방식, 비트 타이밍, Error Handling, 그리고 CAN Bus 물리적 구성 등을 체계적으로 다룬다.

------

### CAN 개요

**CAN (Controller Area Network)** 는 차량, 산업용 장비, 로봇 등에서 널리 사용되는 **고신뢰성 멀티마스터 직렬 통신 프로토콜**이다.
 1983년 Bosch가 개발하였으며, 실시간성과 오류 복원력이 높아 **자동차 ECU 간 통신 표준**으로 자리잡았다.

------

### 주요 특징

- **멀티마스터 구조:** 모든 노드가 Bus 접근 가능
- **비동기, 메시지 기반 통신:** 송신 노드 주소 대신 식별자(ID)로 메시지를 구분
- **CRC 기반 오류 검출:** 높은 통신 신뢰성 확보
- **Arbitration (버스 중재):** 충돌 없는 우선순위 전송
- **표준속도:** 최대 1 Mbps (CAN FD는 최대 8 Mbps까지 확장)

------

### CAN 프레임 구조

CAN 프레임은 전송 목적에 따라 여러 종류가 존재하며, 가장 기본적인 것은 **Data Frame**이다.

| 필드명                            | 길이(bit) | 설명                          |
| --------------------------------- | --------- | ----------------------------- |
| SOF (Start of Frame)              | 1         | 프레임 시작 비트              |
| Identifier                        | 11 or 29  | 메시지 식별자 (우선순위 결정) |
| RTR (Remote Transmission Request) | 1         | 원격 프레임 여부              |
| IDE (Identifier Extension)        | 1         | 0=표준, 1=확장 프레임         |
| DLC (Data Length Code)            | 4         | 데이터 길이 (0~8바이트)       |
| Data Field                        | 0~64      | 실제 전송 데이터              |
| CRC Field                         | 15 + 1    | 오류 검출을 위한 CRC          |
| ACK Field                         | 2         | 수신 노드의 ACK 응답          |
| EOF (End of Frame)                | 7         | 프레임 종료                   |

------

### 프레임 종류

| 구분                 | 설명                          |
| -------------------- | ----------------------------- |
| **Data Frame**       | 데이터를 송신할 때 사용       |
| **Remote Frame**     | 다른 노드의 데이터 요청용     |
| **Error Frame**      | 오류 검출 시 자동 전송        |
| **Overload Frame**   | 버퍼 과부하 시 전송 지연 신호 |
| **Interframe Space** | 프레임 간 최소 간격           |

------

### Arbitration (버스 중재)

CAN은 여러 노드가 동시에 전송할 수 있는 **멀티마스터 구조**이지만, 충돌 없이 버스를 공유하기 위해 **Arbitration Field (식별자)** 를 이용한다.

- **식별자(ID)** 가 낮을수록 **우선순위가 높다.**
- 논리적으로 **‘Dominant(0)’** 가 **‘Recessive(1)’** 보다 강함.
- 여러 노드가 동시에 전송 시, Dominant 신호를 잃은 노드는 자동으로 전송 중단.

#### 예시:

| 노드   | 식별자 | 우선순위 | 결과      |
| ------ | ------ | -------- | --------- |
| Node A | 0x100  | 낮음     | 탈락      |
| Node B | 0x080  | 중간     | 탈락      |
| Node C | 0x040  | 높음     | 전송 성공 |

------

### 비트 타이밍 (Bit Timing)

CAN은 정밀한 비트 타이밍이 중요하다. 각 비트는 다음 구간으로 나뉜다.

| 구간                                 | 의미                    |
| ------------------------------------ | ----------------------- |
| **SYNC_SEG**                         | 동기화 구간 (1 TQ 고정) |
| **PROP_SEG**                         | 전파 지연 보정 구간     |
| **PHASE_SEG1**                       | 샘플링 지연 조정        |
| **PHASE_SEG2**                       | 재동기화 보정           |
| **SJW (Synchronization Jump Width)** | 재동기 허용 폭          |

**1 비트 시간 = (SYNC_SEG + PROP_SEG + PHASE_SEG1 + PHASE_SEG2) × TQ**

예:
 APB1 Clock = 36 MHz, Prescaler = 9, Time Quanta(TQ) = 1/4 µs →
 1 Mbps CAN 속도를 얻으려면 총 16 TQ 설정 필요.

------

### 오류 검출 및 처리

CAN은 자체적인 **에러 검출 및 복구 기능**을 포함한다.

| 오류 종류       | 설명                                                 |
| --------------- | ---------------------------------------------------- |
| **Bit Error**   | 전송 비트와 수신 비트 불일치                         |
| **Stuff Error** | 비트 스터핑 규칙 위반 (5연속 동일 비트 발생 시 오류) |
| **CRC Error**   | 데이터 CRC 불일치                                    |
| **Form Error**  | 프레임 포맷 위반                                     |
| **ACK Error**   | ACK 응답 미수신                                      |

각 노드는 오류 발생 시 **Error Frame**을 전송하고, 내부의 **Transmit Error Counter / Receive Error Counter**를 갱신한다.
 지속적인 오류 발생 시 자동으로 **Bus Off 상태**로 진입하여 통신에서 제외된다.

------

### 물리 계층 (CAN Bus Wiring)

| 항목                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **전송선**          | CAN_H, CAN_L (차동 신호)                                     |
| **전송방식**        | Differential signaling (노이즈 저항성 우수)                  |
| **터미네이션 저항** | 120 Ω × 2개 (Bus 양단)                                       |
| **전압레벨**        | Dominant: CAN_H ≈ 3.5V, CAN_L ≈ 1.5V / Recessive: 두 선 약 2.5V |
| **최대 노드 수**    | 일반적으로 32~64 노드 (하드웨어 종속)                        |
| **최대 길이**       | 1 Mbps 시 약 40m, 125 kbps 시 최대 500m 이상 가능            |

------

### CAN 통신 예시 시나리오

1. **ECU1 (엔진 제어기)** → “엔진 RPM = 3000” 메시지 송신 (ID = 0x100)
2. **ECU2 (계기판)** → 해당 메시지 수신, RPM 게이지 표시
3. **ECU3 (ABS)** → CAN Bus에서 동일 메시지 수신, 엔진 토크 제한 로직 동작

즉, 한 노드의 송신이 여러 노드로 **Broadcast** 되는 구조로, **수신 필터**를 통해 필요한 메시지만 처리한다.

------

### CAN2.0 vs CAN FD

| 구분        | CAN 2.0      | CAN FD                           |
| ----------- | ------------ | -------------------------------- |
| 데이터 길이 | 최대 8바이트 | 최대 64바이트                    |
| 속도        | 1 Mbps       | 최대 8 Mbps                      |
| CRC         | 15-bit       | 21-bit                           |
| 전송 구조   | 고정         | 유연 (Data Phase 속도 가속 가능) |

STM32의 **F4/F7/L4/H7 시리즈**는 대부분 **CAN FD** 또는 **FDCAN**을 지원한다.

------

### 실제 STM32 내장 CAN 구조

STM32의 CAN 주변장치는 다음과 같은 모듈로 구성된다.

- **Bit Timing Logic**: 비트 속도 및 동기화 제어
- **Mailbox (Tx/Rx FIFO)**: 메시지 송수신 버퍼
- **Filter Bank**: ID 기반 수신 필터링
- **Error Management Unit**: 오류 카운트 및 복구

------

### 정리

| 항목           | 핵심 포인트                                |
| -------------- | ------------------------------------------ |
| 프레임 구조    | ID, RTR, DLC, DATA, CRC, ACK               |
| Arbitration    | ID 기반 우선순위, 충돌 없는 중재           |
| 오류 처리      | 자동 Error Frame 및 Bus-Off 복구           |
| 속도 계산      | Bit Timing 파라미터 설정 중요              |
| 물리 구성      | 120Ω 터미네이션, 차동 전송 방식            |
| STM32 HAL 구성 | Mailbox, Filter, Tx/Rx FIFO, Error Counter |

------

### 과제

1. CAN 프레임 구조를 직접 도식화하고 각 필드 역할 설명
2. STM32CubeIDE에서 CAN 속도 계산기(CAN Timing Configuration) 사용하여 500 kbps 설정
3. CAN 통신 시뮬레이터(예: PCAN, USB2CAN)와 연결하여 메시지 송수신 실험

## 11.2 Bit Timing 및 필터 설정

**목표:**
 CAN 통신에서 핵심이 되는 **비트 타이밍(Bit Timing)** 과 **수신 필터(Filter)** 설정 방식을 이해하고, STM32 HAL 기반으로 구체적인 초기화 절차를 분석한다.
 정확한 Bit Timing 계산과 필터 구성은 CAN 네트워크의 안정성과 통신 신뢰도에 직접적으로 영향을 준다.

------

### Bit Timing 개요

CAN의 한 비트는 내부적으로 여러 구간으로 분리되어 있으며, 각 구간의 시간 합이 **비트 타임(Bit Time)** 을 구성한다.
 비트 타이밍은 **Sample Point** (데이터 샘플링 시점) 과 **Synchronization** 정확도를 결정한다.

| 구간                                 | 설명                                            | 단위 |
| ------------------------------------ | ----------------------------------------------- | ---- |
| **SYNC_SEG**                         | 비트의 시작을 맞추기 위한 동기 구간 (항상 1 TQ) | 1    |
| **PROP_SEG**                         | 전파 지연 보상 구간                             | n TQ |
| **PHASE_SEG1**                       | 샘플링 이전의 지연 보정                         | n TQ |
| **PHASE_SEG2**                       | 샘플링 이후의 보정 구간                         | n TQ |
| **SJW** (Synchronization Jump Width) | 재동기 시 허용 오차폭                           | n TQ |

**1 Bit Time = (SYNC_SEG + PROP_SEG + PHASE_SEG1 + PHASE_SEG2) × TQ**

------

### Time Quantum (TQ)

- **TQ (Time Quantum)** 은 CAN 클록(보통 APB1)에서 분주기를 적용해 얻는 가장 작은 시간 단위이다.
- 하나의 비트는 여러 개의 TQ로 구성되며, 보통 8~25 TQ로 설정된다.
- 속도와 안정성의 트레이드오프 관계가 존재한다.

**TQ = (1 / CAN_CLK) × Prescaler**
 예:
 APB1 = 36 MHz, Prescaler = 9 → TQ = 0.25 µs

------

### 속도 계산 예시 (500 kbps)

비트 타임 = 2 µs → 1 비트당 16 TQ 구성

| 항목         | 설정 값   |
| ------------ | --------- |
| Prescaler    | 9         |
| Prop_Seg     | 5         |
| Phase_Seg1   | 5         |
| Phase_Seg2   | 5         |
| SJW          | 1         |
| Bit rate     | 500 kbps  |
| Sample Point | 약 68.75% |

**Sample Point**는 일반적으로 70~80%가 이상적이며, 너무 앞서거나 늦으면 오류율이 증가한다.

------

### HAL 구조에서 Bit Timing 설정

STM32 HAL에서는 `CAN_InitTypeDef` 구조체의 멤버로 Timing을 정의한다.

```
hcan.Instance = CAN1;
hcan.Init.Prescaler = 9;
hcan.Init.Mode = CAN_MODE_NORMAL;
hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
hcan.Init.TimeSeg1 = CAN_BS1_13TQ;
hcan.Init.TimeSeg2 = CAN_BS2_2TQ;
hcan.Init.TimeTriggeredMode = DISABLE;
hcan.Init.AutoBusOff = ENABLE;
hcan.Init.AutoWakeUp = DISABLE;
hcan.Init.AutoRetransmission = ENABLE;
hcan.Init.ReceiveFifoLocked = DISABLE;
hcan.Init.TransmitFifoPriority = DISABLE;

HAL_CAN_Init(&hcan);
```

- `Prescaler`: 분주비 설정
- `TimeSeg1`, `TimeSeg2`: 비트 타이밍 구성
- `SyncJumpWidth`: 재동기화 허용 오차
- `AutoBusOff`: 오류 시 Bus-Off 복구 기능

------

### Bit Timing 조정 팁

- Sample Point는 항상 70~80% 권장
- 빠른 속도(>1 Mbps)일수록 Prop_Seg을 짧게 설정
- 긴 케이블(>100m)에서는 Prop_Seg을 늘려 전파 지연 보상
- 다른 노드와 정확히 동일한 설정 유지 필수

------

### Filter 설정 개요

CAN은 모든 메시지를 수신하지만, 실제로 필요한 ID만 처리하기 위해 **Filter Bank**를 사용한다.
 STM32는 최대 28개의 필터 뱅크를 제공하며, 각 필터는 **Mask Mode** 또는 **List Mode** 로 동작한다.

| 모드          | 설명                                            |
| ------------- | ----------------------------------------------- |
| **Mask Mode** | 마스크 비트를 이용한 패턴 매칭 (0=비교, 1=무시) |
| **List Mode** | 최대 4개의 개별 ID 수신                         |

------

### 필터 비트 구성 (표준 ID 기준)

| 비트  | 역할           |
| ----- | -------------- |
| 31:21 | 식별자(11-bit) |
| 3     | RTR            |
| 2     | IDE            |
| 1     | EXID           |
| 0     | 활성 플래그    |

------

### HAL 기반 필터 설정 예제

```
CAN_FilterTypeDef filterConfig;

filterConfig.FilterBank = 0;
filterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
filterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
filterConfig.FilterIdHigh = (0x100 << 5);
filterConfig.FilterIdLow = 0x0000;
filterConfig.FilterMaskIdHigh = (0x700 << 5); // ID 마스크
filterConfig.FilterMaskIdLow = 0x0000;
filterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
filterConfig.FilterActivation = ENABLE;
filterConfig.SlaveStartFilterBank = 14;

HAL_CAN_ConfigFilter(&hcan, &filterConfig);
```

#### 주요 설정 요소

- `FilterBank`: 필터 번호 (0~27)
- `FilterMode`: IDMASK 또는 IDLIST
- `FilterScale`: 16/32비트 선택
- `FilterIdHigh/Low`: 수신 허용 ID
- `FilterMaskIdHigh/Low`: 비교 마스크
- `FilterFIFOAssignment`: 수신 FIFO 선택 (FIFO0, FIFO1)

------

### 필터 동작 예시

| 설정                              | 수신 허용 ID   |
| --------------------------------- | -------------- |
| ID = 0x100, Mask = 0x700          | 0x100 ~ 0x1FF  |
| ID = 0x200, Mask = 0x7F0          | 0x200 ~ 0x20F  |
| IDLIST 모드 (0x101, 0x305, 0x700) | 지정 ID만 수신 |

------

### 필터 설계 가이드라인

1. ID 그룹화: ECU별로 ID 범위 설계
2. 중요 메시지는 낮은 ID 부여 (중재 우선순위 높임)
3. Mask는 유연하게 설계해 그룹 수신 효율화
4. FIFO0과 FIFO1을 용도별로 분리 (예: 실시간/비실시간 데이터)

------

### 수신 필터 동작 검증 절차

1. STM32CubeIDE에서 CAN 필터 설정
2. CAN 분석기(PCAN View 등)로 송신 테스트
3. 수신 콜백 함수(`HAL_CAN_RxFifo0MsgPendingCallback`) 내에서 필터링된 메시지 확인
4. Debug View → `hcan.RxHeader.StdId` 값 확인

------

### 정리

| 항목         | 핵심 포인트                                       |
| ------------ | ------------------------------------------------- |
| Bit Timing   | Prescaler, Seg1/Seg2, SJW 조합으로 1bit 시간 구성 |
| Sample Point | 약 75%가 안정적                                   |
| Filter Mode  | IDMASK(범위), IDLIST(특정 ID)                     |
| HAL 설정     | `CAN_FilterTypeDef` 구조체 이용                   |
| 실습 포인트  | CubeIDE에서 500kbps 설정 + 특정 ID만 수신         |

------

### 과제

1. APB1 Clock 36MHz에서 1 Mbps CAN 속도를 맞추는 Prescaler, Segment 설정 계산
2. 필터 마스크를 이용해 0x300~0x3FF ID만 수신되도록 설정
3. CAN Analyzer로 다양한 ID를 송신해 필터 동작 검증

------

이 단원은 다음 장 “11.3 송신 및 수신 프레임 구조”의 실습 준비 과정으로, 올바른 Timing과 Filter 구성이 정상 통신의 핵심이다.

## 11.3 CAN Tx/Rx FIFO 구조

**목표:**
 CAN 주변장치의 송신(Tx) 및 수신(Rx) FIFO(FIFO: First In First Out) 구조를 이해하고, STM32 HAL 기반으로 메시지 송수신 흐름을 명확히 파악한다. CAN은 하드웨어 레벨에서 버퍼 관리와 중재(arbitration)를 처리하므로, FIFO의 동작 메커니즘을 정확히 이해하는 것은 신뢰성 높은 통신 설계의 핵심이다.

------

### CAN 송신(Tx) 구조 개요

STM32의 CAN 모듈은 **3개의 송신 메일박스(Tx Mailbox 0~2)** 를 제공한다.
 각 Mailbox는 하나의 CAN 프레임(표준 또는 확장)을 저장할 수 있으며, 우선순위에 따라 전송이 진행된다.

| 구성 요소                        | 설명                            |
| -------------------------------- | ------------------------------- |
| **TME (Transmit Mailbox Empty)** | 송신 버퍼가 비어 있는지 여부    |
| **TXRQ (Transmit Request)**      | 송신 요청 비트 (1=송신 대기 중) |
| **ABRQ (Abort Request)**         | 송신 중단 요청 비트             |
| **TXOK**                         | 송신 완료 플래그                |
| **ALST / TERR**                  | 중재 실패, 전송 오류 플래그     |

- 송신 메일박스는 **하드웨어 레벨에서 자동 중재(arbitration)** 를 수행하며, 낮은 ID가 높은 우선순위를 가진다.
- 송신 중 하나의 Mailbox만 사용 중일 때, 나머지는 대기 상태로 유지된다.

------

### HAL 기반 송신 함수

```
HAL_StatusTypeDef HAL_CAN_AddTxMessage(
    CAN_HandleTypeDef *hcan,
    CAN_TxHeaderTypeDef *pHeader,
    uint8_t *aData,
    uint32_t *pTxMailbox);
```

#### 매개변수 설명

| 매개변수     | 설명                            |
| ------------ | ------------------------------- |
| `hcan`       | CAN 핸들 포인터                 |
| `pHeader`    | 송신 헤더 구조체 포인터         |
| `aData`      | 송신 데이터 버퍼                |
| `pTxMailbox` | 사용된 Mailbox 번호 반환 포인터 |

#### 예제 코드

```
CAN_TxHeaderTypeDef TxHeader;
uint8_t TxData[8];
uint32_t TxMailbox;

TxHeader.StdId = 0x321;
TxHeader.ExtId = 0x01;
TxHeader.RTR = CAN_RTR_DATA;
TxHeader.IDE = CAN_ID_STD;
TxHeader.DLC = 8;
TxHeader.TransmitGlobalTime = DISABLE;

memcpy(TxData, "STM32CAN", 8);
HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox);
```

- `DLC`는 Data Length Code (0~8 bytes)
- `RTR`은 데이터 프레임(`CAN_RTR_DATA`) 또는 원격 프레임(`CAN_RTR_REMOTE`)
- `TransmitGlobalTime`은 타임스탬프 포함 여부

------

### 송신 완료 콜백

송신이 완료되면 `HAL_CAN_TxMailbox0CompleteCallback()` 등의 콜백이 호출된다.

```
void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
{
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 송신 완료 표시
}
```

**콜백 종류**

- `HAL_CAN_TxMailbox0CompleteCallback`
- `HAL_CAN_TxMailbox1CompleteCallback`
- `HAL_CAN_TxMailbox2CompleteCallback`

------

### CAN 수신(Rx) 구조 개요

STM32는 **2개의 수신 FIFO (FIFO0, FIFO1)** 를 제공한다.
 각 FIFO는 하드웨어적으로 ID 필터를 통과한 메시지를 순차 저장한다.

| FIFO      | 주 용도                              | 특징           |
| --------- | ------------------------------------ | -------------- |
| **FIFO0** | 실시간 데이터 (센서, 제어 등)        | 기본 수신 FIFO |
| **FIFO1** | 비실시간 데이터 (로그, 상태 보고 등) | 보조 수신 FIFO |

#### FIFO 상태 플래그

| 플래그 | 설명                           |
| ------ | ------------------------------ |
| `FMPx` | FIFO 내 메시지 개수 (0~3)      |
| `FULL` | FIFO 가득 참                   |
| `OVR`  | 수신 오버런 (데이터 손실 발생) |

------

### HAL 기반 수신 함수

```
HAL_StatusTypeDef HAL_CAN_GetRxMessage(
    CAN_HandleTypeDef *hcan,
    uint32_t RxFifo,
    CAN_RxHeaderTypeDef *pHeader,
    uint8_t *aData);
```

#### 예제 코드

```
CAN_RxHeaderTypeDef RxHeader;
uint8_t RxData[8];

if (HAL_CAN_GetRxFifoFillLevel(&hcan, CAN_RX_FIFO0) > 0)
{
    HAL_CAN_GetRxMessage(&hcan, CAN_RX_FIFO0, &RxHeader, RxData);

    printf("ID: 0x%03lX, DLC: %d, Data: ", RxHeader.StdId, RxHeader.DLC);
    for (int i = 0; i < RxHeader.DLC; i++)
        printf("%02X ", RxData[i]);
    printf("\r\n");
}
```

------

### 수신 콜백 함수

CAN은 하드웨어 인터럽트를 통해 수신 이벤트를 처리한다.
 `HAL_CAN_ActivateNotification()` 함수를 통해 FIFO별 인터럽트를 활성화한다.

```
HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    CAN_RxHeaderTypeDef RxHeader;
    uint8_t RxData[8];

    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);
    // 수신 데이터 처리
}
```

------

### FIFO0 vs FIFO1 구분 전략

| 구분          | FIFO0                  | FIFO1           |
| ------------- | ---------------------- | --------------- |
| **용도**      | 제어 루프, 센서 데이터 | 진단, 로깅      |
| **우선순위**  | 높음                   | 낮음            |
| **필터 매핑** | 필터 Bank 0~13         | 필터 Bank 14~27 |

- 필터 뱅크를 적절히 분할해 메시지 분류 처리 가능
- 예: 센서 ID(0x100~0x1FF)는 FIFO0, 시스템 로그 ID(0x600~0x6FF)는 FIFO1

------

### FIFO 오버런 방지 대책

1. `HAL_CAN_GetRxMessage()` 호출을 빠르게 처리
2. DMA 기반 수신(일부 MCU 시리즈에서 지원) 고려
3. 오버런 플래그(`OVR`) 감시 및 클리어
4. 필터로 불필요한 프레임 수신 최소화

------

### 하드웨어 송수신 경로 요약

```
   [Tx Mailbox 0~2] ───> CAN Bus ───> [Rx Filter] ───> [FIFO0/FIFO1]
```

- 송신은 Mailbox를 통해 자동 중재 후 버스로 전송
- 수신은 ID 필터를 거쳐 FIFO에 저장
- 소프트웨어는 FIFO에서 순차 읽기

------

### 통신 상태 확인 함수

```
uint32_t error = HAL_CAN_GetError(&hcan);
if (error != HAL_CAN_ERROR_NONE)
{
    printf("CAN Error: 0x%08lX\n", error);
}
```

| 주요 에러 코드            | 설명           |
| ------------------------- | -------------- |
| `HAL_CAN_ERROR_TXALST0~2` | 송신 중재 실패 |
| `HAL_CAN_ERROR_RX_FOV0/1` | FIFO 오버런    |
| `HAL_CAN_ERROR_ACK`       | ACK 수신 실패  |
| `HAL_CAN_ERROR_BOF`       | Bus-Off 상태   |

------

### 실습 예제

1. 송신 노드: ID 0x123, 8바이트 데이터 주기적 전송
2. 수신 노드: FIFO0에서 메시지 읽고 UART로 출력
3. FIFO1에는 0x600~0x6FF 로그 메시지 수신

**송신 예제 코드**

```
TxHeader.StdId = 0x123;
TxHeader.DLC = 8;
memcpy(TxData, "NODE1_OK", 8);
HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox);
```

**수신 콜백 코드**

```
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);
    printf("RX ID: 0x%03lX Data: %s\r\n", RxHeader.StdId, RxData);
}
```

------

### 요약

| 구분               | FIFO               | 주요 기능                |
| ------------------ | ------------------ | ------------------------ |
| **Tx Mailbox 0~2** | 송신 버퍼          | 전송 요청 및 중재 처리   |
| **Rx FIFO0**       | 실시간 데이터 수신 | 고속 처리용              |
| **Rx FIFO1**       | 로그성 메시지 수신 | 저속, 비실시간 처리용    |
| **HAL 콜백**       | 이벤트 기반 처리   | 송수신 완료 시 자동 호출 |

------

다음 장에서는 **“11.4 CAN Interrupt 및 Error Handling 구조”** 를 통해 CAN 통신의 인터럽트 기반 처리와 오류 복구 메커니즘을 다룬다.

## 11.4 RS485 통신 구현 (DE/RE 제어)

**목표:**
 RS485의 Half-Duplex 통신 방식과 **송수신 방향 제어(DE/RE 핀)** 원리를 이해하고, STM32 HAL UART 드라이버를 활용하여 실습 환경에서 RS485 송수신 기능을 구현한다.

------

### RS485 개요

RS485는 **차동 신호(differential signaling)** 기반의 **멀티드롭(Multi-Drop)** 통신 규격이다.
 1쌍의 신호선(A, B)을 사용하며, 최대 32개 노드까지 연결 가능하다.

| 항목          | 설명                                    |
| ------------- | --------------------------------------- |
| **통신 방식** | Half-Duplex (송수신 공용)               |
| **전송 거리** | 최대 1200m (속도에 따라 감소)           |
| **속도**      | 최대 10Mbps                             |
| **신호 방식** | 차동 전압 (A+, B−)                      |
| **필요 핀수** | A, B (데이터선 2개) + GND (공통 기준선) |

------

### 하드웨어 구성

RS485는 TTL(UART) 신호를 차동 신호로 변환하기 위해 **RS485 Transceiver (예: MAX485, SP3485)** 를 사용한다.

#### 회로 연결 예시 (STM32 ↔ MAX485)

| STM32 핀           | MAX485 핀 | 설명                            |
| ------------------ | --------- | ------------------------------- |
| **TX (USARTx_TX)** | DI        | 송신 데이터 입력                |
| **RX (USARTx_RX)** | RO        | 수신 데이터 출력                |
| **GPIO (예: PA8)** | DE/RE     | 송수신 방향 제어                |
| **VCC (3.3V)**     | VCC       | 전원                            |
| **GND**            | GND       | 공통 접지                       |
| **A/B**            | A/B       | RS485 차동 라인 (네트워크 연결) |

> ⚙️ DE: Driver Enable (1=송신 활성화), RE: Receiver Enable (0=수신 활성화)
>  대부분의 트랜시버는 DE와 RE를 묶어 하나의 GPIO로 제어한다.
>  → 송신 시: `DE=1`, 수신 시: `DE=0`

------

### RS485 송수신 타이밍

```
송신 시:  DE = 1 → HAL_UART_Transmit() → 전송 완료 후 DE = 0
수신 시:  DE = 0 → HAL_UART_Receive() (or interrupt)
```

RS485는 Half-Duplex 구조이므로, 송신 중에는 수신 불가하고
 반대로 수신 중에는 송신 불가하다.

------

### CubeMX 설정 방법

1. **Peripherals → USARTx → Mode:** “Asynchronous” 선택
2. **Baudrate:** 9600~115200bps 설정
3. **Word Length:** 8 bits
4. **Parity:** None
5. **Stop Bits:** 1
6. **GPIO Configuration:** TX, RX 핀 지정
7. **추가 GPIO (DE/RE 핀)** 을 Output 모드로 설정

------

### 예제 코드 (RS485 송수신)

#### 1️⃣ DE/RE 핀 정의

```
#define RS485_DIR_GPIO_PORT GPIOA
#define RS485_DIR_PIN       GPIO_PIN_8

#define RS485_TX_MODE() HAL_GPIO_WritePin(RS485_DIR_GPIO_PORT, RS485_DIR_PIN, GPIO_PIN_SET)
#define RS485_RX_MODE() HAL_GPIO_WritePin(RS485_DIR_GPIO_PORT, RS485_DIR_PIN, GPIO_PIN_RESET)
```

------

#### 2️⃣ 초기화 코드

```
void RS485_Init(void)
{
    RS485_RX_MODE();  // 기본 수신 모드로 설정
    HAL_UART_Init(&huart1);  // USART1 사용 가정
}
```

------

#### 3️⃣ 송신 함수

```
void RS485_Transmit(uint8_t *pData, uint16_t Size)
{
    RS485_TX_MODE();  // 송신 모드 전환
    HAL_UART_Transmit(&huart1, pData, Size, HAL_MAX_DELAY);
    RS485_RX_MODE();  // 송신 완료 후 수신 모드 복귀
}
```

------

#### 4️⃣ 수신 함수 (폴링 기반)

```
void RS485_Receive(uint8_t *pData, uint16_t Size)
{
    RS485_RX_MODE();
    HAL_UART_Receive(&huart1, pData, Size, HAL_MAX_DELAY);
}
```

------

#### 5️⃣ 수신 인터럽트 기반 예제

```
uint8_t RS485_RxBuffer[64];

void RS485_StartReceiveIT(void)
{
    RS485_RX_MODE();
    HAL_UART_Receive_IT(&huart1, RS485_RxBuffer, 1);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
    {
        printf("Received: %c\r\n", RS485_RxBuffer[0]);
        HAL_UART_Receive_IT(&huart1, RS485_RxBuffer, 1); // 다음 수신 준비
    }
}
```

------

#### 6️⃣ 송신 + 수신 루프 예제

```
uint8_t txData[] = "Hello RS485";
uint8_t rxData[16];

RS485_Init();

while (1)
{
    RS485_Transmit(txData, sizeof(txData));
    HAL_Delay(1000);

    RS485_Receive(rxData, 8);
    printf("Received: %s\r\n", rxData);
}
```

------

### DMA 기반 송수신 (선택)

대용량 데이터를 처리할 때는 DMA를 활용해 CPU 부하를 줄일 수 있다.
 단, DMA 송신 완료 인터럽트에서 DE를 다시 LOW로 내리는 타이밍 조정이 필요하다.

```
RS485_TX_MODE();
HAL_UART_Transmit_DMA(&huart1, txData, sizeof(txData));
```

DMA 송신 완료 콜백:

```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART1)
        RS485_RX_MODE();
}
```

------

### 실습 예시 (STM32 ↔ STM32 RS485 통신)

| 역할                | MCU           | 설명              |
| ------------------- | ------------- | ----------------- |
| **Master (송신기)** | STM32F103C8T6 | 명령 프레임 송신  |
| **Slave (수신기)**  | STM32F103C8T6 | 수신 후 응답 회신 |

#### Master 코드

```
uint8_t cmd[] = {0x01, 0x03, 0x00, 0x00, 0x02};
RS485_Transmit(cmd, sizeof(cmd));
```

#### Slave 코드

```
uint8_t buf[32];
RS485_Receive(buf, sizeof(buf));
if (buf[0] == 0x01)
{
    uint8_t ack[] = {0xAA, 0x55};
    RS485_Transmit(ack, 2);
}
```

------

### DE/RE 핀 타이밍 주의사항

RS485 트랜시버는 DE 신호를 HIGH로 만든 직후 약 **1~2µs의 안정 시간**이 필요하다.
 따라서 실제 하드웨어 환경에서는 송신 전 약간의 지연을 넣는 것이 좋다.

```
RS485_TX_MODE();
for (volatile int i = 0; i < 100; i++);  // 약 2µs 대기
HAL_UART_Transmit(&huart1, data, len, 100);
RS485_RX_MODE();
```

------

### 통신 프레임 설계 예시

| 바이트 | 내용     | 설명           |
| ------ | -------- | -------------- |
| 0      | Slave ID | 대상 장치 식별 |
| 1      | CMD      | 명령 코드      |
| 2~n    | DATA     | 명령 파라미터  |
| n+1    | CRC      | 오류 검출      |

예: `[0x01][0x10][0x05][0x00][CRC_L][CRC_H]`

CRC는 Modbus RTU에서 사용하는 **CRC-16 (0xA001)** 알고리즘을 적용할 수 있다.

------

### 디버깅 팁

| 증상                   | 원인                       | 해결                      |
| ---------------------- | -------------------------- | ------------------------- |
| 송신은 되나 수신 안 됨 | DE 핀이 항상 HIGH 상태     | 송신 후 반드시 LOW로 복귀 |
| 쓰레기 데이터 수신     | GND 미연결 또는 A/B 반전   | A/B 라인 확인             |
| 통신 불안정            | 케이블 길이, 종단저항 문제 | 120Ω 종단저항 추가        |
| 데이터 손실            | 수신 타이밍 늦음           | 인터럽트 or DMA 방식 적용 |

------

### 요약

| 항목               | 내용                                |
| ------------------ | ----------------------------------- |
| **통신 방식**      | Half-Duplex (A/B 라인 공유)         |
| **핵심 제어**      | DE/RE 핀으로 송수신 방향 제어       |
| **송신 순서**      | DE=1 → Transmit → DE=0              |
| **수신 순서**      | DE=0 → Receive                      |
| **전형적 사용 예** | 산업기기, 센서 네트워크, Modbus RTU |

## 11.5 LIN 프로토콜 개념

LIN(Local Interconnect Network)은 자동차 및 산업용 임베디드 시스템에서 사용되는 **저속, 저비용 시리얼 통신 프로토콜**로, CAN 버스를 보조하는 역할을 수행한다. 주로 간단한 센서나 액추에이터 제어에 사용되며, 네트워크 내의 여러 노드를 **마스터-슬레이브 구조**로 연결하여 효율적인 통신을 제공한다.

------

### LIN의 필요성 및 설계 배경

- CAN은 높은 신뢰성과 속도를 제공하지만, **비용이 비싸고 구현 복잡도**가 높다.
- 자동차 내부에는 전력 창 제어, 조명 제어, 시트 조절 등 상대적으로 **낮은 대역폭(20 kbps 이하)** 을 요구하는 서브시스템이 존재한다.
- 이러한 로컬 네트워크는 CAN보다 단순한 구조가 필요하며, 이 목적을 위해 LIN이 개발되었다.
- LIN은 **UART 기반의 직렬 통신**으로 동작하며, **하드웨어 UART + 소프트웨어 프로토콜 스택**만으로 구현 가능하다.

------

### 기본 특징

| 항목              | 내용                                       |
| ----------------- | ------------------------------------------ |
| **전송 속도**     | 최대 20 kbps                               |
| **통신 방식**     | UART 기반 비동기 시리얼 통신               |
| **노드 구조**     | 1개의 마스터 + 최대 15개의 슬레이브        |
| **전송 매체**     | 단일 신호선 (Single Wire, Bus Idle = HIGH) |
| **프레임 동기화** | Break Field + Sync Field                   |
| **Checksum**      | Classic 또는 Enhanced 방식                 |
| **주소 지정**     | Identifier(6-bit)로 Slave 식별             |
| **물리 계층**     | ISO 9141(K-Line) 기반 전기 신호 사용       |

------

### LIN 프레임 구조

| 필드명               | 길이            | 설명                                       |
| -------------------- | --------------- | ------------------------------------------ |
| **Break Field**      | ≥13비트         | 동기화 시작을 알리는 Break 신호 (LOW 유지) |
| **Sync Field**       | 8비트           | `0x55` 고정값 (비트 동기화용)              |
| **Identifier Field** | 6비트 + 2패리티 | 메시지 ID (마스터가 송신)                  |
| **Data Field**       | 1~8 Byte        | 실제 전송 데이터 (슬레이브에 따라 다름)    |
| **Checksum Field**   | 1 Byte          | Classic(데이터만) 또는 Enhanced(ID 포함)   |

LIN 프레임은 항상 마스터가 시작하며, 슬레이브는 ID에 따라 응답 여부를 결정한다.

------

### 통신 절차

1. **마스터가 프레임 헤더 전송**
   - Break → Sync → Identifier 순으로 전송
   - 모든 슬레이브는 ID를 수신 후, 자신에게 해당하는 프레임인지 확인
2. **슬레이브가 응답 (Response Field)**
   - 마스터 혹은 지정된 슬레이브가 데이터 필드 및 체크섬 전송
3. **주기적 스케줄링**
   - 마스터는 사전에 정의된 “Schedule Table”에 따라 주기적으로 각 프레임 전송

------

### LIN Identifier 구조

- Identifier는 6비트 데이터 + 2비트 패리티로 구성
- 패리티 계산 규칙:
  - `P0 = ID0 ⊕ ID1 ⊕ ID2 ⊕ ID4`
  - `P1 = ¬(ID1 ⊕ ID3 ⊕ ID4 ⊕ ID5)`
- 전체 Identifier = `[P1 P0 ID5 ID4 ID3 ID2 ID1 ID0]`

------

### 체크섬 계산

1. **Classic Checksum (LIN 1.x)**
   - 데이터 필드의 합을 8비트로 더한 후 1’s complement
2. **Enhanced Checksum (LIN 2.x 이상)**
   - Identifier까지 포함하여 계산 (데이터와 ID 모두 더함)

------

### LIN 물리 계층

- LIN 버스는 **Single Wire Bus**로 동작하며, Idle 상태는 HIGH(12V 기준).
- 데이터 전송 시 Low 레벨(0V)로 내려가며 UART 방식으로 비트를 전송한다.
- 슬레이브는 트랜시버(IC)로 연결되며 대표적으로 **TJA1020**, **MC33662**, **ATA6631** 등이 사용된다.

------

### 마스터-슬레이브 구조 예시

- **마스터 노드:** Body Control Module (BCM)
- **슬레이브 노드:** 창문 모터, 조명 제어기, 온도 센서 등
- 마스터는 스케줄에 따라 “Window_Status”, “Light_Command” 등의 프레임을 송신함

------

### LIN vs CAN 비교

| 항목          | LIN                       | CAN                         |
| ------------- | ------------------------- | --------------------------- |
| **속도**      | 최대 20 kbps              | 최대 1 Mbps                 |
| **버스 구조** | 단선 (Single Wire)        | 차동선 (Differential Pair)  |
| **노드 수**   | 16개 이하                 | 100개 이상                  |
| **에러 검출** | Checksum                  | CRC, ACK, Bit Monitoring 등 |
| **비용**      | 낮음                      | 높음                        |
| **용도**      | 단순 제어 (창문, 조명 등) | 실시간 제어, 안전 시스템 등 |

------

### LIN 통신 구현 (STM32 예시)

STM32의 **USART 모듈**은 LIN 모드를 지원한다.
 HAL 드라이버를 통해 다음과 같이 설정 가능하다.

```
UART_HandleTypeDef huart1;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.BaudRate = 19200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.LINMode = ENABLE;
HAL_LIN_Init(&huart1, UART_LINBREAKDETECTLENGTH_10B);
```

- **Break Field 전송**

  ```
  HAL_LIN_SendBreak(&huart1);
  ```

- **LIN Frame 수신**

  ```
  HAL_UART_Receive(&huart1, rxBuf, 8, 100);
  ```

------

### 실습 예제 – LIN Slave 시뮬레이션

1. PC에서 LIN USB Dongle (예: PEAK LIN-USB) 사용
2. STM32를 Slave로 설정하고 특정 ID (예: `0x12`) 응답 대기
3. 마스터가 `0x12` 프레임 전송 시, STM32가 데이터 응답
4. UART 터미널에서 수신 프레임 확인

------

### 요약

- LIN은 **저속, 저비용, 단순 구조**의 차량용 통신 프로토콜이다.
- **마스터-슬레이브 구조**, **Break + Sync + ID + Data + Checksum** 형식으로 통신한다.
- STM32는 USART의 LIN 모드를 통해 하드웨어 지원이 가능하며, **소프트웨어 구현도 가능**하다.
- CAN 대비 단순하지만, **로컬 노드 제어용**으로 효율적이다.

## 11.6 차량용 센서 시뮬레이션

이 절에서는 STM32를 이용하여 차량 내 센서 시스템을 **LIN / CAN 기반으로 시뮬레이션**하는 방법을 다룬다. 실제 자동차 네트워크에서는 속도, 온도, 조향각, 조도, 가속도, 회전수(RPM) 등 다양한 센서가 각 제어 유닛(ECU)으로 데이터를 전송한다. 본 시뮬레이션의 목적은 **이러한 환경을 STM32 단일 보드에서 재현하고, CAN 또는 LIN 통신을 통해 데이터 교환 및 검증하는 것**이다.

------

### 차량용 센서 시뮬레이션의 구성 개념

자동차 내부 네트워크는 다음과 같은 구조로 이해할 수 있다.

- **센서 노드:** 실제 물리량을 감지하는 장치 (온도, 속도, 압력 등)
- **게이트웨이 노드:** LIN, CAN, FlexRay 등 서로 다른 버스 간의 데이터 변환 수행
- **ECU(제어 유닛):** 수신 데이터를 이용해 액추에이터 제어 (예: 냉각팬, 연료분사, ABS 등)

STM32는 이 중 **센서 노드 또는 게이트웨이 역할**을 수행할 수 있다.

------

### 하드웨어 구성 예시

| 항목       | 구성 요소                                                    | 설명                           |
| ---------- | ------------------------------------------------------------ | ------------------------------ |
| MCU        | STM32F103, STM32G4, STM32H7 등                               | LIN / CAN 하드웨어 지원 MCU    |
| 센서       | NTC 온도센서, MPU6050, BMP280, ACS712 등                     | 아날로그/디지털 입력           |
| 통신       | CAN Transceiver (MCP2551, TJA1050) / LIN Transceiver (TJA1020) | 물리 계층 연결                 |
| 전원       | 12V → 5V/3.3V DCDC                                           | 차량용 전원 시뮬레이션         |
| 인터페이스 | OLED / UART / USB                                            | 센서 데이터 시각화 및 디버깅용 |

------

### 소프트웨어 아키텍처

1. **센서 데이터 획득 Layer**
   - ADC, I²C, SPI, UART 등으로 물리 센서 데이터를 주기적으로 수집
   - 예: 온도 센서(TMP36) → ADC 변환, 가속도 센서(MPU6050) → I²C 통신
2. **데이터 처리 Layer**
   - 보정(Calibration), 필터링(Moving Average, Kalman Filter) 수행
   - 단위 변환 및 이상치 제거
3. **통신 Layer**
   - LIN 또는 CAN을 통해 ECU(또는 다른 STM32)로 데이터 전송
   - ID 또는 메시지 프레임에 따라 센서 데이터 구분
4. **진단 및 로깅 Layer**
   - UART 콘솔 또는 OLED로 상태 출력
   - CAN Analyzer나 PC 터미널에서 프레임 확인

------

### 예제 시나리오 – 다중 센서 데이터 송신

#### **목표:**

 온도, 조도, 가속도 데이터를 주기적으로 수집하고, CAN/LIN을 통해 ECU에 전송

#### **센서 구성**

| 센서          | 인터페이스 | 데이터 종류           | 송신 주기 |
| ------------- | ---------- | --------------------- | --------- |
| TMP36 (온도)  | ADC        | Temperature (°C)      | 100ms     |
| BH1750 (조도) | I²C        | Light Intensity (lux) | 200ms     |
| MPU6050 (IMU) | I²C        | Accel / Gyro          | 50ms      |

#### **CAN 메시지 매핑**

| 센서 | CAN ID | 데이터 길이 | 설명              |
| ---- | ------ | ----------- | ----------------- |
| 온도 | 0x100  | 2 Byte      | 섭씨 단위         |
| 조도 | 0x110  | 2 Byte      | lux 단위          |
| IMU  | 0x120  | 6 Byte      | X, Y, Z 축 가속도 |

#### **LIN Identifier 매핑**

| 센서 | LIN ID | 데이터 길이 | 주기  |
| ---- | ------ | ----------- | ----- |
| 온도 | 0x12   | 2 Byte      | 100ms |
| 조도 | 0x13   | 2 Byte      | 200ms |

------

### 실습 예제 – CAN 기반 센서 송신 코드

```
CAN_TxHeaderTypeDef txHeader;
uint8_t txData[8];
uint32_t txMailbox;

txHeader.StdId = 0x100;
txHeader.DLC = 2;
txHeader.IDE = CAN_ID_STD;
txHeader.RTR = CAN_RTR_DATA;

uint16_t temperature = (uint16_t)(readTemperature() * 100);
txData[0] = temperature >> 8;
txData[1] = temperature & 0xFF;

HAL_CAN_AddTxMessage(&hcan1, &txHeader, txData, &txMailbox);
```

- `readTemperature()` 함수에서 ADC 값을 읽고 °C 단위로 변환
- CAN Frame ID = `0x100` 으로 송신
- CAN Analyzer(예: PCAN View, CANalyzer)에서 프레임 모니터링 가능

------

### 실습 예제 – LIN 기반 센서 시뮬레이션

```
uint8_t linData[4];
linData[0] = (uint8_t)(temperature >> 8);
linData[1] = (uint8_t)(temperature & 0xFF);
linData[2] = (uint8_t)(light >> 8);
linData[3] = (uint8_t)(light & 0xFF);

HAL_LIN_SendBreak(&huart1);
HAL_UART_Transmit(&huart1, linHeader, 3, 100);  // Break + Sync + ID
HAL_UART_Transmit(&huart1, linData, 4, 100);    // Response
```

- LIN ID에 맞는 헤더를 송신한 뒤, 센서 데이터를 4바이트로 전송
- 마스터 장비(또는 PC LIN Analyzer)에서 응답 프레임 수신 확인

------

### 필터링 및 보정 알고리즘

- **Moving Average Filter**

  ```
  avgTemp = (avgTemp * 0.9) + (newTemp * 0.1);
  ```

- **Kalman Filter**

  - 잡음이 심한 IMU 신호를 안정적으로 처리 가능
  - STM32H7이나 F4 계열에서 부동소수점 연산을 활용

------

### 데이터 시각화

- **OLED 표시 (I²C)**

  ```
  ssd1306_SetCursor(0, 0);
  ssd1306_Printf("TEMP: %.2f C\n", temperature);
  ssd1306_Printf("LIGHT: %d lx\n", light);
  ```

- **UART 로그 출력**

  ```
  printf("[CAN 0x100] TEMP=%.2f, [CAN 0x110] LIGHT=%d\n", temperature, light);
  ```

------

### 확장 응용

1. **CAN → LIN 게이트웨이 구현**
   - CAN으로 받은 센서 데이터를 LIN Slave로 재전송
   - 차량 네트워크 간 데이터 변환 실습 가능
2. **실시간 진단(OBD-II) 시뮬레이션**
   - CAN ID 0x7E8 응답 프레임을 구성해 ECU 응답 테스트
3. **이상 감지 시스템**
   - 온도 과열 시 특정 ID(0x200)로 Fault 메시지 전송

------

### 요약

| 구분                | 내용                                                   |
| ------------------- | :----------------------------------------------------- |
| **주요 목적**       | 차량용 센서 동작 시뮬레이션 및 네트워크 테스트         |
| **사용 인터페이스** | ADC, I²C, SPI, UART (LIN), CAN                         |
| **핵심 기술**       | 필터링, 보정, 데이터 매핑, 프레임 전송                 |
| **결과**            | STM32 단일 보드로 다중 센서 및 통신 네트워크 재현 가능 |