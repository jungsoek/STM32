# 13. DMA (Direct Memory Access)

## 13.1 DMA 구조 및 동작 원리

### 1. 개요

DMA(Direct Memory Access)는 CPU의 개입 없이 **주변장치(Peripheral)** 와 **메모리 간 데이터를 직접 전송**할 수 있게 하는 하드웨어 모듈이다.
 STM32 시리즈는 대부분 **DMA Controller**를 내장하고 있으며, 이를 통해 대용량 또는 실시간 데이터 전송 시 CPU 부하를 대폭 줄일 수 있다.

DMA는 특히 **ADC → 메모리**, **메모리 → DAC**, **UART/SPI → 메모리** 등의 연속 데이터 전송 작업에서 매우 효율적이다.
 CPU가 데이터를 일일이 복사하지 않고, DMA 엔진이 버스 접근을 통해 **자동 전송을 처리**한다.

------

### 2. DMA의 주요 개념

#### 전통적 데이터 전송 구조

CPU가 `memcpy` 또는 반복문을 통해 직접 데이터를 이동한다.

- CPU는 매 전송마다 **읽기(Read)** → **쓰기(Write)** 명령 수행
- 다른 연산이 블로킹되어 실시간 처리 능력이 저하됨

#### DMA 기반 전송 구조

DMA는 **버스 마스터 권한**을 획득하여 CPU 대신 직접 메모리 접근을 수행한다.

- CPU는 전송 명령만 내리고 즉시 다른 연산 수행 가능
- DMA가 백그라운드에서 전송을 완료하면 인터럽트 발생

------

### 3. DMA Controller 구조

STM32F1~F7, H7 등은 시리즈별로 **DMA1 / DMA2 컨트롤러**를 탑재하고 있으며,
 각 컨트롤러는 여러 개의 **Stream(또는 Channel)** 로 구성된다.

| MCU Series | DMA Controller   | 채널(Stream) 수       |
| ---------- | ---------------- | --------------------- |
| STM32F1    | DMA1, DMA2       | 각 7채널              |
| STM32F4    | DMA1, DMA2       | 각 8스트림 × 2 Target |
| STM32G4    | DMAMUX 포함 구조 | 유연한 라우팅 가능    |

#### DMA 주요 구성 요소

- **Source Address (SRC)**: 데이터가 읽히는 위치 (예: ADC Data Register)
- **Destination Address (DST)**: 데이터가 기록될 위치 (예: RAM 버퍼)
- **Transfer Size**: 전송할 데이터 수량
- **Direction**:
  - Peripheral → Memory
  - Memory → Peripheral
  - Memory ↔ Memory
- **Trigger Source**:
  - Peripheral 이벤트 (예: ADC End of Conversion)
  - 소프트웨어 요청

------

### 4. DMA 동작 방식

#### (1) 단일 전송 (Single Transfer)

- DMA는 지정된 데이터 수량만큼 전송 후 자동 종료.
- 예: UART 송신 버퍼를 한 번만 보낼 때 사용.

#### (2) 순환(Circular) 모드

- 전송 완료 후 자동으로 첫 주소로 돌아감.
- 실시간 센서 샘플링, 오디오 버퍼 등 **연속 데이터 스트림 처리**에 사용.
- CPU가 개입하지 않아도 지속적 버퍼 업데이트 가능.

#### (3) Double Buffer Mode

- 두 개의 버퍼를 교대로 전송하며 CPU가 한쪽 버퍼를 처리하는 동안 다른 한쪽을 DMA가 채움.
- 고속 데이터 스트림 (예: 오디오, 영상, ADC 파형)에 사용.

------

### 5. DMA Channel 매핑

DMA 채널은 각 주변장치에 **고정적으로 매핑**되어 있다. (시리즈별 Reference Manual 참조)

| 예시 (STM32F103 기준) | DMA 채널  | 연결 주변장치 |
| --------------------- | --------- | ------------- |
| DMA1_Channel1         | ADC1      |               |
| DMA1_Channel2         | SPI1_TX   |               |
| DMA1_Channel3         | SPI1_RX   |               |
| DMA1_Channel4         | USART1_TX |               |
| DMA1_Channel5         | USART1_RX |               |

예를 들어 ADC1을 DMA로 연동하려면 `DMA1_Channel1`을 사용해야 한다.

------

### 6. DMA 레지스터 구성

| 레지스터   | 설명                                    |
| ---------- | --------------------------------------- |
| DMA_CCRx   | DMA 채널 제어 (방향, 모드, 인터럽트 등) |
| DMA_CNDTRx | 전송할 데이터 개수                      |
| DMA_CPARx  | 주변장치 주소 (Peripheral Address)      |
| DMA_CMARx  | 메모리 주소 (Memory Address)            |

#### 예시 (ADC1 DMA 연동)

```
DMA1_Channel1->CNDTR = 16;              // 전송 개수
DMA1_Channel1->CPAR  = (uint32_t)&ADC1->DR; // 주변장치 주소
DMA1_Channel1->CMAR  = (uint32_t)&adc_buffer; // 메모리 버퍼 주소
DMA1_Channel1->CCR  |= DMA_CCR_MINC | DMA_CCR_CIRC | DMA_CCR_EN;
```

------

### 7. DMA 전송 순서

1. **DMA 초기화**
   - 채널 선택, 전송 방향, 주소 설정
2. **주변장치 트리거 설정**
   - 예: `ADC_Start_DMA()` 또는 `HAL_UART_Transmit_DMA()`
3. **DMA 시작**
   - 전송 개시 후 CPU는 다른 연산 수행 가능
4. **전송 완료 인터럽트 발생**
   - DMA_TCIF (Transfer Complete Flag) → `HAL_DMA_IRQHandler()` 호출
5. **콜백 함수 실행**
   - `HAL_DMA_XferCpltCallback()` 또는 `HAL_ADC_ConvCpltCallback()` 등

------

### 8. DMA Interrupt & Flag 관리

| Flag | 의미                  |
| ---- | --------------------- |
| GIF  | Global Interrupt Flag |
| TCIF | Transfer Complete     |
| HTIF | Half Transfer         |
| TEIF | Transfer Error        |

DMA 인터럽트는 NVIC를 통해 관리되며,
 전송 완료 시 콜백에서 다음 작업을 수행한다.

```
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    adc_ready = 1;
}
```

------

### 9. HAL 함수 기반 DMA 초기화 예제

```
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;
uint16_t adc_buffer[64];

void MX_DMA_Init(void)
{
    __HAL_RCC_DMA1_CLK_ENABLE();

    hdma_adc1.Instance = DMA1_Channel1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;

    HAL_DMA_Init(&hdma_adc1);
    __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
}
```

------

### 10. DMA 사용의 장점

| 항목          | CPU 전송 방식 | DMA 전송 방식          |
| ------------- | ------------- | ---------------------- |
| CPU 부하      | 높음          | 매우 낮음              |
| 실시간 응답   | 낮음          | 높음                   |
| 데이터 연속성 | 불안정        | 안정적 (Circular 지원) |
| 전력 효율     | 낮음          | 우수                   |

DMA는 실시간 센서 데이터, 오디오 스트림, 영상 프레임, 통신 버퍼 관리 등에서
 CPU 자원을 절약하면서도 높은 데이터 처리율을 제공한다.

------

### 11. DMA 사용 시 주의사항

1. **메모리 접근 충돌**
   - DMA와 CPU가 동시에 같은 버퍼를 접근하면 Data Race 발생
   - Double Buffering 또는 Flag 기반 처리 필요
2. **Cache 영향 (Cortex-M7, H7 등)**
   - D-Cache 사용 시 DMA 버퍼는 반드시 `DTCM RAM` 또는 `non-cacheable region`에 배치해야 함.
3. **전송 크기 단위 주의**
   - Peripheral과 Memory의 Data Width(8/16/32bit) 불일치 시 정렬 오류 발생
4. **인터럽트 우선순위**
   - DMA IRQ가 너무 낮으면 다른 ISR에 밀려 데이터 손실 발생 가능

------

### 12. 결론

DMA는 STM32의 **핵심 성능 향상 메커니즘**으로,
 CPU와 병렬로 동작하여 실시간 성능을 유지하면서 데이터 이동을 자동화한다.
 ADC, UART, SPI, DAC, I²C 등 다양한 주변장치와 연동 가능하며,
 특히 FreeRTOS나 실시간 시스템에서 **CPU 부하를 최소화하는 필수 기능**으로 사용된다.

## 13.2 ADC-DMA, UART-DMA, SPI-DMA

DMA(Direct Memory Access)는 CPU 개입 없이 메모리와 주변장치 간 데이터를 전송하는 하드웨어 기능이다.
 STM32의 DMA는 ADC, UART, SPI 등 데이터 전송량이 많은 주변장치와 결합할 때 처리 효율을 크게 향상시킨다.
 본 절에서는 세 가지 주요 주변장치(ADC, UART, SPI)와 DMA의 연동 구조, 설정 절차, 코드 흐름을 상세히 기술한다.

------

### ADC-DMA 연동

#### 개요

ADC는 아날로그 입력을 디지털 데이터로 변환하는 장치이며, DMA를 이용하면 변환 결과를 자동으로 메모리에 저장할 수 있다.
 CPU는 변환 완료 시점을 기다리지 않고, DMA 전송 완료 인터럽트만 처리하면 된다.
 이는 연속 측정, 데이터 로깅, 파형 수집과 같은 애플리케이션에서 필수적인 구조이다.

#### CubeIDE 설정

1. **ADC 설정**
   - Mode: Scan Conversion Mode (다채널일 경우)
   - Continuous Conversion Mode: Enable
   - DMA Continuous Requests: Enable
   - Data Alignment: Right
   - Sampling Time: 채널별 적절히 지정
2. **DMA 설정**
   - Direction: Peripheral to Memory
   - Peripheral Increment: Disable
   - Memory Increment: Enable
   - Peripheral Data Width: Half Word
   - Memory Data Width: Half Word
   - Mode: Circular
   - Priority: High
3. **NVIC 설정**
   - DMA1_Channel1 Interrupt Enable (ADC 채널에 따라 다름)

#### 코드 예시

```
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;
uint16_t adcBuffer[128];

void MX_ADC1_Init(void)
{
    hadc1.Instance = ADC1;
    hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
    hadc1.Init.ContinuousConvMode = ENABLE;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = 3;
    HAL_ADC_Init(&hadc1);

    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adcBuffer, 128);
}
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    adc_ready = 1;
}
```

DMA 전송이 완료되면 `HAL_ADC_ConvCpltCallback()`이 호출되며,
 사용자는 플래그를 세워 메인 루프에서 후처리를 수행할 수 있다.

------

### UART-DMA 연동

#### 개요

UART DMA는 CPU 개입 없이 문자열이나 대용량 데이터를 송수신할 때 사용된다.
 송신(TX)과 수신(RX) 각각에 DMA 채널이 할당되며, 연속 수신 시 Circular 모드를 적용할 수 있다.

#### CubeIDE 설정

1. **UART 설정**
   - Mode: Asynchronous
   - Baud Rate: 115200
   - Word Length: 8 bits
   - Stop Bits: 1
   - Parity: None
2. **DMA 설정**
   - TX: Memory to Peripheral
   - RX: Peripheral to Memory
   - Memory Increment: Enable
   - Peripheral Increment: Disable
   - Mode: Normal (TX) / Circular (RX)
   - Priority: Medium
3. **NVIC 설정**
   - DMA1_Channel4 (TX), DMA1_Channel5 (RX) Interrupt Enable

#### 코드 예시

```
UART_HandleTypeDef huart1;
DMA_HandleTypeDef hdma_usart1_tx;
DMA_HandleTypeDef hdma_usart1_rx;

uint8_t rxBuffer[64];
uint8_t txBuffer[] = "DMA UART Transmission\r\n";

void MX_USART1_UART_Init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    HAL_UART_Init(&huart1);
}

void Start_UART_DMA(void)
{
    HAL_UART_Transmit_DMA(&huart1, txBuffer, sizeof(txBuffer) - 1);
    HAL_UART_Receive_DMA(&huart1, rxBuffer, sizeof(rxBuffer));
}
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    tx_done = 1;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    rx_done = 1;
}
```

DMA 기반 송수신은 CPU의 개입을 최소화하며, 실시간 데이터 스트림 수신에 적합하다.

------

### SPI-DMA 연동

#### 개요

SPI DMA는 고속 연속 데이터 전송에 사용된다.
 LCD, SD 카드, 센서(MPU9250, BME280 등)와 같이 데이터 양이 많은 장치에 필수적이다.

#### CubeIDE 설정

1. **SPI 설정**
   - Mode: Full Duplex Master
   - Data Size: 8-bit
   - CPOL/CPHA: 장치 규격에 맞춤
   - NSS: Software
   - BaudRate Prescaler: 속도에 따라 적절히 조정
2. **DMA 설정**
   - TX: Memory to Peripheral
   - RX: Peripheral to Memory
   - Mode: Normal
   - Priority: High
3. **NVIC 설정**
   - DMA1_Channel2, DMA1_Channel3 Interrupt Enable

#### 코드 예시

```
SPI_HandleTypeDef hspi1;
DMA_HandleTypeDef hdma_spi1_tx;
DMA_HandleTypeDef hdma_spi1_rx;

uint8_t txBuf[32] = {0xAA, 0xBB, 0xCC};
uint8_t rxBuf[32];

void MX_SPI1_Init(void)
{
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
    HAL_SPI_Init(&hspi1);
}

void Start_SPI_DMA(void)
{
    HAL_SPI_TransmitReceive_DMA(&hspi1, txBuf, rxBuf, 32);
}
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
    spi_transfer_done = 1;
}
```

DMA를 통한 SPI 전송은 CPU 부하를 크게 줄이며, 높은 클록에서도 안정적인 통신을 보장한다.

------

### DMA 연동 시 공통 주의사항

1. **버퍼 접근 충돌 방지**
    DMA가 데이터를 쓰는 동안 CPU가 동일 버퍼를 읽으면 데이터 불일치가 발생할 수 있다.
    이 경우 이중 버퍼(Double Buffering) 또는 데이터 유효 플래그 사용이 필요하다.
2. **데이터 정렬 일치**
    Peripheral과 Memory의 데이터 폭(8/16/32bit)이 일치해야 한다.
3. **인터럽트 우선순위**
    DMA Complete IRQ가 낮은 우선순위로 설정되면 타이밍 손실이 발생할 수 있다.
4. **Circular 모드 사용 조건**
    연속 데이터 수집(ADC, UART RX)에만 적용하며, SPI에는 사용하지 않는다.
5. **Cache 영향(H7 계열)**
    DMA 버퍼는 캐시 무효화가 필요하거나 DTCM 영역을 사용해야 한다.

------

### 비교 요약

| 주변장치 | DMA 방향            | 주요 모드 | 대표 응용         |
| -------- | ------------------- | --------- | ----------------- |
| ADC      | Peripheral → Memory | Circular  | 센서 데이터 수집  |
| UART TX  | Memory → Peripheral | Normal    | 로그 전송         |
| UART RX  | Peripheral → Memory | Circular  | 연속 수신         |
| SPI      | Memory ↔ Peripheral | Normal    | LCD, SD 카드 통신 |

## 13.3 Circular Buffer DMA 실습

DMA(Direct Memory Access)에서 **Circular Mode**는 연속적인 데이터 스트림을 처리할 때 매우 유용한 방식으로, 버퍼가 가득 차면 자동으로 처음으로 되돌아가 데이터를 덮어쓰며 무한 순환 구조로 동작한다. 이는 ADC, UART, SPI 등의 **실시간 연속 데이터 수집 및 전송**에 사용된다. STM32의 HAL 라이브러리에서는 `HAL_DMA_Start()` 또는 `HAL_DMA_Start_IT()` 함수와 함께 DMA 설정 시 Circular 모드를 지정함으로써 쉽게 구현할 수 있다.

------

### 13.3.1 Circular Mode 개념

Circular 모드는 DMA 전송이 완료된 후 **자동으로 다시 시작**되는 방식이다. 즉, DMA 전송이 한 번 끝나도 CPU 개입 없이 연속적으로 데이터를 수신/송신할 수 있다.

- **Normal Mode:** 지정된 길이만큼 전송 후 DMA 종료
- **Circular Mode:** 버퍼 끝에 도달하면 자동으로 처음으로 돌아가 재전송

이 방식은 센서 스트리밍, 오실로스코프 버퍼, UART 수신 버퍼, 오디오 데이터 스트림 등에 자주 사용된다.

DMA 설정 시 CubeMX 또는 HAL 코드에서 아래와 같이 설정할 수 있다.

```
hdma_adc1.Init.Mode = DMA_CIRCULAR;  // Circular mode enable
```

------

### 13.3.2 주요 장점

- **CPU 부하 감소:** 데이터가 자동으로 순환되어 중단 처리나 재시작 불필요
- **실시간성 향상:** 지속적인 데이터 스트림 수집에 적합
- **버퍼 관리 용이:** Double Buffering 없이 연속 처리 가능

------

### 13.3.3 ADC + DMA Circular Buffer 예제

#### (1) DMA 및 ADC 초기화

CubeIDE에서 ADC 설정 시 DMA 모드를 Circular로 지정한다. 코드 상에서는 다음과 같이 구현된다.

```
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;
uint16_t adc_buffer[100];  // 100-sample circular buffer

void MX_ADC1_Init(void)
{
    hadc1.Instance = ADC1;
    hadc1.Init.ContinuousConvMode = ENABLE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    HAL_ADC_Init(&hadc1);
}

void MX_DMA_Init(void)
{
    __HAL_RCC_DMA1_CLK_ENABLE();
    hdma_adc1.Instance = DMA1_Channel1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;  // 핵심 설정
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_adc1);
    __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
}
```

#### (2) ADC 변환 및 DMA 시작

```
HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buffer, 100);
```

ADC 변환이 연속적으로 발생하며 DMA가 `adc_buffer`에 순환 저장한다.

------

### 13.3.4 DMA Interrupt 처리

DMA 전송이 완료될 때마다 **Half Transfer** 또는 **Transfer Complete** 인터럽트가 발생한다. Circular Mode에서는 이 두 인터럽트를 활용해 버퍼 절반 단위로 데이터를 실시간 처리할 수 있다.

```
void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
{
    // 버퍼의 전반부 데이터 처리
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    // 버퍼의 후반부 데이터 처리
}
```

이 구조는 실시간 데이터 수집 및 신호 분석(예: FFT, RMS 계산)에 적합하다.

------

### 13.3.5 UART Circular DMA 수신 예제

UART DMA 수신에서도 Circular Mode를 사용할 수 있다.
 UART 수신 버퍼를 DMA로 연결하면 CPU가 개입하지 않고 지속적으로 데이터를 수신한다.

```
uint8_t uart_rx_buffer[256];

HAL_UART_Receive_DMA(&huart1, uart_rx_buffer, sizeof(uart_rx_buffer));
```

이때 DMA는 버퍼의 끝까지 채워지면 자동으로 처음으로 돌아가며, 콜백이나 타이머 기반으로 데이터를 분석할 수 있다.

------

### 13.3.6 Circular Buffer 응용

- **ADC + DMA + FFT 연속 신호 처리**
- **UART 수신 로그 버퍼**
- **오디오 스트리밍(PCM 데이터)**
- **센서 연속 샘플링(가속도, 자이로 등)**

------

### 13.3.7 주의사항

- Circular 모드에서는 **DMA 종료 인터럽트가 발생하지 않는다.** (무한 반복)
- 버퍼 경계 관리가 필요하며, 데이터 덮어쓰기 주기를 잘 조정해야 한다.
- 버퍼 크기가 작으면 데이터 손실이 발생할 수 있다.
- 실시간 분석을 위해 **Half/Full 콜백 처리 루틴**을 반드시 구현해야 한다.

------

### 13.3.8 결론

Circular DMA는 **고속, 저지연, 무한 루프 구조의 데이터 스트림 처리**에 매우 적합한 방식이다. STM32의 HAL 프레임워크를 사용하면 설정이 단순하며, ADC, UART, SPI 등 다양한 주변장치에 쉽게 적용할 수 있다.

> 실무에서는 이 방식을 기반으로 **RTOS 환경에서 Queue/Buffer 관리**와 결합하여 센서 데이터 파이프라인을 구성하는 경우가 많다.

## 13.4 Interrupt + DMA 병행

DMA(Direct Memory Access)는 대량의 데이터를 자동으로 전송하여 CPU 부하를 줄이는 강력한 기능을 제공하지만, 모든 상황에서 DMA만으로는 충분하지 않다.
 **DMA와 인터럽트를 병행(Interrupt + DMA)** 하면, 대용량 데이터 전송과 동시에 **이벤트 중심 처리(Event-driven Processing)** 를 결합하여 **성능과 반응성**을 동시에 확보할 수 있다.

이 절에서는 STM32 HAL 환경에서 **DMA와 Interrupt를 동시에 운용하는 방법**, **콜백 관리 패턴**, **주의사항**, **대표 실습 예제**를 체계적으로 설명한다.

------

### 13.4.1 DMA와 Interrupt의 역할 구분

DMA와 인터럽트는 데이터 처리에서 서로 보완적인 역할을 한다.

| 구분      | DMA                                         | 인터럽트 (IRQ)                              |
| --------- | ------------------------------------------- | ------------------------------------------- |
| 목적      | 대용량, 반복적인 데이터 전송 자동화         | 이벤트/상태 변화에 즉각 반응                |
| 트리거    | 주변장치 요청 (Peripheral Trigger)          | 특정 이벤트 발생 시 (Tx Complete, Error 등) |
| 처리 위치 | 메모리 ↔ 주변장치                           | 제어 흐름, 오류 처리, 제어 명령             |
| CPU 개입  | 최소화                                      | 필요 시 ISR에서 수행                        |
| 주요 예   | ADC 변환 데이터, UART 수신 버퍼, SPI 스트림 | 버튼 입력, DMA 완료, 통신 예외 처리         |

따라서 **데이터 스트림은 DMA**, **제어 흐름과 이벤트는 인터럽트**로 분담하면 효율적인 시스템을 설계할 수 있다.

------

### 13.4.2 DMA + Interrupt 구조

DMA는 내부적으로 **Half-Transfer (HT)**, **Transfer Complete (TC)**, **Error (TE)** 인터럽트를 발생시킨다.
 또한 DMA가 처리하지 않는 이벤트(예: 송신 요청, 타이밍 이벤트)는 별도의 IRQ에서 처리할 수 있다.

#### (1) DMA 인터럽트 종류

| 인터럽트                   | 설명                                       |
| -------------------------- | ------------------------------------------ |
| **Half Transfer (HT)**     | 버퍼 절반 채워짐 (데이터 실시간 처리 가능) |
| **Transfer Complete (TC)** | 버퍼 전송 완료 (다음 처리 준비)            |
| **Transfer Error (TE)**    | DMA 전송 오류 발생                         |
| **FIFO Error (FE)**        | FIFO 모드 사용 시 오류                     |

#### (2) 병행 동작의 기본 개념

- DMA는 데이터 스트림을 자동으로 전송
- NVIC 인터럽트는 DMA 상태 변화나 주변장치 이벤트를 감시
- 콜백 함수(`HAL_xxx_ConvCpltCallback`, `HAL_DMA_IRQHandler`)에서 후처리 수행

------

### 13.4.3 HAL 설정 예시 (UART + DMA + Interrupt)

아래 예제는 UART 송신을 DMA로 처리하면서, 수신 및 오류 처리를 인터럽트로 관리하는 구조이다.

```
uint8_t rx_byte;
uint8_t tx_buffer[100];

void MX_USART1_UART_Init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    HAL_UART_Init(&huart1);

    // UART 수신 인터럽트 활성화
    HAL_UART_Receive_IT(&huart1, &rx_byte, 1);
}
```

DMA 송신 초기화 및 시작:

```
HAL_UART_Transmit_DMA(&huart1, tx_buffer, sizeof(tx_buffer));
```

이후 DMA는 백그라운드에서 송신을 처리하고, 수신은 인터럽트로 즉시 응답한다.

------

### 13.4.4 ADC + DMA + Interrupt 병행 예제

ADC에서 DMA를 사용해 연속 변환을 수행하면서, 특정 외부 이벤트(EX: 버튼 입력, EXTI 인터럽트)로 데이터 처리를 트리거할 수 있다.

```
#define ADC_BUF_SIZE 256
uint16_t adc_buffer[ADC_BUF_SIZE];

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
    // DMA Circular 모드 완료 시 호출됨
    ProcessADCData(adc_buffer);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if(GPIO_Pin == BUTTON_Pin)
    {
        HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buffer, ADC_BUF_SIZE);
    }
}
```

이 구조는 **“데이터 수집은 DMA, 시작/정지는 인터럽트로 제어”** 하는 전형적인 형태다.

------

### 13.4.5 병행 처리 시 주의사항

1. **동기화 관리 필요**
    DMA와 Interrupt가 동일한 데이터 버퍼를 접근할 경우, 경합(Race Condition)이 발생할 수 있다.
   - 해결 방법: 상태 플래그, Mutex, Double Buffer 구조 사용
2. **DMA 인터럽트 중첩 주의**
    NVIC 우선순위 설정(`HAL_NVIC_SetPriority()`)에서 DMA와 주변장치 IRQ 간의 우선순위를 명확히 구분해야 한다.
3. **콜백 함수 중복 호출 방지**
    DMA 완료 콜백과 외부 인터럽트 콜백이 동시에 발생할 경우, 중복 처리 로직이 없도록 상태 플래그를 관리해야 한다.
4. **Circular Mode 시 DMA 종료 불가**
    Circular DMA는 무한 반복이므로 명시적으로 `HAL_DMA_Abort()`로 정지해야 한다.

------

### 13.4.6 대표 응용 구조

#### (1) UART 로그 수신 시스템

- **DMA**: 백그라운드에서 지속적으로 UART 수신
- **Interrupt (Timer or Idle Line)**: 주기적으로 수신된 데이터 처리

#### (2) 센서 스트림 + 이벤트 제어

- **DMA**: ADC/IMU 센서 연속 샘플링
- **Interrupt (EXTI)**: 특정 조건에서 캡처 중단 또는 데이터 저장

#### (3) 오디오 스트리밍

- **DMA**: PCM 데이터 스트림 처리
- **Interrupt**: 버퍼 절반 전송 시 음성 신호 처리

------

### 13.4.7 동작 시퀀스 예 (UART Idle Line Detection)

1. UART DMA 수신 시작

   ```
   HAL_UART_Receive_DMA(&huart1, uart_rx_buf, RX_BUFFER_SIZE);
   ```

2. IDLE 라인 인터럽트 활성화

   ```
   __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
   ```

3. 수신이 멈추면 IDLE 인터럽트 발생

   ```
   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   {
       if(__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
       {
           __HAL_UART_CLEAR_IDLEFLAG(huart);
           ProcessReceivedData(uart_rx_buf);
       }
   }
   ```

DMA는 데이터를 계속 수신하고, **IDLE 인터럽트**는 데이터 수신이 중단되었음을 알려준다.
 이를 통해 고속 비동기 UART 통신에서 CPU 부하를 최소화할 수 있다.

------

### 13.4.8 결론

DMA와 인터럽트를 병행하면 다음과 같은 효과를 얻을 수 있다.

- 실시간 이벤트 응답(Interrupt) + 대량 데이터 자동 처리(DMA)
- CPU 부하 최소화와 응답성 향상
- 복합 통신 구조(UART, SPI, ADC 등)에 최적화

실무에서는 이 구조를 기반으로 **DMA Circular Buffer + Interrupt-driven Control**을 결합하여
 **RTOS Task Queue, 센서 스트림 관리, 통신 파이프라인** 등에 응용한다.

> 핵심은 DMA는 데이터 흐름을 담당하고, 인터럽트는 “언제” 처리할지를 결정하는 제어 트리거 역할을 수행한다는 점이다.

## 13.5 Memory to Memory 전송

DMA(Direct Memory Access)는 단순히 주변장치 ↔ 메모리 간의 전송뿐만 아니라, **메모리 ↔ 메모리(Mem2Mem)** 전송 기능도 지원한다.
 이 기능은 CPU 개입 없이 대량의 데이터를 **SRAM 내에서 빠르게 복사**할 수 있어, 실시간 데이터 처리나 대용량 버퍼 초기화에 유용하다.

이 절에서는 STM32의 **DMA 메모리 간 전송 구조**, **HAL 설정 및 코드 예제**, **성능 비교**, **주의사항**을 심층적으로 설명한다.

------

### 13.5.1 DMA Memory-to-Memory 구조

DMA는 다음 세 가지 방향으로 데이터를 전송할 수 있다:

| 모드                          | 설명                   | 예시                     |
| ----------------------------- | ---------------------- | ------------------------ |
| **Peripheral → Memory (P2M)** | ADC, UART, SPI 수신 등 | 센서 데이터 수집         |
| **Memory → Peripheral (M2P)** | UART, SPI 송신 등      | 버퍼 전송                |
| **Memory → Memory (M2M)**     | 메모리 간 복사         | 버퍼 복사, 메모리 초기화 |

M2M 모드에서는 **두 개의 메모리 주소(Source, Destination)** 가 DMA 컨트롤러에 직접 지정된다.
 CPU는 단지 DMA 전송 요청을 설정하고, 완료 인터럽트를 기다릴 뿐이다.

------

### 13.5.2 DMA 메모리 전송 동작 원리

DMA는 **한 번의 설정으로 지정된 데이터 블록을 자동으로 복사**한다.

- DMA는 `SRC`(소스) 주소에서 데이터를 읽고, `DST`(목적지)에 기록
- 전송 단위는 Byte, Halfword(16bit), Word(32bit) 가능
- 전송 개수(`Length`)는 DMA 스트림의 `NDTR`(Number of Data Register)에 설정
- 전송 완료 시 `Transfer Complete (TC)` 인터럽트 발생

#### 내부 처리 시퀀스

1. DMA 채널 설정 (소스, 목적지, 크기, 전송 단위)
2. 전송 요청 → DMA 컨트롤러가 버스 접근
3. AHB 버스를 통해 읽기(Read) → 쓰기(Write)
4. 지정된 길이만큼 반복
5. 완료 시 TC 플래그 세트 → 인터럽트 발생

------

### 13.5.3 HAL 기반 설정

HAL 라이브러리에서는 **`HAL_DMA_Start()`** 또는 **`HAL_DMA_Start_IT()`** API로
 메모리 간 전송을 손쉽게 구현할 수 있다.

#### (1) 초기화 코드

```
DMA_HandleTypeDef hdma_memtomem;

void MX_DMA_Init(void)
{
    __HAL_RCC_DMA1_CLK_ENABLE();

    hdma_memtomem.Instance = DMA1_Channel1;
    hdma_memtomem.Init.Direction = DMA_MEMORY_TO_MEMORY;
    hdma_memtomem.Init.PeriphInc = DMA_PINC_ENABLE;   // Source address 증가
    hdma_memtomem.Init.MemInc = DMA_MINC_ENABLE;      // Destination address 증가
    hdma_memtomem.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_memtomem.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_memtomem.Init.Mode = DMA_NORMAL;
    hdma_memtomem.Init.Priority = DMA_PRIORITY_HIGH;

    HAL_DMA_Init(&hdma_memtomem);
}
```

#### (2) 전송 코드 (Polling 방식)

```
uint32_t src_buf[256];
uint32_t dst_buf[256];

HAL_DMA_Start(&hdma_memtomem, (uint32_t)src_buf, (uint32_t)dst_buf, 256);
HAL_DMA_PollForTransfer(&hdma_memtomem, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
```

#### (3) 인터럽트 방식

```
HAL_DMA_Start_IT(&hdma_memtomem, (uint32_t)src_buf, (uint32_t)dst_buf, 256);
```

콜백 함수에서 완료 이벤트 처리:

```
void HAL_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
{
    if(hdma->Instance == DMA1_Channel1)
        printf("Memory copy complete!\n");
}
```

------

### 13.5.4 예제: 버퍼 초기화 및 복사

#### (1) 메모리 복사 (Buffer Copy)

```
uint8_t buffer1[1024];
uint8_t buffer2[1024];

// buffer1 → buffer2 복사
HAL_DMA_Start_IT(&hdma_memtomem, (uint32_t)buffer1, (uint32_t)buffer2, 1024);
```

#### (2) 버퍼 초기화 (메모리 세팅)

```
uint32_t init_value = 0x00000000;
HAL_DMA_Start_IT(&hdma_memtomem, (uint32_t)&init_value, (uint32_t)buffer1, 256);
```

> DMA는 동일한 값(예: 0)으로 메모리를 빠르게 채우는 데도 활용 가능하다.

------

### 13.5.5 전송 속도 비교

| 방식             | 1KB 데이터 복사 시간 (예시, 72MHz F103 기준) |
| ---------------- | -------------------------------------------- |
| `memcpy()` (CPU) | 약 50 µs                                     |
| DMA (M2M)        | 약 8 µs                                      |
| 속도 향상        | 약 6~7배                                     |

> CPU는 DMA 전송 중 다른 작업을 수행할 수 있으므로, 실효 성능 향상은 이보다 훨씬 크다.

------

### 13.5.6 동작 시 주의사항

1. **M2M은 특정 DMA 채널만 지원**
    STM32F1 시리즈의 경우, 모든 채널이 M2M을 지원하지 않는다.
   - 예: F103에서는 `DMA1_Channel1`만 M2M 가능
2. **SRAM ↔ SRAM 전용**
    Flash, Peripheral 레지스터 영역과는 M2M 전송 불가. 반드시 RAM 주소 사용.
3. **Alignment(정렬)**
    소스와 목적지 주소는 전송 단위(Word/Halfword)에 정렬되어야 함.
4. **Cache 무효화** (Cortex-M7 이상)
    DMA가 접근한 메모리 구간은 Cache Sync 처리가 필요.

------

### 13.5.7 M2M + Interrupt 활용 예제

대용량 메모리 복사 후, 완료 시 인터럽트로 다음 연산을 트리거할 수 있다.

```
void Copy_Memory_DMA(uint32_t *src, uint32_t *dst, uint32_t len)
{
    HAL_DMA_Start_IT(&hdma_memtomem, (uint32_t)src, (uint32_t)dst, len);
}

void HAL_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
{
    if(hdma->Instance == DMA1_Channel1)
        ProcessCopiedData();
}
```

> 이 방식은 RTOS 환경에서 **비동기 버퍼 교체(Double Buffering)** 에 자주 활용된다.

------

### 13.5.8 실무 응용 사례

| 응용 분야   | 활용 내용                         |
| ----------- | --------------------------------- |
| 이미지 처리 | 프레임 버퍼 복사, LUT 변환 전처리 |
| 오디오 처리 | 버퍼 교체, PCM 데이터 이동        |
| 통신 스택   | Tx/Rx 링버퍼 스위칭               |
| 데이터 로깅 | 센서 버퍼 스냅샷 저장             |
| RTOS Task   | Task 간 안전한 메모리 전송        |

------

### 13.5.9 결론

Memory-to-Memory 전송은 DMA의 기본이자 핵심 기능 중 하나로,
 **CPU 개입 없이 대용량 메모리 블록을 고속으로 복사하거나 초기화**할 수 있다.

이 기능을 활용하면 다음과 같은 효과를 얻을 수 있다.

- `memcpy()` 대비 5~10배 이상 빠른 처리
- CPU 자원 절약 및 실시간 응답성 향상
- RTOS 및 대용량 데이터 처리에 최적

> 정리하자면, M2M DMA는 **“CPU 대신 메모리를 복사하는 전용 엔진”** 으로,
>  STM32 시스템 최적화의 필수적인 구성 요소이다.