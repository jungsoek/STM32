# 19. USB / FATFS / SD 카드

## 19.1 USB CDC / HID / MSC

### 개요

STM32 시리즈는 USB Full-Speed(12Mbps) 또는 High-Speed(480Mbps) 인터페이스를 지원하며, HAL 라이브러리를 통해 다양한 USB 클래스(CDC, HID, MSC 등)를 구현할 수 있다.
 각 클래스는 **통신 목적과 호스트 인식 방식이 다르며**, CubeMX를 통해 자동 코드 생성 및 HAL USB 스택 초기화를 수행할 수 있다.

------

### USB 구조 개념

- **Device / Host 모드**: STM32는 주로 USB Device 역할 수행 (예: PC에 연결되는 장치).
- **Endpoint (EP)**: 데이터 송수신 단위 (EP0은 항상 제어용).
- **Descriptor**: 장치의 기능 및 클래스 정보를 호스트에 제공.
- **Interface**: 동일한 장치 내에서 기능적으로 구분된 구성요소.

------

### USB CDC (Communication Device Class)

#### 개요

CDC는 **가상 직렬 포트(Virtual COM Port)** 형태로 동작하며, PC에서는 일반 UART 포트처럼 인식된다.
 디버깅 콘솔, 데이터 로깅, 센서 출력 등에 널리 사용된다.

#### 주요 특징

- PC ↔ MCU 간 양방향 데이터 전송
- 표준 시리얼 통신 드라이버 (Windows, Linux, macOS에서 자동 인식)
- `usbd_cdc_if.c` 내 `CDC_Transmit_FS()` API를 통해 송신 수행

#### HAL 기반 구현 절차

1. CubeMX에서 **USB_DEVICE** 활성화 → **Communication Device Class (CDC)** 선택
2. `MX_USB_DEVICE_Init()` 자동 생성 확인
3. `usbd_cdc_if.c`의 `CDC_Receive_FS()` 함수에서 수신 데이터 처리
4. 송신 시 `CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)` 호출

#### 실습 예시

```
uint8_t msg[] = "STM32 USB CDC Test\r\n";
CDC_Transmit_FS(msg, strlen((char*)msg));
```

PC의 시리얼 모니터에서 USB를 통한 메시지 확인 가능.

------

### USB HID (Human Interface Device)

#### 개요

HID는 키보드, 마우스, 조이스틱, 리모컨 등의 **입력 장치 인터페이스**를 구현하는 표준이다.
 별도 드라이버 설치 없이 운영체제에서 자동 인식된다.

#### 주요 특징

- Report Descriptor를 통해 데이터 구조 정의
- Low-Latency 통신 (주로 64바이트 이하)
- 입력/출력 방향의 Endpoint 구성

#### CubeIDE 구현 절차

1. CubeMX에서 **USB_DEVICE → Human Interface Device Class (HID)** 선택
2. `usbd_hid.c` 내 `USBD_HID_SendReport()` API 이용
3. Report 구조를 사용자 정의 후 주기적으로 전송

#### 실습 예시

마우스 에뮬레이션:

```
uint8_t HID_Buffer[4] = {0, 5, 0, 0};  // X축 5픽셀 이동
USBD_HID_SendReport(&hUsbDeviceFS, HID_Buffer, sizeof(HID_Buffer));
```

------

### USB MSC (Mass Storage Class)

#### 개요

MSC는 **USB 메모리 스틱처럼 인식되는 스토리지 장치 클래스**이다.
 STM32의 Flash 또는 외부 SD카드를 마운트하여 PC에서 읽기/쓰기 가능하게 한다.

#### 주요 특징

- 표준 SCSI 명령 기반
- 파일 시스템 연동 (주로 FATFS)
- 드라이버 자동 인식 (Windows / macOS / Linux)

#### CubeIDE 구현 절차

1. CubeMX에서 **USB_DEVICE → Mass Storage Class (MSC)** 선택
2. Storage 인터페이스 함수 (`STORAGE_Read_FS`, `STORAGE_Write_FS`) 구현
3. 내부 Flash 또는 SD카드(FATFS)와 연결
4. PC 연결 시 이동식 디스크로 인식됨

#### 예시 코드

```
int8_t STORAGE_Read_FS(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len) {
    BSP_SD_ReadBlocks((uint32_t*)buf, blk_addr, blk_len, 1000);
    return (USBD_OK);
}
```

------

### USB 디버깅 및 트러블슈팅

- **장치 인식 실패 시**:
  - `Device Descriptor` 구조 확인
  - CubeMX에서 Clock 설정 (48MHz PLLQ) 확인
- **CDC 통신 지연**:
  - `CDC_Transmit_FS()` 연속 호출 시 전송 버퍼 처리 주의
- **HID 동작 불량**:
  - Report Descriptor 크기와 데이터 구조 불일치 여부 점검

------

### CubeIDE 내 주요 파일 구성

- `usb_device.c / usb_device.h`: USB 초기화 및 클래스 등록
- `usbd_cdc_if.c`: CDC 전송/수신 인터페이스
- `usbd_hid.c`: HID 데이터 전송 함수
- `usbd_storage_if.c`: MSC 스토리지 함수

------

### 요약

| 클래스 | 역할                          | 연결 시 OS 인식   | 주요 인터페이스 파일 |
| ------ | ----------------------------- | ----------------- | -------------------- |
| CDC    | 가상 COM 포트                 | USB Serial (COMx) | `usbd_cdc_if.c`      |
| HID    | 입력 장치 (키보드, 마우스 등) | HID Device        | `usbd_hid.c`         |
| MSC    | 대용량 저장장치               | Removable Disk    | `usbd_storage_if.c`  |

## 19.2 SD/MMC SPI 모드

### 개요

SD(Secure Digital) 및 MMC(MultiMediaCard)는 임베디드 시스템에서 널리 사용되는 비휘발성 저장 매체이다.
 STM32에서는 **SDIO(4비트 병렬)** 또는 **SPI(직렬)** 인터페이스를 통해 SD/MMC를 제어할 수 있다.
 본 절에서는 **SPI 모드 기반 SD/MMC 접근 방법**을 다룬다.

SPI 모드는 **단순한 하드웨어 구성, 높은 호환성, 낮은 전송속도**를 특징으로 하며, 소형 시스템이나 외부 SD 슬롯을 사용하는 보드에 자주 활용된다.

------

### SPI 모드와 SDIO 모드 비교

| 구분            | SPI 모드               | SDIO 모드                   |
| --------------- | ---------------------- | --------------------------- |
| 인터페이스 라인 | SCK, MISO, MOSI, CS    | CMD, CLK, D0~D3             |
| 최대 전송 속도  | 약 25 MHz              | 최대 50 MHz (4비트)         |
| 구현 난이도     | 낮음 (일반 SPI로 제어) | 높음 (전용 주변장치 필요)   |
| CubeMX 설정     | SPI + GPIO             | SDMMC Peripheral            |
| 용도            | 저속 로깅, 데이터 백업 | 고속 데이터 처리, 카메라 등 |

------

### SPI 기반 SD 카드 연결 회로 예시

#### 기본 핀 구성

| SD 핀 | STM32 연결 핀 | 설명                     |
| ----- | ------------- | ------------------------ |
| CS    | SPI_NSS       | Chip Select (Slave 선택) |
| MOSI  | SPI_MOSI      | 데이터 송신              |
| MISO  | SPI_MISO      | 데이터 수신              |
| SCK   | SPI_SCK       | 클럭                     |
| VCC   | 3.3V          | 전원                     |
| GND   | GND           | 공통 접지                |

> 주의: SD카드는 **3.3V 동작**만 지원하므로 5V MCU 사용 시 레벨 시프터 필요.

------

### SD 카드 초기화 절차 (SPI 모드)

SPI 모드에서는 SD 카드를 전원 인가 후 아래 순서로 초기화한다.

1. **Power On**: 카드 전원 인가 후 최소 74 클럭 이상 제공 (Dummy Clock).
2. **CMD0 (GO_IDLE_STATE)**: SPI 모드 진입 명령 전송.
3. **CMD8 (SEND_IF_COND)**: SDHC/SDXC 여부 확인.
4. **ACMD41 (SD_SEND_OP_COND)**: 카드 초기화 진행 (반복).
5. **CMD58 (READ_OCR)**: 카드 전압 범위 확인.
6. **CMD16 (SET_BLOCKLEN)**: 블록 크기 지정 (512바이트).

------

### HAL 기반 SD SPI 드라이버 구성 절차

#### 1. CubeMX 설정

- **SPI Peripheral** 활성화
  - Mode: Full Duplex Master
  - Prescaler: 적절히 설정 (초기화 시 낮은 클럭, 이후 고속 전환 가능)
- **CS 핀(GPIO Output)** 지정
- **FATFS Middleware → User-defined SPI mode** 선택

#### 2. `sd_spi.c` 예제 구조

```
extern SPI_HandleTypeDef hspi1;

#define SD_CS_HIGH() HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET)
#define SD_CS_LOW()  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET)

uint8_t SD_SPI_Transmit(uint8_t data)
{
    uint8_t recv;
    HAL_SPI_TransmitReceive(&hspi1, &data, &recv, 1, HAL_MAX_DELAY);
    return recv;
}
```

#### 3. 명령 전송 함수

```
uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc)
{
    uint8_t buf[6];
    buf[0] = 0x40 | cmd;
    buf[1] = (arg >> 24);
    buf[2] = (arg >> 16);
    buf[3] = (arg >> 8);
    buf[4] = (arg);
    buf[5] = crc;

    SD_CS_LOW();
    for (int i = 0; i < 6; i++) SD_SPI_Transmit(buf[i]);

    uint8_t response;
    for (int i = 0; i < 8; i++) {
        response = SD_SPI_Transmit(0xFF);
        if (!(response & 0x80)) break;
    }
    SD_CS_HIGH();
    return response;
}
```

------

### 데이터 블록 읽기/쓰기 절차

#### 데이터 읽기 (CMD17)

1. CMD17 전송 (READ_SINGLE_BLOCK)
2. Start Token (0xFE) 수신 대기
3. 512바이트 데이터 블록 수신
4. CRC 2바이트 무시

```
if (SD_SendCmd(17, blockAddr, 0xFF) == 0x00) {
    while (SD_SPI_Transmit(0xFF) != 0xFE);
    for (int i = 0; i < 512; i++)
        buffer[i] = SD_SPI_Transmit(0xFF);
}
```

#### 데이터 쓰기 (CMD24)

1. CMD24 전송 (WRITE_SINGLE_BLOCK)
2. Start Token (0xFE) 전송
3. 512바이트 데이터 블록 송신
4. Dummy CRC + Response 수신

------

### FATFS 연동

FATFS와 SPI SD 드라이버를 연계하면, 일반 파일 시스템 API를 사용 가능하다.

#### 주요 함수

- `f_mount(&fs, "", 1)` — 파일시스템 마운트
- `f_open(&file, "data.txt", FA_WRITE | FA_CREATE_ALWAYS)`
- `f_write(&file, buffer, size, &written)`
- `f_close(&file)`

#### 예시

```
FATFS fs;
FIL file;
f_mount(&fs, "", 1);
f_open(&file, "log.txt", FA_WRITE | FA_CREATE_ALWAYS);
f_puts("STM32 SD SPI Test\n", &file);
f_close(&file);
```

------

### 성능 최적화 포인트

- **DMA 사용**: SPI 송수신을 DMA 기반으로 처리하면 CPU 부하 감소
- **클럭 동적 변경**: 초기화(100~400kHz) 후 18MHz 이상으로 상향 가능
- **파일 쓰기 버퍼링**: FATFS 버퍼(`FF_MAX_SS`) 조정으로 속도 향상

------

### 디버깅 팁

- 초기화 실패 시 **CMD0 응답 여부** 확인
- SPI 클럭이 너무 높으면 초기화 불가
- `f_mount()` 실패 시 `disk_initialize()` 구현체 점검

------

### 요약

| 항목        | 내용                                           |
| ----------- | ---------------------------------------------- |
| 인터페이스  | SPI 기반 직렬 통신                             |
| 데이터 단위 | 512바이트 블록                                 |
| 초기화 명령 | CMD0 → CMD8 → ACMD41 → CMD58                   |
| 장점        | 단순한 배선, 높은 호환성                       |
| 단점        | SDIO 대비 저속                                 |
| 활용        | 데이터 로깅, 설정 백업, 펌웨어 업데이트 저장소 |

## 19.3 FATFS 파일 시스템 구성

### 개요

FATFS(FAT File System Module)는 ChaN이 개발한 경량화 FAT 파일시스템 라이브러리로, 임베디드 시스템에서 **SD 카드, NAND Flash, NOR Flash, USB 메모리** 등 블록 디바이스에 파일 입출력을 가능하게 한다.
 STM32 CubeIDE 환경에서는 FATFS가 **Middlewares → FATFS** 형태로 통합되어 있으며, **SD(SDIO/SPI)**, **USB MSC**, **NAND/NOR** 등의 드라이버 계층과 함께 사용된다.

FATFS는 Microsoft의 FAT12/16/32 및 exFAT 표준을 기반으로 하며, POSIX와 유사한 API(`f_open`, `f_read`, `f_write`, `f_close`)를 제공한다.

------

### FATFS 계층 구조

FATFS는 다음과 같은 3계층으로 구성된다.

#### 1. 애플리케이션 계층

- 사용자는 `f_open()`, `f_read()`, `f_write()` 등 고수준 API를 통해 파일 입출력을 수행한다.
- FATFS 내부의 버퍼 및 파일 포인터 관리를 자동으로 처리한다.

#### 2. FATFS 파일시스템 계층

- FAT 테이블 관리, 디렉터리 구조, 클러스터 할당 등을 담당한다.
- 파일 이름 변환(Short/Long File Name) 및 시간 스탬프 관리 기능을 포함한다.

#### 3. 디스크 I/O 드라이버 계층

- 물리적 저장장치 접근을 담당하는 계층.
- `disk_read()`, `disk_write()`, `disk_ioctl()` 등의 함수를 통해 블록 단위로 데이터를 읽고 쓴다.
- 각 디바이스(SD, USB, Flash)에 맞는 드라이버를 직접 구현하거나 CubeMX가 자동 생성한다.

------

### CubeMX에서의 FATFS 구성 절차

1. **Middlewares → FATFS** 활성화
   - Interface: SD Card (SPI or SDIO) 선택
   - Enable Long File Name (LFN) 옵션 활성화
   - Code Page 설정 (예: 437, 949 등)
   - RTOS 사용 시 Thread-safe 옵션(`FF_FS_REENTRANT`) 활성화 가능
2. **Low-Level Driver 연결**
   - `diskio.c` 및 `sd_diskio.c` 파일 자동 생성
   - CubeMX에서 선택한 인터페이스(SPI/SDMMC)에 따라 `USER_diskio.c` 혹은 `bsp_driver_sd.c` 형태로 생성된다.
3. **User Code 작성 영역**
   - `MX_FATFS_Init()` 함수 이후 파일시스템 마운트 및 테스트 코드를 작성한다.

------

### FATFS 주요 헤더 및 구조체

#### `ff.h`

FATFS의 핵심 API와 구조체가 정의되어 있다.

```
typedef struct {
    BYTE fs_type;    /* FAT 타입 (FAT12/16/32/exFAT) */
    BYTE drv;        /* 물리 드라이브 번호 */
    BYTE n_fats;     /* FAT 복제본 개수 */
    DWORD csize;     /* 클러스터 크기(섹터 단위) */
    DWORD n_rootdir; /* 루트 디렉터리 엔트리 수 (FAT12/16 전용) */
    DWORD last_clust;/* 마지막 할당된 클러스터 */
    DWORD free_clust;/* 남은 클러스터 수 */
} FATFS;
```

#### `FIL` 구조체

```
typedef struct {
    FATFS* fs;      /* 파일이 속한 파일시스템 */
    WORD id;        /* 파일 식별자 */
    BYTE flag;      /* 접근 모드 플래그 */
    DWORD fptr;     /* 파일 포인터 */
    DWORD objsize;  /* 파일 크기 */
} FIL;
```

------

### FATFS 기본 API 사용 예제

#### 파일 시스템 마운트

```
FATFS fs;
f_mount(&fs, "", 1);  // 첫 번째 드라이브 자동 마운트
```

#### 파일 쓰기

```
FIL file;
UINT written;
f_open(&file, "test.txt", FA_WRITE | FA_CREATE_ALWAYS);
f_write(&file, "STM32 FATFS Test\r\n", 18, &written);
f_close(&file);
```

#### 파일 읽기

```
FIL file;
UINT read;
char buffer[64];

f_open(&file, "test.txt", FA_READ);
f_read(&file, buffer, sizeof(buffer), &read);
f_close(&file);
```

#### 디렉터리 탐색

```
DIR dir;
FILINFO fno;
f_opendir(&dir, "/");
while (f_readdir(&dir, &fno) == FR_OK && fno.fname[0])
    printf("%s\n", fno.fname);
f_closedir(&dir);
```

------

### FATFS 내부 동작 과정

#### 1. 파일 오픈(`f_open`)

- 디렉터리 엔트리 탐색 후 파일 존재 여부 판단
- 없으면 새 엔트리 생성(FA_CREATE_ALWAYS/NEW 옵션 시)
- 파일 핸들(`FIL`) 할당

#### 2. 파일 읽기(`f_read`)

- 현재 파일 포인터 위치 기반으로 클러스터 계산
- 클러스터 → 섹터 변환 → `disk_read()` 호출
- FAT 테이블을 통해 다음 클러스터 추적

#### 3. 파일 쓰기(`f_write`)

- 클러스터가 부족하면 FAT에 새 클러스터 할당
- 변경된 FAT 및 데이터 블록 기록
- 마지막으로 `f_sync()` 호출 시 메타데이터 동기화

------

### FATFS 설정 옵션 (`ffconf.h`)

| 매크로            | 설명                | 예시        |
| ----------------- | ------------------- | ----------- |
| `FF_FS_READONLY`  | 읽기 전용 모드 설정 | 0           |
| `FF_FS_MINIMIZE`  | API 최소화 수준     | 0~3         |
| `FF_USE_LFN`      | 긴 파일명 사용      | 1           |
| `FF_CODE_PAGE`    | 문자 인코딩 설정    | 437, 949 등 |
| `FF_FS_REENTRANT` | RTOS 재진입성 허용  | 1           |
| `FF_USE_FASTSEEK` | 빠른 파일 탐색 허용 | 1           |

------

### 시간 스탬프 지원

FATFS는 파일 생성 및 수정 시간을 기록하기 위해 **get_fattime()** 함수를 호출한다.
 RTC가 활성화된 경우, 이 함수를 사용자 코드에서 아래와 같이 구현한다.

```
DWORD get_fattime(void)
{
    RTC_TimeTypeDef time;
    RTC_DateTypeDef date;
    HAL_RTC_GetTime(&hrtc, &time, RTC_FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &date, RTC_FORMAT_BIN);

    return ((DWORD)(date.Year + 20) << 25)
         | ((DWORD)date.Month << 21)
         | ((DWORD)date.Date << 16)
         | ((DWORD)time.Hours << 11)
         | ((DWORD)time.Minutes << 5)
         | ((DWORD)time.Seconds >> 1);
}
```

------

### 디버깅 및 트러블슈팅

| 증상                     | 원인                         | 해결                             |
| ------------------------ | ---------------------------- | -------------------------------- |
| `FR_DISK_ERR`            | 물리 드라이버 초기화 실패    | SPI/SDIO 핀, CS 신호 확인        |
| `FR_NOT_READY`           | 카드 미삽입 또는 전원 불안정 | 카드 인식 루틴 추가              |
| `FR_NO_FILESYSTEM`       | 포맷되지 않은 카드           | PC에서 FAT32 포맷                |
| `f_write()` 시 속도 저하 | FAT 단편화, 버퍼 부족        | 버퍼 확장(`FF_MAX_SS`), DMA 사용 |
| 파일명이 깨짐            | Code Page 불일치             | `FF_CODE_PAGE` 949로 설정 (한글) |

------

### 요약

| 항목        | 내용                                       |
| ----------- | ------------------------------------------ |
| 파일 시스템 | FAT12/16/32, exFAT 지원                    |
| 구성 계층   | Application → FATFS Core → Disk I/O Driver |
| 주요 API    | f_open, f_read, f_write, f_close, f_mkdir  |
| 지원 장치   | SD/MMC, USB MSC, NOR/NAND Flash            |
| 장점        | 표준화된 파일 접근, CubeIDE 완전 통합      |
| 주의점      | 초기화 순서, 타이밍 문제, 버퍼 설정 필요   |

## 19.4 데이터 로깅 (CSV 저장)

### 개요

데이터 로깅(Data Logging)은 센서, ADC, 통신 데이터 등을 주기적으로 측정하여 SD 카드 등의 외부 저장장치에 기록하는 기능이다.
 STM32에서 FATFS를 이용해 CSV(Comma-Separated Values) 형식으로 데이터를 저장하면, PC에서 Excel이나 Python 등으로 손쉽게 분석할 수 있다.
 본 절에서는 **FATFS + RTC + 센서 데이터**를 결합하여 **CSV 포맷의 로그 파일을 주기적으로 생성하고 기록하는 방법**을 설명한다.

------

### CSV 파일 포맷

CSV는 각 데이터를 쉼표(,)로 구분하고, 한 줄마다 하나의 레코드를 기록하는 단순 텍스트 포맷이다.
 예시는 다음과 같다.

```
Timestamp,Temperature,Humidity,Pressure
2025-11-11 10:30:00,24.5,52.3,1013.2
2025-11-11 10:31:00,24.6,52.4,1013.1
```

이 포맷은 모든 운영체제와 분석 툴에서 호환성이 높고, 실험·계측 데이터의 표준 형태로 널리 사용된다.

------

### 시스템 구성 개요

#### 구성 요소

- **RTC**: 시간 스탬프 생성
- **FATFS (SD SPI 또는 SDIO)**: 파일 입출력
- **센서 (예: BME280, DHT22 등)**: 측정 데이터
- **Timer 또는 FreeRTOS Task**: 주기적 기록 트리거

#### 데이터 흐름

```
[Sensor Data] → [Format CSV Line] → [FATFS Append] → [SD Card]
```

------

### 초기 설정

#### 1. FATFS 및 RTC 초기화

```
FATFS fs;
FIL logFile;
RTC_TimeTypeDef sTime;
RTC_DateTypeDef sDate;

void System_Init(void)
{
    MX_FATFS_Init();
    f_mount(&fs, "", 1);

    MX_RTC_Init();
    HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
}
```

#### 2. 로그 파일 생성 (날짜 기반 파일명)

```
char filename[32];
sprintf(filename, "%02d%02d%02d.csv", sDate.Year + 2000, sDate.Month, sDate.Date);

if (f_open(&logFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
{
    f_open(&logFile, filename, FA_CREATE_ALWAYS | FA_WRITE);
    f_puts("Timestamp,Temperature,Humidity,Pressure\n", &logFile);
}
```

------

### CSV 데이터 기록 함수

#### 센서 데이터 획득 + CSV 포맷 변환

```
void Log_Write(float temp, float hum, float pres)
{
    RTC_TimeTypeDef t;
    RTC_DateTypeDef d;
    HAL_RTC_GetTime(&hrtc, &t, RTC_FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &d, RTC_FORMAT_BIN);

    char line[128];
    sprintf(line, "%04d-%02d-%02d %02d:%02d:%02d,%.2f,%.2f,%.2f\n",
            d.Year + 2000, d.Month, d.Date,
            t.Hours, t.Minutes, t.Seconds,
            temp, hum, pres);

    f_puts(line, &logFile);
    f_sync(&logFile);  // 즉시 기록 (전원 손실 방지)
}
```

------

### 주기적 로깅 (Timer 또는 RTOS Task)

#### HAL Timer 기반

```
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM3)
    {
        float temp = BME280_ReadTemperature();
        float hum  = BME280_ReadHumidity();
        float pres = BME280_ReadPressure();

        Log_Write(temp, hum, pres);
    }
}
```

#### FreeRTOS Task 기반

```
void vTaskLogger(void *argument)
{
    for (;;)
    {
        float t = DHT22_ReadTemperature();
        float h = DHT22_ReadHumidity();
        float p = BME280_ReadPressure();

        Log_Write(t, h, p);
        vTaskDelay(pdMS_TO_TICKS(60000)); // 1분마다 기록
    }
}
```

------

### 로그 파일 구조 예시

#### 생성 파일명

```
251111.csv
```

#### 내용

```
Timestamp,Temperature,Humidity,Pressure
2025-11-11 09:00:00,23.7,50.5,1013.4
2025-11-11 09:01:00,23.8,50.7,1013.2
2025-11-11 09:02:00,23.8,50.6,1013.3
```

#### Excel에서 시각화

- Excel에서 “텍스트/CSV 가져오기” 기능 사용
- 구분 기호 “,” 선택 → 표 형태 자동 변환
- 시간 축 그래프, 온습도 선 그래프 작성 가능

------

### 최적화 및 주의사항

#### FATFS 성능 최적화

- `FF_FS_TINY = 0` : 내부 버퍼 확장 가능
- `FF_USE_FASTSEEK = 1` : 파일 탐색 성능 개선
- `f_sync()` 호출은 필요 시 주기적으로 수행 (매번 호출 시 속도 저하)

#### 전원 안정성

- 로그 중 전원 손실 방지를 위해 **Super Cap 또는 Li-ion 백업** 권장
- 파일 작성 중 전원 차단 시 FAT 테이블 손상 가능 → `f_sync()` 주기적 호출 필요

#### 파일 크기 관리

- FAT32는 단일 파일 최대 4GB 제한
- 하루 단위로 파일 분리 저장 권장 (YYYYMMDD.csv 형식)

------

### CSV 파싱 예시 (Python 분석)

```
import pandas as pd
df = pd.read_csv('251111.csv')
print(df.head())
df.plot(x='Timestamp', y=['Temperature', 'Humidity'])
```

------

### 디버깅 포인트

| 증상                   | 원인                         | 해결                       |
| ---------------------- | ---------------------------- | -------------------------- |
| 파일이 생성되지 않음   | f_open 실패                  | SD 카드 마운트 여부 확인   |
| 데이터가 기록되지 않음 | 파일 포인터 또는 f_sync 누락 | f_sync() 주기적으로 호출   |
| 로그가 중복 기록       | 파일 포인터 위치 불명확      | `FA_OPEN_APPEND` 사용      |
| CSV 깨짐               | 개행 문자 차이               | `\r\n` 사용 (Windows 호환) |

------

### 요약

| 항목        | 내용                         |
| ----------- | ---------------------------- |
| 로그 포맷   | CSV (Comma-Separated Values) |
| 핵심 함수   | f_open, f_puts, f_sync       |
| 시간 기준   | RTC Timestamp                |
| 주기 제어   | Timer 또는 FreeRTOS Task     |
| 권장 구조   | 일별 로그 파일 생성          |
| 분석 호환성 | Excel, Python, MATLAB 등     |

## 19.5 SD→PC 데이터 추출

### SD 카드 파일 접근 개요

STM32에서 SD/MMC 카드에 데이터를 저장한 후, 이를 PC로 추출하기 위해서는 **파일 시스템의 호환성(FATFS)** 과 **인터페이스 모드(SPI 또는 SDIO)** 가 중요하다. FATFS로 생성된 파일은 일반적인 FAT32 포맷이므로, SD 카드를 직접 PC 리더기에 삽입하면 OS에서 바로 인식할 수 있다.

### 데이터 추출 방식

1. **SD 카드 직접 연결 (권장)**
   - STM32에서 기록된 SD 카드를 **카드 리더기**에 연결.
   - Windows/Linux/macOS에서 자동 인식되어 내부 파일 확인 가능.
   - FATFS에서 생성한 `.csv`, `.txt`, `.log` 등의 파일을 복사/분석 가능.
2. **USB Mass Storage (MSC) 모드 사용**
   - STM32를 **USB 디바이스로 인식**시키는 방법.
   - HAL의 **USB MSC Class**를 활성화하여 SD 카드 영역을 PC에서 외장 드라이브처럼 접근.
   - CubeMX 설정: *USB Device → Class → Mass Storage (MSC)*.
   - PC 연결 시 자동으로 SD 카드 파티션이 마운트됨.
3. **UART 또는 BLE 기반 데이터 전송**
   - UART 통신으로 CSV 데이터를 전송 후 PC의 시리얼 터미널 또는 Python 스크립트에서 수신 저장.
   - BLE 모듈(HM-10 등)을 통해 무선 데이터 전송 가능.
   - 장점: SD 카드를 분리하지 않아도 됨.
   - 단점: 전송 속도 제한 및 추가 프로토콜 설계 필요.

### 실습 예제: FATFS CSV → PC 전송

1. **데이터 저장 (STM32 측)**

   ```
   FIL file;
   f_open(&file, "data.csv", FA_READ);
   char buffer[64];
   UINT br;
   while (f_read(&file, buffer, sizeof(buffer)-1, &br) == FR_OK && br > 0) {
       HAL_UART_Transmit(&huart1, (uint8_t*)buffer, br, HAL_MAX_DELAY);
   }
   f_close(&file);
   ```

2. **PC 측 Python 수신 예시**

   ```
   import serial
   ser = serial.Serial('COM5', 115200)
   with open('data.csv', 'wb') as f:
       while True:
           data = ser.read(ser.in_waiting or 1)
           if not data:
               break
           f.write(data)
   ser.close()
   ```

### FATFS 호환성 및 주의사항

- FATFS는 **FAT12/16/32** 포맷을 지원하므로 반드시 카드가 FAT32로 포맷되어야 한다.
- 파일 접근 시 `f_sync()` 또는 `f_close()`를 반드시 호출해야 데이터 손실 방지 가능.
- SD/MMC 전원이 불안정할 경우 파일시스템 손상 방지를 위해 **Write Protection** 또는 **Safe Unmount** 절차 필요.

### 검증 및 문제 해결

- SD 카드를 PC에서 인식하지 못할 경우 → FATFS 설정 확인 (`_FS_EXFAT`, `_USE_LFN`)
- 파일 손상 또는 0바이트 파일 발생 시 → `f_sync()` 누락, 전원 차단 타이밍 확인
- USB MSC 모드가 작동하지 않을 경우 → USB Clock 설정 및 Endpoint 버퍼 크기 점검

### 확장 응용

- **자동 로그 추출 스크립트**: PC가 STM32 USB 연결 시 자동으로 로그 파일 복사
- **SD → Wi-Fi 전송 (ESP8266 연동)**: SD 데이터를 HTTP POST로 클라우드 업로드
- **SD 백업 시스템 구축**: FATFS 기반 파일 백업 및 시간 스탬프 관리

이 단원에서는 SD 카드의 물리적 분리 없이 USB MSC 또는 UART를 통해 데이터를 추출하는 실습을 포함하며, **파일 무결성, 전송 신뢰성, FATFS 구조 이해**를 중점적으로 다룬다.