# 14. Flash / EEPROM / Backup

## 14.1 Flash 영역 구조 (Page, Sector)

STM32의 **내부 Flash 메모리**는 프로그램 코드, 상수 데이터, 사용자 파라미터 등을 저장하는 **비휘발성 메모리(Non-volatile Memory)** 이다.
 전원이 꺼져도 데이터가 유지되며, CPU가 직접 명령을 실행(Execute in Place, XIP)할 수 있다.
 이 절에서는 **STM32 Flash 메모리의 구조(Page, Sector)**, **물리적 구성**, **Erase/Write 동작**, **주의사항**을 심층적으로 다룬다.

------

### 14.1.1 STM32 Flash 메모리의 특징

- **비휘발성**: 전원 제거 후에도 데이터 유지
- **랜덤 읽기 가능(Read-While-Execute)**
- **Erase 단위는 Page 또는 Sector**
- **쓰기(Program)는 Word 단위로 가능 (32bit)**
- **내부 전압 레귤레이터와 플래시 인터페이스(FMI)** 를 통해 안정적인 접근 보장
- **Flash latency**(Wait State)는 CPU 클록 주파수에 따라 조정

> STM32F1 시리즈의 경우 기본 Flash 접근 속도는 0 Wait State (≤ 24MHz),
>  최대 72MHz일 때 2 Wait States 설정 필요.

------

### 14.1.2 메모리 맵 개요

STM32의 Flash 메모리는 **코어 주소 공간(0x0800_0000)** 부터 시작한다.
 각 시리즈에 따라 크기 및 섹터(Page) 구조가 다르다.

| MCU 시리즈 | 시작 주소   | 크기      | 페이지/섹터 크기 | Erase 단위 |
| ---------- | ----------- | --------- | ---------------- | ---------- |
| STM32F0    | 0x0800_0000 | 32~128KB  | 1KB              | Page       |
| STM32F1    | 0x0800_0000 | 64~512KB  | 1KB/2KB          | Page       |
| STM32F4    | 0x0800_0000 | 512KB~2MB | 16~128KB         | Sector     |
| STM32G4    | 0x0800_0000 | 64~512KB  | 2KB              | Page       |
| STM32H7    | 0x0800_0000 | 최대 2MB  | 128KB~256KB      | Sector     |

> **Page(Page Erase)**: STM32F0/F1/F3 계열 등
>  **Sector(Sector Erase)**: STM32F4/F7/H7 등 고성능 계열

------

### 14.1.3 Flash 구조 – Page / Sector 개념

#### Page 구조 (STM32F1 기준)

- 플래시는 **Page 단위(1KB 또는 2KB)** 로 구성된다.
- **한 번에 지울 수 있는 최소 단위**가 Page이다.
- CPU는 Page를 부분적으로 수정할 수 없고, **전체 Page를 Erase 후 재작성**해야 한다.

#### Sector 구조 (STM32F4 이상)

- F4 계열은 **Sector 단위**로 구성되며, Sector마다 크기가 다를 수 있다.
- 예: STM32F407 (1MB Flash)
  - Sector 0–3: 16KB
  - Sector 4: 64KB
  - Sector 5–11: 128KB
- 큰 데이터를 관리할 때는 Sector 단위가 유리하지만, 소규모 설정 데이터에는 비효율적일 수 있다.

------

### 14.1.4 Flash Controller 구성

STM32의 Flash 메모리 접근은 내부의 **Flash Interface Controller (FPEC 또는 FMC)** 에 의해 관리된다.

주요 레지스터 (F1 기준):

- **FLASH_ACR**: 접근 제어 레지스터 (Latency, Prefetch)
- **FLASH_KEYR**: 언락(Unlock) 키 입력
- **FLASH_SR**: 상태 플래그 (BSY, EOP 등)
- **FLASH_CR**: 제어 비트 (PG, PER, STRT 등)
- **FLASH_AR**: 지울 Page 주소 설정

동작 절차는 다음과 같다:

1. 언락 키 입력 (Unlock)
2. Page Erase 또는 Program 모드 설정
3. 주소 및 데이터 지정
4. Start 명령
5. 완료 시 BSY 비트 클리어 확인

------

### 14.1.5 Flash Erase 동작

Erase는 Page/Sector 단위로 수행된다.

- Flash 셀은 전기적으로 1(‘1’)로만 초기화 가능
- 데이터를 0(‘0’)으로 쓰려면 Erase 후 Program 수행 필요

**Erase 절차 (HAL 예시):**

```
FLASH_EraseInitTypeDef EraseInitStruct;
uint32_t PageError;

HAL_FLASH_Unlock();

EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;
EraseInitStruct.PageAddress = 0x0800F800; // 마지막 페이지 예시
EraseInitStruct.NbPages = 1;

HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);
HAL_FLASH_Lock();
```

> Erase 완료 후 반드시 Lock을 다시 설정해야 Flash 보호 상태가 복구된다.

------

### 14.1.6 Flash Program(쓰기) 동작

Flash에 데이터를 쓰려면 다음 순서를 따른다.

```
HAL_FLASH_Unlock();
HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, 0x0800F800, 0x12345678);
HAL_FLASH_Lock();
```

- Word(32bit) 단위로만 쓰기 가능
- 이미 0이 된 비트를 다시 1로 바꾸려면 Erase 필요
- 연속 쓰기 시 **Write Protection** 및 **Alignment** 주의

------

### 14.1.7 Flash 보호 및 잠금

STM32는 다양한 보호 기능을 제공한다:

- **Write Protection**: 특정 섹터/페이지 쓰기 금지
- **Read Protection (RDP)**: 외부 디버깅 시 코드 읽기 방지
- **Option Bytes**: RDP, WRP, BOR 설정 등 저장

> RDP Level 1 이상에서는 SWD/JTAG을 통한 코드 접근이 차단된다.
>  실무 환경에서는 펌웨어 유출 방지용으로 RDP Level 1이 많이 사용된다.

------

### 14.1.8 Flash 수명 (Endurance)

- Flash 셀의 평균 수명은 **10,000~100,000 Erase/Write 사이클**
- 특정 페이지를 반복적으로 쓰는 경우, **Wear Leveling 기법** 필요
- EEPROM 에뮬레이션 시에도 이 한계를 반드시 고려해야 한다.

------

### 14.1.9 성능 및 접근 속도

| 조건         | Flash 접근 속도 | Wait State |
| ------------ | --------------- | ---------- |
| 0WS (≤24MHz) | 1 CPU cycle     | 0          |
| 1WS (≤48MHz) | 2 cycles        | 1          |
| 2WS (≤72MHz) | 3 cycles        | 2          |

> Flash Latency는 클록 설정 시 반드시 CubeMX의 Clock Configuration 탭에서 자동 설정되며,
>  직접 설정 시에는 `FLASH_ACR_LATENCY_x` 매크로를 적용해야 한다.

------

### 14.1.10 요약

| 항목        | 내용                             |
| ----------- | -------------------------------- |
| 저장 위치   | 0x0800_0000                      |
| 단위        | Page / Sector                    |
| 접근 모드   | XIP (Execute In Place)           |
| 쓰기 단위   | Word (32bit)                     |
| 지우기 단위 | Page / Sector                    |
| 보호 기능   | RDP, WRP, BOR 등                 |
| 수명        | 10k~100k Write Cycle             |
| 주요 활용   | 펌웨어 저장, 설정값, 데이터 로그 |

------

STM32의 Flash 메모리 구조(Page, Sector)는 MCU의 시리즈별 성능 및 메모리 용도에 직접적인 영향을 미친다.
 올바른 Page/Sector 관리, 보호 설정, 수명 고려는 **부트로더 설계, 펌웨어 업데이트, 데이터 로깅 시스템**에서 필수적인 기술 요소이다.

## 14.2 Flash Write/Erase 실습

STM32의 내장 Flash 메모리는 프로그램 코드뿐 아니라 설정값, 보정 데이터, 사용자 파라미터 등을 저장하기 위해 활용할 수 있다. 이 단원에서는 HAL 라이브러리를 이용하여 Flash 메모리의 쓰기(Write), 소거(Erase) 동작을 실습하며, 메모리 구조, 제약사항, 보호 설정 등에 대해 깊이 있게 다룬다.

------

### Flash 메모리 접근 절차 개요

1. **Unlock 단계**
   - Flash 제어 레지스터는 보호되어 있으므로, 쓰기/지우기 작업 전에 `HAL_FLASH_Unlock()` 함수를 통해 보호를 해제해야 한다.
   - 모든 작업이 끝난 후에는 반드시 `HAL_FLASH_Lock()`을 호출하여 재잠금한다.
2. **Erase (소거)**
   - Flash는 Byte 단위로 직접 덮어쓸 수 없고, 반드시 **Page(또는 Sector)** 단위로 Erase 후 Write 해야 한다.
   - 소거 시 모든 비트는 `1`로 설정된다 (`0xFF`).
   - HAL에서는 `FLASH_EraseInitTypeDef` 구조체를 이용해 소거 구간을 설정한 뒤 `HAL_FLASHEx_Erase()`를 호출한다.
   - 주요 파라미터:
     - `TypeErase` : `FLASH_TYPEERASE_PAGES` (또는 STM32 시리즈에 따라 `SECTORS`)
     - `PageAddress` 또는 `Sector` : 시작 주소 또는 섹터 번호
     - `NbPages` : 소거할 페이지 개수
3. **Program (쓰기)**
   - 한 번 Erase 된 영역에는 `HAL_FLASH_Program()`을 사용해 데이터를 기록한다.
   - 쓰기 단위는 MCU 시리즈에 따라 다르며, F1 시리즈는 **Half Word (16bit)** 단위, F4/H7 시리즈는 **Word(32bit)** 또는 **Double Word(64bit)** 단위를 지원한다.
   - 쓰기 전, 해당 주소가 `0xFFFF` 또는 `0xFFFFFFFF` 상태인지 반드시 확인해야 한다.
4. **데이터 검증**
   - Flash에 기록된 데이터는 `*(uint16_t*)address` 또는 `*(uint32_t*)address` 형태로 직접 읽어 확인할 수 있다.
   - 쓰기/소거 중 전원 차단 시 데이터 손상 가능성이 있으므로, CRC나 체크섬을 함께 저장하는 것이 바람직하다.

------

### 예제 코드: Flash Write / Erase

```
#include "stm32f1xx_hal.h"

#define FLASH_USER_START_ADDR   0x0801F800  // Flash 마지막 페이지 예시 (STM32F103C8 기준)
#define DATA_32                 0x12345678

void Flash_Write_Example(void)
{
    HAL_StatusTypeDef status;
    uint32_t address = FLASH_USER_START_ADDR;

    // 1. Flash Unlock
    HAL_FLASH_Unlock();

    // 2. Flash Erase
    FLASH_EraseInitTypeDef eraseInit;
    uint32_t PageError = 0;

    eraseInit.TypeErase   = FLASH_TYPEERASE_PAGES;
    eraseInit.PageAddress = FLASH_USER_START_ADDR;
    eraseInit.NbPages     = 1;

    status = HAL_FLASHEx_Erase(&eraseInit, &PageError);
    if (status != HAL_OK)
    {
        // Error handling
        HAL_FLASH_Lock();
        return;
    }

    // 3. Flash Program
    status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address, DATA_32);
    if (status != HAL_OK)
    {
        // Error handling
    }

    // 4. Flash Lock
    HAL_FLASH_Lock();

    // 5. Verify
    uint32_t read_data = *(uint32_t*)address;
    if (read_data == DATA_32)
    {
        // 성공
    }
}
```

------

### Flash Write/Erase 시 주의사항

- **Erase는 Page 단위로만 가능**하며, Page 크기는 MCU마다 다르다 (예: STM32F103C8은 1KB, STM32F407은 16KB~128KB 다양).
- Flash는 쓰기 횟수에 제한이 있다 (일반적으로 약 10,000~100,000회). 빈번한 업데이트는 EEPROM이나 외부 Flash, FRAM으로 대체하는 것이 바람직하다.
- 쓰기 중 인터럽트나 전원 차단이 발생하면 데이터 손상 가능성이 있으므로, 반드시 중요 데이터는 이중 저장하거나 유효성 검증 절차를 둔다.
- 실행 중 Flash에 쓰기 작업을 수행하면 CPU Access Stall이 발생할 수 있으므로, **Interrupt Masking** 또는 **Code Execution from RAM** 방식을 고려한다.

------

### Flash 메모리 보호 옵션

- **Read Protection (RDP)** : 코드 읽기 방지.
- **Write Protection (WRP)** : 특정 영역의 쓰기 방지.
- **Option Bytes**를 통해 설정하며, CubeProgrammer 또는 `HAL_FLASHEx_OBProgram()`으로 변경 가능.

------

### 고급 실습 확장

- 사용자 파라미터 (보정값, 설정값) 저장용 Flash 영역을 할당하고, 부팅 시 자동 로드/저장 기능 구현.
- 구조체 단위 데이터 저장 시 CRC 검증 포함.
- “EEPROM Emulation” 구현: Flash Page를 순차적으로 사용하여 수명 연장.
- FreeRTOS 환경에서 Flash Write 요청 큐를 사용한 비동기 저장 시스템 구축.

## 14.3 보정값 저장 (Calibration Data)

아날로그 신호를 다루는 시스템에서 보정값(calibration data)은 측정 오차를 줄이고 일관된 결과를 얻기 위해 필수적이다. 특히 ADC, 센서, 로드셀, 온도 센서 등은 하드웨어적 편차가 존재하므로, 소프트웨어적으로 보정 상수를 적용해야 한다. STM32는 Flash 또는 EEPROM 에뮬레이션 영역을 이용해 이러한 보정값을 비휘발성(non-volatile) 메모리에 저장할 수 있다.

------

### 보정값의 필요성과 개념

보정(calibration)은 실제 물리량과 측정값 간의 관계를 보정 상수로 모델링하는 과정이다.
 예를 들어 로드셀에서 1 kg의 하중이 ADC로 800값으로 측정된다면, 변환 계수(scale factor)를 구해 실제 질량으로 변환할 수 있다.
 보정값은 다음과 같은 형태로 구성될 수 있다.

- Offset (영점 보정값)
- Scale Factor (비율 계수)
- Linearization Coefficient (보정 곡선 계수)
- Temperature Compensation Value (온도 보정값)

보정값은 일반적으로 float, int32_t, uint16_t 등의 데이터 타입으로 정의되며, 구조체 형태로 묶어서 관리하는 것이 효율적이다.

------

### 보정 데이터 구조 설계

보정값을 관리할 때는 구조체 형태로 정의하여 메모리에 일관되게 저장하고 읽을 수 있도록 한다.

```
typedef struct {
    float offset;
    float scale;
    float temperature_coeff;
    uint32_t checksum;
} CalibrationData_t;
```

- **offset**: 센서의 영점 보정용 값
- **scale**: 측정값을 실제 단위로 변환하는 계수
- **temperature_coeff**: 온도 변화에 따른 보정값
- **checksum**: 데이터 무결성 검증용 CRC 또는 단순 합계

이 구조체는 플래시 메모리에 직접 저장하거나 EEPROM 에뮬레이션 방식을 사용할 수 있다.

------

### Flash에 보정값 저장 구조

STM32의 내부 Flash는 보통 코드와 데이터를 함께 저장하며, 섹터 단위로만 Erase가 가능하다.
 데이터 저장 시 다음 사항을 반드시 고려해야 한다.

- Flash는 byte 단위 쓰기가 불가능하며, word(4 byte) 또는 half-word 단위로 기록된다.
- 동일한 영역에 여러 번 write할 수 없고, erase 후 다시 기록해야 한다.
- Flash erase는 수명이 제한되어 있으므로, 너무 자주 수행하지 않는다.

------

### Flash 메모리 주소 관리

보정 데이터를 저장할 Flash 주소를 코드 상에서 명시해야 한다.
 일반적으로 마지막 섹터(Page)를 데이터 저장용으로 남겨둔다.

```
#define CALIBRATION_FLASH_ADDR  0x0800FC00  // STM32F103C8 기준 (64KB Flash의 마지막 1KB)
```

Flash의 용량과 Page 크기는 MCU 데이터시트를 참조해야 하며, CubeIDE의 Memory Map에서도 확인할 수 있다.

------

### Flash 쓰기 절차

Flash에 데이터를 저장하는 절차는 다음과 같다.

1. Flash Unlock 수행 (`HAL_FLASH_Unlock()`)
2. Flash 영역 Erase (해당 Page만)
3. 구조체 데이터를 Word 단위로 Write
4. Flash Lock 수행 (`HAL_FLASH_Lock()`)

예시 코드:

```
void SaveCalibrationData(CalibrationData_t *data)
{
    HAL_FLASH_Unlock();

    FLASH_EraseInitTypeDef eraseInit;
    uint32_t pageError = 0;

    eraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
    eraseInit.PageAddress = CALIBRATION_FLASH_ADDR;
    eraseInit.NbPages = 1;

    HAL_FLASHEx_Erase(&eraseInit, &pageError);

    uint32_t *ptr = (uint32_t*)data;
    for (uint32_t i = 0; i < sizeof(CalibrationData_t)/4; i++) {
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
                          CALIBRATION_FLASH_ADDR + (i * 4),
                          ptr[i]);
    }

    HAL_FLASH_Lock();
}
```

------

### Flash에서 데이터 읽기

Flash는 메모리 맵 방식으로 접근 가능하므로, 단순히 포인터로 구조체를 읽으면 된다.

```
CalibrationData_t *GetCalibrationData(void)
{
    return (CalibrationData_t*)CALIBRATION_FLASH_ADDR;
}
```

혹은 데이터를 복사해서 사용할 수도 있다.

```
CalibrationData_t calib;
memcpy(&calib, (void*)CALIBRATION_FLASH_ADDR, sizeof(CalibrationData_t));
```

------

### 데이터 무결성 검증 (Checksum / CRC)

Flash에 저장된 데이터는 손상될 수 있으므로, 무결성 검증 절차가 필요하다.

1. 저장 시 checksum 계산 후 함께 기록
2. 부팅 시 checksum 검증
3. 불일치 시 기본 보정값(Default Value) 로드

간단한 예:

```
uint32_t CalculateChecksum(CalibrationData_t *data)
{
    uint32_t *ptr = (uint32_t*)data;
    uint32_t sum = 0;
    for (uint32_t i = 0; i < (sizeof(CalibrationData_t)/4) - 1; i++)
        sum += ptr[i];
    return sum;
}
```

------

### EEPROM 에뮬레이션 방식

Flash를 직접 다루는 대신, **EEPROM Emulation Library**를 사용하는 방법도 있다.
 STM32 일부 시리즈(F0, F1, F3)는 하드웨어 EEPROM이 없으므로, Flash의 일부를 EEPROM처럼 사용한다.

이 방식은 ST에서 제공하는 예제 코드(`EEPROM_Emulation`)를 CubeMX로 추가할 수 있다.

- `EE_WriteVariable(uint16_t VirtAddress, uint16_t Data)`
- `EE_ReadVariable(uint16_t VirtAddress, uint16_t *Data)`

이 함수들은 내부적으로 Page 단위 관리를 자동으로 수행하여 Flash 마모를 줄이고 데이터 일관성을 유지한다.

------

### 보정 데이터의 유지 및 업데이트 절차

보정값은 일반적으로 다음 절차로 관리한다.

1. 시스템 부팅 시 Flash에서 보정값 읽기
2. Checksum 검증 후 유효하면 사용, 아니면 기본값 로드
3. 사용자 조정 후 “Save” 명령 시 Flash에 저장
4. 저장 후 다시 읽어 확인

------

### 기본값 관리 및 초기화 루틴

보정값이 존재하지 않거나 무효한 경우를 대비해, 기본값(Default Value)을 정의해야 한다.

```
const CalibrationData_t defaultCalib = {
    .offset = 0.0f,
    .scale  = 1.0f,
    .temperature_coeff = 0.0f,
    .checksum = 0
};
```

초기화 루틴:

```
void LoadCalibrationData(CalibrationData_t *data)
{
    memcpy(data, (void*)CALIBRATION_FLASH_ADDR, sizeof(CalibrationData_t));

    if (CalculateChecksum(data) != data->checksum) {
        *data = defaultCalib;
    }
}
```

------

### 실전 적용 예시

로드셀(HX711) 기반 무게 측정 장치에서 보정값을 저장하는 경우:

1. 0 kg 상태에서 offset 측정
2. 기준 추(예: 1 kg)로 scale 계산
3. 계산된 offset과 scale을 Flash에 저장
4. 전원 재부팅 후에도 동일한 보정값을 적용

이를 통해 하드웨어 개체 간의 오차를 최소화하고, 제품 간 일관된 측정값을 보장할 수 있다.

------

### 주의사항 및 팁

- Flash 수명은 일반적으로 약 10,000~100,000회 erase/write에 한정됨
- EEPROM 에뮬레이션 사용 시 wear-leveling 기술 적용 필요
- 보정값은 부팅 시 RAM으로 복사하여 사용하는 것이 안전함
- 보정 데이터 저장 중 전원 차단 방지를 위한 보호 절차 필요
- CRC 연산 시 DMA나 Hardware CRC Unit을 사용할 수 있음 (`__HAL_CRC_DR_RESET`, `HAL_CRC_Calculate()`)

------

### 결론

보정값 저장은 단순한 데이터 보존이 아니라, 시스템 신뢰성과 재현성을 결정짓는 핵심 요소이다.
 STM32에서는 Flash 또는 EEPROM 에뮬레이션을 통해 비휘발성 저장을 구현하며, 구조적 데이터 설계와 무결성 검증 절차를 반드시 포함해야 한다.
 보정값 저장 모듈은 실험 장비, 산업용 센서, IoT 측정 장치 등 거의 모든 응용 시스템의 필수 구성 요소이다.

## 14.4 EEPROM 에뮬레이션

STM32 대부분의 시리즈(F0, F1, F3 등)는 하드웨어 EEPROM을 내장하지 않는다.
 그러나 비휘발성 데이터(예: 보정값, 설정값, 사용자 파라미터 등)를 유지하기 위해, 내부 Flash 일부를 EEPROM처럼 사용하는 **EEPROM Emulation** 기법을 적용할 수 있다.
 이는 STMicroelectronics에서 공식적으로 제공하는 방식으로, Flash 페이지(Page)를 EEPROM 영역으로 할당하여 읽기/쓰기 기능을 구현한다.

------

### EEPROM 에뮬레이션 개요

EEPROM 에뮬레이션은 Flash 메모리의 일부 섹터(Page)를 가상 EEPROM처럼 사용하는 기법이다.
 다음과 같은 방식으로 구성된다.

- **가상 주소(Virtual Address)**: EEPROM의 주소처럼 동작하는 변수 ID
- **Flash Page 구조**: 2개 이상의 Page를 순환 사용 (Page0, Page1)
- **데이터 저장 방식**: Key-Value 형태로 가상 주소와 데이터를 함께 저장
- **Wear Leveling**: Flash 수명을 연장하기 위해 동일한 Page에 반복 기록을 분산

즉, 실제 EEPROM처럼 “바이트 단위 쓰기”는 불가능하지만, 소프트웨어적으로 동일한 기능을 제공한다.

------

### 구조 개념

EEPROM 에뮬레이션은 Flash 메모리의 2개 페이지(Page)를 사용한다.
 한 페이지는 **활성(active)** 상태로 데이터를 저장하고, 다른 한 페이지는 **비활성(receive)** 상태로 다음 데이터 갱신 시 사용된다.

데이터 갱신 시 Flash는 전체 페이지를 지우지 않고, 기존 데이터 위에 새 값을 덮지 않고 새 항목으로 추가한다.
 페이지가 가득 차면 새 페이지로 복사(transfer) 과정을 수행한다.

------

### 주요 구성 요소

EEPROM 에뮬레이션 모듈은 보통 다음 파일로 구성된다.

- `eeprom_emul.h` / `eeprom_emul.c` : 라이브러리 소스 코드
- `main.c` 또는 `app_eeprom.c` : 사용자 호출 함수 정의
- `flash_if.c` : Flash 접근 인터페이스

CubeIDE에서 **“EEPROM Emulation Example”** 프로젝트를 기반으로 추가할 수 있다.
 (경로 예시: `STM32Cube_FW_F1_Vx.x.x/Projects/STM32F103RB-Nucleo/Examples/EEPROM_Emulation`)

------

### 동작 원리

EEPROM 에뮬레이션은 다음 순서로 동작한다.

1. MCU 부팅 시 Flash 페이지 상태 확인
2. 유효한 Page를 활성화 상태로 지정
3. 데이터 쓰기 요청 시 Virtual Address와 Data를 쌍으로 Flash에 기록
4. 동일 주소에 새로운 값이 쓰이면, 이전 데이터는 무시되고 새 항목이 유효
5. Page가 가득 차면, 유효 데이터만 다음 Page로 복사하고 현재 Page는 Erase

이 과정을 통해 Flash의 수명 한계를 보완하며, 가상 EEPROM처럼 동작한다.

------

### Virtual Address 시스템

모든 변수는 고유한 “가상 주소(Virtual Address)”를 가진다.
 예를 들어, 다음과 같이 변수 ID를 정의한다.

```
#define ADDR_CALIB_OFFSET      0x0001
#define ADDR_CALIB_SCALE       0x0002
#define ADDR_DEVICE_ID         0x0003
#define ADDR_CONFIG_FLAG       0x0004
```

각 변수는 16비트 주소를 가지고, 값은 16비트 데이터로 저장된다.

------

### 주요 함수 인터페이스

ST의 EEPROM Emulation Library는 다음 API를 제공한다.

```
EE_Status EE_Init(void);
EE_Status EE_ReadVariable(uint16_t VirtAddress, uint16_t *Data);
EE_Status EE_WriteVariable(uint16_t VirtAddress, uint16_t Data);
```

#### EE_Init()

- Flash 영역의 Page 상태를 확인하고 유효한 페이지를 활성화
- 초기화 실패 시 Page 복구 또는 포맷 수행

#### EE_ReadVariable()

- 지정된 가상 주소의 최근 유효 데이터를 검색
- 존재하지 않으면 `EE_NO_DATA` 리턴

#### EE_WriteVariable()

- 가상 주소와 데이터를 Flash에 추가로 기록
- 페이지 공간이 부족하면 자동으로 Page Transfer 수행

------

### 초기화 및 설정 절차

EEPROM 에뮬레이션을 적용하기 위해서는 Flash 페이지를 직접 지정해야 한다.
 MCU의 Flash 크기와 Page 크기를 고려하여 마지막 2개 Page를 EEPROM 용도로 할당한다.

예시 (STM32F103C8, 64KB Flash, 1KB/Page):

```
#define PAGE_SIZE       (uint16_t)0x400  // 1 Kbyte
#define PAGE0_BASE_ADDR ((uint32_t)(0x0800F800)) // Page 62
#define PAGE1_BASE_ADDR ((uint32_t)(0x0800FC00)) // Page 63
```

이 영역은 코드 영역과 겹치지 않아야 하며, Linker Script (`STM32F103C8_FLASH.ld`)에서 영역을 명시적으로 분리할 수도 있다.

------

### 데이터 쓰기 예시

```
uint16_t offset = 1234;
uint16_t scale = 4321;

EE_WriteVariable(ADDR_CALIB_OFFSET, offset);
EE_WriteVariable(ADDR_CALIB_SCALE, scale);
```

이 코드는 Flash의 EEPROM 영역에 두 개의 데이터를 기록한다.
 각 기록은 새로운 엔트리로 추가되며, 이전 데이터는 무효 처리된다.

------

### 데이터 읽기 예시

```
uint16_t offset, scale;

if (EE_ReadVariable(ADDR_CALIB_OFFSET, &offset) != EE_OK)
    offset = 0;

if (EE_ReadVariable(ADDR_CALIB_SCALE, &scale) != EE_OK)
    scale = 1000;
```

Flash에 데이터가 존재하지 않으면 기본값으로 초기화한다.
 EEPROM 에뮬레이션은 전원 재부팅 후에도 데이터가 유지된다.

------

### Page Transfer 메커니즘

Page Transfer는 기존 Page가 가득 차면 자동 수행된다.

1. 다음 Page를 활성화 (Receive 상태로 변경)
2. 기존 Page에서 유효 데이터만 복사
3. 새 Page에 데이터 기록 완료 후, 이전 Page Erase

이 과정은 자동으로 이루어지며, 유저 코드에서는 `EE_WriteVariable()`만 호출하면 된다.

------

### 오류 처리 및 상태 코드

`EE_Status` 열거형은 다음과 같은 상태 코드를 반환한다.

```
typedef enum {
    EE_OK = 0,
    EE_NO_VALID_PAGE,
    EE_ERROR_NO_DATA,
    EE_ERROR_WRITE,
    EE_ERROR_PAGE_FULL
} EE_Status;
```

각 상태는 Flash 접근 오류, Page 손상, 데이터 없음 등의 조건을 나타낸다.

------

### 데이터 무결성 보호

EEPROM 에뮬레이션은 전원 차단 시 손상 위험이 있으므로, 다음을 고려해야 한다.

- Flash 쓰기 중에는 인터럽트 중단 금지
- 백업 전원(RTC 배터리)로 쓰기 완료 보장
- 주기적 Checksum 검증 또는 CRC 추가
- 데이터 저장 후 `EE_ReadVariable()`을 통해 즉시 검증

------

### Wear Leveling 기법

Flash는 반복 Erase/Write에 한계가 있으므로, 데이터가 자주 변경되는 항목은 Wear Leveling 기법을 통해 수명을 연장한다.

기본적으로 ST의 라이브러리는 다음을 수행한다.

- 동일 변수의 새 값은 항상 새로운 주소에 기록
- Page Transfer 시 오래된 데이터는 폐기
- Page 순환 구조로 Flash 마모 분산

즉, 10만 회 쓰기 제한이더라도 수십 배의 수명 연장이 가능하다.

------

### 실전 예제 – 센서 보정 데이터 저장

온도 센서 또는 로드셀 보정값을 EEPROM에 저장하는 경우:

```
typedef struct {
    uint16_t offset;
    uint16_t scale;
} SensorCalib_t;

void SaveSensorCalib(SensorCalib_t *cal)
{
    EE_WriteVariable(ADDR_CALIB_OFFSET, cal->offset);
    EE_WriteVariable(ADDR_CALIB_SCALE, cal->scale);
}

void LoadSensorCalib(SensorCalib_t *cal)
{
    EE_ReadVariable(ADDR_CALIB_OFFSET, &cal->offset);
    EE_ReadVariable(ADDR_CALIB_SCALE, &cal->scale);
}
```

이 구조는 전원 재시작 후에도 보정값이 유지되며, Flash를 EEPROM처럼 안정적으로 사용할 수 있다.

------

### Flash 직접 접근 대비 장점

| 항목        | Flash 직접 접근              | EEPROM 에뮬레이션           |
| ----------- | ---------------------------- | --------------------------- |
| 데이터 관리 | 수동 구조 설계 필요          | 자동 Virtual Address 관리   |
| 페이지 관리 | 직접 Erase/Write             | 자동 Page Transfer          |
| 무결성 보호 | 사용자 코드에 의존           | 내장 검증 알고리즘 포함     |
| Flash 수명  | 짧음 (한정된 Page 반복 사용) | Wear Leveling으로 수명 연장 |
| 코드 복잡도 | 단순                         | 다소 복잡하지만 안정적      |

EEPROM 에뮬레이션은 구조적으로 Flash 관리의 복잡함을 숨기며, 데이터 안정성을 보장한다.

------

### CubeMX를 통한 설정

CubeIDE의 **Middleware → EEPROM Emulation**을 활성화하면 관련 파일이 자동 생성된다.
 생성된 코드에는 Flash 페이지 주소, Page 관리 루틴, 기본 API가 포함되어 있으며, `EE_Init()` 호출만으로 초기화가 완료된다.

------

### 주의사항 및 권장 사항

- EEPROM 영역은 코드 업데이트 시 덮어쓰이지 않도록 Linker Script 수정 필요
- Flash Write는 전원 불안정 시 손상 가능 → 안정적인 전원 환경 유지
- 빈번한 쓰기를 피하고, 변경 시점에만 기록하도록 로직 설계
- 장시간 사용 시 Wear Leveling을 고려한 주기적 Page Swap 필요
- 데이터 크기가 큰 경우 구조체 단위 저장보다는 변수 단위 저장이 유리

------

### 결론

EEPROM 에뮬레이션은 STM32에서 비휘발성 데이터를 저장하기 위한 가장 효율적인 방법이다.
 Flash Page를 EEPROM처럼 활용하며, Wear Leveling과 Page Transfer를 통해 수명을 보장한다.
 이 기법은 보정값, 장치 설정, 동작 로그, 통신 파라미터 등 다양한 용도에서 안정적으로 적용 가능하며,
 실제 EEPROM이 없는 MCU에서도 동일한 기능을 제공한다.

## 14.5 RTC Backup Register 활용

STM32 MCU의 RTC(Real-Time Clock) 백업 레지스터(Backup Register)는 전원 차단 후에도 유지되어야 하는 중요한 소량의 데이터를 저장하기 위한 비휘발성 저장 영역으로 사용된다. 이 영역은 VBAT 핀을 통해 독립적인 백업 배터리 또는 슈퍼캡(Super Capacitor)이 연결되어 있을 경우 유지되며, 시스템의 주 전원이 꺼지더라도 데이터가 소실되지 않는다.
 주로 시간 정보 외에도 **보정값(calibration data), 설정 값, 시스템 상태 플래그 등**을 저장하는 데 활용된다.

------

### 구조 및 특징

RTC Backup Register는 **RTC 영역 내에 포함된 소형 데이터 저장 공간**으로, SRAM과 유사하게 접근 가능하다.
 STM32F1 시리즈를 기준으로 `RTC_BKP_DR1` ~ `RTC_BKP_DR10`까지 총 10개의 16비트 레지스터를 제공하며, 시리즈에 따라 개수가 다를 수 있다. (예: F4/H7 계열은 최대 32개 이상 제공)

- **데이터 폭**: 16비트 단위
- **백업 유지 조건**: VBAT 전원 공급 시 유지
- **초기화 조건**:
  - 백업 도메인 리셋 발생 시 초기화됨
  - 전원 완전 차단 시(즉, VBAT도 차단 시) 데이터 소실
- **비휘발적 유지**: 메인 전원이 꺼져도 RTC와 Backup Register는 VBAT로 유지

------

### 주요 사용 사례

- 공장 보정값(Factory Calibration Data) 저장
- 사용자 설정값(User Configuration) 저장
- 시스템 부팅 플래그 유지 (예: “이전 부팅은 저전력 복귀였다” 등)
- RTC 시간 정보 유지 (시간/날짜 데이터 보호)
- 펌웨어 버전, 디버깅용 마커, 부팅 상태 플래그 등 저장

------

### 초기화 및 접근 절차

RTC Backup Register 접근은 **백업 도메인 보호 해제** 후 가능하다.
 보호를 해제하기 위해서는 PWR 및 BKP 클록을 활성화한 뒤, 백업 도메인 쓰기 권한을 허용해야 한다.

```
#include "stm32f1xx_hal.h"

void BackupRegister_Init(void)
{
    __HAL_RCC_PWR_CLK_ENABLE();
    __HAL_RCC_BKP_CLK_ENABLE();

    HAL_PWR_EnableBkUpAccess();   // 백업 영역 쓰기 허용
}
```

------

### 데이터 쓰기 및 읽기 예제

#### 데이터 쓰기

```
void BackupRegister_Write(uint16_t data)
{
    // 예시: RTC_BKP_DR1에 데이터 기록
    HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR1, data);
}
```

#### 데이터 읽기

```
uint16_t BackupRegister_Read(void)
{
    return HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1);
}
```

`HAL_RTCEx_BKUPWrite()`와 `HAL_RTCEx_BKUPRead()`는 HAL 레벨의 표준 함수이며, 각 DR 레지스터 번호를 지정하여 사용한다.

------

### 보정값 및 상태정보 저장 예제

시스템 보정 데이터(예: 센서 오프셋, 스케일 팩터 등)를 RTC 백업 영역에 저장할 수 있다.
 아래 예제에서는 보정 완료 여부 플래그와 센서 오프셋값을 백업 영역에 저장한다.

```
#define BKP_CAL_FLAG    RTC_BKP_DR1
#define BKP_OFFSET_VAL  RTC_BKP_DR2

void SaveCalibrationData(float offset)
{
    uint16_t flag = 0xA5A5;  // 보정 완료 표시 플래그
    uint16_t offset_raw = (uint16_t)(offset * 100);

    HAL_RTCEx_BKUPWrite(&hrtc, BKP_CAL_FLAG, flag);
    HAL_RTCEx_BKUPWrite(&hrtc, BKP_OFFSET_VAL, offset_raw);
}

bool IsCalibrationDone(void)
{
    return (HAL_RTCEx_BKUPRead(&hrtc, BKP_CAL_FLAG) == 0xA5A5);
}
```

------

### 시스템 재부팅 후 데이터 유지 검증

RTC Backup Register에 저장된 데이터는 시스템 리셋 후에도 유지된다.
 이를 활용해 “이전 보정 완료 여부”를 부팅 시점에서 판별할 수 있다.

```
void System_Init(void)
{
    BackupRegister_Init();

    if (IsCalibrationDone())
    {
        uint16_t offset = HAL_RTCEx_BKUPRead(&hrtc, BKP_OFFSET_VAL);
        printf("Calibration offset loaded: %.2f\n", offset / 100.0f);
    }
    else
    {
        printf("No calibration data found. Performing calibration...\n");
        PerformCalibration();
    }
}
```

------

### 백업 도메인 리셋

백업 도메인을 완전히 초기화해야 하는 경우(예: 새로운 펌웨어 배포 시) 다음과 같이 수행할 수 있다.

```
__HAL_RCC_BACKUPRESET_FORCE();
__HAL_RCC_BACKUPRESET_RELEASE();
```

이 명령은 **RTC와 Backup Register 전체를 초기화**하므로 신중히 사용해야 한다.

------

### RTC Backup Register vs EEPROM / Flash 비교

| 구분      | RTC Backup Register            | EEPROM (또는 Emulation)    | Flash Memory               |
| --------- | ------------------------------ | -------------------------- | -------------------------- |
| 용량      | 매우 작음 (수십 바이트)        | 수백 ~ 수천 바이트         | 수십~수백 KB               |
| 유지 조건 | VBAT 유지 필요                 | 전원 차단에도 유지         | 전원 차단에도 유지         |
| 접근 속도 | 매우 빠름 (SRAM 수준)          | 느림                       | 느림                       |
| 수명      | 반영구적                       | 쓰기 횟수 제한 (10⁵~10⁶회) | 쓰기 횟수 제한 (10⁴~10⁵회) |
| 사용 용도 | 설정 플래그, 보정값, 상태 비트 | 소규모 설정 데이터         | 대규모 비휘발성 데이터     |

RTC Backup Register는 EEPROM보다 훨씬 빠르고 간단하지만 저장 용량이 작으므로, **플래그성 정보나 단일 보정값 저장용**으로 사용하는 것이 이상적이다.

------

### 실습 아이디어

- RTC 백업 레지스터에 “보정 완료” 플래그와 보정값을 저장 후, 재부팅 시 자동 복원 확인
- RTC를 동작시키며 VBAT만 연결한 상태에서 전원 리셋 → 데이터 유지 여부 확인
- Flash/EEPROM 저장 방식과 비교하여 데이터 유지성과 속도 측정

------

### 요약

RTC Backup Register는 **소량의 비휘발성 데이터 저장을 위한 경량 솔루션**으로, 시스템 부팅 상태나 센서 보정값과 같은 간단한 데이터를 빠르고 안정적으로 유지할 수 있다.
 Flash/EEPROM 접근보다 훨씬 빠르며, HAL API를 통해 손쉽게 읽고 쓸 수 있다.
 단, VBAT가 끊기면 데이터가 소실되므로 전원 설계 단계에서 반드시 **RTC Backup Domain 전원 유지 회로**를 고려해야 한다.