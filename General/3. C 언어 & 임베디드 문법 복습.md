# 3. C 언어 & 임베디드 문법 복습

## 3.1 volatile, const, static 키워드

### volatile

`volatile`은 **컴파일러 최적화를 방지**하기 위한 키워드이다.
 임베디드 시스템에서는 하드웨어 레지스터, 인터럽트 서비스 루틴(ISR), DMA, 외부 장치와 공유하는 변수가 프로그램 흐름 외부에서 변경될 수 있다. 이러한 변수에 `volatile`을 지정하지 않으면, 컴파일러가 해당 변수가 “변하지 않는다”고 가정하고 레지스터에 캐시하거나 읽기/쓰기 동작을 생략하는 최적화를 수행하여, 실제 하드웨어 값이 반영되지 않는 문제가 발생한다.

**예시:**

```
volatile uint8_t flag;
```

이 변수는 매번 메모리에서 읽히며, 캐싱되지 않는다.
 대표적인 사용 예시는 다음과 같다.

#### 사용 예시

- 인터럽트 핸들러에서 변경되는 상태 변수
- 하드웨어 상태 레지스터 (GPIO, ADC, USART 등)
- DMA 전송 완료 플래그, 타이머 오버플로 플래그
- 메모리 매핑된 주변장치 레지스터

#### 예제

```
#define STATUS_REG (*(volatile uint32_t*)0x40021000)
while (!(STATUS_REG & 0x01));  // Flag가 외부에서 세트될 때까지 대기
```

#### 주의점

- `volatile`은 원자성(atomic)을 보장하지 않는다.
   → 여러 스레드나 ISR에서 동시에 접근할 경우에는 `atomic` 연산 또는 `__disable_irq()` / `__enable_irq()` 등을 병행해야 한다.
- `volatile`은 **읽기/쓰기 순서만 보장**, 연산 자체의 일관성은 보장하지 않는다.

------

### const

`const`는 **변경 불가능한 상수화 변수**를 선언하는 키워드다.
 임베디드에서는 **ROM(Flash)**에 데이터를 저장하여 RAM 사용량을 줄이거나, **읽기 전용 설정값**을 정의할 때 자주 사용된다.

#### 사용 예시

```
const uint8_t DEVICE_ID = 0x32;
const float CALIBRATION_TABLE[10] = { ... };
```

#### 특징

- `const` 데이터는 기본적으로 **Flash 메모리에 저장**된다.
- 포인터와 함께 사용 시 “포인터 자체의 변경 금지”와 “가리키는 데이터의 변경 금지”를 구분해야 한다.

#### 예제

```
const int *p1;      // p1이 가리키는 값은 수정 불가
int * const p2;     // p2 포인터는 변경 불가
const int * const p3; // 포인터도, 값도 수정 불가
```

#### 주의점

- `const` 변수는 런타임에 변경 불가하지만,
   `#define`과 달리 **타입 검사(type checking)**가 수행된다.
- Flash에 저장된 `const` 배열에 DMA를 직접 연결할 수 없다.
   (DMA는 RAM 영역만 접근 가능하기 때문)

------

### static

`static`은 **저장 영역(storage class)**을 지정하는 키워드로, 변수나 함수의 **수명(lifetime)**과 **가시성(scope)**을 제어한다.

#### 주요 의미

1. **전역 변수에서 사용 시:**

   - 외부 파일에서 접근 불가 (`extern` 불가)
   - 파일 내부 전용의 “정적 전역 변수”

   ```
   static int counter = 0; // 이 파일 안에서만 접근 가능
   ```

2. **함수 내부에서 사용 시:**

   - 함수 호출이 끝나도 값이 유지된다.
   - ROM이 아닌 RAM 내 static 영역(.data / .bss)에 저장됨.

   ```
   void func(void) {
       static int n = 0;
       n++;
   }
   ```

3. **함수 정의에 사용 시:**

   - 함수의 범위를 해당 파일로 제한한다.

   ```
   static void internal_process(void);
   ```

#### 임베디드에서의 활용

- **ISR 내 카운터 변수**: 지역 변수처럼 사용하지만 리셋 없이 누적 필요할 때.
- **모듈 내부 유틸 함수**: 외부에 노출하지 않기 위해.
- **초기화된 상태 변수**: 부팅 이후 유지되는 로직 제어용.

#### 주의점

- `static`은 **전역 변수처럼 초기화 시 한 번만 할당**되며, RAM 점유량이 늘어난다.
- `static` 전역 변수는 **링커 스크립트의 .data/.bss** 섹션에 포함되어 초기화 순서에 영향.

------

## 3.2 구조체와 비트필드

### 구조체 (Structure)

구조체는 관련 데이터를 하나의 논리 단위로 묶기 위한 **사용자 정의 데이터 타입**이다.
 레지스터 맵핑, 설정 파라미터 집합, 복합 데이터 전달 시 매우 자주 사용된다.

#### 기본 문법

```
typedef struct {
    uint16_t mode;
    uint16_t prescaler;
    uint32_t period;
} TIM_ConfigTypeDef;
```

#### 접근 예시

```
TIM_ConfigTypeDef config = {0};
config.mode = 1;
config.prescaler = 72;
config.period = 1000;
```

#### 포인터를 통한 접근

```
TIM_ConfigTypeDef *pConfig = &config;
pConfig->period = 500;
```

------

### 비트필드 (Bit Field)

비트필드는 구조체 내부에서 변수의 **비트 단위 크기**를 지정하는 문법이다.
 레지스터 제어 시 특정 비트만 읽거나 쓸 때 사용한다.

#### 예제 — 레지스터 맵핑

```
typedef struct {
    uint32_t EN      : 1;  // Bit 0
    uint32_t MODE    : 2;  // Bit 1~2
    uint32_t INTFLAG : 1;  // Bit 3
    uint32_t RESERVED: 28; // Bit 4~31
} CTRL_Reg_t;

#define CTRL_REG ((volatile CTRL_Reg_t*)0x40010000)
```

#### 사용 예시

```
CTRL_REG->EN = 1;      // Bit0 = 1
CTRL_REG->MODE = 3;    // Bit1~2 = 11b
```

#### 장점

- 코드 가독성 향상 (비트 연산 제거 가능)
- 레지스터 정의를 문서화하기 쉬움
- 유지보수 및 디버깅 용이

#### 단점

- 컴파일러마다 비트 배치 순서(Endian, Packing)가 다를 수 있음
- 하드웨어 매핑 시 정확한 비트 위치가 보장되지 않음 → **레지스터 접근용으로는 비트마스크 사용이 안전**

#### 안전한 대안

```
#define CTRL_EN_Pos     0
#define CTRL_MODE_Pos   1
#define CTRL_MODE_Msk   (0x3U << CTRL_MODE_Pos)
#define CTRL_INTFLAG_Pos 3
#define CTRL_INTFLAG_Msk (0x1U << CTRL_INTFLAG_Pos)
*(uint32_t*)0x40010000 |= CTRL_MODE_Msk;  // 안전한 방식
```

------

### 구조체 + 비트필드 혼합 활용 (HAL 내부 패턴)

STM32 HAL 드라이버는 대부분 **Handle 구조체**와 **Init 구조체**, **Instance 레지스터 포인터**를 함께 사용한다.

#### 예시 (HAL Timer)

```
typedef struct {
    uint32_t Prescaler;
    uint32_t CounterMode;
    uint32_t Period;
} TIM_Base_InitTypeDef;

typedef struct {
    TIM_TypeDef              *Instance;  // 실제 하드웨어 레지스터 주소
    TIM_Base_InitTypeDef     Init;       // 초기화 설정값
    HAL_LockTypeDef          Lock;
    __IO HAL_TIM_StateTypeDef State;
} TIM_HandleTypeDef;
```

→ 이 방식은 레지스터 접근을 구조화하여, 하드웨어 제어를 추상화하고 코드 유지보수를 용이하게 한다.

## 3.3 포인터와 메모리 맵 접근

임베디드 시스템에서 **포인터(pointer)**는 단순한 변수 참조가 아니라, **하드웨어 레지스터 및 메모리 맵에 직접 접근하기 위한 핵심 도구**이다.
 STM32는 **메모리 맵 구조(Memory Map Structure)**를 통해 CPU, Flash, SRAM, 주변장치 레지스터 등의 주소 영역을 고정적으로 정의하고 있으며, 펌웨어는 이 영역을 포인터를 통해 제어한다.

------

### 메모리 맵 개요

| 영역         | 주소 범위     | 설명                                              |
| ------------ | ------------- | ------------------------------------------------- |
| Code / Flash | 0x0800 0000 ~ | 사용자 프로그램 코드 저장 공간                    |
| SRAM         | 0x2000 0000 ~ | 스택, 전역 변수, 동적 메모리 저장                 |
| Peripheral   | 0x4000 0000 ~ | 타이머, GPIO, UART, ADC 등 주변장치 레지스터 매핑 |
| System       | 0xE000 0000 ~ | NVIC, SysTick, SCB 등 Cortex-M 시스템 제어 블록   |

모든 주변장치는 **레지스터 기반 제어 구조**를 가지며, 각 레지스터는 32비트 단위 주소로 정의되어 있다.
 예를 들어 GPIOA의 **ODR(Output Data Register)**는 다음과 같은 주소로 접근 가능하다.

```
#define GPIOA_BASE   (0x40010800UL)
#define GPIOA_ODR    (*(volatile uint32_t *)(GPIOA_BASE + 0x0C))
```

이후 다음과 같은 명령으로 하드웨어를 직접 제어할 수 있다.

```
GPIOA_ODR |= (1 << 5);   // PA5 핀 HIGH
GPIOA_ODR &= ~(1 << 5);  // PA5 핀 LOW
```

------

### 포인터를 통한 직접 접근

```
volatile uint32_t *pReg = (uint32_t *)(GPIOA_BASE + 0x0C);
*pReg = 0x00000020;  // 레지스터 직접 쓰기
```

- `volatile`: 최적화 방지를 위해 반드시 필요. 하드웨어 레지스터는 언제든 값이 바뀔 수 있기 때문.
- `uint32_t *`: 32비트 단위 접근을 위한 포인터 타입.
- `*(pReg)`를 통해 실제 하드웨어 주소에 쓰기/읽기 수행.

------

### 구조체 기반 접근

CMSIS 및 HAL 라이브러리는 모든 주변장치 레지스터를 구조체로 정의한다.

```
typedef struct {
  __IO uint32_t CRL;
  __IO uint32_t CRH;
  __IO uint32_t IDR;
  __IO uint32_t ODR;
  __IO uint32_t BSRR;
  __IO uint32_t BRR;
  __IO uint32_t LCKR;
} GPIO_TypeDef;

#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)
```

이를 통해 다음과 같은 형태로 하드웨어 제어가 가능하다.

```
GPIOA->ODR |= (1 << 5);
GPIOA->BSRR = (1 << 5); // 더 빠른 GPIO set 명령
```

이는 레지스터 주소 계산을 추상화하여 코드 가독성과 유지보수성을 높이는 표준 접근 방식이다.

------

### 포인터 연산과 메모리 안정성

- 포인터 연산 시에는 반드시 정렬(alignment)을 고려해야 한다.
- Cortex-M은 32비트 접근 단위를 기본으로 하므로, misaligned 접근 시 하드폴트가 발생할 수 있다.
- 주소 타입 캐스팅 시 `uint32_t *`, `uint16_t *`, `uint8_t *` 등 접근 폭에 따라 구분한다.

예:

```
*((volatile uint8_t *)(GPIOA_BASE + 0x0C)) = 0x20;  // 8비트 단위 접근
```

------

### Register-Level 접근 vs HAL

| 구분                      | 장점                            | 단점                                               |
| ------------------------- | ------------------------------- | -------------------------------------------------- |
| 직접 접근 (레지스터 접근) | 빠름, 코드 최적화 용이          | 하드웨어 의존성 높음, 코드 이식 어려움             |
| HAL / LL API              | 유지보수 용이, 코드 이식성 우수 | 약간의 성능 손실, 추상화로 인한 디버깅 복잡도 증가 |

------

## 3.4 인터럽트 핸들러 선언

Cortex-M 기반 MCU는 **벡터 테이블(Vector Table)**을 통해 인터럽트 핸들러를 관리한다.
 각 인터럽트는 정해진 함수 이름(weak alias 형태)으로 선언되어 있으며, 사용자가 이를 재정의하여 실제 핸들러를 구현한다.

------

### 인터럽트 벡터 구조

부트 영역의 시작 주소(일반적으로 0x0800 0000)에 벡터 테이블이 위치하며, 다음과 같은 형태로 구성된다.

| 항목                  | 설명                                        |
| --------------------- | ------------------------------------------- |
| 초기 Stack Pointer 값 | 프로그램 시작 시 SP 초기화                  |
| Reset_Handler         | 리셋 시 실행되는 함수 (main 진입 전 초기화) |
| NMI_Handler           | Non-Maskable Interrupt                      |
| HardFault_Handler     | 하드 폴트 예외 처리                         |
| SysTick_Handler       | 주기 타이머 인터럽트                        |
| EXTIx_IRQHandler      | 외부 인터럽트 (핀 변화 감지 등)             |
| TIMx_IRQHandler       | 타이머 오버플로우/이벤트                    |
| USARTx_IRQHandler     | UART 통신 인터럽트                          |

------

### 인터럽트 함수 선언 예제

```
void EXTI0_IRQHandler(void)
{
    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_0) != RESET)
    {
        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);  // 인터럽트 플래그 클리어
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
    }
}
```

- 함수명은 `startup_stm32f1xx.s`에 정의된 **weak alias 함수명**과 동일해야 한다.
- HAL 매크로를 통해 인터럽트 발생 및 클리어를 안전하게 처리.

------

### 인터럽트 우선순위 설정

NVIC(Nested Vectored Interrupt Controller)를 통해 인터럽트 우선순위를 지정한다.

```
HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
```

- **첫 번째 인자**: 인터럽트 채널 (IRQn 열거형)
- **두 번째 인자**: Preemption Priority
- **세 번째 인자**: Sub Priority

------

### 사용자 정의 인터럽트 등록

LL 드라이버나 Bare-metal 환경에서는 다음과 같이 직접 등록 가능하다.

```
NVIC->ISER[0] |= (1 << EXTI0_IRQn);
NVIC_SetPriority(EXTI0_IRQn, 2);
```

이 경우 HAL 없이 NVIC 레지스터를 직접 제어한다.

------

### 인터럽트 처리 주의사항

- 인터럽트 내에서는 **긴 연산, printf, HAL_Delay()** 사용 금지.
- 플래그 기반 동작(Interrupt flag set 후 main loop에서 처리)이 권장된다.
- 인터럽트 중첩 시 우선순위와 Clear 시점을 명확히 관리해야 한다.

------

### 인터럽트 디버깅 팁

- **NVIC->ISPR, ISER, ICPR, IABR** 레지스터를 통해 현재 인터럽트 상태 확인 가능.
- **CMSIS Core Debug Registers (ICSR, SHCSR)**를 통해 Pend 상태, 활성화 상태 점검.
- 인터럽트 핸들러 진입 여부는 **breakpoint**나 **GPIO 토글**로 확인.

------

이 두 단원은 STM32 펌웨어 설계에서 **레지스터 접근 기반 하드웨어 제어**와 **실시간 이벤트 반응 구조**의 기초를 형성하며, 이후 HAL 기반 GPIO, Timer, EXTI, DMA, FreeRTOS 등으로 확장된다.

## 3.5 링버퍼, 큐, 상태머신 기초

임베디드 시스템에서 효율적인 데이터 처리와 이벤트 흐름 제어를 위해 **링버퍼(Ring Buffer)**, **큐(Queue)**, **상태머신(State Machine)** 구조는 필수적인 소프트웨어 설계 기법이다.
 이들은 실시간 데이터 스트림 처리, 비동기 이벤트 관리, 복잡한 제어 로직의 단순화를 가능하게 한다.

------

### 링버퍼 (Ring Buffer, Circular Buffer)

#### 개념

링버퍼는 **고정된 크기의 버퍼 메모리를 순환 구조로 사용하는 FIFO(First-In First-Out)** 자료구조이다.
 데이터를 연속된 메모리에 저장하되, **쓰기 포인터(write index)**와 **읽기 포인터(read index)**를 관리함으로써 큐처럼 동작한다.

#### 구조 개념도

```
[0][1][2][3][4][5][6][7]
 ^           ^
 R           W
```

- `R`: Read index (읽기 위치)
- `W`: Write index (쓰기 위치)
- 버퍼 끝에 도달하면 0으로 순환(Circular)

------

#### 기본 구현 예시

```
#define BUFFER_SIZE 128
typedef struct {
    uint8_t data[BUFFER_SIZE];
    uint16_t head;
    uint16_t tail;
} RingBuffer;

void RB_Init(RingBuffer *rb) {
    rb->head = rb->tail = 0;
}

uint8_t RB_IsEmpty(RingBuffer *rb) {
    return rb->head == rb->tail;
}

uint8_t RB_IsFull(RingBuffer *rb) {
    return ((rb->head + 1) % BUFFER_SIZE) == rb->tail;
}

void RB_Push(RingBuffer *rb, uint8_t val) {
    if (!RB_IsFull(rb)) {
        rb->data[rb->head] = val;
        rb->head = (rb->head + 1) % BUFFER_SIZE;
    }
}

uint8_t RB_Pop(RingBuffer *rb) {
    uint8_t val = 0;
    if (!RB_IsEmpty(rb)) {
        val = rb->data[rb->tail];
        rb->tail = (rb->tail + 1) % BUFFER_SIZE;
    }
    return val;
}
```

#### 장점

- 인터럽트 기반 UART RX, ADC DMA 수신 버퍼에 적합.
- 메모리 고정 구조로 동적 할당 불필요.
- Lock-free 구현이 가능해 실시간성 보장.

------

### 큐 (Queue)

큐는 링버퍼의 일반화된 형태로, 데이터 구조 수준에서 FIFO 성질을 제공한다.
 FreeRTOS 등 RTOS 환경에서는 **스레드 간 통신(Inter-Task Communication)** 수단으로 사용된다.

#### RTOS 기반 큐 예시

```
QueueHandle_t xQueue = xQueueCreate(10, sizeof(uint8_t));

void SenderTask(void *pvParameters) {
    uint8_t data = 0x55;
    xQueueSend(xQueue, &data, portMAX_DELAY);
}

void ReceiverTask(void *pvParameters) {
    uint8_t rx;
    xQueueReceive(xQueue, &rx, portMAX_DELAY);
}
```

- RTOS 큐는 **뮤텍스 기반 임계영역 보호**를 포함하며,
   다중 태스크 환경에서 안전한 데이터 전달을 보장한다.

------

### 상태머신 (State Machine)

#### 개념

상태머신은 시스템이 일정한 **상태(State)**를 가지고,
 입력(Event)에 따라 **다른 상태로 전이(Transition)** 하는 구조를 가진다.

이 패턴은 UART 프로토콜 파싱, 센서 측정 단계 제어, 모터 구동 시퀀스 등에서 자주 사용된다.

#### 기본 형태 (switch-case 기반)

```
typedef enum {
    STATE_IDLE,
    STATE_RECEIVE,
    STATE_PROCESS,
    STATE_ERROR
} SystemState;

SystemState state = STATE_IDLE;

void System_Update(void) {
    switch (state) {
        case STATE_IDLE:
            if (data_ready) state = STATE_RECEIVE;
            break;
        case STATE_RECEIVE:
            Receive_Data();
            state = STATE_PROCESS;
            break;
        case STATE_PROCESS:
            Process_Data();
            state = STATE_IDLE;
            break;
        case STATE_ERROR:
            Handle_Error();
            state = STATE_IDLE;
            break;
    }
}
```

#### 장점

- 코드 흐름이 명확하며, 각 상태별 동작이 분리되어 유지보수가 용이.
- 복잡한 if-else 분기 구조를 단순화.
- 실시간 제어 루프, 통신 프로토콜 FSM(Finite State Machine)에 적합.

#### 확장형 (함수 포인터 기반)

```
typedef void (*StateFunc)(void);
void State_Idle(void);
void State_Run(void);
void State_Error(void);

StateFunc current = State_Idle;
```

이 구조는 객체지향적 FSM 설계와 유사한 확장성을 제공한다.

------

## 3.6 CMSIS 데이터 타입 (`uint32_t`, `__IO` 등)

**CMSIS (Cortex Microcontroller Software Interface Standard)**는 ARM이 정의한 Cortex-M 시리즈용 소프트웨어 표준이다.
 STM32 HAL 역시 CMSIS를 기반으로 하며, 모든 MCU 레벨 코드에서 공통된 타입, 매크로, 코어 함수 인터페이스를 제공한다.

------

### CMSIS 기본 정수형 타입

CMSIS는 컴파일러별 정수 크기 불일치를 방지하기 위해 고정폭 데이터 타입을 정의한다.

| 타입       | 크기                          | 설명       |
| ---------- | ----------------------------- | ---------- |
| `uint8_t`  | 8비트 부호 없는 정수          | 0~255 범위 |
| `int8_t`   | 8비트 부호 있는 정수          | -128~127   |
| `uint16_t` | 16비트 부호 없는 정수         |            |
| `uint32_t` | 32비트 부호 없는 정수         |            |
| `int32_t`  | 32비트 부호 있는 정수         |            |
| `uint64_t` | 64비트 부호 없는 정수         |            |
| `bool`     | 1비트 논리값 (`true`/`false`) |            |

모든 CMSIS 타입은 `<stdint.h>` 또는 `core_cm*.h`에 포함된다.

------

### CMSIS 접근 한정자 (Qualifier)

#### `__IO`

- Input/Output용 메모리 접근을 의미.
- 컴파일러의 최적화를 방지하기 위한 키워드.
- 하드웨어 레지스터 또는 DMA 버퍼 등 **외부 요인에 의해 값이 변할 수 있는 변수**에 반드시 사용.
- 실질적으로는 `volatile` 키워드와 동일한 의미.

```
__IO uint32_t GPIOA_ODR;
```

#### `__I` / `__O`

- `__I`: Read-only register (입력 전용)
- `__O`: Write-only register (출력 전용)

예시:

```
typedef struct {
  __IO uint32_t CR;
  __I  uint32_t SR;
  __O  uint32_t DR;
} ADC_TypeDef;
```

------

### CMSIS 매크로

| 매크로                          | 설명                               |
| ------------------------------- | ---------------------------------- |
| `__INLINE`                      | 인라인 함수 지정 (`inline` 대체)   |
| `__STATIC_INLINE`               | 정적 인라인 함수 정의              |
| `__ASM`                         | 어셈블리 코드 삽입                 |
| `__NOP()`                       | No Operation — 1클록 지연          |
| `__WFI()`                       | Wait For Interrupt, 절전 대기 명령 |
| `__DSB()`, `__ISB()`, `__DMB()` | 파이프라인 동기화 명령             |

예:

```
__NOP();   // 1 CPU cycle 지연
__WFI();   // 인터럽트 발생까지 대기 (저전력 모드)
```

------

### CMSIS 구조체 예시 (GPIO, RCC 등)

CMSIS는 모든 주변장치를 C 구조체로 표현한다.

```
typedef struct {
  __IO uint32_t CRL;
  __IO uint32_t CRH;
  __IO uint32_t IDR;
  __IO uint32_t ODR;
  __IO uint32_t BSRR;
  __IO uint32_t BRR;
  __IO uint32_t LCKR;
} GPIO_TypeDef;
```

사용 시:

```
GPIOA->BSRR = (1 << 5);  // PA5 Set
```

------

### CMSIS Core Function 예시

| 함수                                                  | 설명                   |
| ----------------------------------------------------- | ---------------------- |
| `NVIC_EnableIRQ(IRQn_Type IRQn)`                      | 특정 인터럽트 활성화   |
| `NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)` | 인터럽트 우선순위 설정 |
| `SysTick_Config(uint32_t ticks)`                      | 시스템 틱 타이머 설정  |
| `__get_PRIMASK()` / `__disable_irq()`                 | 전역 인터럽트 제어     |

------

### CMSIS의 역할 요약

| 구분            | 역할                       |
| --------------- | -------------------------- |
| 데이터 타입     | 하드웨어 독립형 코드 작성  |
| 코어 함수       | NVIC, SysTick, Fault 제어  |
| 레지스터 구조체 | 주변장치 접근 추상화       |
| 매크로          | 코드 이식성 및 가독성 향상 |

------

CMSIS는 STM32 HAL, LL, FreeRTOS 포팅 계층 모두의 기반이 되는 핵심 인터페이스로,
 **펌웨어 레벨의 하드웨어 제어**와 **표준화된 타입 시스템**을 보장한다.

