# 5. Timer / Counter

## 5.1 Timer 구조 (PSC, ARR, CNT)

STM32의 **Timer(타이머)**는 MCU 내부의 다목적 하드웨어 카운터로, 시간 기반 이벤트 생성, PWM 출력, 입력 캡처, 주파수 측정, Encoder 인터페이스 등 다양한 기능을 제공한다.
 각 타이머는 **Prescaler(PSC)**, **Auto-Reload Register(ARR)**, **Counter(CNT)** 등 핵심 레지스터를 통해 동작 속도와 주기를 제어한다.

------

### ① Timer 기본 구성요소

| 구성요소                                 | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| **PSC (Prescaler)**                      | 입력 클록을 분주하여 타이머의 카운트 속도 결정. 예: `PSC=71`이면 72MHz / (71+1) = 1MHz |
| **CNT (Counter)**                        | 실제 카운트 값이 저장되는 레지스터. 0부터 ARR까지 증가(또는 감소). |
| **ARR (Auto-Reload Register)**           | CNT가 도달하면 오버플로(갱신 이벤트) 발생 후 CNT가 0으로 리셋. 타이머의 주기 결정. |
| **EGR (Event Generation Register)**      | 소프트웨어에서 강제로 이벤트 갱신(UG 비트 설정) 가능.        |
| **SR (Status Register)**                 | Update, Capture, Compare 등의 상태 플래그 저장.              |
| **DIER (DMA/Interrupt Enable Register)** | 인터럽트 또는 DMA 요청 활성화 설정.                          |

------

### ② 타이머 클록 계산식

타이머 주기는 다음 식으로 계산된다.
$$
T_{update} = \frac{(PSC + 1) \times (ARR + 1)}{f_{timer}}
$$
예를 들어,

- 타이머 클록: 72MHz
- PSC = 71 (→ 1MHz)
- ARR = 999 (→ 1000 count)

→ 오버플로 주기 = 1ms
 즉, 1kHz 주기의 타이머 이벤트 발생.

------

### ③ 타이머 종류

| 타입                       | 대표 타이머   | 특징                                             |
| -------------------------- | ------------- | ------------------------------------------------ |
| **Basic Timer**            | TIM6, TIM7    | 단순한 시간 기반, PWM 불가, DAC Trigger 용도     |
| **General Purpose Timer**  | TIM2~TIM5     | PWM, Input Capture, Output Compare, Encoder 가능 |
| **Advanced Control Timer** | TIM1, TIM8    | Complementary PWM, Dead Time, Break 기능 내장    |
| **Low-Power Timer**        | LPTIM1~LPTIM2 | 저전력 동작, RTC/LSE 클록 사용 가능              |

------

### ④ 기본 동작 흐름

1. PSC로 입력 클록 분주
2. CNT가 0→ARR까지 증가
3. CNT == ARR → Update Event 발생 (CNT 리셋)
4. Update Event 시 ISR 실행 혹은 DMA 요청 발생

------

### ⑤ 레지스터 관찰 예시

디버깅 중 CubeIDE의 **SFR(Special Function Register)** 창에서 TIMx_CNT, TIMx_PSC, TIMx_ARR 값을 실시간 확인 가능하다.
 ARR 값 변경 후 EGR의 UG 비트를 1로 설정해야 즉시 반영된다.

------

### ⑥ 예시 코드

```
/* TIM2를 1kHz 주기로 설정 */
htim2.Instance = TIM2;
htim2.Init.Prescaler = 71;     // 72MHz / (71+1) = 1MHz
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 999;       // 1MHz / (999+1) = 1kHz
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
HAL_TIM_Base_Init(&htim2);
HAL_TIM_Base_Start_IT(&htim2); // 인터럽트 모드 시작
```

------

### ⑦ 실무 활용 예시

- 주기적 LED 토글 (1Hz, 10Hz 등)
- 주기적 센서 샘플링 트리거
- 일정 시간 간격으로 ADC 변환 요청
- FreeRTOS Tickless 모드에서 저전력 타이머로 대체

------

## 5.2 Time Base 생성 (Delay, Periodic Event)

Timer를 이용한 **Time Base**는 시스템 내에서 일정한 주기나 지연(Delay)을 발생시키는 기본 구조를 제공한다.
 이는 `HAL_Delay()`보다 정밀하고, 멀티태스킹 환경에서 사용하기 용이하다.

------

### ① HAL 기반 타임베이스 원리

STM32 HAL은 기본적으로 **SysTick Timer (1ms)**를 시스템 타임베이스로 사용한다.
 `HAL_Delay()`는 SysTick 인터럽트로 관리되며, FreeRTOS 사용 시 Tick Timer로 대체된다.

그러나 **사용자 타이머(TIMx)**를 별도로 활용하면 다음이 가능하다.

- 여러 주기 동시 생성
- µs 단위 정밀 Delay
- 실시간 이벤트 처리

------

### ② 주기적 이벤트 타이머 (Interrupt Mode)

```
/* 타이머 인터럽트 콜백 함수 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 1kHz 이벤트
    }
}
```

CubeMX 설정 시:

- TIM2 → Clock Source: Internal Clock
- Mode: Time Base
- Interrupt Enable

------

### ③ 마이크로초(µs) 단위 Delay 구현

정확한 마이크로초 지연은 소프트웨어 루프보다 하드웨어 타이머 기반이 효율적이다.

```
void delay_us(uint16_t us)
{
    __HAL_TIM_SET_COUNTER(&htim1, 0);
    while (__HAL_TIM_GET_COUNTER(&htim1) < us);
}
```

조건:

- TIM1 클록 = 1MHz (1 tick = 1µs)
- ARR ≥ 지연 시간보다 충분히 커야 함.

------

### ④ PWM 기반 주기 제어

Time Base와 PWM 모드를 결합하면 일정 Duty Cycle로 출력 제어 가능.

- 예: 1kHz PWM, 50% Duty → ARR=999, CCR=500

```
TIM_OC_InitTypeDef sConfigOC = {0};
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 500;
HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
```

------

### ⑤ 타임베이스와 FreeRTOS의 관계

- FreeRTOS는 기본 Tick Timer(1ms)를 기반으로 Task Scheduling 수행.
- HAL_TIM_Base를 이용해 별도의 하드웨어 타이머를 FreeRTOS “Soft Timer” 트리거로 활용 가능.
- 실시간 제어 로직은 FreeRTOS Task보다 하드웨어 타이머 ISR 내에서 처리하는 것이 더 안정적.

------

### ⑥ 주기적 이벤트 설계 예시

| 목적             | 타이머 | 주기    | 동작                |
| ---------------- | ------ | ------- | ------------------- |
| LED 깜빡임       | TIM2   | 500ms   | LED Toggle          |
| 온도 센서 샘플링 | TIM3   | 100ms   | ADC Trigger         |
| 통신 Watchdog    | TIM4   | 5s      | 연결 확인 및 재시도 |
| 초음파 거리 측정 | TIM1   | µs 단위 | Echo 신호 시간 계산 |

------

### ⑦ 주의사항

- PSC나 ARR 변경 시 반드시 **EGR.UG=1**로 갱신 이벤트 발생시켜야 즉시 반영된다.
- 오버플로 주기가 길어지면 타이머 정밀도 감소.
- 인터럽트 기반 Delay는 시스템 전체 응답성을 저하시킬 수 있으므로 비차단(non-blocking) 구조 권장.

------

### ⑧ 요약

- PSC, ARR, CNT는 타이머의 시간 흐름을 결정하는 핵심 레지스터이다.
- 타이머를 이용한 Time Base는 주기적 이벤트, 마이크로초 단위 Delay, PWM 등 모든 시간 기반 제어의 근간이 된다.
- 효율적인 실시간 시스템을 위해 타이머 구조와 인터럽트 흐름을 명확히 이해해야 한다.

## 5.3 Output Compare / PWM 생성

**Output Compare(OC)**와 **Pulse Width Modulation(PWM)**은 STM32 타이머의 핵심 출력 기능이다.
 타이머 카운터(CNT)가 특정 비교 값(CCR)에 도달할 때 하드웨어적으로 이벤트(핀 출력 변화, 인터럽트 발생 등)를 발생시키는 구조를 기반으로 한다.
 PWM은 Output Compare 기능의 확장으로, 주기(Period)와 듀티비(Duty Cycle)를 이용해 파형의 평균 전력을 제어한다.

------

### ① Output Compare 기본 원리

- 타이머의 CNT가 CCRx(Compare Register) 값과 일치할 때, OC 이벤트 발생
- 이벤트 발생 시 **출력 핀 상태를 Toggle, Set, Reset, 또는 아무 동작 안 함**으로 설정 가능
- 주로 **정확한 타이밍 이벤트 생성**에 사용된다.

| 모드          | 동작 설명                                  |
| ------------- | ------------------------------------------ |
| **Active**    | CNT = CCR 시 핀 High 유지                  |
| **Inactive**  | CNT = CCR 시 핀 Low 유지                   |
| **Toggle**    | CNT = CCR 시 핀 상태 반전                  |
| **PWM1/PWM2** | PWM 출력 모드 (CCR과 ARR 비교로 듀티 생성) |

------

### ② Output Compare 설정 예제 (Toggle Mode)

```
TIM_OC_InitTypeDef sConfigOC = {0};

htim2.Instance = TIM2;
htim2.Init.Prescaler = 71;     // 1MHz (72MHz / 72)
htim2.Init.Period = 999;       // 1kHz base
HAL_TIM_Base_Init(&htim2);

sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
sConfigOC.Pulse = 500;         // CNT=500일 때 토글
HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);

HAL_TIM_OC_Start(&htim2, TIM_CHANNEL_1);
```

결과적으로, TIM2_CH1 핀에서 **1Hz 출력 (500ms마다 토글)**이 생성된다.

------

### ③ PWM(Pulse Width Modulation) 원리

PWM은 ARR(Period)과 CCR(Duty Cycle)을 조합해 파형을 생성한다.

- **Period (ARR):** PWM의 주파수 결정
- **Pulse (CCR):** High 레벨 지속 시간
- **Duty Cycle:** (CCR / ARR) × 100 (%)

| 구성요소 | 역할                     |
| -------- | ------------------------ |
| PSC      | 입력 클록 분주           |
| ARR      | PWM 주기 설정            |
| CCRx     | 듀티비 결정              |
| OCx      | 출력 채널 선택 (CH1~CH4) |

------

### ④ PWM 모드 동작

| 모드     | CNT < CCR | CNT ≥ CCR | 설명               |
| -------- | --------- | --------- | ------------------ |
| **PWM1** | High      | Low       | CCR에 도달 시 Low  |
| **PWM2** | Low       | High      | CCR에 도달 시 High |

------

### ⑤ PWM 예시 (LED 밝기 제어)

```
htim3.Instance = TIM3;
htim3.Init.Prescaler = 71;   // 1MHz
htim3.Init.Period = 999;     // 1kHz PWM
HAL_TIM_PWM_Init(&htim3);

TIM_OC_InitTypeDef sConfigOC = {0};
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 500;       // 50% 듀티
HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);

HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
```

→ 1kHz PWM, 50% Duty 출력.
 CCR 값을 동적으로 변경하면 LED 밝기 조절 가능.

```
__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, new_duty);
```

------

### ⑥ Complementary PWM (고급 타이머 전용)

- TIM1, TIM8 등 Advanced Timer는 **CH1N~CH3N** 보조 채널을 지원.
- **Dead-Time** 삽입 가능 → 모터, 인버터 제어 시 스위칭 손실 방지.

```
TIM_BreakDeadTimeConfigTypeDef sBDTConfig = {0};
sBDTConfig.DeadTime = 80; // 80ns dead time
HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBDTConfig);
```

------

### ⑦ DMA 연동 PWM

DMA를 사용하면 실시간으로 CCR 값을 자동 업데이트하여 **파형 변조 (예: 사인파 생성)** 가능.

- DMA 소스: LUT 테이블 (예: 256개 Duty 값)
- DMA 대상: CCR 레지스터
- DMA Trigger: Timer Update Event

------

### ⑧ 실무 활용 예시

| 응용           | 설명                                         |
| -------------- | -------------------------------------------- |
| LED Dimmer     | PWM Duty 제어로 밝기 조절                    |
| DC Motor       | PWM로 속도 제어                              |
| Buzzer         | PWM 주파수 변경으로 음계 출력                |
| Servo Motor    | 20ms 주기, 1~2ms Duty로 각도 제어            |
| DAC 에뮬레이션 | PWM + 저역통과 필터(RC)로 아날로그 전압 생성 |

------

### ⑨ 주의사항

- PWM 출력 핀은 반드시 **Alternate Function (AFx)** 로 설정되어야 함.
- ARR, CCR 변경 후 즉시 반영하려면 **EGR.UG 비트**로 갱신.
- Duty=0 또는 Duty=ARR 시 출력이 상시 Low/High로 고정됨.
- 고속 PWM일수록 GPIO Slew Rate 설정과 출력 부하 고려 필요.

------

## 5.4 Input Capture / Encoder Interface

**Input Capture(IC)**와 **Encoder Interface**는 타이머 입력 신호를 기반으로 주파수, 펄스폭, 위치를 측정하는 기능이다.
 Input Capture는 외부 입력의 시간 간격을, Encoder Interface는 회전축의 각도 및 방향을 측정한다.

------

### ① Input Capture 기본 원리

타이머의 CNT 값은 지속적으로 증가(또는 감소)한다.
 특정 입력 핀에 상승/하강 에지가 감지되면 **현재 CNT 값이 CCRx 레지스터에 복사**된다.
 이를 통해 두 이벤트 간의 시간 간격을 측정할 수 있다.

| 항목                   | 설명                        |
| ---------------------- | --------------------------- |
| **Signal Input**       | 외부 입력 핀 (TIMx_CH1~CH4) |
| **Edge Detect**        | Rising, Falling, Both Edge  |
| **Captured Value**     | CNT 값이 CCRx로 복사됨      |
| **Period Calculation** | ΔCNT = CCRn - CCRn-1        |

------

### ② Input Capture 설정 예시

```
TIM_IC_InitTypeDef sConfigIC = {0};

htim2.Instance = TIM2;
htim2.Init.Prescaler = 71;     // 1MHz (1µs resolution)
htim2.Init.Period = 0xFFFF;
HAL_TIM_IC_Init(&htim2);

sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);

HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
```

인터럽트 발생 시 다음 콜백 실행:

```
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    static uint32_t prev = 0;
    if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
        uint32_t now = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
        uint32_t diff = (now >= prev) ? (now - prev) : (0xFFFF - prev + now);
        prev = now;
        float freq = 1.0f / (diff * 1e-6f); // Hz 단위
    }
}
```

------

### ③ 입력 주파수 / 펄스폭 측정

- **주기 측정:** 두 상승엣지 간 ΔCNT
- **펄스폭 측정:** 상승엣지 → 하강엣지 시간 간격

```
TIM_IC_InitTypeDef sConfigIC = {0};
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_BOTHEDGE;
```

------

### ④ Quadrature Encoder Interface

**Incremental Encoder**는 두 개의 위상차 90° 신호 (A, B)를 출력한다.
 STM32의 Encoder Mode는 두 채널의 위상 관계로 회전 방향과 위치를 자동 계산한다.

| 모드               | 입력 채널                         | 특징 |
| ------------------ | --------------------------------- | ---- |
| **Encoder Mode 1** | CH1만 카운트, CH2 방향 검출       |      |
| **Encoder Mode 2** | CH2만 카운트, CH1 방향 검출       |      |
| **Encoder Mode 3** | CH1, CH2 모두 카운트 (4배 해상도) |      |

```
htim3.Instance = TIM3;
htim3.Init.Prescaler = 0;
htim3.Init.Period = 1023; // 10-bit encoder
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
HAL_TIM_Encoder_InitTypeDef sConfig = {0};
sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
HAL_TIM_Encoder_Init(&htim3, &sConfig);
HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
```

CNT 값은 회전량을 나타내며, 방향 반전 시 자동 증가/감소한다.

------

### ⑤ 실무 활용 예시

| 응용                  | 설명                       |
| --------------------- | -------------------------- |
| 펄스 센서 주파수 측정 | 팬 속도, RPM 측정          |
| 초음파 거리 측정      | Echo 시간 측정             |
| PWM 입력 디코딩       | 입력 신호의 Duty/Freq 측정 |
| 로터리 엔코더         | 각도, 방향 검출            |
| 모터 위치 제어        | Encoder + PID 피드백       |

------

### ⑥ 주의사항

- 입력 핀은 반드시 **AF(Alternate Function Input)** 으로 설정.
- 고속 신호 입력 시 Noise Filter(ICFilter) 설정 필요.
- CNT Overflow 고려 (0xFFFF → 0으로 롤오버 시 보정 계산).
- 인터럽트 과다 발생 시 DMA 모드 활용 가능.

------

### ⑦ 요약

- Output Compare는 시간 기반 이벤트 생성, PWM은 신호 생성용 출력 모드.
- Input Capture는 외부 입력의 시간 분석, Encoder Interface는 회전량 측정에 사용.
- STM32 타이머는 출력/입력 제어 모두 지원하는 고정밀 타이밍 모듈로, 실시간 제어의 중심 역할을 한다.

## 5.5 One Pulse Mode / DMA 연동

STM32 타이머는 단순한 주기 생성기뿐만 아니라, **단 한 번만 정밀하게 동작하는 펄스(One Pulse Mode, OPM)** 도 만들 수 있다.
 이 기능은 트리거 신호 입력 후 한 번의 PWM 또는 토글 동작만 수행하고 자동 정지하는 형태로, 초음파 송신기, 정밀 타이밍 트리거, 측정 장비 등에 자주 사용된다.

또한, DMA(Direct Memory Access)를 활용하면 타이머의 CCR 레지스터에 데이터를 자동으로 전송하여 **PWM 패턴, 가변 주기, DAC 유사 출력** 등을 효율적으로 구현할 수 있다.

------

### ① One Pulse Mode 개념

| 항목            | 설명                                           |
| --------------- | ---------------------------------------------- |
| **목적**        | 트리거 입력 후 단 한 번의 펄스 발생            |
| **특징**        | CNT는 동작 후 자동 정지                        |
| **트리거 입력** | 내부/외부 신호 (TI1FP1, ETR 등)                |
| **활용 예시**   | 초음파 트리거, 카메라 셔터, 정밀 타이밍 이벤트 |

------

### ② 동작 순서

1. **CNT 정지 상태에서 대기**
2. **트리거 입력 발생 시 CNT 시작**
3. **지정된 비교 시점에 펄스 출력 후 자동 정지**

------

### ③ 설정 절차

```
TIM_OnePulse_InitTypeDef sConfig = {0};

htim2.Instance = TIM2;
htim2.Init.Prescaler = 71;     // 1MHz
htim2.Init.Period = 1000;      // 1ms
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);

sConfig.OCMode = TIM_OCMODE_PWM1;
sConfig.Pulse = 200;           // 200µs 펄스
sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfig.ICPolarity = TIM_ICPOLARITY_RISING;
sConfig.ICSelection = TIM_ICSELECTION_DIRECTTI;

HAL_TIM_OnePulse_ConfigChannel(&htim2, &sConfig, TIM_CHANNEL_1, TIM_CHANNEL_2);
HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_1);
```

위 설정은 외부 Rising Edge 입력 시, **200µs 폭의 펄스**가 한 번 출력된다.

------

### ④ PWM + One Pulse Mode 조합

- PWM 모드와 함께 사용하면 **한 번만 출력되는 PWM 파형** 구현 가능
- `HAL_TIM_PWM_Start` 대신 `HAL_TIM_OnePulse_Start` 사용
- Trigger 소스로 EXTI나 다른 타이머의 TRGO 사용 가능

------

### ⑤ DMA 연동 개념

DMA는 CPU 개입 없이 **메모리 → 주변장치** 간 데이터를 전송한다.
 PWM 출력 시 CCR 레지스터에 듀티 값을 자동 갱신시켜, **다단계 파형 생성**을 효율화할 수 있다.

| 항목        | 설명                                  |
| ----------- | ------------------------------------- |
| **소스**    | LUT 배열, 신호 데이터 버퍼            |
| **목적지**  | TIMx_CCRx (비교 레지스터)             |
| **Trigger** | Update Event (UEV) 또는 Compare Event |

------

### ⑥ DMA 연동 예시

```
uint32_t pwm_table[8] = {100, 200, 400, 600, 800, 600, 400, 200}; // Duty 패턴

HAL_TIM_PWM_Start_DMA(&htim3, TIM_CHANNEL_1, pwm_table, 8);
```

- Timer가 Update Event마다 `CCR1` 값을 변경
- LED 밝기가 부드럽게 변화하는 효과

------

### ⑦ DMA 동작 흐름

1. DMA Controller가 메모리의 데이터 버퍼를 참조
2. 타이머 이벤트(UEV) 발생 시 CCR 레지스터로 데이터 전송
3. CPU는 별도 개입 없이 실시간으로 PWM 듀티 갱신

------

### ⑧ 실무 활용

| 응용                | 설명                               |
| ------------------- | ---------------------------------- |
| 초음파 송신 트리거  | 40kHz 펄스 8개만 출력 후 정지      |
| PWM 패턴 생성       | LED Fade In/Out 자동 실행          |
| DAC 대체 출력       | PWM + RC 필터로 아날로그 파형 생성 |
| 모터 프로파일 제어  | 가속/감속 곡선 DMA로 로드          |
| 오실로스코프 트리거 | 외부 이벤트 후 단일 펄스 출력      |

------

### ⑨ 주의사항

- DMA 모드 사용 시 **HAL_TIM_PWM_Start_DMA()** 또는 **LL_TIM_EnableDMAReq_UPDATE()** 사용
- DMA 버퍼는 `static` 또는 전역 변수로 선언 (스택 해제 방지)
- OPM은 자동으로 CNT 정지 → 반복 동작 시 **재시작 필요**
- Trigger Source 선택은 CubeMX의 “Slave Mode Configuration” 탭에서 설정 가능

------

## 5.6 SysTick vs General Purpose Timer 비교

STM32에는 여러 종류의 타이머가 있다. 그중 **SysTick Timer**는 코어 내부에 존재하며, **OS Tick 및 Delay 관리**에 사용되고,
 **General Purpose Timer (TIM2~TIM5 등)** 는 하드웨어 타이밍, PWM, Input Capture 등 **주변 제어**에 사용된다.

------

### ① SysTick Timer

| 항목              | 설명                          |
| ----------------- | ----------------------------- |
| **위치**          | Cortex-M 코어 내부            |
| **주요 용도**     | OS Tick (1ms), HAL_Delay() 등 |
| **클록 소스**     | HCLK 또는 HCLK/8              |
| **정확도**        | 클록 주파수에 의존 (보통 1ms) |
| **인터럽트 기반** | `SysTick_Handler()` 주기 호출 |
| **장점**          | 설정 간단, OS와 연동 용이     |
| **단점**          | PWM, Input Capture 등은 불가  |

```
void SysTick_Handler(void)
{
  HAL_IncTick(); // HAL_Delay() 관리
}
```

- 일반적으로 HAL 초기화 시 자동 설정 (`HAL_Init()` 내부)
- RTOS 환경에서는 **FreeRTOS Tick**으로도 사용됨

------

### ② General Purpose Timer

| 항목              | 설명                                      |
| ----------------- | ----------------------------------------- |
| **위치**          | 주변장치 (APB 버스에 연결)                |
| **주요 용도**     | PWM, Input Capture, Encoder, One Pulse 등 |
| **클록 소스**     | APB1/APB2 Peripheral Clock                |
| **정확도**        | 매우 높음 (하드웨어 이벤트 단위)          |
| **인터럽트 기반** | 각 채널 별 ISR 지원                       |
| **장점**          | 다기능, 실시간 제어 가능                  |
| **단점**          | 설정 복잡, 자원 소모 큼                   |

------

### ③ 기능 비교 표

| 기능          | SysTick          | General Timer        |
| ------------- | ---------------- | -------------------- |
| 타이머 개수   | 1개 (고정)       | 다수 (TIM2~TIM17 등) |
| 해상도        | 보통 1ms         | µs ~ ns 단위 가능    |
| PWM 출력      | 불가             | 가능                 |
| 입력 캡처     | 불가             | 가능                 |
| DMA 연동      | 불가             | 가능                 |
| NVIC 우선순위 | 낮음 (코어 전용) | 개별 설정 가능       |
| OS Tick       | 지원             | 별도 구성 필요       |
| 전력 소모     | 낮음             | 주변장치 활성 필요   |

------

### ④ 사용 시 선택 기준

| 목적                 | 추천 타이머                        |
| -------------------- | ---------------------------------- |
| Delay, OS Tick       | **SysTick**                        |
| PWM, 모터 제어       | **General Timer**                  |
| 주파수 측정          | **General Timer (Input Capture)**  |
| 엔코더 입력          | **General Timer (Encoder Mode)**   |
| 단일 트리거 이벤트   | **General Timer (One Pulse Mode)** |
| 시스템 스케줄러 Tick | **SysTick / RTOS Tick Timer**      |

------

### ⑤ 예시: SysTick 기반 vs TIM 기반 Delay

**SysTick 사용**

```
HAL_Delay(1000); // 1초 지연 (SysTick 기반)
```

**TIM 기반**

```
__HAL_TIM_SET_COUNTER(&htim4, 0);
while (__HAL_TIM_GET_COUNTER(&htim4) < 1000); // µs 단위 지연
```

SysTick은 1ms 단위이므로 **정밀 제어에는 부적합**, 반면 TIM은 µs 단위로 동작 가능하다.

------

### ⑥ 요약

| 구분                    | SysTick | General Timer |
| ----------------------- | ------- | ------------- |
| 코어 내부               | O       | X             |
| HAL_Delay, RTOS Tick    | O       | X             |
| PWM / Capture / Encoder | X       | O             |
| µs 정밀도               | X       | O             |
| 설정 난이도             | 낮음    | 높음          |
| 실시간 제어 적합성      | 낮음    | 매우 높음     |

> 즉, **SysTick은 시스템 시간 관리용**, **General Timer는 하드웨어 제어용**이다.
>  STM32 프로젝트에서는 두 타이머를 함께 사용하여 **논리적 제어와 물리적 제어를 분리**하는 것이 일반적이다.

## 5.7 Timer Interrupt / Callback 활용

STM32의 타이머는 단순히 PWM이나 Delay 생성뿐 아니라, **정해진 주기마다 자동으로 인터럽트를 발생시키는 기능**을 제공한다.
 이를 이용하면 주기적 작업(LED 점멸, 센서 샘플링, 제어 루프 실행 등)을 **정확한 하드웨어 기반 주기**로 수행할 수 있다.
 HAL 라이브러리에서는 타이머 이벤트 발생 시 **콜백 함수(`HAL_TIM_PeriodElapsedCallback`)** 를 통해 사용자 코드 실행이 가능하다.

------

### ① 타이머 인터럽트 개념

| 항목              | 설명                                                   |
| ----------------- | ------------------------------------------------------ |
| **발생 조건**     | 타이머의 CNT 값이 ARR(자동재장전 레지스터)에 도달할 때 |
| **인터럽트 소스** | Update Event (UEV)                                     |
| **ISR 연결**      | NVIC를 통해 타이머별 핸들러 등록                       |
| **콜백 호출**     | HAL이 내부 ISR 처리 후 사용자 콜백 호출                |

즉, 타이머는 일정 주기로 “Update Event”를 발생시키고, HAL은 이를 감지하여 `HAL_TIM_PeriodElapsedCallback()` 함수를 자동 실행한다.

------

### ② CubeMX 설정 절차

1. **Peripherals → Timers → TIMx 선택**
2. **Mode**: "Internal Clock" 선택
3. **Configuration → NVIC Settings** 탭에서 `TIMx global interrupt` 활성화
4. **Parameter Settings**에서 `Prescaler`, `Counter Period` 설정
   - 예: 1MHz 클록, 주기 1000 → 1ms 인터럽트
5. 코드 생성 후, `MX_TIMx_Init()` 내부에서 초기화 코드 확인

------

### ③ 코드 예제

```
#include "main.h"

TIM_HandleTypeDef htim2;

void SystemClock_Config(void);
static void MX_TIM2_Init(void);
static void MX_GPIO_Init(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_TIM2_Init();

    HAL_TIM_Base_Start_IT(&htim2); // 타이머 인터럽트 시작

    while (1)
    {
        // 메인 루프는 유휴 상태
    }
}

// 인터럽트 발생 시 호출되는 콜백 함수
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM2)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 1ms마다 LED 토글
    }
}
```

------

### ④ 주요 HAL 함수 설명

| 함수                              | 설명                                     |
| --------------------------------- | ---------------------------------------- |
| `HAL_TIM_Base_Start_IT()`         | 타이머를 인터럽트 모드로 시작            |
| `HAL_TIM_IRQHandler()`            | NVIC ISR에서 호출되는 HAL 내부 처리 루틴 |
| `HAL_TIM_PeriodElapsedCallback()` | Update Event 발생 시 사용자 정의 콜백    |
| `__HAL_TIM_CLEAR_FLAG()`          | 수동으로 인터럽트 플래그 클리어          |

CubeIDE에서 자동 생성된 `stm32f1xx_it.c` 내 ISR은 다음과 같이 구성된다:

```
void TIM2_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&htim2);
}
```

HAL은 이 ISR에서 인터럽트 소스 플래그를 확인한 후, 자동으로 콜백을 호출한다.

------

### ⑤ 주기 계산 예시

타이머 주기는 다음 식으로 결정된다:
$$
T_{update} = \frac{(PSC + 1) \times (ARR + 1)}{f_{timer\_clk}}
$$
예시:

- Timer Clock = 72MHz
- Prescaler = 7199
- Period (ARR) = 999

$$
T_{update} = \frac{(7199+1) \times (999+1)}{72MHz} = 0.1s = 100ms
$$

즉, 100ms마다 인터럽트 발생 → 초당 10회 호출.

------

### ⑥ NVIC 설정

타이머 인터럽트가 정상 작동하려면 NVIC(중첩 벡터 인터럽트 컨트롤러)에 등록되어야 한다.
 CubeMX에서는 자동으로 설정되지만, 수동 등록 시 다음과 같이 작성한다.

```
HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(TIM2_IRQn);
```

------

### ⑦ 실무 활용 예시

| 응용                     | 설명                                              |
| ------------------------ | ------------------------------------------------- |
| **LED Blinking**         | 간단한 시각 피드백, heartbeat 용도                |
| **센서 샘플링**          | 1kHz 인터럽트 기반 주기적 ADC 변환 트리거         |
| **제어 루프 (PID)**      | 1ms 주기로 엔코더 및 모터 제어 수행               |
| **타임슬롯 스케줄러**    | 다중 작업의 주기적 분배                           |
| **UART Polling Timeout** | Timer로 일정 시간 내 데이터 미수신 시 이벤트 발생 |

------

### ⑧ FreeRTOS와의 관계

- FreeRTOS 사용 시, 타이머 인터럽트는 RTOS Tick과 별도로 동작 가능.

- ISR 내에서 FreeRTOS API를 직접 호출하지 말고, **Event Flag / Queue / Task Notification** 방식으로 전달해야 한다.

  ```
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  vTaskNotifyGiveFromISR(xTaskHandle, &xHigherPriorityTaskWoken);
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  ```

------

### ⑨ 디버깅 시 유의사항

- NVIC 활성화 여부 확인 (`TIMx global interrupt` Enable).
- `htimx.Instance` 일치 여부 확인 (콜백 다중 등록 시 혼동 방지).
- 인터럽트 중 HAL_Delay() 사용 금지 (SysTick 충돌).
- 인터럽트가 너무 짧은 주기로 발생하면 CPU 부하 급증 가능.

------

### ⑩ 확장 응용

| 기능                     | 활용 방식                                     |
| ------------------------ | --------------------------------------------- |
| **멀티 타이머 스케줄링** | TIM2: 1ms, TIM3: 100ms, TIM4: 1s 주기로 분리  |
| **하드웨어 동기화**      | TIM1 → TRGO → TIM2 슬레이브 트리거 구성       |
| **DMA 트리거**           | TIMx Update Event로 DMA 요청 발생             |
| **ADC 트리거**           | TIMx TRGO 설정 후 ADC External Trigger로 연결 |

------

### ⑪ LL 드라이버 기반 구현 예시

```
LL_TIM_EnableIT_UPDATE(TIM2);
LL_TIM_EnableCounter(TIM2);

void TIM2_IRQHandler(void)
{
    if (LL_TIM_IsActiveFlag_UPDATE(TIM2))
    {
        LL_TIM_ClearFlag_UPDATE(TIM2);
        LL_GPIO_TogglePin(GPIOC, LL_GPIO_PIN_13);
    }
}
```

LL(저수준) 드라이버를 사용하면 오버헤드가 적고, ISR 실행 속도가 빠르다.
 실시간 제어(모터, 서보, PWM Sync) 환경에서는 HAL보다 LL이 더 적합하다.

------

### ⑫ 요약

| 항목            | 내용                                                         |
| --------------- | ------------------------------------------------------------ |
| **핵심 함수**   | `HAL_TIM_Base_Start_IT()`, `HAL_TIM_PeriodElapsedCallback()` |
| **주기 계산식** | `(PSC + 1) × (ARR + 1) / TimerClock`                         |
| **콜백 활용**   | 주기적 작업, 타이밍 제어, 이벤트 발생                        |
| **주의점**      | 인터럽트 내 HAL_Delay() 금지, NVIC 설정 필수                 |
| **확장성**      | DMA / ADC / PWM 트리거 등 하드웨어 연동 가능                 |

> 타이머 인터럽트는 **정확한 주기 제어의 핵심 메커니즘**이며,
>  STM32 실시간 시스템의 기반이 되는 가장 중요한 주변장치 중 하나이다.