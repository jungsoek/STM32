# 12. External Interrupt / NVIC

## 12.1 인터럽트 구조 및 벡터 테이블

### 개요 — 인터럽트의 역할과 구성 요소

인터럽트는 CPU의 정상 실행 흐름을 일시 정지시키고 우선 처리해야 할 이벤트에 대해 즉시 제어를 넘기는 메커니즘이다.
 ARM Cortex-M 기반 STM32에서는 인터럽트 관련 핵심 구성요소가 다음과 같다.

- **NVIC (Nested Vectored Interrupt Controller)**: 우선순위 및 벡터 기반 인터럽트 디스패치 담당. 중첩(interrupt nesting)과 우선순위 기반 선점(preemption) 관리.
- **SCB (System Control Block)**: 예외/리셋/벡터 테이블 주소(VTOR) 관리, 시스템 예외 관련 레지스터 제공.
- **벡터 테이블(Vector Table)**: 예외/인터럽트 서비스 루틴(ISR) 주소 목록. 초기 스택 포인터와 Reset Handler가 테이블의 첫 항목들.
- **Peripherals**: 각 주변장치에서 발생한 IRQ가 NVIC로 전달되어 핸들러 실행.

벡터 테이블의 형식과 NVIC의 동작 원리는 시스템 부팅, ISR 진입/복귀, 우선순위 구성, ISR 작성 관례(weak 심볼 오버라이드 등)와 밀접히 연결된다.

------

### 벡터 테이블 포맷과 메모리 위치

벡터 테이블은 32-bit 엔트리의 연속 배열이다. 각 엔트리는 예외 또는 외부 IRQ에 해당하는 핸들러의 함수 포인터(즉시 실행할 주소)이다.

- **첫 두 엔트리**
  1. Initial Main Stack Pointer (MSP) 값
  2. Reset Handler 주소
- **그 다음 항목들**
  - 기본 시스템 예외(Reset, NMI, HardFault, MemManage, BusFault, UsageFault, SVCall, PendSV, SysTick 등)
  - 구현별 외부 IRQ 핸들러들 (Device specific IRQs)

표준 위치:

- 기본적으로 **플래시(예: 0x0800_0000)** 에 고정되어 링크되며, 부트로더/어플리케이션 구조에 따라 다른 주소(예: 0x0800_4000)로 배치 가능.
- **SCB->VTOR** 레지스터를 통해 벡터 테이블을 RAM으로 옮겨 동적으로 재설정할 수 있음 (예: 부트로더 → 애플리케이션 전환, 런타임 ISR 수정). VTOR는 128-byte 정렬(실제 구현 요구사항 확인) 또는 16바이트/32바이트 정렬 제한을 요구할 수 있으므로 구현 자료 확인 권장.

링커 관점:

- 링커 스크립트(.ld)에 `.isr_vector` 섹션을 정의하여 벡터 테이블의 위치와 정렬을 지정한다.

------

### 예외와 IRQ 번호 체계 (IRQn_Type)

Cortex-M 예외는 음수 값을 갖는 정수로 정의되고, 외부 인터럽트(Peripherals)는 0 이상의 정수로 정의된다. 예:

- 예외(negative): Reset, NMI, HardFault, MemManage, BusFault, UsageFault, SVCall, PendSV, SysTick 등
- 외부 IRQ (non-negative): EXTI0, USART1, I2C1_EV 등 (MCU별로 수와 번호 다름)

CMSIS에서는 `IRQn_Type` 열거형을 통해 이 매핑을 제공하므로 코드에서는 이 타입을 사용해 NVIC 관련 API를 호출한다.

------

### ISR 진입/스택 프레임 (하드웨어 스택킹)

Cortex-M 예외 진입 시 하드웨어가 자동으로 다음 레지스터들을 스택에 푸시(stacking)한다.

- 자동 푸시 레지스터(기본): `R0, R1, R2, R3, R12, LR, PC, xPSR` (총 8 워드)
- FPU가 활성화된 경우(및 lazy stacking 설정에 따라): 추가로 S0..S15, FPSCR 등이 스택될 수 있음 (FPU 스택킹)

ISR가 시작되면 CPU는 제공된 LR(특수값, EXC_RETURN)을 사용해 적절한 복귀 시퀀스를 수행한다. 이 하드웨어 스택킹은 ISR 구현자가 컨텍스트 저장/복원을 직접하지 않아도 되는 근거다. 단, ISR에서 추가 레지스터(예: R4~R11)를 사용하면 컴파일러가 프로로그/에필로그에서 자동으로 저장/복원한다.

------

### 우선순위 구조: preemption vs subpriority

NVIC에서 우선순위는 **그룹핑(priority grouping)** 에 따라 Preemption Priority(선점 우선순위)와 Subpriority(동일 우선순위 내 순서)를 조합하여 표현된다.

- **Priority grouping** (NVIC_SetPriorityGrouping / CMSIS `NVIC_SetPriorityGrouping`) 으로 전역 분할 수 지정.
  - 예: 4비트 우선순위를 갖는 경우 `PREEMPTION_BITS + SUBPRIORITY_BITS = 4`.
- **NVIC_SetPriority(IRQn, priority)** 또는 HAL의 `HAL_NVIC_SetPriority(IRQn, preempt, sub)` 로 우선순위 설정.
- **선점 동작**: 우선순위(Preemption)가 낮은 ISR이 실행 중일 때, 더 높은 preemption 우선순위의 IRQ가 들어오면 현재 ISR이 중단되고 높은 우선순위 ISR로 전환(선점)된다.
- **tail-chaining**: ISR A가 끝나자마자 처리 대기 중인 ISR B가 있으면 복귀 없이 곧바로 B로 분기하여 오버헤드 최소화.
- **late arriving interrupt**: 이미 우선순위 검증이 진행 중인 경우 처리 방식의 최적화가 존재(하드웨어 레벨).

우선순위 수와 세부 동작은 Cortex-M 타입(Cortex-M0/M3/M4/M7 등)과 구현 세부에 따라 달라지므로, 우선순위 비트 수(예: 3비트, 4비트)를 확인해야 한다.

------

### 시스템 예외 (Faults) — 주요 예외와 대응

- **HardFault**: 치명적 예외. 복구 불가 수준의 오류(예: 벡터 테이블 문제, EXC_RETURN 오류). HardFault 핸들러에서 레지스터 스택 프레임(PC, LR, R0..R3 등) 덤프 후 디버깅 권장.
- **MemManage (Memory Management Fault)**: MPU 위반, 유효하지 않은 메모리 접근 등.
- **BusFault**: 버스 에러(AXI/AHB 등), 외부 버스 오류.
- **UsageFault**: 잘못된 명령, 알라인먼트 오류, 스택 언더/오버플로 등.
- **DebugFault / SecureFault 등**: 구현에 따라 추가.

Fault 핸들링은 `SCB->HFSR`, `SCB->CFSR`, `SCB->MMFAR`/`SCB->BFAR` 등의 레지스터를 통해 상세 원인을 확인할 수 있다.

------

### 벡터 테이블 작성 관례 (startup code & weak symbols)

- 스타트업 코드(startup.s / startup_stm32xx.s)는 `.isr_vector` 섹션을 정의하고, weak 심볼로 default handler를 선언한 뒤 사용자가 같은 이름의 함수(예: `void USART1_IRQHandler(void)`)를 정의하면 링커가 이를 오버라이드한다.
- weak 선언 예: `void __attribute__((weak)) USART1_IRQHandler(void) { while(1); }`
- C++ 사용 시 `extern "C"`로 ISR을 선언해야 이름 맹글링 방지.

------

### 동적 벡터 테이블 (RAM으로의 relocation)

런타임에 ISR 포인터를 바꿔야 하는 경우(예: 부트로더 → 애플리케이션 전환, 플러그인 드라이버 등), 벡터 테이블을 RAM에 복사하고 **SCB->VTOR = (uint32_t)ram_vector_table** 으로 설정하여 동작한다. 유의점:

- RAM 테이블은 충분히 정렬(aligned)되어야 함(보통 128바이트 또는 256바이트 경계).
- VTOR 변경 전 인터럽트 비활성화 권장.
- 복사 후 링크/주소 보정을 정확히 해야 한다.

------

### NVIC API 및 HAL 사용 예제

```
// NVIC 우선순위 설정 (CMSIS)
NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2); // 예: 2비트 preemption, 2비트 subpriority
NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 1, 0));
NVIC_EnableIRQ(USART1_IRQn);

// HAL 방식
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0); // preempt=5, sub=0
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
```

핵심 권장사항:

- IRQ를 활성화하기 전 우선순위를 먼저 설정하라.
- ISR 내부에서 긴 작업(예: printf, 블로킹 I/O)을 피하고, 플래그/큐에 데이터를 넣은 뒤 빠르게 복귀하라.

------

### ISR 작성 모범 사례 및 주의사항

- **짧고 빠르게**: ISR은 가능한 한 짧게 유지하고, 복잡한 처리는 메인 루프나 RTOS 태스크에서 처리.
- **상태 플래그 사용**: ISR에서는 상태 플래그(volatile) 설정 또는 FreeRTOS Queue/Notify 사용.
- **인터럽트 재진입/동기화**: 공유 데이터 접근 시 atomic 처리 또는 critical section, mutex 사용(특히 ISR ↔ Task 간).
- **플래그/레지스터 클리어**: 주변장치의 인터럽트 원인 플래그를 반드시 적절히 클리어하지 않으면 ISR이 즉시 재진입될 수 있음.
- **스택 사용 고려**: ISR가 호출될 때 사용되는 스택은 충분히 확보되어야 한다(특히 RTOS와 FPU 사용 시).
- **우선순위와 API 제약**: 일부 CMSIS/HAL/RTOS 함수는 특정 IRQ 우선순위 범위에서만 안전하게 호출 가능. (ex: FreeRTOS API from ISR 전용 함수 사용)

------

### 예외 복귀 및 EXC_RETURN 값

ISR 종료 시 LR에 저장된 EXC_RETURN 값은 복귀 동작을 결정한다(예: PSP 또는 MSP 복귀, FPU 상태 복구 등). EXC_RETURN의 비트 값은 복귀 경로를 지정하므로, 이 동작을 수동으로 조작하면 안 된다. 대신 ISR은 정상적으로 리턴(return)하면 하드웨어가 자동으로 복구한다.

------

### 디버깅 팁 — 흔한 문제와 점검 포인트

- ISR 미실행: NVIC_EnableIRQ 누락, 우선순위 0이 아닌데 상위 우선순위에 의해 숨겨짐, 인터럽트 소스 플래그 미설정.
- ISR 반복 호출(룹): 주변장치의 인터럽트 클리어 미흡.
- HardFault 발생: ISR에서 스택 오버플로우, 잘못된 함수 포인터(벡터 테이블 오류), 비정렬 VTOR.
- 벡터 테이블 복사 실패: VTOR 정렬/주소 오류 확인.

확인 명령:

- `SCB->ICSR`(pending bits), `SCB->HFSR`(HardFault status), `SCB->CFSR`(Configurable Fault Status Register), `NVIC_GetPendingIRQ()`, `NVIC_GetActive()` 등 사용.

------

### 요약 체크리스트 (설계/구현 시)

1. 벡터 테이블을 링크 스크립트에 정확히 배치하고 정렬을 확인한다.
2. 스타트업에서 초기 MSP/Reset Handler가 올바르게 설정되는지 검증한다.
3. NVIC 우선순위 그룹을 시스템 요구에 맞게 설정한다.
4. 각 IRQ에 대해 우선순위와 enable을 명시적으로 설정한다.
5. ISR은 짧게 유지하고, 플래그/큐로 작업을 위임한다.
6. 인터럽트 플래그/레지스터를 ISR 내에서 확실히 클리어한다.
7. 동적 벡터 테이블 사용 시 VTOR 정렬과 복사 로직을 검증한다.
8. Fault 핸들러에서 레지스터 스택 프레임을 덤프하여 원인 분석이 가능하도록 준비한다.

## 12.2 HAL_NVIC_SetPriority()

### 개요 — NVIC 우선순위 설정의 목적

`HAL_NVIC_SetPriority()` 함수는 **Cortex-M 프로세서의 NVIC(Nested Vectored Interrupt Controller)** 에서 특정 인터럽트(IRQ)의 우선순위를 설정하는 HAL 계층 API이다.
 이 함수는 **인터럽트의 선점(Preemption)** 과 **동일 그룹 내 우선순위(Subpriority)** 를 결정하며, 시스템 안정성과 응답 시간을 좌우하는 핵심 설정 중 하나이다.

STM32 HAL은 이 함수를 통해 CMSIS의 `NVIC_SetPriority()`를 래핑(wrap)하며, 내부적으로 **Priority Grouping**(우선순위 비트 분할 구조)을 고려한 인코딩 과정을 수행한다.

------

### 함수 원형 및 정의

```
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
```

**매개변수 설명:**

| 인자              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| `IRQn`            | 설정할 인터럽트 번호. CMSIS에서 정의된 `IRQn_Type` 열거형 사용 (예: `EXTI0_IRQn`, `USART1_IRQn` 등). |
| `PreemptPriority` | 선점 우선순위 (숫자가 낮을수록 높은 우선순위).               |
| `SubPriority`     | 동일 그룹 내 서브 우선순위 (Preemption이 같을 때 실행 순서 결정). |

------

### 내부 동작 원리

HAL의 `HAL_NVIC_SetPriority()` 함수는 CMSIS NVIC API를 기반으로 다음 절차를 수행한다.

1. **현재 Priority Group 읽기**
   - `NVIC_GetPriorityGrouping()`을 통해 현재 설정된 그룹 비트 수를 읽음.
   - 이 그룹 비트 수는 `HAL_NVIC_SetPriorityGrouping()` 또는 `NVIC_SetPriorityGrouping()`으로 사전에 지정해야 함.
2. **우선순위 인코딩(Encoding)**
   - Cortex-M의 우선순위 레벨은 “PreemptPriority + SubPriority” 조합으로 표현된다.
   - HAL은 `NVIC_EncodePriority(group, preempt, sub)` 함수를 이용해 두 값을 하나의 하드웨어 우선순위 값으로 변환한다.
3. **실제 NVIC 레지스터에 우선순위 기록**
   - `NVIC_SetPriority(IRQn, encoded_priority)` 호출로 각 IRQ의 PRI 레지스터 필드에 값을 씀.
   - 하드웨어의 우선순위 비트 수(예: 4비트, 8비트 등)는 MCU에 따라 다름.

------

### 예시 — 기본적인 설정 흐름

```
// 1. NVIC 그룹 설정 (전역)
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);  
// => Preemption 2비트, Subpriority 2비트 구조

// 2. 특정 인터럽트 우선순위 지정
HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);  
HAL_NVIC_EnableIRQ(EXTI0_IRQn);

// 3. 또 다른 인터럽트의 우선순위 지정
HAL_NVIC_SetPriority(USART1_IRQn, 2, 1);
HAL_NVIC_EnableIRQ(USART1_IRQn);
```

**설명:**

- `EXTI0_IRQn`의 Preemption Priority가 `1`이므로, `USART1_IRQn`(2)보다 우선 실행됨.
- 동일 Preemption Priority일 경우 `SubPriority` 값이 작은 쪽이 먼저 서비스된다.

------

### Priority Grouping의 개념 (핵심 이해 포인트)

Cortex-M NVIC는 우선순위 비트를 “Preemption bits”와 “Subpriority bits”로 나누어 사용한다.
 이 비트 분할 구조는 **NVIC_PRIORITYGROUP_x** 상수로 정의되어 있다.

| 그룹 매크로          | Preemption 비트 수 | SubPriority 비트 수 |
| -------------------- | ------------------ | ------------------- |
| NVIC_PRIORITYGROUP_0 | 0                  | 4                   |
| NVIC_PRIORITYGROUP_1 | 1                  | 3                   |
| NVIC_PRIORITYGROUP_2 | 2                  | 2                   |
| NVIC_PRIORITYGROUP_3 | 3                  | 1                   |
| NVIC_PRIORITYGROUP_4 | 4                  | 0                   |

즉,

- `NVIC_PRIORITYGROUP_4`는 **Subpriority 없음**, 선점만 가능.
- `NVIC_PRIORITYGROUP_0`는 **모두 Subpriority**, 선점 불가.

이 분할 구조는 ISR 간의 중첩 허용 여부와 응답 지연에 직접적인 영향을 미친다.

------

### 내부 구현 코드 (stm32f1xx_hal_cortex.c)

```
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(
      IRQn,
      NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority)
  );
}
```

**핵심 포인트:**

- HAL은 CMSIS 함수 `NVIC_SetPriority()`와 `NVIC_EncodePriority()`를 직접 호출한다.
- 실제로 CMSIS의 이 두 함수가 모든 Cortex-M에서 공통으로 동작한다.

------

### 하드웨어 제한 사항

1. **유효 비트 수 제한**
   - STM32F1 시리즈: 4비트(0~15), STM32H7 시리즈: 8비트(0~255)까지 사용 가능.
   - 남는 비트는 무시되므로, `PreemptPriority` / `SubPriority`가 너무 크면 자동으로 마스킹된다.
2. **숫자가 작을수록 높은 우선순위**
   - `PreemptPriority = 0`은 가장 높은 우선순위.
   - 우선순위가 동일한 인터럽트는 중첩되지 않으며, pending 상태로 대기함.
3. **System Exception (HardFault 등)은 NVIC 우선순위 설정 불가**
   - HardFault, NMI 등은 고정 우선순위를 가지며 조정할 수 없다.

------

### HAL과 CMSIS의 차이점

| 구분                   | HAL_NVIC_SetPriority()        | NVIC_SetPriority()             |
| ---------------------- | ----------------------------- | ------------------------------ |
| 우선순위 그룹 고려     | O                             | X (직접 인코딩 필요)           |
| HAL 레벨에서 호출 권장 | O                             | CMSIS 직접 접근 시 주의 필요   |
| FreeRTOS와 연동        | HAL 권장 (시스템 일관성 유지) | 가능하나 그룹 설정 불일치 주의 |

즉, HAL 기반 프로젝트에서는 반드시 HAL 함수로 일관성 있게 설정해야 한다.

------

### 예시 — FreeRTOS와의 연동 시 주의점

FreeRTOS는 **IRQ 우선순위의 상한선**을 정의하여, 커널보다 높은 우선순위의 ISR에서 RTOS API 호출이 불가능하다.

```
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5
```

따라서 HAL_NVIC_SetPriority를 사용할 때는:

```
HAL_NVIC_SetPriority(USART1_IRQn, 6, 0); // OK (RTOS 호출 가능)
HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);  // X (RTOS API 호출 불가)
```

이처럼 FreeRTOS를 사용할 때는 **configMAX_SYSCALL_INTERRUPT_PRIORITY보다 낮은(숫자가 큰) 우선순위만 RTOS API 호출 허용**된다.

------

### 디버깅 팁

- NVIC의 실제 설정 확인:

  ```
  NVIC_GetPriority(IRQn);
  NVIC_GetPriorityGrouping();
  ```

- 잘못된 우선순위 그룹 설정 시, `HAL_NVIC_SetPriority()` 호출이 의도한 대로 작동하지 않음.

- ISR이 실행되지 않으면 `NVIC_EnableIRQ()` 호출 여부, `__enable_irq()` 활성화 상태 확인.

- HAL 라이브러리 버전에 따라 Default Priority Group이 다를 수 있음 (예: NVIC_PRIORITYGROUP_4).

------

### 실습 예제 — EXTI 버튼 우선순위 비교

```
void MX_NVIC_Init(void)
{
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);

    // 우선순위 높은 외부 인터럽트 (긴급 스위치)
    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);

    // 우선순위 낮은 UART 수신
    HAL_NVIC_SetPriority(USART1_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
}
```

**동작 설명:**

- `EXTI0`(긴급버튼)이 발생하면, 현재 UART ISR 실행 중이라도 **즉시 선점**되어 실행된다.
- 두 인터럽트 모두 끝나면 NVIC가 자동으로 원래 ISR 복귀를 수행한다.

------

### 요약 체크리스트

1. `HAL_NVIC_SetPriorityGrouping()`으로 우선순위 그룹 먼저 설정.
2. `HAL_NVIC_SetPriority()`로 IRQ별 선점/서브 우선순위 지정.
3. `HAL_NVIC_EnableIRQ()`로 인터럽트 활성화.
4. ISR 내부에서는 빠른 처리와 적절한 플래그/큐 사용.
5. FreeRTOS 사용 시 IRQ 우선순위 제한을 반드시 준수.
6. CMSIS 직접 접근 대신 HAL API 일관 사용 권장.

## 12.3 Nested Interrupt 시 주의사항

### 1. Nested Interrupt(중첩 인터럽트)란

- **Nested Interrupt**란, 하나의 인터럽트(ISR, Interrupt Service Routine)가 실행되는 도중 **더 높은 우선순위의 다른 인터럽트가 발생할 경우**, 현재 ISR 실행을 **일시 중단하고 새로운 인터럽트를 처리**한 뒤 복귀하는 구조를 말한다.
- STM32는 **NVIC(Nested Vectored Interrupt Controller)**를 통해 이러한 중첩 인터럽트를 **자동으로 관리**하며, 벡터 테이블과 우선순위 시스템에 의해 실행 순서를 제어한다.

------

### 2. NVIC의 우선순위 구조

- **NVIC_PriorityGroupConfig** 또는 `HAL_NVIC_SetPriorityGrouping()`을 통해 그룹화 방식을 설정한다.
- 우선순위는 두 가지로 나뉜다:
  - **Preemption Priority (선점 우선순위)**: 현재 실행 중인 인터럽트를 **중단할 수 있는지** 여부 결정
  - **Sub Priority (서브 우선순위)**: **동일한 Preemption Priority 내에서** 실행 순서를 결정

| 예시    | 설명                               |
| ------- | ---------------------------------- |
| Group 0 | Preemption 0bit / SubPriority 4bit |
| Group 4 | Preemption 4bit / SubPriority 0bit |

> 즉, Preemption Priority가 낮은 인터럽트는 높은 인터럽트에 의해 언제든 **중단될 수 있음**.

------

### 3. Nested Interrupt의 실행 과정 예시

1. `TIM2_IRQHandler()` 실행 중
2. `USART1_IRQHandler()` 발생 (더 높은 우선순위)
3. NVIC가 TIM2 ISR을 **자동으로 스택에 저장하고 중단**
4. USART1 ISR 실행 완료 후 NVIC가 **TIM2 ISR 복귀**
5. 원래 TIM2 ISR 실행 재개

➡ 이렇게 하드웨어적으로 스택을 통해 **자동 중첩 관리**가 이루어진다.

------

### 4. 중첩 인터럽트 시 주의해야 할 문제점

#### (1) 스택 오버플로(Stack Overflow) 위험

- ISR이 중첩될수록 MCU는 **현재 레지스터 상태를 스택에 저장**해야 하므로, **중첩 깊이가 깊을수록 스택 메모리 사용량 증가**.
- FreeRTOS나 RTOS 환경에서는 **태스크 스택과 ISR 스택이 분리**되지 않아, 예기치 않게 스택이 초과될 수 있다.

> → 해결: 중첩 깊이를 제한하거나, ISR 내부에서 다른 인터럽트를 차단(`__disable_irq()` / `__enable_irq()` 적절히 사용)

------

#### (2) ISR 내 장시간 처리 금지

- ISR은 가능한 짧게 유지해야 하며, 중첩 시에는 **우선순위 역전(priority inversion)** 또는 **타이밍 지연(jitter)**이 발생할 수 있다.
- 긴 처리나 연산은 ISR 내부에서 하지 않고, **Flag 설정 후 메인 루프나 Task에서 처리**하도록 설계.

------

#### (3) 공유 자원 접근 문제 (Concurrency Issue)

- 중첩 인터럽트 시 동일한 전역 변수나 주변장치 레지스터를 동시에 접근하면 **Data Race** 발생 가능.

> → 해결책:

- `volatile` 키워드 사용
- 임계구역 보호 (`__disable_irq()` / `__enable_irq()` or FreeRTOS `taskENTER_CRITICAL()` 등)
- Circular Buffer 사용

------

#### (4) 인터럽트 우선순위 설정 오류

- 동일한 Preemption Priority로 설정된 경우 **중첩 불가**, 즉 하나가 끝나야 다른 것이 실행됨.
- 반대로 모든 인터럽트를 낮은 그룹으로 설정하면 **의도치 않게 중첩이 과도하게 발생**할 수 있다.

**예시 (적절한 설정):**

```
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);  // 높은 우선순위
HAL_NVIC_SetPriority(TIM2_IRQn,   1, 0);  // 낮은 우선순위
```

------

### 5. Nested Interrupt 사용 시 베스트 프랙티스

1. **ISR 내부 최소화**
   - 데이터 읽기/저장만 수행하고, 실제 처리는 main loop나 RTOS task에서 수행
2. **중첩 깊이 제어**
   - NVIC 우선순위를 적절히 배분하고, 필요 시 일부 인터럽트 비활성화
3. **공유 자원 보호**
   - 전역 변수 접근 시 임계영역 설정
4. **디버깅**
   - 중첩 시 ISR이 중단되는 지점을 확인하기 위해 **Watchpoint, Breakpoint**를 사용
5. **스택 모니터링**
   - `__get_MSP()`, `__get_PSP()` 등으로 현재 스택 상태 점검

------

### 6. 실습 예시

```
void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
    // 낮은 우선순위
}

void USART1_IRQHandler(void) {
    HAL_UART_IRQHandler(&huart1);
    // 높은 우선순위: TIM2 인터럽트 실행 중이라도 즉시 진입
}
```

**설명:**

- USART1이 더 높은 우선순위를 갖기 때문에 TIM2 ISR 실행 중에도 중첩 가능.
- NVIC가 자동으로 레지스터 백업/복원 처리.

------

### 7. 디버깅 시 확인 포인트

- `SCB->ICSR` 레지스터의 **VECTACTIVE** 필드로 현재 실행 중인 IRQ 번호 확인 가능.
- `HAL_NVIC_GetPriority()`를 통해 실제 설정된 우선순위 조회 가능.
- 중첩 시 **RTOS Tick Interrupt**가 지연되지 않도록, SysTick의 우선순위는 항상 **가장 낮게 설정**해야 한다.

------

이 항목은 “**12. 인터럽트 및 예외 처리 심화**” 단원에서 핵심적으로 다루는 부분이며,
 STM32에서 **실시간 응답성 향상과 안정적인 인터럽트 제어**를 위해 반드시 이해해야 하는 영역이다.

## 12.4 Callback 함수 관리 패턴

### 1. Callback 함수의 개념

- **Callback 함수**는 하드웨어 이벤트(Interrupt, DMA 전송 완료 등)가 발생했을 때, **HAL 라이브러리 내부에서 자동으로 호출되는 사용자 정의 함수**이다.
- 사용자는 HAL이 호출할 수 있도록 함수 원형을 동일하게 유지하면서 **“약한 연결(weak linking)”**을 통해 해당 함수를 재정의(override)할 수 있다.
- 예를 들어, `HAL_UART_TxCpltCallback()`은 UART 송신 완료 인터럽트가 발생했을 때 자동 호출된다.

#### 예시:

```
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    // 송신 완료 처리
}
```

→ HAL 내부의 `__weak` 정의된 함수가 사용자 코드의 같은 이름 함수로 대체됨.

------

### 2. Callback 함수 호출 흐름 (HAL 내부 구조)

1. **하드웨어 이벤트 발생** → NVIC에서 해당 인터럽트 호출
2. **IRQHandler()** 함수 실행 → HAL 내부 ISR 진입
3. HAL 내부에서 이벤트를 확인 후 대응하는 Callback 함수 호출

#### 예시 (UART 전송 완료):

```
USART1_IRQHandler()
   ↓
HAL_UART_IRQHandler(&huart1)
   ↓
if (Tx Complete flag) → HAL_UART_TxCpltCallback()
```

------

### 3. 주요 HAL Callback 함수 종류

| 주변장치 | Callback 함수명                                             | 설명                            |
| -------- | ----------------------------------------------------------- | ------------------------------- |
| GPIO     | `HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)`                 | 외부 인터럽트 핀 이벤트 발생 시 |
| ADC      | `HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)`         | ADC 변환 완료 시                |
| UART     | `HAL_UART_RxCpltCallback()`, `HAL_UART_TxCpltCallback()`    | UART 수신/송신 완료 시          |
| SPI      | `HAL_SPI_TxRxCpltCallback()`                                | SPI 전송 완료 시                |
| TIM      | `HAL_TIM_PeriodElapsedCallback()`                           | 타이머 주기 이벤트 발생 시      |
| DMA      | `HAL_DMA_XferCpltCallback()`, `HAL_DMA_XferErrorCallback()` | DMA 전송 완료 / 오류 발생 시    |
| I2C      | `HAL_I2C_MasterRxCpltCallback()`, `HAL_I2C_ErrorCallback()` | I²C 수신 완료 / 에러 시         |
| USB      | `HAL_PCD_DataOutStageCallback()`, `HAL_PCD_SOFCallback()`   | USB 스택 통신 단계별 이벤트     |

------

### 4. Callback 함수 관리의 필요성

프로젝트가 커질수록 **각 주변장치의 Callback 함수가 많아지며**, 관리가 복잡해진다.
 다음과 같은 이유로 체계적인 관리 패턴이 필요하다.

- 여러 장치(UART1, UART2 등)가 동일한 Callback을 공유할 수 있음
- 모듈별로 Callback이 흩어져 있으면 디버깅이 어려움
- 사용자 정의 처리 로직을 중앙에서 제어할 필요가 있음

------

### 5. Callback 관리 패턴 설계 방식

#### (1) **Device-based 분리형 구조**

장치별로 Callback 함수를 파일 단위로 분리하여 관리.

**예시 구조:**

```
/Core/Src/
 ├── uart_callback.c
 ├── adc_callback.c
 └── timer_callback.c
// uart_callback.c
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART1)
        uart1_tx_complete_flag = 1;
    else if (huart->Instance == USART2)
        uart2_tx_complete_flag = 1;
}
```

➡ 장치별 독립적 관리가 가능하고 유지보수가 용이.

------

#### (2) **함수 포인터 기반 Dispatcher 구조**

여러 이벤트를 하나의 “Dispatcher”에서 중앙 관리.

```
typedef struct {
    void (*OnAdcComplete)(void);
    void (*OnUartReceive)(void);
    void (*OnTimerElapsed)(void);
} CallbackTable_t;

CallbackTable_t CallbackTable;

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
    if (CallbackTable.OnAdcComplete != NULL)
        CallbackTable.OnAdcComplete();
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (CallbackTable.OnUartReceive != NULL)
        CallbackTable.OnUartReceive();
}
```

➡ 런타임에 동적으로 콜백 함수를 등록/교체할 수 있어 **모듈화된 코드 설계에 유리**.

------

#### (3) **RTOS 메시지 큐 기반 구조**

FreeRTOS 환경에서는 콜백 내부에서 직접 처리하지 않고,
 **Queue, Semaphore, EventGroup**을 통해 태스크로 이벤트 전달.

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    uint8_t rxByte = rx_buffer;
    xQueueSendFromISR(uartQueue, &rxByte, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

➡ ISR은 최소 처리만 수행하고, 실제 데이터 처리는 Task에서 진행.

------

### 6. Callback 함수 우선순위와 중첩 제어

- NVIC 우선순위와 상관없이, 콜백은 **인터럽트 핸들러 내부에서 호출**되므로 즉시 실행된다.
- Callback 내부에서 다른 HAL 함수 호출 시 **Deadlock** 가능성이 있음.
  - 예: UART Rx Callback 내에서 다시 HAL_UART_Receive 호출 → HAL 상태가 BUSY로 충돌.
- 따라서, **플래그 기반 or RTOS 통신 방식으로 후속 작업을 분리**하는 것이 안전하다.

------

### 7. Callback 디버깅 및 관리 팁

1. **약한 함수(weak) 확인**

   - STM32 HAL 소스(`stm32f1xx_hal_uart.c` 등)에서 `__weak` 키워드로 정의되어 있음

2. **호출 순서 트레이싱**

   - `HAL_UART_IRQHandler()` 내부를 살펴보면 콜백 호출 시점을 명확히 파악 가능

3. **공용 로깅 함수 추가**

   ```
   void CommonCallbackLogger(const char *msg) {
       printf("[CALLBACK] %s\r\n", msg);
   }
   ```

   - 각 콜백에서 호출하면 이벤트 흐름 추적에 매우 유용

------

### 8. Callback 관리 시 주의사항 요약

| 항목                 | 설명                              | 주의 포인트        |
| -------------------- | --------------------------------- | ------------------ |
| ISR 내 HAL 함수 호출 | 일부 HAL 함수는 재진입 불가       | BUSY 상태 주의     |
| 전역 변수 사용       | ISR과 main 간 동기화 필요         | volatile 선언 필수 |
| 콜백 중첩 실행       | 다중 인터럽트 환경에서 충돌 가능  | NVIC 우선순위 확인 |
| RTOS 연동            | ISR 내부 Task 함수 직접 호출 금지 | FromISR 함수 사용  |

------

### 9. 정리

- Callback은 HAL 프레임워크의 핵심 메커니즘으로, **하드웨어 이벤트를 추상화하여 사용자 코드와 연결**한다.
- 구조적 관리가 되지 않으면, 프로젝트가 커질수록 **이벤트 로직이 파편화되고 유지보수성이 급격히 저하**된다.
- 따라서, **콜백 분리 / 디스패처 / RTOS 이벤트 전달** 세 가지 관리 패턴을 상황에 맞게 선택하는 것이 중요하다.

------

👉 이 절에서는 다음 단원 **“12.5 인터럽트 우선순위 동적 제어 및 실시간 튜닝”**으로 이어지며,
 콜백 기반 시스템의 **응답성 최적화와 안정성 확보**를 중점적으로 다룬다.

## 12.5 Low Power + EXTI 연동

### 1. 개요

STM32 마이크로컨트롤러는 **저전력(Low Power)** 기능을 내장하여, 시스템이 유휴 상태일 때 전력 소비를 최소화할 수 있다.
 대표적인 저전력 모드로는 **Sleep, Stop, Standby 모드**가 있으며, 이들 모드에서 **외부 인터럽트(EXTI)** 를 통해 시스템을 깨울 수 있다.

이 절에서는 STM32의 저전력 모드와 EXTI(External Interrupt) 기능을 결합하여,
 버튼이나 센서 신호와 같은 외부 입력을 통해 시스템을 **절전 상태에서 즉시 복귀(Wakeup)** 시키는 방법을 다룬다.

------

### 2. STM32 저전력 모드 개요

#### Sleep Mode

- **CPU 클록만 정지**하며, 주변장치는 동작 가능.
- 진입 시: `__WFI()` 또는 `HAL_PWR_EnterSLEEPMode()` 호출
- 빠른 복귀가 가능하고, 인터럽트 발생 시 즉시 실행 재개
- 사용 예: 짧은 대기 시간의 절전 동작

#### Stop Mode

- 대부분의 클록(HSI, HSE, PLL 등) 정지

- **SRAM, 레지스터 내용 유지**

- Wake-up 시 클록 재설정 필요 (SystemClock_Config 재호출)

- 전력 소비가 매우 낮음 (수백 µA 수준)

- 진입 시:

  ```
  HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
  ```

#### Standby Mode

- **SRAM/레지스터 모두 손실**, RTC 백업만 유지 가능
- 전력 소비 최소 (수 µA 수준)
- Wake-up 원인: WKUP 핀, RTC 알람, EXTI
- 복귀 후 리셋과 동일하게 초기화 수행

------

### 3. EXTI(External Interrupt) 구조

- EXTI는 외부 핀(GPIO)에서 발생한 신호 변화를 감지하여 CPU를 깨우거나 인터럽트를 발생시키는 주변장치.
- EXTI 라인은 GPIO 핀과 매핑되어 있으며, 상승/하강 에지 트리거 가능.
- 저전력 모드에서도 **EXTI 라인은 유지**되어, 특정 입력 변화가 있을 때 **Wake-up Source**로 동작한다.

#### 주요 레지스터

| 레지스터  | 설명                              |
| --------- | --------------------------------- |
| EXTI_IMR  | 인터럽트 마스크 설정              |
| EXTI_RTSR | Rising Edge Trigger 설정          |
| EXTI_FTSR | Falling Edge Trigger 설정         |
| EXTI_PR   | Pending 비트 (인터럽트 발생 상태) |

#### 예시 (PA0을 EXTI0으로 설정):

```
GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Pin = GPIO_PIN_0;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
```

------

### 4. Low Power + EXTI 동작 순서

#### (1) 초기 설정

- GPIO 입력 핀을 EXTI 모드로 구성
- NVIC에서 해당 EXTI 인터럽트를 활성화
- 필요 시 내부 풀업/풀다운 설정

#### (2) 절전 진입

- `HAL_SuspendTick();` 로 SysTick 정지
- `HAL_PWR_EnterSTOPMode()` 또는 `HAL_PWR_EnterSLEEPMode()` 호출
- CPU 클록 중단, 전력 소비 최소화

#### (3) EXTI 이벤트 발생

- 외부 신호(버튼, 센서 출력)가 EXTI 핀에 입력되면
   EXTI 라인이 pending 상태로 전환되고 NVIC가 CPU를 깨움

#### (4) 인터럽트 핸들러 실행

- CPU가 즉시 활성화되고, `EXTI_IRQHandler()` → `HAL_GPIO_EXTI_Callback()` 호출
- 콜백 내에서 이벤트 처리 수행

#### (5) 클록 및 Tick 재개

- Stop Mode에서 복귀한 경우, 반드시 시스템 클록 재설정 필요

  ```
  SystemClock_Config();
  HAL_ResumeTick();
  ```

------

### 5. 실습 예제 — 버튼으로 Sleep 모드에서 깨우기

```
void EXTI0_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        led_toggle = !led_toggle;
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();

    while (1)
    {
        HAL_SuspendTick(); // SysTick 중단
        HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
        HAL_ResumeTick(); // 복귀 후 SysTick 재개
    }
}
```

➡ 버튼 입력이 들어오면 CPU가 깨어나 LED를 토글한 후 다시 Sleep 진입

------

### 6. Stop 모드 + EXTI 복귀 예제

```
void EnterStopMode(void)
{
    HAL_SuspendTick();
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_SLEEPENTRY_WFI);
    SystemClock_Config();  // Wake-up 후 클록 복구
    HAL_ResumeTick();
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        // Wake-up 이벤트 처리
        printf("System Wakeup by EXTI!\r\n");
    }
}
```

#### 주의사항:

- Stop 모드에서 복귀 후 **PLL / HSE 클록은 자동으로 꺼져 있음**
- 반드시 `SystemClock_Config()`를 호출해 클록을 재설정해야 한다.
- 그렇지 않으면 HAL Delay, UART 등 클록 기반 동작이 불안정해진다.

------

### 7. Wake-up 핀 (WKUP) 사용

- 일부 STM32 시리즈(F4, F7, L4 등)는 **전용 Wake-up 핀(WKUP1~WKUP6)** 을 제공한다.
- Standby 모드에서 RTC 또는 WKUP 핀을 통해 복귀 가능.

```
HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);
HAL_PWR_EnterSTANDBYMode();
```

➡ 외부 신호(High 입력) 발생 시 MCU 재시작 (Cold Boot 형태 복귀).

------

### 8. 디버깅 시 주의사항

- 저전력 모드 진입 시 SWD(JTAG) 인터페이스도 비활성화될 수 있음.
- CubeIDE 디버깅 중에는 Stop/Sleep 모드 진입이 제한될 수 있으므로,
   **Release 빌드 + 전원 공급 후 독립 동작 테스트**로 검증해야 한다.

------

### 9. 전력 소비 측정 팁

- VDD 전원 라인에 **샌드위치 저항(0.1Ω~1Ω)** 추가 후 전류 측정

- 저전력 모드 전류 확인 시 **SysTick 비활성화, LED 끄기, 클록 정지** 필수

- 일반적으로 STM32F1 시리즈 기준 전류:

  | 모드        | 소비 전류 (3.3V 기준) |
  | ----------- | --------------------- |
  | Run (72MHz) | 약 20~30 mA           |
  | Sleep       | 수 mA                 |
  | Stop        | 수백 µA               |
  | Standby     | 수 µA 이하            |

------

### 10. 정리

- EXTI는 저전력 모드에서 **Wake-up 이벤트의 핵심 트리거** 역할을 한다.
- Sleep 모드는 빠른 복귀가 장점이며, Stop/Standby는 극저전력에 적합하다.
- Stop/Standby 복귀 시에는 **클록 재설정(SystemClock_Config())** 이 필수.
- 실시간 센서나 배터리 기반 장비에서는 “주기적 Sleep + EXTI Wake-up” 구조가 가장 효율적이다.