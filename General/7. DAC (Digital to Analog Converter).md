# 7. DAC (Digital to Analog Converter)

## 7.1 DAC 기본 원리

### 개요

DAC(Digital-to-Analog Converter)는 **디지털 신호(이산 값)**를 **아날로그 전압(연속 값)**으로 변환하는 장치이다.
 STM32의 DAC는 메모리에 저장된 정수형 데이터를 일정한 변환 주기로 출력 핀에 전압 형태로 전달하며, 오디오 출력, 센서 보정, 파형 발생, 제어 신호 생성 등 다양한 임베디드 애플리케이션에서 활용된다.

------

### 동작 원리

DAC는 입력된 N비트 디지털 값을 기준 전압(Reference Voltage, Vref)에 비례하여 아날로그 전압으로 변환한다.
 변환 식은 다음과 같다.
$$
V_{OUT} = \frac{D_{IN}}{2^N - 1} \times V_{REF}
$$

- $V_{OUT}$: 출력 아날로그 전압
- $D_{IN}$: 디지털 입력값 (0 ~ 2ⁿ-1)
- $V_{REF}$: 기준 전압
- $N$: 변환 해상도(비트 수, STM32에서는 12bit)

------

### STM32 DAC의 구성 요소

1. **해상도(Resolution)**
   - 12-bit 정밀도를 기본 제공 (0~4095 단계 출력 가능)
   - 일부 시리즈는 8-bit, 10-bit 모드 지원
2. **레지스터 구조**
   - `DAC_DHR12R1`: 채널1의 12비트 오른쪽 정렬 입력
   - `DAC_DHR12L1`: 채널1의 12비트 왼쪽 정렬 입력
   - `DAC_DOR1`: 변환 결과 출력
3. **출력 채널**
   - 대부분의 MCU는 1~2채널의 DAC 제공 (예: STM32F3, STM32F4)
   - 독립 출력 또는 Dual Mode 가능
4. **Trigger (트리거) 시스템**
   - 변환은 소프트웨어 트리거나, 타이머, 외부 이벤트로 시작 가능
   - 일반적으로 `TIM6` 또는 `TIM7`의 TRGO 신호로 주기적 변환
5. **Buffer 기능**
   - 출력 버퍼를 통해 출력 임피던스를 낮추고 안정적인 전압 생성
   - 필요 시 `DAC_CR` 레지스터에서 버퍼 비활성화 가능

------

### 주요 동작 모드

| 모드             | 설명                               | 예시                |
| ---------------- | ---------------------------------- | ------------------- |
| **Normal Mode**  | 단일 변환, 소프트웨어로 직접 갱신  | DC 전압 발생        |
| **Trigger Mode** | 타이머 신호로 자동 변환            | 사인파, 삼각파 출력 |
| **DMA Mode**     | 메모리의 데이터 스트림을 자동 전송 | 오디오 신호 발생    |

------

### 예제: 소프트웨어 트리거 DAC 출력

```
DAC_HandleTypeDef hdac;
DAC_ChannelConfTypeDef sConfig = {0};

void DAC_Init(void) {
    __HAL_RCC_DAC_CLK_ENABLE();
    hdac.Instance = DAC;
    HAL_DAC_Init(&hdac);

    sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
    sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
    HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1);

    HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
}

void DAC_Output(uint16_t value) {
    HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, value);
}
```

- `HAL_DAC_Init()` : DAC 하드웨어 초기화
- `HAL_DAC_ConfigChannel()` : 트리거 및 버퍼 설정
- `HAL_DAC_Start()` : DAC 변환 시작
- `HAL_DAC_SetValue()` : 디지털 입력값 → 아날로그 출력

------

### 주파수 및 타이밍 고려

DAC 출력 주파수는 트리거 주기 또는 DMA 업데이트 속도에 의해 결정된다.
$$
f_{OUT} = \frac{1}{T_{TRIGGER}} = \frac{f_{TIM}}{PSC \times ARR}
$$

- 빠른 샘플링 주파수가 필요할 경우 DMA 사용이 필수적이며, CPU 개입 없이 연속적인 데이터 출력 가능

------

### 디버깅 포인트

- `VREF+`와 `VDDA`가 안정적으로 공급되는지 확인 (특히 저전압 시 왜곡 발생)
- 출력 버퍼가 비활성화된 경우, 출력 임피던스 증가로 인해 신호 손실 가능
- ADC 루프백 테스트(ADC 입력에 DAC 출력을 연결)로 동작 검증 가능

------

### 활용 예시

- **파형 발생기**: Sine/Cosine LUT를 DMA로 전송하여 파형 출력
- **오디오 출력**: PCM 데이터를 DAC로 실시간 출력
- **센서 시뮬레이터**: DAC을 통해 아날로그 센서 신호 모사
- **전압 제어 장치**: PID 제어 루프의 출력값을 DAC 전압으로 변환

------

### 참고 자료

- *STM32F4 Reference Manual – DAC section*
- *AN4566: DAC in STM32 microcontrollers*
- *RM0008 / RM0090: DAC configuration registers*

## 7.2 정전압 출력

### 개요

정전압(Constant Voltage) 출력은 DAC의 가장 기본적이고 직관적인 활용 방식이다.
 특정 디지털 값을 DAC에 입력하여, **고정된 아날로그 전압**을 지속적으로 출력하는 방식으로, 센서 오프셋 보정, 기준 전압 생성, 아날로그 회로 테스트 등에 사용된다.
 STM32의 DAC는 12비트 해상도를 가지며, 내부 기준 전압(VREF+)을 기준으로 **0~VREF+ 범위의 연속적인 전압**을 생성할 수 있다.

------

### 출력 전압 계산

DAC는 디지털 값(`D`)과 기준 전압(`VREF`)에 따라 아래와 같이 선형 비례 출력된다.
$$
V_{OUT} = \frac{D}{2^{12} - 1} \times V_{REF}
$$
예시:

- VREF = 3.3V
- 12-bit DAC, `D = 2048 (0x800)`

$$
V_{OUT} = \frac{2048}{4095} \times 3.3 ≈ 1.65V
$$

즉, `D = 0`일 때 0V, `D = 4095`일 때 3.3V가 출력된다.

------

### 주요 설정 항목

| 항목                          | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| **DAC Channel**               | STM32에 따라 1~2채널 존재 (`DAC_CHANNEL_1`, `DAC_CHANNEL_2`) |
| **Output Buffer**             | 내부 버퍼로 출력 임피던스 감소, 안정적 전압 제공             |
| **Trigger**                   | 정전압 출력 시 `NONE` 사용                                   |
| **Alignment**                 | `DAC_ALIGN_12B_R` (일반적인 12비트 오른쪽 정렬 방식)         |
| **Reference Voltage (VREF+)** | 일반적으로 `VDDA` 핀과 동일 (3.3V 또는 5V 시스템)            |

------

### HAL 기반 정전압 출력 코드

```
#include "main.h"

DAC_HandleTypeDef hdac;
DAC_ChannelConfTypeDef sConfig = {0};

void DAC_Init(void) {
    __HAL_RCC_DAC_CLK_ENABLE();

    hdac.Instance = DAC;
    HAL_DAC_Init(&hdac);

    sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
    sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
    HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1);

    HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
}

void DAC_SetVoltage(float voltage) {
    uint16_t dac_value = (uint16_t)((voltage / 3.3f) * 4095);
    HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dac_value);
}
```

#### 코드 해설

- `DAC_TRIGGER_NONE` → 변환은 수동으로 제어
- `HAL_DAC_SetValue()` → 직접적인 정전압 갱신 함수
- `DAC_OUTPUTBUFFER_ENABLE` → 출력 안정화용 버퍼 사용
- `voltage` 파라미터로 원하는 전압을 지정 (예: `DAC_SetVoltage(1.65f)`)

------

### 예제: 1.65V 출력

```
DAC_Init();
DAC_SetVoltage(1.65f);
```

결과적으로 VREF가 3.3V인 경우, DAC 채널 1 핀(DAC_OUT1, PA4)에 약 1.65V가 출력된다.

------

### CubeMX 설정 요약

1. **Pinout & Configuration**
   - `DAC1_OUT1` (PA4) 또는 `DAC1_OUT2` (PA5) 활성화
2. **Parameter Settings**
   - Trigger: None
   - Output Buffer: Enabled
   - Alignment: 12-bit Right
3. **Project Manager**
   - Generate Code → 자동으로 HAL 초기화 코드 생성

------

### 디버깅 및 검증

1. **멀티미터 측정**

   - DAC 출력 핀에 직접 연결하여 출력 전압 확인

2. **ADC 루프백 테스트**

   - ADC 입력을 DAC 출력에 연결하여 내부에서 전압 측정

   ```
   HAL_ADC_Start(&hadc1);
   HAL_ADC_PollForConversion(&hadc1, 100);
   adc_val = HAL_ADC_GetValue(&hadc1);
   ```

3. **오실로스코프 관찰**

   - 정전압의 리플, 버퍼 안정성 확인

------

### 주의사항

- `VDDA` 전압이 불안정하면 출력 오차가 증가한다.
- DAC 출력 핀에 직접 부하를 걸면 정확도가 떨어진다 (권장 부하 > 5kΩ).
- 버퍼 비활성화 시 출력 임피던스가 높아지므로 외부 연산 증폭기(Buffer Amp)를 사용하는 것이 좋다.

------

### 확장 응용

| 응용 분야                   | 설명                                           |
| --------------------------- | ---------------------------------------------- |
| **센서 캘리브레이션**       | DAC을 통해 기준 전압을 출력하고 센서 보정 수행 |
| **오프셋 제어 회로**        | 연산증폭기의 기준 전압 설정용                  |
| **테스트 신호 출력**        | 고정 전압을 발생시켜 외부 장비 반응 점검       |
| **DAC-ADC 루프백 자가진단** | 하드웨어 ADC/DAC 정확도 교차 검증              |

------

### 참고 문서

- RM0008 – STM32F1 Reference Manual, “DAC section”
- AN4566 – *DAC in STM32 microcontrollers*
- DS5319 – *STM32F103 Datasheet (Electrical Characteristics)*

## 7.3 사인파/삼각파 생성 (Timer + DMA)

### 개요

STM32의 DAC는 단순한 정전압 출력을 넘어, **DMA(Direct Memory Access)**와 **Timer 트리거(TIMx TRGO)**를 조합함으로써 CPU 개입 없이 **주기적 파형 생성**이 가능하다.
 이 구조를 활용하면 사인파(Sine Wave), 삼각파(Triangle Wave), 톱니파(Sawtooth), 임의 파형(Arbitrary Waveform) 등을 정확한 주파수로 출력할 수 있다.
 이 방식은 오디오 출력, 센서 시뮬레이션, 신호 발생기, 제어기 테스트 등에서 널리 사용된다.

------

### 동작 구조

1. **Timer (TRGO)**
   - 지정한 주기로 Trigger 신호를 발생 (`Update Event`)
   - DAC는 이 신호에 맞춰 변환을 수행
2. **DMA (Memory → DAC)**
   - LUT(Look-Up Table)에 저장된 샘플 데이터를 주기적으로 DAC 데이터 레지스터로 전송
   - CPU 개입 없이 실시간 파형 출력
3. **DAC**
   - DMA로 전달받은 데이터를 전압으로 변환
   - 출력 핀(DAC_OUTx)을 통해 연속적 파형을 생성

------

### 시스템 블록 다이어그램

```
   ┌────────────┐      ┌──────────────┐      ┌────────────┐
   │   Memory   │ ---> │     DMA      │ ---> │    DAC     │ ---> Analog Output
   └────────────┘      └──────────────┘      └────────────┘
                                      ▲
                                      │
                                  ┌────────┐
                                  │  Timer │
                                  └────────┘
                               (Trigger Source)
```

------

### 사인파 LUT (Look-Up Table) 예시

사인파를 근사화하기 위해 일정 개수의 샘플을 테이블에 저장한다.
 샘플 개수가 많을수록 파형 품질이 향상되지만, 메모리와 DMA 처리량이 증가한다.

```
#define SINE_SAMPLES 100
uint16_t sine_lut[SINE_SAMPLES];

void SineWave_LUT_Init(void) {
    for (int i = 0; i < SINE_SAMPLES; i++) {
        sine_lut[i] = (uint16_t)((sin(2 * M_PI * i / SINE_SAMPLES) + 1) * 2047);
    }
}
```

- 12-bit DAC 기준으로 0~4095 사이 값을 생성
- 정규화 후 DC 오프셋(+2047)을 추가해 음수 구간 제거

------

### 삼각파 LUT 예시

```
#define TRI_SAMPLES 100
uint16_t tri_lut[TRI_SAMPLES];

void Triangle_LUT_Init(void) {
    for (int i = 0; i < TRI_SAMPLES / 2; i++) {
        tri_lut[i] = (uint16_t)(i * (4095.0 / (TRI_SAMPLES / 2)));
        tri_lut[i + TRI_SAMPLES / 2] = (uint16_t)(4095 - tri_lut[i]);
    }
}
```

------

### CubeMX 설정 요약

| 설정 항목                    | 내용                                           |
| ---------------------------- | ---------------------------------------------- |
| **DAC Channel**              | DAC1_OUT1 (PA4) 활성화                         |
| **Trigger Source**           | TIM6 TRGO                                      |
| **Trigger Event**            | Update Event                                   |
| **DMA Mode**                 | Circular Mode (Memory → Peripheral, Half Word) |
| **Timer Prescaler / Period** | 주파수 계산용 (f = Fclk / (PSC × ARR))         |

------

### 코드 예제 (HAL + DMA + TIM6)

```
#include "main.h"
#include <math.h>

#define SINE_SAMPLES 100
uint16_t sine_lut[SINE_SAMPLES];

DAC_HandleTypeDef hdac;
TIM_HandleTypeDef htim6;
DMA_HandleTypeDef hdma_dac1;

void SystemClock_Config(void);
void DAC_Init(void);
void TIM6_Init(void);
void SineWave_LUT_Init(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    SineWave_LUT_Init();
    DAC_Init();
    TIM6_Init();

    // DMA + DAC Start
    HAL_DAC_Start_DMA(&hdac, DAC_CHANNEL_1, (uint32_t*)sine_lut, SINE_SAMPLES, DAC_ALIGN_12B_R);
    HAL_TIM_Base_Start(&htim6);

    while (1);
}
```

#### DAC 초기화

```
void DAC_Init(void)
{
    __HAL_RCC_DAC_CLK_ENABLE();
    hdac.Instance = DAC;
    HAL_DAC_Init(&hdac);

    DAC_ChannelConfTypeDef sConfig = {0};
    sConfig.DAC_Trigger = DAC_TRIGGER_T6_TRGO;
    sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
    HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1);
}
```

#### Timer 6 설정

```
void TIM6_Init(void)
{
    __HAL_RCC_TIM6_CLK_ENABLE();
    htim6.Instance = TIM6;
    htim6.Init.Prescaler = 71;     // 72MHz / (71+1) = 1MHz
    htim6.Init.Period = 99;        // 1MHz / 100 = 10kHz (10k samples/s)
    HAL_TIM_Base_Init(&htim6);

    TIM_MasterConfigTypeDef sMasterConfig = {0};
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
    HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig);
}
```

------

### 주파수 계산

$$
f_{OUT} = \frac{f_{TIM}}{(PSC + 1) \times (ARR + 1) \times N}
$$

예시:

- TIM6 주파수: 72 MHz
- PSC = 71, ARR = 99 → 10 kHz 트리거
- LUT 샘플 개수 = 100 →

$$
f_{OUT} = \frac{10kHz}{100} = 100Hz
$$

즉, 100Hz 사인파 또는 삼각파가 출력된다.

------

### DMA 설정 (Circular Mode)

- DMA는 LUT의 데이터를 순환하며 DAC에 전송
- `HAL_DAC_Start_DMA()` 호출 시 자동 초기화
- CPU 개입 없이 실시간 데이터 전송 수행
- `DMA1_Channel3`(DAC1) 사용 (STM32F1 기준)

------

### 디버깅 및 검증

1. **오실로스코프 연결**
   - DAC1_OUT1 핀(PA4)에 연결
   - 100Hz 사인파 형태 확인
2. **DMA 중단 점검**
   - `HAL_DAC_ConvCpltCallbackCh1()` 콜백 호출 여부로 순환 동작 검증
3. **샘플링 품질 확인**
   - LUT 개수를 늘리면 파형 왜곡 감소
   - Timer 주기를 조절해 주파수 변경 가능

------

### 성능 비교

| 항목        | Polling | Interrupt | DMA       |
| ----------- | ------- | --------- | --------- |
| CPU 개입    | 높음    | 중간      | 매우 낮음 |
| 처리 속도   | 느림    | 보통      | 매우 빠름 |
| 코드 복잡도 | 낮음    | 중간      | 높음      |
| 파형 품질   | 낮음    | 중간      | 높음      |

------

### 응용 예시

| 응용 분야       | 설명                                   |
| --------------- | -------------------------------------- |
| **파형 발생기** | 오실로스코프/신호 발생기 대체용        |
| **오디오 출력** | WAV/PCM 데이터를 DAC로 출력            |
| **센서 테스트** | DAC 출력으로 센서 입력 신호 시뮬레이션 |
| **제어 실험**   | PID 루프의 기준 파형 입력 생성         |

------

### 참고 문서

- RM0008 – *DAC section (12.3.5 DMA requests)*
- AN3126 – *Using DAC with DMA and Timer trigger on STM32F1 series*
- UM1850 – *STM32Cube HAL user manual (DAC chapter)*

## 7.4 오디오 출력 실습 (PWM 기반)

### 개요

STM32에는 DAC이 없는 MCU도 많기 때문에, **PWM(Pulse Width Modulation)**을 이용한 **오디오 신호 출력**은 매우 실용적인 방법이다.
 PWM은 디지털 신호의 듀티비(Duty Cycle)를 조절하여 아날로그 전압을 근사화하고,
 **저역통과필터(LPF)** 를 거쳐 아날로그 오디오로 변환할 수 있다.

이 장에서는 **Timer PWM 모드 + DMA**를 사용하여 오디오(WAV/PCM) 데이터를 재생하는 실습을 다룬다.

------

### PWM 오디오의 원리

PWM은 일정한 주기로 신호의 ON/OFF 비율(듀티비)을 바꿔서 평균 전압을 변화시키는 방식이다.
 듀티비가 높을수록 평균 전압이 높고, 낮을수록 낮다.
 이 평균 전압을 빠르게 변화시키면 결과적으로 **아날로그 오디오 신호**를 재현할 수 있다.

#### PWM 평균 전압 관계

$$
V_{OUT} = V_{DD} \times \frac{DUTY}{100}
$$

#### 개념도

```
Digital PWM Signal  -->  RC Low-Pass Filter  -->  Speaker / Amplifier
      (Timer Output)          (R, C)                (Analog Output)
```

------

### PWM 오디오 출력 구성도

```
   ┌────────────┐
   │  PCM/WAV   │
   └─────┬──────┘
         │ (DMA)
   ┌─────▼──────┐
   │   Timer    │ → PWM 신호 발생
   └─────┬──────┘
         │
   ┌─────▼──────┐
   │   GPIO     │ → PWM 핀 (예: PA8 / TIM1_CH1)
   └─────┬──────┘
         │
   ┌─────▼──────┐
   │  RC Filter │ → 아날로그 오디오
   └────────────┘
```

------

### RC 저역통과필터(LPF) 설계

PWM 신호의 주파수 성분 중 고주파(캐리어 주파수)를 제거하고,
 듀티비 변화에 따른 평균값만 남기기 위해 LPF를 사용한다.

#### 필터 차단 주파수 계산

$$
f_c = \frac{1}{2 \pi R C}
$$

- 예) R = 10kΩ, C = 1µF →
  $$
  f_c ≈ 15.9Hz
  $$
  (오디오의 고주파를 유지하려면 더 낮은 R 또는 C를 사용)

> 실제 오디오용은 **R=1kΩ, C=100nF ~ 1µF** 정도가 일반적이다.
>  PWM 캐리어 주파수는 20~40kHz 이상이 되어야 청음상 잡음이 적다.

------

### CubeMX 설정 요약

| 설정 항목         | 내용                                   |
| ----------------- | -------------------------------------- |
| **Timer**         | TIM1 / TIM3 / TIM4 중 1개 (PWM Mode 1) |
| **Channel**       | CH1 (예: PA8)                          |
| **PWM Frequency** | 약 20~40 kHz                           |
| **DMA Mode**      | Circular Mode (Memory → CCRx)          |
| **Sample Rate**   | 8~16 kHz PCM 데이터 기준               |
| **GPIO 출력**     | Alternate Function - Push Pull         |

------

### 코드 예제 (PWM 오디오 재생 with DMA)

```
#include "main.h"
#include <math.h>

#define AUDIO_SAMPLES 8000  // 0.5초 분량 (16kHz 샘플링 시)
uint16_t audio_data[AUDIO_SAMPLES];

TIM_HandleTypeDef htim1;
DMA_HandleTypeDef hdma_tim1_ch1;

void SystemClock_Config(void);
void TIM1_PWM_Init(void);
void Audio_Wave_Generate(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    Audio_Wave_Generate();
    TIM1_PWM_Init();

    // DMA를 이용한 CCR 업데이트
    HAL_TIM_PWM_Start_DMA(&htim1, TIM_CHANNEL_1, (uint32_t*)audio_data, AUDIO_SAMPLES);

    while (1);
}
```

------

### 1️⃣ 오디오 파형 생성 예시 (사인파 기반)

```
void Audio_Wave_Generate(void)
{
    for (int i = 0; i < AUDIO_SAMPLES; i++) {
        float t = (float)i / AUDIO_SAMPLES;
        // 440Hz (A4 음) 사인파 생성
        audio_data[i] = (uint16_t)((sin(2 * M_PI * 440 * t) + 1) * 500);
    }
}
```

- PWM의 `ARR` 값을 기준으로 `CCR`에 듀티비 데이터를 채워 넣음

------

### 2️⃣ TIM1 PWM 초기화

```
void TIM1_PWM_Init(void)
{
    __HAL_RCC_TIM1_CLK_ENABLE();

    htim1.Instance = TIM1;
    htim1.Init.Prescaler = 0;        // 최대 속도로 동작
    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim1.Init.Period = 1000 - 1;    // PWM 주기 (ARR)
    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_PWM_Init(&htim1);

    TIM_OC_InitTypeDef sConfigOC = {0};
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;             // 초기 듀티 0
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);
}
```

------

### 3️⃣ PWM 핀 설정

- CubeMX에서 TIM1_CH1 → **PA8** (AF Push-Pull)
- 외부에 RC 필터 및 스피커 연결

------

### DMA 동작 구조

- `audio_data[]` 배열의 값이 순차적으로 **CCR1 레지스터**로 전송됨
- PWM의 듀티비가 실시간으로 변하여 오디오 신호 재현
- Circular Mode로 반복 재생 가능

------

### 오디오 파일 재생 (추가 실습)

WAV 파일을 SD카드나 Flash에 저장하고,
 PCM 데이터를 DMA로 읽어 PWM CCR에 전송하면 실제 음성 재생이 가능하다.

| 항목       | 설명                                |
| ---------- | ----------------------------------- |
| 파일 형식  | 8-bit PCM, 8k~16kHz                 |
| DMA 버퍼링 | Double Buffer (Ping-Pong) 구조 추천 |
| 필터       | RC 필터 or 오디오 앰프 모듈         |
| 출력       | 이어폰, 피에조, 스피커 모듈         |

------

### 출력 주파수 및 품질 설정

| 항목                 | 권장 값       | 설명                   |
| -------------------- | ------------- | ---------------------- |
| **PWM 주파수**       | 25~40kHz      | 청음상 노이즈 감소     |
| **샘플링 주파수**    | 8kHz / 16kHz  | 음성용                 |
| **DMA 버퍼 크기**    | 256~1024 샘플 | CPU 부하와 메모리 절충 |
| **ARR (PWM 분해능)** | 1000~4096     | 파형 세밀도 향상       |

------

### 성능 비교

| 방식         | 장점               | 단점                |
| ------------ | ------------------ | ------------------- |
| **DAC 출력** | 고음질, 단순 구조  | DAC 없는 MCU 불가   |
| **PWM 출력** | 대부분의 MCU 가능  | 필터 필요, SNR 낮음 |
| **PWM+DMA**  | CPU 부하 거의 없음 | 하드웨어 설정 복잡  |

------

### 응용 예시

| 응용 분야                    | 설명                           |
| ---------------------------- | ------------------------------ |
| **음성 알림 장치**           | WAV 음성 재생 (예: “Warning!”) |
| **전자 악기 / 효과음**       | 사인파, 톱니파 합성            |
| **모터음, 경고음 발생기**    | 알람음 출력, 상태 표시용       |
| **임베디드 오디오 플레이어** | SD카드 WAV 파일 스트리밍       |

------

### 참고 문서

- RM0008 – *Timer Output Compare / PWM Mode section*
- AN4013 – *PWM generation for audio applications using STM32 timers*
- UM1850 – *STM32Cube HAL user manual (TIM & DMA chapters)*
- AN4031 – *Audio and waveform generation using PWM with STM32 MCUs*