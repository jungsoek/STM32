# 22. 프로젝트 구조 설계

## 22.1 Layered Architecture 설계

### 개요

Layered Architecture(계층형 아키텍처)는 임베디드 시스템 소프트웨어를 **기능적 역할과 추상화 수준에 따라 구분**하여 설계하는 구조이다.
 STM32 프로젝트에서는 HAL, BSP, Application 등으로 계층을 명확히 구분함으로써 **유지보수성, 이식성, 확장성**을 높일 수 있다.
 이 구조는 RTOS 기반 시스템뿐 아니라 Bare-metal 구조에서도 동일하게 적용 가능하다.

------

### 계층 구조의 기본 구성

| 계층                                 | 주요 역할                                         | 예시 구성요소                                         |
| ------------------------------------ | ------------------------------------------------- | ----------------------------------------------------- |
| **Application Layer**                | 사용자 로직, 제어 알고리즘, UI 처리               | Main control loop, sensor fusion, communication logic |
| **Middleware Layer**                 | 프로토콜 스택, 파일 시스템, RTOS, 통신 라이브러리 | FreeRTOS, FATFS, USB, TCP/IP stack                    |
| **BSP (Board Support Package)**      | 보드별 하드웨어 추상화, 디바이스 드라이버 집합    | GPIO, UART, ADC, SPI, LCD, Motor driver 등            |
| **HAL (Hardware Abstraction Layer)** | MCU 주변장치 추상화, 레지스터 접근 캡슐화         | HAL_GPIO, HAL_TIM, HAL_ADC 등                         |
| **Low-Level (LL) / Driver Layer**    | 하드웨어 레지스터 직접 접근                       | LL_GPIO_WritePin(), RCC register control 등           |
| **Hardware Layer**                   | 실제 물리적 하드웨어                              | MCU, Sensor, Motor, Power, PCB 등                     |

------

### 계층 간 의존성 규칙

- **상위 계층은 하위 계층에만 의존**해야 하며, 반대 방향의 참조는 금지한다.
- 각 계층 간 인터페이스는 **함수 포인터, 구조체, 콜백** 등을 통해 명확히 정의한다.
- 하위 계층의 변경이 상위 계층에 영향을 주지 않도록 **추상화 인터페이스(API Layer)** 를 설계한다.

```
[Application]
     ↓
[Middleware]
     ↓
[BSP / Driver]
     ↓
[HAL / LL]
     ↓
[Hardware]
```

------

### STM32 프로젝트에서의 적용 예시

**예: 센서 데이터를 읽어 LCD에 표시하는 시스템**

| 계층        | 구현 예시                   | 파일 구조                   |
| ----------- | --------------------------- | --------------------------- |
| Application | 메인 루프, 데이터 처리 로직 | `app_main.c`                |
| Middleware  | FreeRTOS Task, Queue        | `os_tasks.c`, `os_queue.c`  |
| BSP         | 센서, LCD 제어 인터페이스   | `bsp_sensor.c`, `bsp_lcd.c` |
| HAL         | HAL I²C, HAL GPIO API 호출  | `stm32f1xx_hal_i2c.c`       |
| Hardware    | 센서 모듈, LCD 모듈         | SCL/SDA, VCC, GND 연결      |

```
// app_main.c
SensorData_t data = Sensor_Read();
LCD_Display(data.temperature);
// bsp_sensor.c
SensorData_t Sensor_Read(void) {
    HAL_I2C_Mem_Read(&hi2c1, SENSOR_ADDR, REG_TEMP, I2C_MEMADD_SIZE_8BIT, buf, 2, 100);
    return Parse_Sensor(buf);
}
```

------

### 계층 설계의 이점

- **유지보수 용이**: 특정 드라이버 변경 시 상위 애플리케이션 코드 수정 불필요.
- **플랫폼 이식성 확보**: MCU 변경 시 HAL/BSP만 수정.
- **팀 개발 효율성**: 각 계층을 독립적으로 개발 및 테스트 가능.
- **테스트 용이성**: Mock Interface를 통한 단위 테스트 가능.

------

### 인터페이스 설계 원칙

- **명확한 경계(Interface Header)**: `bsp_*.h`, `drv_*.h` 형태로 모듈별 헤더를 제공.
- **함수 네이밍 규칙화**: `BSP_`, `DRV_`, `APP_` 접두어 사용.
- **데이터 타입 통일**: 구조체 기반의 API 전달.
- **Callback 기반 이벤트 처리**: 하위 계층 이벤트를 상위 계층에서 등록 처리.

```
// bsp_button.h
typedef void (*ButtonCallback_t)(void);
void BSP_Button_RegisterCallback(ButtonCallback_t cb);
```

------

### 실습 과제

1. HAL 드라이버 기반의 `BSP_LED`, `BSP_BUTTON` 모듈을 작성하고 Application에서 이를 호출하도록 구조화한다.
2. I²C 센서와 LCD를 포함한 프로젝트를 3계층 구조(Application-BSP-HAL)로 리팩토링한다.
3. FreeRTOS를 도입하여 **Middleware 계층**을 추가하고 Task 간 모듈 의존성을 명확히 구분한다.
4. Mock BSP 모듈을 사용해 Application Layer를 하드웨어 없이 단위 테스트한다.

------

### 확장 구조 예시 (산업용 시스템)

대형 프로젝트에서는 다음과 같은 **Layer + Module 구조**로 확장된다.

```
Application Layer
 ├── Control Logic
 ├── UI / Communication
 └── Fault / Event Handler
Middleware Layer
 ├── RTOS / Filesystem / Network
BSP Layer
 ├── Sensor / Actuator / Display / Motor
HAL Layer
 ├── Peripherals (I2C, SPI, UART, ADC, PWM)
Hardware
 └── MCU + External Modules
```

------

### 결론

Layered Architecture는 STM32 프로젝트의 **코드 구조화, 유지보수성, 모듈 간 독립성**을 보장하는 핵심 설계 방식이다.
 HAL/CubeMX 기반 프로젝트에서 이를 체계적으로 구현하면 **대형 펌웨어 시스템**에서도 확장 가능한 구조를 유지할 수 있다.

## 22.2 Module / Driver / Task 분리

### 개요

STM32 임베디드 시스템 개발에서 **Module**, **Driver**, **Task**는 각기 다른 수준의 추상화 계층을 담당한다.
 이들을 명확히 분리하면 시스템의 **구조적 안정성**, **확장성**, **디버깅 효율성**이 비약적으로 향상된다.
 FreeRTOS, HAL, CubeIDE 기반 프로젝트에서는 이 세 계층을 구분하여 관리하는 것이 실질적인 산업 표준이다.

------

### 주요 개념 구분

| 구분       | 주요 역할                                  | 구현 단위                        | 예시                            |
| ---------- | ------------------------------------------ | -------------------------------- | ------------------------------- |
| **Driver** | MCU 주변장치 제어, 레지스터 접근 캡슐화    | HAL / LL 함수, Peripheral Driver | `drv_uart.c`, `drv_adc.c`       |
| **Module** | 기능 단위 로직, 복수의 드라이버 통합       | 응용 로직 기반의 독립 기능 블록  | `mod_sensor.c`, `mod_motor.c`   |
| **Task**   | RTOS 스케줄링 단위, 동작 제어 및 상태 관리 | FreeRTOS Task 또는 Loop 함수     | `task_comm.c`, `task_control.c` |

이 구조는 계층 간 명확한 의존 방향을 가진다.

```
[Task] → [Module] → [Driver] → [HAL / LL]
```

------

### Driver 계층 설계

#### 역할

- MCU의 **주변장치 하드웨어를 직접 제어**한다.
- HAL / LL API를 기반으로 하며, 하드웨어 의존성이 가장 높다.
- Register-level 접근 또는 HAL 함수 캡슐화로 구성한다.

#### 구현 예시

```
// drv_uart.c
#include "drv_uart.h"
extern UART_HandleTypeDef huart1;

void DRV_UART_Send(uint8_t *buf, uint16_t len) {
    HAL_UART_Transmit(&huart1, buf, len, 100);
}

void DRV_UART_Receive_IT(uint8_t *buf, uint16_t len) {
    HAL_UART_Receive_IT(&huart1, buf, len);
}
```

#### 특징

- 하드웨어 변경 시, 해당 드라이버 파일만 수정하면 된다.
- 다른 계층에서는 HAL 객체(`huart1`, `hadc1` 등)를 직접 접근하지 않는다.
- 각 드라이버는 **Init**, **Read**, **Write**, **DeInit** 함수 인터페이스를 갖춘다.

------

### Module 계층 설계

#### 역할

- 여러 Driver를 조합하여 특정 기능(Feature)을 구현한다.
- 센서 처리, 통신 프로토콜, 제어 알고리즘 등을 포함한다.
- 하드웨어 독립적이며, 다른 MCU에서도 재사용 가능하다.

#### 예시: 센서 모듈

```
// mod_sensor.c
#include "mod_sensor.h"
#include "drv_adc.h"

void MOD_Sensor_Read(SensorData_t *data) {
    data->temperature = DRV_ADC_Read_Channel(0);
    data->humidity = DRV_ADC_Read_Channel(1);
}
```

#### 특징

- Driver에 직접 접근하지 않고 **함수 인터페이스**로 통신한다.
- 기능 단위로 코드가 독립되어 있어 테스트 및 유지보수에 유리하다.
- 각 모듈은 `mod_xxx.h` / `mod_xxx.c` 형태로 구성한다.

------

### Task 계층 설계

#### 역할

- RTOS 환경에서 실행되는 **스케줄링 단위(Task)**.
- Module을 호출하고 시스템 동작 흐름을 관리한다.
- 우선순위, 주기, 이벤트 기반 실행 등을 담당한다.

#### 예시: 센서 데이터 송신 태스크

```
// task_comm.c
#include "mod_sensor.h"
#include "drv_uart.h"

void Task_Comm(void *argument) {
    SensorData_t data;
    for (;;) {
        MOD_Sensor_Read(&data);
        DRV_UART_Send((uint8_t*)&data, sizeof(data));
        osDelay(1000);
    }
}
```

#### 특징

- Task는 주기적 동작을 수행하며, RTOS에서 독립적으로 스케줄된다.
- 다른 Task와는 Queue, Semaphore, EventGroup으로 통신한다.
- 하드웨어 변경 시 Task 코드는 거의 수정하지 않는다.

------

### 파일 구조 예시

```
Core/
 ├── Src/
 │   ├── main.c
 │   ├── drv_uart.c
 │   ├── drv_adc.c
 │   ├── mod_sensor.c
 │   ├── mod_control.c
 │   ├── task_comm.c
 │   └── task_control.c
 └── Inc/
     ├── drv_uart.h
     ├── drv_adc.h
     ├── mod_sensor.h
     ├── mod_control.h
     ├── task_comm.h
     └── task_control.h
```

이 구조는 **BSP(Bare Support Package)** 기반 프로젝트에도 동일하게 적용 가능하며, CubeMX 생성 디렉토리 구조를 그대로 유지하면서 계층을 추가할 수 있다.

------

### 계층 간 통신 규칙

- **Task ↔ Module**: 함수 호출 및 RTOS IPC(Queue, Event) 사용
- **Module ↔ Driver**: 함수 호출 기반, 포인터 전달 최소화
- **Driver ↔ HAL**: 직접 호출, 하드웨어 의존적 코드

```
Task_Comm → MOD_Sensor_Read() → DRV_ADC_Read() → HAL_ADC_GetValue()
```

------

### 인터페이스 설계 원칙

- 함수 네이밍은 계층별 접두어로 구분한다.
  - Driver: `DRV_XXX_*`
  - Module: `MOD_XXX_*`
  - Task: `TASK_XXX_*`
- 데이터 전달은 구조체를 통한 추상화 방식 사용.
- 전역 변수(Global Handle) 사용을 지양하고, Context 기반 접근을 선호.
- 각 계층 간 직접 헤더 참조를 최소화 (`#include` 최소화).

------

### 실습 과제

1. ADC 기반 온도 측정 시스템을 Driver, Module, Task로 분리하라.
   - `drv_adc.c`: HAL_ADC를 이용한 채널별 샘플링
   - `mod_sensor.c`: ADC 데이터를 변환하여 `SensorData_t` 구조체 생성
   - `task_comm.c`: 주기적으로 데이터를 UART로 송신
2. PWM 제어 모터를 위한 `drv_pwm`, `mod_motor`, `task_motor` 구조를 설계하라.
3. RTOS Queue를 이용하여 Sensor Task → Display Task 간 데이터 전달을 구현하라.

------

### 설계 이점

- 코드 재사용성 및 모듈화 극대화
- 디버깅 시 영향 범위 최소화
- 팀 단위 병렬 개발 효율 증가
- 하드웨어 변경 시 수정 범위 최소화

------

### 결론

Module / Driver / Task의 계층적 분리는 STM32 프로젝트의 핵심 설계 원칙 중 하나다.
 이 구조를 준수하면 **하드웨어 종속성과 응용 로직을 완전히 분리**할 수 있으며,
 RTOS 기반 시스템에서도 **기능 단위의 안정적 확장성**을 확보할 수 있다.

## 22.3 Config Header 관리

### 개요

Config Header 관리란, 프로젝트 전체의 **설정값(매크로, 핀 정의, 기능 활성화 플래그 등)** 을 일관되고 체계적으로 관리하는 방법을 말한다.
 STM32 프로젝트에서는 HAL, FreeRTOS, BSP, Application 모듈 등 각 계층에서 다양한 설정이 필요하므로, 이를 분산 관리하지 않고 **Config 헤더 파일 단위로 통합 관리**하는 것이 중요하다.
 CubeIDE 기반 프로젝트에서는 `stm32f1xx_hal_conf.h`, `FreeRTOSConfig.h`, `app_config.h` 등이 대표적인 예이다.

------

### Config Header의 목적

- **모듈 간 설정 통합**: 핀맵, 기능 선택, 주기, 타이밍 등을 한 곳에서 관리
- **빌드 옵션 분리**: Debug / Release, HW 버전별로 설정 구분
- **코드 유지보수 용이화**: 매직 넘버 제거 및 명시적 설정 관리
- **이식성 향상**: MCU 변경 시 Config 파일만 수정

------

### 구성 방식

#### 전형적인 Config Header 구조

```
// app_config.h
#ifndef __APP_CONFIG_H__
#define __APP_CONFIG_H__

// ===== Feature Enable Flags =====
#define USE_SENSOR_MODULE      1
#define USE_COMM_UART          1
#define USE_LOGGING            0

// ===== System Parameters =====
#define SYSTEM_TICK_MS         1
#define SENSOR_SAMPLE_PERIOD   1000
#define UART_BAUDRATE          115200

// ===== Hardware Mapping =====
#define PIN_LED                GPIO_PIN_13
#define PORT_LED               GPIOC

#define PIN_BUTTON             GPIO_PIN_0
#define PORT_BUTTON            GPIOA

// ===== Debug Settings =====
#define ENABLE_ASSERT          1
#define DEBUG_UART_HANDLE      huart1

#endif // __APP_CONFIG_H__
```

이 파일은 프로젝트 전체에서 **전역 설정 정보**를 정의하며, 다른 모든 모듈이 참조할 수 있다.

------

### Config 파일의 계층적 분류

| 파일명                     | 적용 범위         | 주요 내용                                       |
| -------------------------- | ----------------- | ----------------------------------------------- |
| **`stm32f1xx_hal_conf.h`** | HAL Layer         | 주변장치 활성화, IRQ 우선순위, HAL 기능 설정    |
| **`FreeRTOSConfig.h`**     | RTOS Layer        | Task 수, Stack 크기, Tick Rate, Hook 설정       |
| **`bsp_config.h`**         | BSP Layer         | 핀맵, 보드별 기능 설정                          |
| **`app_config.h`**         | Application Layer | 기능 활성화 플래그, 주기, 로직 관련 파라미터    |
| **`drv_config.h`**         | Driver Layer      | Peripheral별 설정, DMA 사용 여부, 인터럽트 설정 |

------

### CubeMX 생성 파일과의 연계

CubeMX는 자동으로 `stm32f1xx_hal_conf.h` 및 `main.h`를 생성하지만,
 이들은 HAL 중심으로 제한적 설정만 제공한다.

따라서 다음과 같이 **사용자 정의 Config Header**를 추가하는 것이 일반적이다:

```
Core/
 ├── Inc/
 │   ├── app_config.h
 │   ├── bsp_config.h
 │   ├── drv_config.h
 │   ├── FreeRTOSConfig.h
 │   └── stm32f1xx_hal_conf.h
 └── Src/
     └── main.c
```

이 구조를 유지하면, 하드웨어 리비전이나 기능 추가 시도 **Config 파일만 변경**하면 전체 코드가 자동으로 반영된다.

------

### 기능 활성화 매크로 설계

#### 예시: 기능별 조건부 컴파일

```
// app_main.c
#include "app_config.h"

#if USE_SENSOR_MODULE
#include "mod_sensor.h"
#endif

void App_MainLoop(void) {
#if USE_SENSOR_MODULE
    MOD_Sensor_Process();
#endif
}
```

#### 예시: 하드웨어 버전에 따른 설정 분기

```
// bsp_config.h
#define BOARD_VERSION  2

#if BOARD_VERSION == 1
#define PIN_LED  GPIO_PIN_13
#elif BOARD_VERSION == 2
#define PIN_LED  GPIO_PIN_5
#endif
```

------

### 다중 Config 관리 기법

#### 빌드 프로파일 기반 분리

Debug / Release, Test / Production 등 빌드 목적에 따라 서로 다른 설정을 적용할 수 있다.

**예시:**

```
Config/
 ├── config_debug.h
 ├── config_release.h
 ├── config_test.h
```

빌드 시 특정 매크로를 통해 조건 분기:

```
#if defined(BUILD_DEBUG)
#include "config_debug.h"
#elif defined(BUILD_RELEASE)
#include "config_release.h"
#endif
```

#### MCU / 보드별 Config 분리

STM32F103 / STM32F407 등 MCU가 다른 경우,
 각 MCU별 핀맵과 클록 구성을 별도 관리한다.

```
Config/
 ├── f1_config/
 │   └── bsp_config_f1.h
 └── f4_config/
     └── bsp_config_f4.h
```

------

### 주의 사항

- Config 파일에서 **로직 구현 금지** (함수 포함 금지, 매크로 정의만 허용)
- `#define` 오타, 중복 정의 방지를 위해 `#ifndef / #endif` 필수
- `#pragma once` 대신 전통적인 include guard 사용 권장
- Config 변경 시 반드시 전체 리빌드 수행 (헤더 종속성 반영)
- 장치 주소, 핀 번호 등은 하드코딩하지 않고 Config 파일에 집중시킨다

------

### 실습 과제

1. `app_config.h`를 작성하여 다음 설정을 관리하도록 구성하라.
   - 센서 모듈 활성화
   - UART 통신 속도
   - Task 주기 (센서 주기, 로깅 주기)
2. Debug 모드와 Release 모드에 따라 UART 로그 출력을 On/Off하도록 매크로를 설계하라.
3. 동일 코드 기반에서 보드 리비전 A / B를 Config 파일 분리로 지원하라.

------

### 베스트 프랙티스 요약

| 항목               | 권장 방식                     |
| ------------------ | ----------------------------- |
| 설정값 관리        | 전용 Config 헤더 파일로 집중  |
| 코드 내 하드코딩   | 금지                          |
| 계층별 Config 구분 | HAL / BSP / App 별로 분리     |
| 조건부 컴파일      | 기능별 매크로로 제어          |
| 빌드 프로파일      | Debug / Release / Test로 구분 |
| 파일 네이밍        | `*_config.h` 형태 일관성 유지 |

------

### 결론

Config Header 관리는 STM32 프로젝트의 **유지보수성과 이식성**을 결정짓는 핵심 설계 요소이다.
 기능별·계층별로 Config 파일을 명확히 분리하면,
 하드웨어 변경이나 프로젝트 확장 시 **코드 수정 없이 설정 변경만으로 대응**할 수 있다.
 이는 실무 환경에서 대규모 펌웨어를 안정적으로 관리하기 위한 필수적인 아키텍처 기법이다.

## 22.4 Coding Convention 및 Naming Rule

STM32 프로젝트의 유지보수성과 확장성을 확보하기 위해서는 코드 일관성을 유지하는 명확한 코딩 규칙과 네이밍 체계를 수립하는 것이 필수적이다. 이 절에서는 프로젝트 전반에서 통일된 스타일을 적용하기 위한 표준 규칙을 정의한다.

------

### 코드 스타일 기본 규칙

- **인덴트(Indent)**: 공백 4칸(Space 4) 사용, Tab 금지
- **중괄호 위치**: 함수 정의 시 다음 줄, 제어문(if/for 등)은 같은 줄에 배치
- **줄 길이 제한**: 최대 120자, 초과 시 논리 단위로 줄바꿈
- **공백 규칙**
  - 연산자 앞뒤에 공백 삽입 (`a + b`, `if (x == y)`)
  - 함수 호출 시 괄호 앞에 공백 금지 (`foo(x, y)`)
- **주석 규칙**
  - 한 줄 설명: `//` 사용
  - 함수, 구조체, 모듈 설명: `/** ... */` Doxygen 스타일
  - 모든 함수는 입력(`@param`), 출력(`@return`)을 반드시 명시

------

### 네이밍 규칙 (Naming Convention)

#### 일반 원칙

- 명확성, 일관성, 기능 기반 명명
- CamelCase는 **함수**, SnakeCase는 **변수 및 상수**에 사용
- 약어는 최소화하되, STM32 HAL 구조체와 일관성 유지

#### 함수명

- 동사 + 목적어 구조 사용
- HAL 함수와 구분되도록 프로젝트 prefix 사용

예:

```
void App_Init(void);
void Motor_ControlStart(void);
uint8_t Sensor_ReadValue(void);
```

#### 변수명

- 의미 중심으로 명명, 약어 지양
- 지역 변수는 소문자 기반 SnakeCase
- 전역 변수는 `g_` 접두어 사용

예:

```
int16_t g_motor_speed;
float temperature_avg;
uint8_t uart_rx_buffer[64];
```

#### 상수 및 매크로

- 전부 대문자, 단어 구분은 언더바 `_`
- 매직넘버 직접 사용 금지

예:

```
#define MAX_BUFFER_SIZE 128
#define MOTOR_PWM_FREQ 20000
```

#### 구조체 및 타입명

- PascalCase 사용, `_t` 접미사 금지 (표준 라이브러리와 구분)

예:

```
typedef struct {
    uint16_t speed;
    uint8_t direction;
} MotorStatus;
```

#### 파일명

- 기능 단위로 소문자 + 언더바 형식 사용
- 예: `motor_driver.c`, `sensor_task.c`, `system_init.c`

------

### Doxygen 기반 주석 예시

```
/**
 * @brief  온도 센서 데이터를 읽어 평균값을 계산
 * @param  samples 센서 샘플 배열 포인터
 * @param  count   샘플 개수
 * @return 계산된 평균 온도 (float)
 */
float Sensor_GetAverage(const float *samples, uint8_t count);
```

------

### 디렉터리 구조 표준 예시

```
/Core
  ├── Inc/                // 헤더 파일
  ├── Src/                // 소스 파일
  ├── Drivers/            // HAL / BSP / Custom Driver
  ├── Tasks/              // FreeRTOS Task 모듈
  ├── Config/             // 프로젝트 설정 파일
  ├── Utils/              // 공통 유틸리티
  └── Docs/               // 문서 및 코드 규칙 명세
```

------

### 정적 분석 및 규칙 검증

- **Clang-Tidy / cppcheck**: Naming Rule 및 MISRA C 검증
- **SonarQube**: 함수 복잡도, 주석 커버리지, 규칙 위반 모니터링
- **Git Hook (pre-commit)**: 포맷 검사 자동화 (`clang-format`)

------

### 참고 규격

- MISRA-C:2012
- STM32 HAL API Naming Rule
- Google C Style Guide (일부 차용)
- STMicroelectronics Firmware Package Format

## 22.5 Git + CubeIDE 연동

STM32 프로젝트에서 Git을 활용하면 코드 이력 관리, 버전 추적, 협업 및 배포 자동화를 체계적으로 수행할 수 있다. STM32CubeIDE는 Eclipse 기반이므로 Git 플러그인(EGit)이 기본 내장되어 있으며, CubeIDE 환경에서 직접 커밋, 브랜치, 병합, 리모트 동기화 작업이 가능하다.

------

### Git 환경 구성

#### Git 설치 및 기본 설정

1. Git 공식 사이트에서 설치

   - Windows: https://git-scm.com

2. 사용자 정보 설정

   ```
   git config --global user.name "username"
   git config --global user.email "email@example.com"
   git config --global core.autocrlf true
   ```

3. CubeIDE에서 Git 인식 확인

   - **Window → Preferences → Team → Git**
   - Git executable 경로 확인 및 자동 감지

------

### STM32CubeIDE 프로젝트 Git 초기화

1. **프로젝트 생성 후 초기화**

   - Project Explorer에서 프로젝트 우클릭
   - `Team → Share Project → Git` 선택
   - 로컬 저장소(Repository) 생성 경로 지정

2. `.gitignore` 설정
    STM32 프로젝트에서는 빌드 아티팩트, 중간 생성물, 설정 캐시 등을 제외해야 한다.

   예시 `.gitignore`:

   ```
   # CubeIDE build output
   /Debug/
   /Release/
   /.settings/
   /.metadata/
   /.loadpath
   /.cproject
   /.project
   /build/
   *.elf
   *.map
   *.lst
   *.o
   *.d
   *.bak
   ```

3. 초기 커밋

   ```
   git add .
   git commit -m "Initial STM32CubeIDE project commit"
   ```

------

### CubeIDE 내 Git 작업 흐름

#### 변경 사항 추적

- **Window → Show View → Other → Git → Git Staging**
   → 변경된 파일(Stage/Unstage/Commit) 관리
- **Diff Viewer**: 변경된 라인 비교 및 주석 가능

#### 커밋 및 푸시

- `Team → Commit` 또는 Git Staging 뷰에서 직접 입력
- `Team → Push to Upstream`으로 원격 저장소 반영

#### 브랜치 및 병합 관리

- `Team → Switch To → New Branch`
- `Team → Merge` 로 브랜치 통합
- 브랜치 명명 규칙 예시:
  - `main` : 안정화된 릴리즈
  - `develop` : 기능 개발 통합
  - `feature/xxx` : 개별 기능 구현
  - `bugfix/xxx` : 버그 수정
  - `release/v1.0.0` : 배포 준비 버전

------

### GitHub / GitLab 리모트 연동

#### 리모트 저장소 등록

```
git remote add origin https://github.com/username/project.git
```

CubeIDE에서:

- **Team → Remote → Configure Push to Upstream**
- Repository URL 입력 후 인증

#### 리모트 동기화

- **Pull**: 리모트 변경 내용 로컬 반영
- **Push**: 로컬 변경 내용 리모트 반영
- **Fetch**: 변경사항 확인만 수행

------

### 브랜치 전략 및 협업 구조

| 브랜치      | 목적                  | 병합 방향             |
| ----------- | --------------------- | --------------------- |
| `main`      | 제품 릴리즈 안정 버전 | ← `release`           |
| `develop`   | 개발 통합 및 테스트   | ← `feature`, `bugfix` |
| `feature/*` | 신규 기능 구현        | → `develop`           |
| `release/*` | 배포 전 검증 단계     | → `main`              |
| `hotfix/*`  | 긴급 버그 수정        | → `main`, `develop`   |

------

### CubeIDE + Git 고급 기능

#### 변경 이력 및 주석 추적

- **Team → Show in History**
   → 함수 단위 변경 내역 추적 가능
- **Annotate (Blame)** 기능으로 코드 라인별 변경자 확인

#### 자동 버전 태깅

- 빌드 시점에 `git describe` 명령으로 펌웨어 버전 자동 삽입

  ```
  git describe --tags --always > version.txt
  ```

  → CubeIDE 빌드 스크립트(`post-build command`)에서 사용 가능

#### 커밋 메시지 규칙 (권장)

```
[타입] 요약 설명

본문 설명 (선택)
- 변경 이유
- 영향 범위

예시:
[fix] UART DMA 수신 버그 수정
- DMA circular buffer overflow 방지
```

------

### 권장 자동화 구성

- **Pre-commit Hook**: 코드 포맷 검사 (`clang-format`)
- **CI/CD (GitHub Actions / GitLab CI)**:
  - CubeIDE headless 빌드
  - 펌웨어 산출물 자동 업로드
  - 릴리즈 노트 생성

------

### 예시 CubeIDE + Git Workflow

```
개발자 A
 ├─ feature/sensor_task 브랜치 생성
 ├─ 코드 수정 후 커밋
 ├─ PR(Pull Request) 생성 → develop 병합
 └─ CI 빌드 통과 후 main 릴리즈 반영
```

------

### 참고

- STM32CubeIDE User Manual – Git Integration
- Git SCM Documentation
- “Pro Git” (Apress, 2nd Edition)
- GitFlow Workflow by Vincent Driessen