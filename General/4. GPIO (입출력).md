# 4. GPIO (입출력)

## 4.1 Input / Output / Alternate Function 설정

STM32의 **GPIO (General Purpose Input/Output)** 포트는 MCU가 외부 장치와 직접 신호를 주고받는 기본 인터페이스이다.
 각 핀은 **입력(Input)**, **출력(Output)**, **대체 기능(Alternate Function, AF)**, **아날로그(Analog)** 중 하나의 모드로 설정할 수 있으며,
 해당 설정은 CubeMX의 **Pinout & Configuration 탭** 또는 HAL 함수를 통해 제어된다.

------

### GPIO 기본 구조

STM32의 각 포트(`GPIOA`, `GPIOB`, …)는 **최대 16개 핀(PA0~PA15)**으로 구성된다.
 모든 포트는 동일한 레지스터 구조를 가지며, RCC를 통해 클록을 인가한 후 제어 가능하다.

#### RCC 클록 인가

```
__HAL_RCC_GPIOA_CLK_ENABLE();
```

#### 핀 초기화 구조체

```
GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
```

------

### GPIO 모드 구분

| 모드                        | 설명                                                     |
| --------------------------- | -------------------------------------------------------- |
| **Input**                   | 외부 신호를 읽는 모드                                    |
| **Output**                  | MCU에서 외부로 신호를 출력                               |
| **Alternate Function (AF)** | 주변장치(UART, SPI, I²C 등) 제어 신호로 사용             |
| **Analog**                  | ADC 입력, 저전력 모드 등에서 사용 (디지털 회로 비활성화) |

#### Alternate Function 예시

각 핀은 **다중 기능(Multiplexed Function)**을 지원하며,
 AF 번호를 통해 특정 주변장치에 매핑된다.

| 핀   | AF0      | AF1  | AF2  | AF7       |
| ---- | -------- | ---- | ---- | --------- |
| PA9  | TIM1_CH2 | —    | —    | USART1_TX |
| PA10 | TIM1_CH3 | —    | —    | USART1_RX |

```
GPIO_InitStruct.Pin = GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
```

------

### HAL 기반 GPIO 입출력

```
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);

GPIO_PinState state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);
```

- `HAL_GPIO_WritePin()` : 출력 상태 제어
- `HAL_GPIO_ReadPin()` : 입력 상태 읽기

------

### LL 드라이버 기반 접근

HAL보다 가벼운 LL 드라이버를 사용하면 직접 레지스터에 접근할 수 있다.

```
LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_13);
LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_13);
```

------

### 직접 레지스터 접근 예

```
GPIOA->BSRR = (1 << 5);   // PA5 HIGH
GPIOA->BSRR = (1 << (5 + 16)); // PA5 LOW
```

`BSRR`(Bit Set/Reset Register)는 비트 단위로 빠르게 제어 가능하며,
 ODR 직접 쓰기보다 성능이 높고 인터럽트 세이프하다.

------

### CubeMX 설정 흐름

1. **Pinout 탭**에서 핀 선택 (예: PA5 → GPIO_Output)
2. **Configuration 탭**에서 속성 설정 (Mode, Pull, Speed)
3. **Project → Generate Code**
4. `MX_GPIO_Init()` 함수 내부에 HAL 설정 자동 생성

------

## 4.2 GPIO 모드 (Push-Pull, Open-Drain, Pull-up/down)

STM32의 출력 핀은 물리적 회로 구성에 따라 **Push-Pull**과 **Open-Drain** 두 가지 구동 방식을 지원하며,
 입력 핀은 내부 저항을 이용해 **Pull-up**, **Pull-down**, **Floating** 상태를 제어할 수 있다.

------

### 출력 모드: Push-Pull vs Open-Drain

#### 1. Push-Pull (기본 출력 방식)

- 내부적으로 **P-MOS와 N-MOS 트랜지스터가 모두 활성화**되어,
   핀을 VDD(‘1’) 또는 GND(‘0’)로 직접 구동.
- 외부 풀업 저항 불필요.
- 대부분의 LED, 디지털 IC 구동에 적합.

```
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
```

**특징**

- 강한 드라이브 능력 (sink/source 가능)
- 빠른 전압 전환 속도
- 외부 전압 레벨 제약 존재 (3.3V 시스템 한정)

------

#### 2. Open-Drain

- N-MOS만 활성화되어 **‘0’은 직접 구동**, **‘1’은 외부 풀업 저항에 의해 상승**.
- 여러 장치가 같은 라인에 연결되는 **버스 구조(I²C, 1-Wire 등)**에서 사용.

```
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
```

**특징**

- 외부 풀업 저항 필요 (4.7kΩ ~ 10kΩ)
- 다중 장치가 동일 핀을 공유 가능
- 외부 전압 레벨 호환 가능 (5V tolerant)

**예시:**

```
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET); // Low (구동)
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);   // High-Z 상태
```

------

### 입력 모드: Pull-up, Pull-down, Floating

입력 핀은 외부 회로가 연결되지 않은 상태에서 **임의의 전위(부유 상태)**가 되지 않도록
 내부 저항(Pull-up/Pull-down)을 활성화할 수 있다.

| 모드              | 동작                          | 내부 저항   |
| ----------------- | ----------------------------- | ----------- |
| **GPIO_NOPULL**   | Floating 상태, 외부 회로 필요 | 없음        |
| **GPIO_PULLUP**   | 내부 풀업 (논리 ‘1’ 유지)     | 약 30~50 kΩ |
| **GPIO_PULLDOWN** | 내부 풀다운 (논리 ‘0’ 유지)   | 약 30~50 kΩ |

**예시:**

```
GPIO_InitStruct.Pin = GPIO_PIN_0;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
```

------

### 아날로그 모드

입력 버퍼와 디지털 스위치를 모두 차단하여
 ADC 입력이나 저전력 모드에서 사용한다.

```
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
```

- 디지털 노이즈 제거
- 저전력 모드 진입 시 **IO Leakage Current 최소화**

------

### GPIO 속도 설정 (Output Speed)

| 속도 설정                   | 내부 전류 특성 | 용도           |
| --------------------------- | -------------- | -------------- |
| `GPIO_SPEED_FREQ_LOW`       | 약 2MHz        | 일반 제어 신호 |
| `GPIO_SPEED_FREQ_MEDIUM`    | 약 10MHz       | SPI, PWM 등    |
| `GPIO_SPEED_FREQ_HIGH`      | 약 50MHz       | 고속 통신 핀   |
| `GPIO_SPEED_FREQ_VERY_HIGH` | 100MHz 이상    | FMC, SDIO 등   |

출력 속도는 실제 신호의 rise/fall time을 조정하는 것으로,
 **전력 소모 및 EMI 특성**에 영향을 준다.

------

### GPIO 전류 구동 능력

각 포트는 평균적으로 **20mA 이하**를 권장하며,
 VDD 및 GND 라인의 총 합은 **150mA 이하**로 제한된다.
 LED 직구동 시에는 반드시 저항(330~1kΩ)을 직렬 연결해야 한다.

------

### 요약

| 구분              | 설정값                | 주요 용도           |
| ----------------- | --------------------- | ------------------- |
| Output Push-Pull  | `GPIO_MODE_OUTPUT_PP` | LED, 디지털 IC 구동 |
| Output Open-Drain | `GPIO_MODE_OUTPUT_OD` | I²C, 버스형 출력    |
| Input Pull-up     | `GPIO_PULLUP`         | 스위치 입력         |
| Input Pull-down   | `GPIO_PULLDOWN`       | 트리거 감지         |
| Analog            | `GPIO_MODE_ANALOG`    | ADC 입력, 저전력    |

------

GPIO 설정은 **CubeMX의 Pinout Configuration → GPIO Mode 설정**을 통해 시각적으로 지정할 수 있으며,
 코드 생성 후 `MX_GPIO_Init()` 함수 내의 초기화 코드로 자동 반영된다.
 이는 이후 타이머, PWM, UART, ADC 등 모든 주변장치 설정의 기반이 된다.4.3 HAL_GPIO API / Register 직접 접근 비교

## 4.4 LED 제어 실습

LED 제어는 GPIO 출력의 가장 기본적인 예제로, MCU의 출력 포트를 이용해 디지털 신호(High/Low)를 제어함으로써 LED의 점등/소등을 수행한다. STM32에서는 `HAL_GPIO_WritePin()` 혹은 `HAL_GPIO_TogglePin()` 함수를 통해 손쉽게 구현할 수 있다.

------

### ① 하드웨어 구성

- **LED 핀 연결**: MCU의 임의의 GPIO 핀 (예: PC13)을 통해 LED 음극(−)을 제어.
- **회로 구성**:
  - VCC (3.3V) → 저항(330Ω~1kΩ) → LED → GPIO 핀
  - 또는, GPIO 핀 → LED → 저항 → GND
- **주의**: GPIO 핀의 Sink/Source 전류는 MCU 데이터시트에 명시된 한계를 초과하지 않아야 한다.

------

### ② 코드 구조

```
/* LED 제어 예제 */
#include "main.h"

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();

    while (1)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        HAL_Delay(500); // 500ms 주기로 LED 토글
    }
}
```

------

### ③ HAL 함수 분석

- `HAL_GPIO_TogglePin(GPIOx, Pin)` : 지정된 핀의 현재 상태를 반전시킴.
- `HAL_GPIO_WritePin(GPIOx, Pin, GPIO_PIN_SET/RESET)` : 명시적으로 High 또는 Low 출력.
- `HAL_Delay(ms)` : SysTick 기반의 지연 함수. FreeRTOS 사용 시 `vTaskDelay()`로 대체 가능.

------

### ④ 디버깅 포인트

- CubeMX에서 **GPIO Mode**가 Output Push-Pull인지 확인.
- CubeIDE의 Debug 모드에서 PC13 비트값을 “Watch”로 확인 가능.
- 전류 제한 저항 누락 시 LED 또는 MCU 핀 손상 위험.

------

### ⑤ 확장 응용

- 다중 LED (예: LED 배열 제어) → `for` 루프 기반 순차점등 효과 구현.
- PWM 기반 밝기 제어 → TIM Peripheral 사용.
- FreeRTOS 환경에서는 LED Task로 독립 구성해 Task 주기 확인 용도로 활용 가능.

------

## 4.5 스위치 입력 디바운싱

기계식 스위치는 접점이 물리적으로 닫히는 순간 진동(bounce)이 발생하며, 수 밀리초(ms) 동안 불안정한 High/Low 신호가 출력된다. MCU가 이를 그대로 읽을 경우 다중 입력으로 인식하는 오류가 발생한다. 이를 방지하기 위해 **디바운싱(Debouncing)** 처리가 필요하다.

------

### ① 하드웨어 디바운싱

- **RC 필터** (저항 + 커패시터) 사용.
  - 저항과 커패시터를 직렬 또는 병렬로 연결해 신호 안정화.
  - 일반적으로 10kΩ 저항, 0.1µF 커패시터 조합 사용.
- **슈미트 트리거 입력 (Schmitt Trigger)**
  - STM32의 GPIO 입력은 대부분 슈미트 트리거 특성이 있으므로 기본적인 노이즈 억제가 가능.

------

### ② 소프트웨어 디바운싱

1. **지연 기반 방식**

   ```
   if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) {
       HAL_Delay(20); // 20ms 대기
       if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) {
           // 유효한 입력
       }
   }
   ```

2. **상태 머신 기반 방식**

   - 스위치 상태(Released, Pressed, Stable)를 주기적으로 샘플링하여 안정화된 입력만 인식.
   - FreeRTOS 환경에서는 Task 주기(10~20ms)마다 폴링하여 처리.

3. **타이머 기반 인터럽트 방식**

   - EXTI 인터럽트 발생 시, 타이머를 시작하고 특정 시간(예: 10ms) 후 입력 재확인.
   - 빠른 응답성과 안정성 모두 확보 가능.

------

### ③ 인터럽트 연동 예시

```
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        static uint32_t last_tick = 0;
        if (HAL_GetTick() - last_tick > 50) // 50ms 차단 구간
        {
            // 유효한 버튼 입력 처리
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
            last_tick = HAL_GetTick();
        }
    }
}
```

------

### ④ 디바운싱 설계 고려사항

- 입력 샘플링 주기와 사람의 반응속도(약 100~200ms)를 고려해야 함.
- 짧은 버튼은 **Edge Trigger**, 긴 입력(홀드 기능)은 **State Machine** 방식이 적합.
- 장시간 폴링 시 CPU 점유율 증가 가능 → 인터럽트 기반 구현 권장.

------

### ⑤ 실무 적용 예시

- **메뉴 선택 버튼**: 짧은 입력(클릭), 긴 입력(홀드) 구분.
- **긴급 정지 스위치(E-Stop)**: 하드웨어 및 소프트웨어 디바운싱 병행.
- **휴대기기 전원 버튼**: 1초 이상 눌렀을 때만 On/Off 작동하도록 상태머신 처리.

------

### ⑥ 결론

LED 제어와 스위치 입력은 GPIO의 기본 동작을 이해하는 핵심 주제이다.
 디바운싱은 단순한 지연이 아니라 시스템 응답성과 신뢰성을 좌우하는 필수 설계 요소로, 하드웨어·소프트웨어 접근을 함께 고려해야 한다.

## 4.6 외부 인터럽트 (EXTI) 실습

**EXTI (External Interrupt/Event Controller)**는 외부 입력 핀에서 발생하는 신호 변화를 감지하여 MCU가 즉시 반응할 수 있도록 하는 하드웨어 인터럽트 시스템이다.
 STM32의 모든 GPIO 핀은 EXTI 라인에 매핑될 수 있으며, Rising / Falling / Both Edge 트리거를 지원한다.

------

### ① EXTI의 동작 구조

- **GPIO 입력 핀 → SYSCFG (External Interrupt Configuration Register)**
- **SYSCFG → EXTI Controller → NVIC (Interrupt Vector Table)**

즉, 특정 GPIO 핀의 변화(상승/하강)를 감지하면 EXTI 라인을 통해 NVIC로 인터럽트 요청(IRQ)이 전달되고, 사용자 정의 핸들러(`HAL_GPIO_EXTI_Callback()`)가 실행된다.

------

### ② CubeMX 설정 절차

1. **Pinout 탭**
   - 버튼 입력 핀 선택 (예: `PA0` → GPIO_EXTI0).
2. **Configuration 탭 → GPIO Settings**
   - Mode: *External Interrupt Mode with Rising Edge Trigger Detection* 선택.
   - Pull-up/Pull-down: 버튼 회로 구성에 맞게 설정.
3. **NVIC 설정**
   - EXTI0 interrupt 활성화 체크.
4. **코드 생성 후 빌드/플래시**

------

### ③ 예제 코드

```
/* main.c */
#include "main.h"

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
    }
}

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();

    while (1)
    {
        // 메인 루프는 비워둠, 인터럽트만 동작
    }
}
```

------

### ④ 코드 흐름

1. 버튼이 눌리면 GPIO 입력 신호가 하강(Rising/Falling)한다.
2. SYSCFG를 통해 해당 핀이 EXTI0 라인에 연결되어 있음.
3. EXTI 라인이 Pending 상태로 전환되며 NVIC에 IRQ 요청 발생.
4. NVIC가 `EXTI0_IRQHandler()`를 호출 → 내부에서 HAL이 `HAL_GPIO_EXTI_Callback()` 실행.
5. 사용자 코드에 정의된 LED 토글 코드 실행.

------

### ⑤ 디버깅 및 주의사항

- **동일 라인 공유 문제**: EXTI0~EXTI15까지 총 16라인만 존재하므로 동일 번호 핀 간 충돌 주의 (예: PA0와 PB0 동시 사용 불가).
- **인터럽트 부하 방지**: 디바운싱 미적용 시 짧은 시간에 다중 인터럽트 발생 가능.
- **콜백 중 장시간 작업 금지**: 인터럽트 핸들러 내에서는 반드시 짧고 간결한 코드만 실행.

------

### ⑥ 응용 예시

- 버튼 입력 이벤트 처리
- 인코더 방향 감지
- 외부 센서의 “데이터 준비” 신호 감지 (e.g., DRDY 핀)
- 저전력 모드에서 외부 신호로 MCU 웨이크업

------

## 4.7 NVIC 설정과 인터럽트 우선순위

**NVIC (Nested Vectored Interrupt Controller)**는 ARM Cortex-M 코어 내부에 통합된 인터럽트 관리 유닛이다.
 인터럽트의 **우선순위(Priority)**, **중첩(Nesting)**, **마스크(Masking)** 등을 제어하여 실시간성을 확보한다.

------

### ① NVIC의 주요 기능

- 최대 240개의 인터럽트 소스 관리 (시리즈별 상이).
- 하드웨어 벡터 테이블 기반의 자동 분기.
- 인터럽트 중첩 허용 (Nested Interrupt Handling).
- 소프트웨어 인터럽트(SWI) 트리거 지원.

------

### ② 우선순위 구조

- Cortex-M3/M4/M7 코어 기준, NVIC는 4~8비트의 우선순위 레벨을 지원.
- STM32 HAL에서는 “**Preemption Priority**”와 “**Sub Priority**”로 구분.
  - **Preemption Priority**: 더 높은 우선순위 인터럽트가 낮은 우선순위 인터럽트를 중단할 수 있는 단계.
  - **Sub Priority**: 동일 Preemption 레벨 내에서의 실행 순서 결정.

------

### ③ NVIC 설정 방법

#### (1) CubeMX에서 설정

- `System Core → NVIC` 메뉴에서 각 인터럽트의 우선순위 지정.
- 일반적으로 “0”이 가장 높은 우선순위.

#### (2) 코드 수동 설정

```
HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
```

#### (3) NVIC 비활성화

```
HAL_NVIC_DisableIRQ(EXTI0_IRQn);
```

------

### ④ 인터럽트 중첩 예시

```
// EXTI0_IRQn (우선순위 1), TIM2_IRQn (우선순위 2)

void EXTI0_IRQHandler(void)
{
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 높은 우선순위
}

void TIM2_IRQHandler(void)
{
    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);  // 낮은 우선순위
}
```

- 실행 중 TIM2 인터럽트가 발생하더라도 EXTI0 (더 높은 우선순위)이 들어오면 즉시 중단하고 EXTI0 처리 후 복귀.

------

### ⑤ 인터럽트 벡터 테이블

- `startup_stm32f1xx.s` 내에 각 인터럽트 핸들러의 벡터 주소 정의.
- 사용자는 HAL이 제공하는 `HAL_GPIO_EXTI_Callback()` 또는 직접 정의한 핸들러를 구현 가능.

------

### ⑥ 우선순위 설계 원칙

| 구분                            | 우선순위 | 비고                   |
| ------------------------------- | -------- | ---------------------- |
| 긴급 정지, Fault                | 0        | 최상위                 |
| 실시간 제어 (PWM, Timer)        | 1~2      | 빠른 응답 필요         |
| 통신 인터럽트 (USART, SPI, I2C) | 3~4      | 데이터 손실 방지       |
| 사용자 입력 (EXTI, Button)      | 5~7      | 비교적 느려도 무방     |
| 백그라운드 이벤트               | 8 이상   | DMA 완료, 상태 갱신 등 |

------

### ⑦ 디버깅 시 유용한 팁

- **NVIC Pending 상태 확인**: `NVIC_GetPendingIRQ()` 사용.
- **인터럽트 활성 상태 확인**: `__HAL_NVIC_IS_ENABLED()` 매크로 활용.
- **FreeRTOS 사용 시 주의**: 커널 내부에서 NVIC 우선순위 5 이하만 ISR로 등록 가능 (`configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY`).

------

### ⑧ 요약

- EXTI는 GPIO 입력 신호를 NVIC 인터럽트로 연결하는 하드웨어 통로.
- NVIC은 모든 인터럽트의 실행 순서와 중첩을 제어하는 핵심 제어기.
- 효율적인 실시간 시스템 설계를 위해, 인터럽트 우선순위는 하드 실시간성 요구사항에 따라 체계적으로 구성되어야 한다.