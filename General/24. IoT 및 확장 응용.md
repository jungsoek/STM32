# 24. IoT 및 확장 응용

## 24.1 ESP32 / STM32 간 UART 통신

### 개요

ESP32와 STM32 간의 UART 통신은 **이종 MCU 간 데이터 교환(Serial Bridge)**을 구현하는 대표적인 방법이다.
 ESP32는 Wi-Fi 및 BLE 기능을 제공하며, STM32는 정밀한 센서 제어나 실시간 신호 처리를 담당한다.
 두 장치를 UART(Universal Asynchronous Receiver/Transmitter)로 연결하면, **저속 신뢰성 기반의 데이터 통신 채널**을 구성할 수 있다.
 이 구성은 IoT 센서 허브, 로깅 시스템, OTA 업데이트 브릿지 등 다양한 시스템의 기본 구조로 활용된다.

------

### 시스템 구성도

```
┌────────────┐        UART TX/RX         ┌─────────────┐
│   STM32    │  <--------------------->  │    ESP32    │
│ (Sensor)   │                          │ (Wi-Fi/BLE) │
└────────────┘                          └─────────────┘
```

- **STM32 역할:** 센서 데이터 수집, 연산, 버퍼 관리, 실시간 제어
- **ESP32 역할:** Wi-Fi/BLE 통신, 클라우드 전송, 원격 명령 수신

------

### 하드웨어 연결 구성

| STM32 Pin                  | ESP32 Pin                | 기능        |
| -------------------------- | ------------------------ | ----------- |
| TX (e.g. PA9 / USART1_TX)  | RX (e.g. GPIO16 / U2RXD) | 데이터 전송 |
| RX (e.g. PA10 / USART1_RX) | TX (e.g. GPIO17 / U2TXD) | 데이터 수신 |
| GND                        | GND                      | 공통 접지   |

- **전압 주의:** STM32(3.3V) ↔ ESP32(3.3V) 직접 연결 가능
- **통신 속도:** 기본 115200bps, 필요 시 921600bps까지 가능
- **풀업 저항:** 일반적으로 필요 없음, 단 장거리 케이블 사용 시 노이즈 필터 권장

------

### STM32 측 코드 예시 (HAL 기반)

```
#include "usart.h"
#include "string.h"

uint8_t rx_buffer[64];
uint8_t tx_buffer[64];

void UART_Send_To_ESP32(const char* msg) {
    HAL_UART_Transmit(&huart1, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART1) {
        // 수신 데이터 처리
        if (strstr((char*)rx_buffer, "CMD_LED_ON")) {
            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
            UART_Send_To_ESP32("LED ON OK\n");
        }
        HAL_UART_Receive_IT(&huart1, rx_buffer, sizeof(rx_buffer));
    }
}

void UART_Init_And_Start(void) {
    HAL_UART_Receive_IT(&huart1, rx_buffer, sizeof(rx_buffer));
    UART_Send_To_ESP32("STM32 Ready\n");
}
```

**설명:**

- 인터럽트 기반 비동기 수신 (`HAL_UART_Receive_IT`)
- 명령어 수신 후 파싱 처리
- 응답 메시지 송신

------

### ESP32 측 코드 예시 (Arduino Framework)

```
#define RXD2 16
#define TXD2 17

void setup() {
  Serial.begin(115200);     // 디버그용
  Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2);
  Serial.println("ESP32 Ready");
}

void loop() {
  if (Serial2.available()) {
    String msg = Serial2.readStringUntil('\n');
    Serial.print("STM32 → ESP32: ");
    Serial.println(msg);

    if (msg.indexOf("Ready") >= 0) {
      Serial2.println("CMD_LED_ON"); // STM32 LED 제어 명령
    }
  }
}
```

**설명:**

- `Serial2` 사용 (하드웨어 UART2: GPIO16/17)
- STM32 메시지 수신 후 명령 전송
- PC 시리얼 모니터에서 로그 확인 가능

------

### 양방향 통신 프로토콜 설계

UART은 단순한 바이트 스트림이므로, **프레임 구조 정의**가 필요하다.
 일반적으로 다음과 같은 포맷을 사용한다:

```
<STX><CMD><DATA><CHK><ETX>
```

| 필드 | 설명              | 예시              |
| ---- | ----------------- | ----------------- |
| STX  | Start Byte (0x02) | 패킷 시작 구분    |
| CMD  | 명령 코드         | 'T' = Temperature |
| DATA | 페이로드          | ASCII 또는 HEX    |
| CHK  | Checksum          | XOR 또는 CRC8     |
| ETX  | End Byte (0x03)   | 패킷 종료         |

**예시:**

```
0x02 0x54 0x32 0x35 0x2E 0x35 0x0A 0x03
(STX)(T)(2)(5)(.)(5)(LF)(ETX)
```

------

### 통신 오류 처리

- **Parity Error**: `USART_CR1_PCE` 비트로 패리티 검사
- **Framing Error**: RX 라인 노이즈 → `UART_FLAG_FE` 플래그 확인
- **Overrun Error**: 수신 속도 초과 시 DMA 활용
- **Checksum 검증 실패 시 재전송 요청**

```
if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_ORE)) {
    __HAL_UART_CLEAR_FLAG(&huart1, UART_FLAG_ORE);
}
```

------

### DMA 기반 UART 확장 (STM32)

DMA를 이용하면 CPU 개입 없이 대량 데이터를 송수신할 수 있다.

```
HAL_UART_Transmit_DMA(&huart1, tx_buffer, length);
HAL_UART_Receive_DMA(&huart1, rx_buffer, 128);
```

- 실시간 센서 스트림이나 로그 송신에 적합
- Circular DMA 버퍼와 함께 사용 시 지속 수신 가능

------

### FreeRTOS 환경에서의 구조

- **UART Rx Task:** 수신 버퍼 모니터링 및 Queue 전송
- **Command Parser Task:** 메시지 분석 및 처리
- **Tx Task:** 송신 요청 처리 및 응답
- **Semaphore:** UART 접근 동기화

```
xQueueSend(uartQueue, &rxMsg, portMAX_DELAY);
```

------

### 통신 타이밍 / 버퍼 설계 팁

| 항목                | 권장 값       | 설명               |
| ------------------- | ------------- | ------------------ |
| Baud Rate           | 115200~460800 | 안정성과 속도 균형 |
| Rx Buffer           | ≥ 128 bytes   | Burst 대응         |
| Idle Line Detection | Enabled       | 수신 종료 감지     |
| DMA Mode            | Circular      | 연속 데이터 수집용 |
| Line Ending         | '\n'          | 명령 구분자        |

------

### 응용 확장 아이디어

- **Wi-Fi → STM32 센서 브릿지** (ESP32 HTTP Server ↔ STM32 UART)
- **BLE UART Service → STM32 디바이스 제어**
- **ESP32 OTA 펌웨어 다운로드 → STM32 Flash Write 전송**
- **STM32 데이터 → ESP32 MQTT Publish 브릿지**
- **ESP32 ↔ STM32 간 Firmware Debug Console**

------

### 분석 요약

| 구분            | 내용                                   |
| --------------- | -------------------------------------- |
| 연결 인터페이스 | UART TX/RX                             |
| 통신 속도       | 115200bps 기본                         |
| 동작 모드       | Interrupt / DMA 기반 비동기            |
| 통신 구조       | 명령/응답형 패킷 구조                  |
| 주요 기능       | 데이터 송수신, 명령 처리, 상태 보고    |
| 활용 분야       | IoT, 센서 허브, 원격 로깅, 펌웨어 제어 |

------

### 결론

ESP32–STM32 UART 연동은 **Wi-Fi 및 BLE 기능을 외부 확장하는 가장 효율적인 방식**이다.
 UART 인터럽트, DMA, FreeRTOS Queue를 병행 활용하면 신뢰성 있는 비동기 데이터 교환이 가능하며,
 향후 MQTT, OTA, Modbus RTU, CLI Console 등 상위 프로토콜로 확장할 수 있다.

## 24.2 BLE GATT Profile 설계

### 개요

BLE(GATT: Generic Attribute Profile)는 Bluetooth Low Energy 통신에서 데이터 구조와 접근 방식을 정의하는 핵심 계층이다. GATT는 Service–Characteristic–Descriptor로 구성되며, 각 노드는 Attribute Handle 기반으로 데이터 교환을 수행한다. STM32(또는 ESP32)에서 GATT를 직접 설계하면 BLE 기반의 센서 노드, 로거, 제어기 등의 구조적 데이터 교환이 가능하다.

------

### GATT Profile 기본 구조

- **Service**: 기능 단위의 논리 그룹 (예: Environmental Sensing Service, Device Information Service)
- **Characteristic**: 실제 데이터 단위 (예: Temperature, Humidity, Battery Level)
- **Descriptor**: Characteristic의 속성 추가정보 (예: Notification 설정, 단위, 포맷 등)

------

### 설계 단계

#### 1. GATT 서비스 트리 구조 정의

- 프로젝트 목적에 따라 **Custom Service** 또는 **표준 SIG 정의 Service** 선택
- 예:
  - Environmental Sensor Service (UUID: 0x181A)
  - Custom Weight Scale Service (UUID: 0xFFF0)

#### 2. Characteristic 정의

- 각 데이터 포인트마다 별도 UUID 부여

- 속성 정의 (Read / Write / Notify / Indicate)

- 예시:

  | Characteristic | UUID   | Property    | Data Type | 예시 값        |
  | -------------- | ------ | ----------- | --------- | -------------- |
  | Temperature    | 0x2A6E | Notify      | int16_t   | 2500 (25.00°C) |
  | Humidity       | 0x2A6F | Notify      | uint16_t  | 450 (45%)      |
  | Battery Level  | 0x2A19 | Read/Notify | uint8_t   | 90 (%)         |

#### 3. Descriptor 설정

- Client Characteristic Configuration Descriptor (CCCD, 0x2902) 사용
- Client가 Notify/Indicate 기능을 활성화할 수 있도록 구성

#### 4. Attribute Table 구성

- Attribute Handle 순서대로 정리

- 예시:

  | Handle | Type            | UUID   | Value / 설명       |
  | ------ | --------------- | ------ | ------------------ |
  | 0x0001 | Primary Service | 0xFFF0 | Weight Service     |
  | 0x0002 | Characteristic  | 0xFFF1 | Weight Data        |
  | 0x0003 | Value           | 0xFFF1 | 측정 무게 값 (g)   |
  | 0x0004 | Descriptor      | 0x2902 | CCCD (Notify 설정) |

------

### STM32 (BlueNRG / WB 시리즈) 구현 포인트

- **Middleware: STM32_BLE Stack (HCI + GATT)**
- **핵심 API:**
  - `aci_gatt_add_service()`, `aci_gatt_add_char()`, `aci_gatt_update_char_value()`
- **특징:**
  - HCI Layer를 통해 UART/SPI로 BLE 모듈 제어
  - FreeRTOS Task 기반 Notification 처리 가능
  - Attribute Table은 초기화 시 등록 후 변경 불가

------

### ESP32 구현 포인트

- **라이브러리:** `NimBLE` 또는 `ESP-IDF BLE GATT Server API`

- **핵심 구조:**

  - `esp_ble_gatts_create_attr_tab()`로 Attribute Table 등록
  - 이벤트 콜백(`ESP_GATTS_READ_EVT`, `ESP_GATTS_WRITE_EVT`, `ESP_GATTS_CONNECT_EVT`)에서 데이터 처리

- **예시:**

  ```
  esp_ble_gatts_create_attr_tab(gatt_db, gatts_if, NUM_HANDLE, 0);
  esp_ble_gatts_add_char(service_handle, &char_uuid, 
                         ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                         ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_NOTIFY, 
                         NULL, NULL);
  ```

------

### GATT Profile 설계 예제

#### 예제 1: 스마트 체중계 (Weight Service)

- Service UUID: 0xFFF0
- Characteristics:
  - Weight Data (Notify, 0xFFF1)
  - Battery Level (Read, 0x2A19)

#### 예제 2: 환경 센서 허브 (Environmental Service)

- Service UUID: 0x181A
- Characteristics:
  - Temperature (Notify, 0x2A6E)
  - Humidity (Notify, 0x2A6F)
  - Pressure (Notify, 0x2A6D)

------

### GATT 설계 시 주의사항

- UUID는 16bit(표준) 또는 128bit(Custom) 모두 사용 가능
- Handle 번호는 자동 증가 방식 (변경 불가)
- Notify/Indicate 활성화를 위해 CCCD 반드시 추가
- Attribute Table 변경 시 재등록 필요 (Reinit)
- 데이터 전송 시 MTU(Max Transmission Unit) 고려 (기본 20byte, 확장 가능)

------

### 참고 자료

- Bluetooth SIG GATT Specification
- STMicroelectronics **AN5289 – BlueNRG GATT Database Management**
- Espressif **ESP-IDF BLE GATT Server Example**
- Nordic Semiconductor **nRF Connect / nRF Sniffer**

## 24.3 Wi-Fi 모듈 (ESP8266, ESP32) 연동

### 개요

Wi-Fi 모듈은 STM32와 같은 MCU가 직접 TCP/IP 스택을 처리하기 어려운 환경에서 무선 네트워크 통신을 가능하게 해준다. 대표적으로 **ESP8266**과 **ESP32**는 저전력 SoC로서 UART, SPI, 또는 AT Command 인터페이스를 통해 STM32와 통신하며, IoT 데이터 전송, OTA 업데이트, MQTT 클라우드 연동 등에 사용된다.

------

### Wi-Fi 통신 방식

#### 1. **AT Command 기반 (STM32 ↔ ESP8266/ESP32)**

- UART를 통한 문자열 명령어 인터페이스
- STM32는 단순 시리얼 명령 송신기로 동작
- ESP는 내부 TCP/IP Stack을 이용해 Wi-Fi 및 소켓 처리

#### 2. **직접 제어 기반 (ESP32 독립 MCU로 사용)**

- STM32는 보조 MCU, ESP32는 주 MCU로 동작
- FreeRTOS + Wi-Fi + BLE + MQTT 통합 가능
- UART/I²C/SPI로 STM32와 데이터 교환

------

### 하드웨어 연결

| STM32          | ESP8266 / ESP32 | 기능             |
| -------------- | --------------- | ---------------- |
| TX (USARTx_TX) | RX              | AT 명령 송신     |
| RX (USARTx_RX) | TX              | 응답 수신        |
| 3.3V           | VCC             | 전원 공급        |
| GND            | GND             | 공통 접지        |
| EN / RST       | EN / RST        | 모듈 초기화 제어 |

> **주의:** ESP8266은 부팅 시 전류 피크(>300mA)가 발생하므로 **전원 안정화용 커패시터(470µF 이상)** 권장.

------

### 펌웨어 구성 예시 (AT Command 모드)

#### STM32 측 UART 초기화 예제 (HAL 기반)

```
void MX_USART2_UART_Init(void)
{
    huart2.Instance = USART2;
    huart2.Init.BaudRate = 115200;
    huart2.Init.WordLength = UART_WORDLENGTH_8B;
    huart2.Init.StopBits = UART_STOPBITS_1;
    huart2.Init.Parity = UART_PARITY_NONE;
    huart2.Init.Mode = UART_MODE_TX_RX;
    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart2.Init.OverSampling = UART_OVERSAMPLING_16;
    HAL_UART_Init(&huart2);
}
```

#### ESP8266 제어 명령 예시

```
HAL_UART_Transmit(&huart2, (uint8_t*)"AT\r\n", 4, 1000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+CWMODE=1\r\n", 13, 1000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+CWJAP=\"SSID\",\"PASS\"\r\n", 25, 3000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+CIPSTART=\"TCP\",\"192.168.0.10\",8080\r\n", 41, 3000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+CIPSEND=10\r\n", 15, 1000);
HAL_UART_Transmit(&huart2, (uint8_t*)"HelloWorld", 10, 1000);
```

#### 응답 수신 처리

```
uint8_t rx_buf[256];
HAL_UART_Receive(&huart2, rx_buf, sizeof(rx_buf), 1000);
printf("ESP Response: %s\r\n", rx_buf);
```

------

### ESP32 독립 MCU 모드

#### 1. STM32 ↔ ESP32 UART 프로토콜

- STM32가 센서 데이터 전송
- ESP32는 Wi-Fi 및 MQTT 클라우드 전송

#### 2. ESP32 측 코드 (Arduino / ESP-IDF) 예시

```
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {
  Serial.begin(115200);
  WiFi.begin("SSID", "PASS");
  while (WiFi.status() != WL_CONNECTED) delay(500);

  client.setServer("test.mosquitto.org", 1883);
}

void loop() {
  if (Serial.available()) {
    String data = Serial.readStringUntil('\n');
    client.publish("stm32/data", data.c_str());
  }
}
```

------

### TCP/UDP 송신 구조

#### TCP Client 모드

1. `AT+CIPSTART="TCP","IP",PORT`
2. `AT+CIPSEND=LEN`
3. 데이터 전송 후 `SEND OK` 수신
4. 서버에서 응답 수신

#### UDP Client 모드

1. `AT+CIPSTART="UDP","IP",PORT`
2. `AT+CIPSEND=LEN`
3. `AT+CIPCLOSE`로 연결 종료

------

### 실습 예제: Wi-Fi 데이터 로거

#### 구성

- 센서 (BME280) → STM32 → ESP8266 → Wi-Fi → MQTT Broker
- 통신 프로토콜: UART (115200bps)
- 데이터 형식: `TEMP:24.5,HUM:52.1,PRES:1013.2`

#### CubeIDE + HAL 기반 STM32 송신 코드

```
sprintf(tx_buf, "TEMP:%.1f,HUM:%.1f,PRES:%.1f\r\n", temp, hum, pres);
HAL_UART_Transmit(&huart2, (uint8_t*)tx_buf, strlen(tx_buf), 100);
```

------

### 디버깅 및 검증

- **Wireshark**: TCP/UDP 데이터 흐름 확인
- **MQTT Explorer**: MQTT 토픽 데이터 모니터링
- **AT Command 로그 분석**: 실패 응답(`ERROR`, `FAIL`) 원인 추적

------

### 주의사항

- ESP8266의 펌웨어 버전에 따라 명령어 차이 존재 (예: v2.2 이상부터 SSL 지원)
- UART 버퍼 오버플로 방지를 위한 **DMA 수신** 권장
- Wi-Fi 연결 유지용 **Watchdog 타이머** 구성 필요
- FreeRTOS 환경에서는 AT 송신/수신 Task 분리

------

### 확장 응용

- **MQTT 클라우드 업로드** (ThingSpeak, HiveMQ, AWS IoT)
- **OTA 펌웨어 다운로드** (HTTP GET 방식)
- **Wi-Fi + BLE 동시 통신 (ESP32)**
- **SoftAP 모드 기반 로컬 설정 페이지 제공**

------

### 참고 자료

- Espressif **ESP8266 AT Instruction Set**
- Espressif **ESP-IDF Wi-Fi API Reference**
- STMicroelectronics **UM2609 – Wi-Fi Communication with ESP8266 using STM32**
- Example Repositories:
  - [esp8266_at](https://github.com/espressif/esp-at)
  - [esp32-mqtt](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt)

## 24.4 MQTT / HTTP 프로토콜

### 개요

MQTT와 HTTP는 IoT 환경에서 MCU(예: STM32, ESP32)가 클라우드 서버와 데이터를 주고받기 위해 가장 널리 사용되는 애플리케이션 계층 프로토콜이다.

- **MQTT**는 경량 메시지 기반 프로토콜로 저전력·저대역폭 환경에 적합하며, 센서 네트워크 및 실시간 상태 전송에 사용된다.
- **HTTP**는 RESTful API 방식으로 데이터를 송수신하며, 파일 업로드·다운로드, OTA 업데이트 등 일반 네트워크 서비스에 적합하다.

본 절에서는 두 프로토콜의 구조, 통신 절차, 펌웨어 구현 방식, 네트워크 최적화 및 오류 복구 기법을 다룬다.

------

### MQTT 프로토콜

#### 특징

- 메시지 기반의 **Publish/Subscribe 구조**
- 브로커(Broker)가 클라이언트 간 메시지를 중계
- QoS(Quality of Service) 0/1/2 단계 지원
- 지속 연결(TCP) 기반, Keep-Alive 기능
- 메시지 주제(Topic) 단위로 데이터 분류

#### 데이터 흐름 구조

```
[Sensor Node (STM32/ESP32)]
        ↓ Publish
     MQTT Broker
        ↓ Subscribe
 [Cloud Dashboard / Mobile App]
```

#### 주요 명령 및 개념

| 명령               | 설명             |
| ------------------ | ---------------- |
| CONNECT            | 브로커 접속 요청 |
| PUBLISH            | 메시지 전송      |
| SUBSCRIBE          | 특정 Topic 구독  |
| PINGREQ / PINGRESP | Keep-Alive 유지  |
| DISCONNECT         | 연결 종료        |

#### QoS 레벨

| QoS  | 의미          | 특징                      |
| ---- | ------------- | ------------------------- |
| 0    | At most once  | 손실 가능, 최소 오버헤드  |
| 1    | At least once | 재전송 보장               |
| 2    | Exactly once  | 중복 없는 전송, 높은 지연 |

------

### MQTT 예제 (ESP32 / STM32 + ESP8266)

#### ESP32 (Arduino) MQTT 클라이언트 예제

```
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {
  Serial.begin(115200);
  WiFi.begin("SSID", "PASS");
  while (WiFi.status() != WL_CONNECTED) delay(500);

  client.setServer("broker.hivemq.com", 1883);
}

void loop() {
  if (!client.connected()) {
    if (client.connect("stm32_node")) {
      client.publish("iot/data", "Connected");
      client.subscribe("iot/cmd");
    }
  }
  if (Serial.available()) {
    String msg = Serial.readStringUntil('\n');
    client.publish("iot/data", msg.c_str());
  }
  client.loop();
}
```

#### STM32 → ESP8266 → MQTT Broker (AT Command)

```
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+MQTTUSERCFG=0,1,\"STM32NODE\",\"user\",\"pass\",0,0,\"\"\r\n", 60, 1000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+MQTTCONN=0,\"broker.hivemq.com\",1883,0\r\n", 40, 2000);
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+MQTTPUB=0,\"stm32/data\",\"TEMP:24.3,HUM:51.9\",0,0\r\n", 55, 1000);
```

------

### HTTP 프로토콜

#### 특징

- 요청(Request)과 응답(Response) 기반 구조
- RESTful API, JSON 데이터 전송 형식
- OTA 업데이트, 파일 업로드, REST API 호출에 활용
- 단순 연결, 요청 단위로 TCP 세션 생성

#### 요청/응답 구조

```
Client → Server
GET /api/data HTTP/1.1
Host: example.com
Content-Type: application/json

Response:
HTTP/1.1 200 OK
Content-Type: application/json
{"temp":24.1,"hum":53.2}
```

#### 주요 메서드

| 메서드 | 용도          | 특징            |
| ------ | ------------- | --------------- |
| GET    | 데이터 요청   | 센서 조회       |
| POST   | 데이터 업로드 | 로깅, 제어 명령 |
| PUT    | 리소스 갱신   | 설정 변경       |
| DELETE | 리소스 삭제   | 관리용          |

------

### HTTP 클라이언트 예제

#### ESP32 (Arduino)

```
#include <WiFi.h>
#include <HTTPClient.h>

void setup() {
  WiFi.begin("SSID", "PASS");
  while (WiFi.status() != WL_CONNECTED) delay(500);
}

void loop() {
  HTTPClient http;
  http.begin("http://example.com/api/upload");
  http.addHeader("Content-Type", "application/json");

  String payload = "{\"temp\":24.5,\"hum\":52.1}";
  int httpResponseCode = http.POST(payload);
  Serial.println(httpResponseCode);
  http.end();
  delay(5000);
}
```

#### STM32 (ESP8266 AT 명령 사용)

```
HAL_UART_Transmit(&huart2, (uint8_t*)"AT+HTTPCLIENT=2,0,\"http://example.com/api/upload\",\"\",\"{\\\"temp\\\":24.5}\",1\r\n", 95, 5000);
```

------

### MQTT vs HTTP 비교

| 구분        | MQTT                 | HTTP                 |
| ----------- | -------------------- | -------------------- |
| 연결 방식   | 지속 연결 (TCP)      | 단발성 요청/응답     |
| 오버헤드    | 매우 낮음            | 상대적으로 높음      |
| 데이터 형식 | Topic + Payload      | URI + JSON           |
| 적합 분야   | 실시간 센서 데이터   | 파일, API, 설정 전송 |
| 전송 주기   | 주기적 / 이벤트 기반 | 요청 시마다          |
| 보안        | TLS (MQTTS)          | HTTPS                |

------

### 클라우드 플랫폼 연동

| 서비스             | 프로토콜     | 특징                  |
| ------------------ | ------------ | --------------------- |
| HiveMQ             | MQTT         | 공개 브로커, 테스트용 |
| ThingSpeak         | HTTP / MQTT  | 시각화 기능 제공      |
| AWS IoT Core       | MQTT (TLS)   | 인증서 기반 보안      |
| Google Cloud IoT   | MQTT / HTTPS | 대규모 디바이스 관리  |
| Node-RED Dashboard | MQTT / HTTP  | 로컬 서버용           |

------

### QoS 및 재접속 관리

- **MQTT 연결 유지:**
  - `client.loop()` 주기 호출
  - 연결 끊김 시 자동 재연결
- **HTTP 재시도 로직:**
  - `HTTPClient` 응답 코드 검사 (`200 OK`)
  - 오류 발생 시 지수적 Backoff 적용

#### STM32 예시

```
if (HAL_UART_Transmit(&huart2, cmd, strlen(cmd), 2000) != HAL_OK) {
    retry_count++;
    HAL_Delay(1000 * retry_count);
}
```

------

### 보안 확장

- **MQTTS (TLS over MQTT)**
  - 포트 8883 사용
  - X.509 인증서 기반 암호화
- **HTTPS**
  - SSL 인증서 검증 및 인증
  - OTA 펌웨어 무결성 보장

------

### 디버깅 및 트러블슈팅

- **Wireshark:** TCP/SSL/MQTT 패킷 분석
- **MQTT Explorer:** 토픽 실시간 모니터링
- **Postman:** REST API 테스트
- **ESP AT Log:** 전송 결과, 연결 상태 확인

------

### 실습 응용

- **MQTT 센서 허브:**
  - STM32가 다중 센서 데이터를 MQTT Broker로 전송
  - Node-RED Dashboard로 실시간 표시
- **HTTP OTA 업데이트:**
  - ESP8266이 HTTP 서버에서 bin 파일 다운로드
  - Bootloader를 통해 STM32 펌웨어 갱신

------

### 참고 자료

- OASIS MQTT v3.1.1 / v5.0 Specification
- RFC 2616 HTTP/1.1 Specification
- Espressif ESP-AT MQTT / HTTP Command Set
- STMicroelectronics Application Note AN5408 “Using ESP8266/ESP32 with STM32 for IoT Communication”

## 24.5 Firebase / ThingsBoard 연동

### 개요

Firebase와 ThingsBoard는 MCU(예: STM32, ESP32) 기반 IoT 디바이스의 **데이터 시각화**, **원격 제어**, **로그 저장**, **알림 전송** 등을 지원하는 대표적인 클라우드 플랫폼이다.

- **Firebase**는 Google이 제공하는 실시간 데이터베이스 및 REST API 기반 클라우드로, 모바일/웹 통합 서비스에 적합하다.
- **ThingsBoard**는 오픈소스 IoT 플랫폼으로 MQTT, HTTP, CoAP를 통해 디바이스와 서버 간 양방향 통신을 제공한다.

본 절에서는 두 플랫폼의 통신 구조, 인증 절차, 펌웨어 연동 코드, 데이터 포맷, 대시보드 시각화 구성법을 상세히 설명한다.

------

### Firebase 연동

#### 1. 구조 개요

Firebase는 **Realtime Database** 또는 **Firestore**를 중심으로 MCU가 REST API를 통해 데이터를 송수신하는 방식으로 구성된다.
 데이터는 JSON 기반 트리 구조로 저장되며, **HTTP 요청**을 통해 읽기/쓰기 동작을 수행한다.

```
[STM32 / ESP32] ⇄ [Firebase Realtime DB] ⇄ [Mobile App / Web Dashboard]
```

#### 2. 인증 및 연결 방식

- REST API Key 기반 접근

- HTTPS 통신 필수

- URL 형식:

  ```
  https://<PROJECT_ID>.firebaseio.com/<PATH>.json?auth=<API_KEY>
  ```

#### 3. 데이터 업로드 예시

##### ESP32 (Arduino)

```
#include <WiFi.h>
#include <HTTPClient.h>

void setup() {
  WiFi.begin("SSID", "PASS");
  while (WiFi.status() != WL_CONNECTED) delay(500);
}

void loop() {
  HTTPClient http;
  http.begin("https://example.firebaseio.com/sensor/data.json?auth=API_KEY");
  http.addHeader("Content-Type", "application/json");

  String payload = "{\"temp\":25.4,\"hum\":48.7}";
  int code = http.PUT(payload);  // PUT or PATCH
  Serial.printf("HTTP Response: %d\n", code);
  http.end();
  delay(5000);
}
```

##### STM32 (ESP8266 AT 명령 사용)

```
HAL_UART_Transmit(&huart2, (uint8_t*)
  "AT+HTTPCLIENT=2,0,\"https://example.firebaseio.com/sensor/data.json?auth=API_KEY\",\"\",\"{\\\"temp\\\":24.8,\\\"hum\\\":49.2}\",1\r\n",
  150, 5000);
```

#### 4. 데이터 조회 예시

```
http.begin("https://example.firebaseio.com/sensor/data.json?auth=API_KEY");
int code = http.GET();
if (code == 200) {
  String res = http.getString();
  Serial.println(res);
}
```

#### 5. Firebase 콘솔 구성

- Realtime Database 생성
- Rules 탭에서 읽기/쓰기 권한 조정
- Authentication > API Key 확인
- Web UI에서 데이터 트리 실시간 관찰

------

### ThingsBoard 연동

#### 1. 구조 개요

ThingsBoard는 오픈소스 IoT 서버로서 MQTT, HTTP, CoAP를 지원한다.
 센서 노드는 고유 **Access Token**을 통해 인증되며, MQTT Broker(`tcp://thingsboard.cloud:1883`)를 사용해 데이터를 전송한다.

```
[STM32 / ESP32] ⇄ [MQTT Broker] ⇄ [ThingsBoard Server Dashboard]
```

#### 2. 인증 절차

- 디바이스 등록 후 Access Token 발급
- MQTT 로그인 시 `username = AccessToken`
- 기본 Broker 주소: `thingsboard.cloud` 또는 로컬 서버 IP

#### 3. 데이터 포맷

모든 Telemetry 데이터는 JSON 형태로 전송된다.

```
{"temperature": 23.4, "humidity": 47.8}
```

#### 4. ESP32 MQTT 예제

```
#include <WiFi.h>
#include <PubSubClient.h>

WiFiClient espClient;
PubSubClient client(espClient);

const char* THINGSBOARD_SERVER = "thingsboard.cloud";
const char* ACCESS_TOKEN = "your_device_token";

void setup() {
  WiFi.begin("SSID", "PASS");
  while (WiFi.status() != WL_CONNECTED) delay(500);

  client.setServer(THINGSBOARD_SERVER, 1883);
  if (client.connect("esp32_client", ACCESS_TOKEN, NULL)) {
    Serial.println("Connected to ThingsBoard");
  }
}

void loop() {
  String payload = "{\"temp\":25.7,\"hum\":52.3}";
  client.publish("v1/devices/me/telemetry", payload.c_str());
  client.loop();
  delay(5000);
}
```

#### 5. HTTP 업로드 방식 (대체)

```
HTTPClient http;
http.begin("http://thingsboard.cloud/api/v1/<ACCESS_TOKEN>/telemetry");
http.addHeader("Content-Type", "application/json");
http.POST("{\"light\":320,\"pressure\":1012}");
```

------

### ThingsBoard 대시보드 구성

#### 1. 디바이스 등록

- Devices → “Add new device” → Token 자동 생성
- Device credentials 탭에서 Access Token 확인

#### 2. 데이터 시각화

- Dashboards → “Add new dashboard”
- Widget Library → Time Series Chart, Gauge, Map 추가
- 데이터 소스: 해당 Device 선택
- 실시간 갱신(Real-time) 활성화

#### 3. 알림 및 자동화

- Rule Chains → Trigger: 조건(온도 초과 등)
- Action: 이메일, SMS, Telegram, Webhook 등

------

### Firebase vs ThingsBoard 비교

| 항목               | Firebase           | ThingsBoard                 |
| ------------------ | ------------------ | --------------------------- |
| 프로토콜           | HTTP (REST)        | MQTT / HTTP / CoAP          |
| 데이터 구조        | JSON 트리          | Key-Value Telemetry         |
| 실시간 동기화      | 즉시 반영          | MQTT Push                   |
| 보안               | API Key 기반       | Access Token 기반           |
| 대시보드           | Web UI 중심        | 커스터마이즈 가능 Dashboard |
| 오프라인 서버 구축 | 불가능             | 가능 (On-premise 설치)      |
| 주요 용도          | 모바일 연동 / 알림 | 산업용 모니터링 / IoT 허브  |

------

### 실습 예제

#### Firebase 실습: 환경 모니터링 로거

- 센서: BME280
- 데이터: `{temp, hum, pres}`
- 업로드 주기: 10초
- Firebase Console에서 실시간 데이터 변화 확인

#### ThingsBoard 실습: IoT 대시보드 구축

- Node: ESP32 MQTT Client
- 대시보드 위젯: 온도 게이지, 습도 그래프
- Rule Chain: “온도 > 30°C → 경고 표시” 자동 트리거

------

### 보안 및 안정성

- HTTPS/TLS 적용 필수 (Firebase)
- Access Token 암호화 저장 (ThingsBoard)
- MQTT KeepAlive 주기 조정 (기본 60초)
- 네트워크 불안정 시 로컬 버퍼링(DMA Ring Buffer) 구현 권장

------

### 디버깅 및 검증

| 도구           | 용도                         |
| -------------- | ---------------------------- |
| MQTT Explorer  | ThingsBoard MQTT 데이터 확인 |
| Postman        | Firebase REST 요청 검증      |
| Wireshark      | 패킷 구조 분석               |
| Serial Monitor | MCU 로그 디버깅              |

------

### 확장 응용

- **Firebase Cloud Messaging (FCM)**을 이용한 알림 전송
- **ThingsBoard Rule Chain**을 통한 자동화 제어
- **Hybrid 구조:** Firebase 앱 알림 + ThingsBoard 대시보드 병행
- **OTA 업데이트 관리**: HTTP 기반 펌웨어 배포

------

### 참고 자료

- [Firebase REST API Documentation](https://firebase.google.com/docs/reference/rest/database)
- [ThingsBoard MQTT API Reference](https://thingsboard.io/docs/reference/mqtt-api/)
- [STMicroelectronics AN5408 – IoT Cloud Integration Examples]
- [Espressif MQTT / HTTP Client Library (esp-idf)]

## 24.6 Android 연동 앱 제작 (BLE / UART Bridge)

STM32 또는 ESP32 기반의 임베디드 시스템과 안드로이드 앱 간의 양방향 통신을 구현하는 실습이다. BLE (Bluetooth Low Energy) 또는 UART-USB 브리지를 통해 센서 데이터를 전송하고, 제어 명령을 수신하는 구조를 설계한다. CubeIDE와 Android Studio를 연동하여 펌웨어-앱 통신 프로토콜을 통합적으로 검증한다.

------

### 시스템 개요

BLE 또는 UART 통신을 통해 MCU(예: STM32, ESP32)와 안드로이드 스마트폰 간에 데이터를 송수신한다. BLE의 경우 GATT 서비스/특성 구조를 사용하며, UART는 USB-Serial 변환을 통해 PC 또는 안드로이드 단말과 연결된다.

- **MCU 측 구성:** BLE 모듈 (HM-10, ESP32 BLE), UART 인터페이스, 센서 모듈, 제어 모듈
- **앱 측 구성:** Android BLE Manager, GATT Profile Handler, UART Interface, UI Controller
- **통신 방향:**
  - MCU → Android: 센서 데이터, 상태 정보 송신
  - Android → MCU: 제어 명령, 설정값 전송

------

### 주요 구성 요소

#### BLE 기반 통신 구조

- BLE GATT 서버는 MCU에서 구동되며, 다음과 같은 서비스로 구성된다.
  - **Service UUID:** 0xFFF0
  - **Characteristic UUID (TX):** 0xFFF1 → MCU → Android
  - **Characteristic UUID (RX):** 0xFFF2 → Android → MCU
- BLE 데이터 전송 단위는 20 Byte 제한이 있으며, Fragmentation/Assembly 루틴 필요.
- Notify/Indicate 방식으로 실시간 데이터 전송 구현.
- Advertising Name, Manufacturer Data, Service UUID를 포함한 Advertising Packet 설정.

#### UART 기반 통신 구조

- USB-to-UART Bridge (예: CH340, CP2102) 또는 OTG-Serial 통신으로 연결.
- 안드로이드 앱은 `usb-serial-for-android` 라이브러리를 이용해 CDC 장치와 통신.
- Baudrate, Data bit, Parity, Stop bit 설정 후 Read/Write Thread 구성.
- 텍스트 기반 프로토콜 (예: `TEMP:25.6,HUM:40.2\n`) 또는 JSON 구조로 송수신.

------

### Android 측 구현 절차

#### BLE 모드

1. `BluetoothAdapter` 및 `BluetoothLeScanner` 초기화.
2. BLE 스캔 → Target Device 필터링 → GATT 연결.
3. Service/Characteristic 탐색 후 Notification 활성화.
4. 수신 콜백(`onCharacteristicChanged`)에서 MCU 데이터 파싱.
5. 송신 시 `writeCharacteristic` 호출로 제어 명령 전달.

#### UART 모드

1. `UsbManager`를 통해 CDC 장치 검색 및 Permission 요청.
2. `UsbSerialDriver` 생성 → `UsbSerialPort` Open.
3. RX/TX Thread를 분리하여 비동기 통신 처리.
4. 수신 데이터는 Handler 또는 Coroutine을 통해 UI 업데이트.
5. 송신 명령 (예: `LED_ON`, `LED_OFF`, `SET_PWM:128`)을 포맷팅 후 전송.

------

### MCU 측 펌웨어 구조

- **UART 모드:**
  - `HAL_UART_Receive_IT()` 또는 `HAL_UARTEx_ReceiveToIdle_DMA()`로 데이터 수신.
  - 수신 버퍼 파싱 → 명령 문자열 처리 → Peripheral 동작 수행.
  - `HAL_UART_Transmit_IT()`로 응답 전송.
- **BLE 모드 (ESP32 예시):**
  - `BLEDevice`, `BLEServer`, `BLECharacteristic` 클래스 구성.
  - RX Callback 함수에서 명령 처리, TX Characteristic에 데이터 갱신.
  - 주기적 센서 데이터를 `notify()`로 송신.

------

### UI 구성 예시

- 상단: 연결 상태 표시 (Connected / Disconnected)
- 중앙: 센서 데이터 실시간 표시 (온도, 습도, 전압 등)
- 하단: 제어 버튼 (LED, 모터, 릴레이 등) 및 전송 로그

```
[Connect BLE] [Scan Devices]
--------------------------------
Temp: 25.6°C
Humi: 42.3%
--------------------------------
[LED ON] [LED OFF] [Refresh]
Log:
> Connected to STM32_BLE
> Received: TEMP=25.6,HUM=42.3
```

------

### 데이터 프로토콜 설계 예시

| 방향          | 데이터 예시          | 설명            |
| ------------- | -------------------- | --------------- |
| MCU → Android | `TEMP:25.6,HUM:40.2` | 센서 측정값     |
| Android → MCU | `LED=1`              | LED ON          |
| Android → MCU | `PWM=128`            | PWM 제어값 설정 |
| MCU → Android | `ACK:OK`             | 명령 수행 응답  |

------

### 실습 확장 아이디어

- BLE 기반 펌웨어 OTA 기능 추가
- Firebase 또는 ThingsBoard MQTT 연동으로 클라우드 업로드
- 안드로이드 앱에서 그래프 시각화 (MPAndroidChart 활용)
- 데이터 암호화 (AES128 / Base64)
- 다중 센서 노드 BLE Mesh 연동

------

### 검증 및 디버깅 포인트

- GATT Connection Timeout / Reconnect Handling
- BLE MTU 사이즈 설정 (기본 23 → 확장 247)
- UART RX 버퍼 Overflow 방지
- 안드로이드 앱 Background 동작 시 Notification Channel 유지
- MCU 측 Command Parsing Robustness

------

### 결과 요약

이 실습을 통해 다음을 구현한다.

- BLE 및 UART 기반 양방향 통신 구조 이해
- Android BLE 및 USB Serial API 실습
- MCU ↔ 앱 간 실시간 데이터 송수신 프로토콜 설계
- CubeIDE 펌웨어 + Android Studio 앱의 통합 디버깅 및 검증

이 프로젝트는 임베디드 시스템과 모바일 플랫폼 간의 상호운용성을 학습하는 핵심 실습으로, 이후 IoT 게이트웨이, 원격 제어, 데이터 로거, 산업용 모니터링 시스템으로 확장할 수 있다.

