# 16. FreeRTOS 통합

## 16.1 RTOS 개요 및 스케줄링 원리

RTOS(Real-Time Operating System)는 실시간 응답성을 보장하기 위한 운영체제이다. 일반적인 OS가 전체 처리량(Throughput)을 중시하는 반면, RTOS는 **정확한 시간 내에 특정 작업을 완료해야 하는 "시간 결정성(Determinism)"**을 핵심 목표로 한다. 임베디드 시스템에서는 센서 입력, 모터 제어, 통신 패킷 처리 등 시간에 민감한 이벤트가 많기 때문에 RTOS는 필수적인 역할을 수행한다.

------

### RTOS의 주요 특성

- **Deterministic Response (결정적 응답성)**
   시스템이 외부 이벤트에 대해 예측 가능한 시간 내에 응답해야 함.
   RTOS 커널은 인터럽트 지연(latency)과 컨텍스트 스위칭 시간(context switch time)을 최소화하도록 설계된다.
- **Preemptive Multitasking (선점형 멀티태스킹)**
   우선순위가 높은 태스크가 낮은 태스크를 즉시 중단시키고 실행될 수 있도록 한다.
- **Priority-based Scheduling (우선순위 기반 스케줄링)**
   모든 태스크는 정해진 우선순위를 가지며, 커널은 항상 가장 높은 우선순위의 Ready 상태 태스크를 실행한다.
- **Minimal Jitter (지터 최소화)**
   동일한 주기성 작업의 실행 타이밍이 일정하게 유지되어야 한다.
- **Resource Protection (자원 보호)**
   세마포어(semaphore), 뮤텍스(mutex) 등을 통해 다중 태스크 간 공유 자원 접근 시 충돌을 방지한다.

------

### RTOS 주요 구성 요소

- **Task (Thread)**
   독립적으로 실행되는 코드 블록. 각 태스크는 자신의 스택(stack)과 상태(state)를 가진다.
- **Scheduler (스케줄러)**
   현재 Ready 상태인 태스크 중 어떤 태스크를 실행할지 결정하는 핵심 모듈.
- **Kernel Services (커널 서비스)**
   세마포어, 큐(queue), 이벤트(event group), 타이머(timer) 등의 동기화 및 통신 기능을 제공한다.
- **ISR (Interrupt Service Routine)**
   하드웨어 인터럽트 발생 시 즉시 실행되는 루틴. ISR은 일반적으로 커널 호출을 최소화해야 하며, 태스크 간 동기화를 위해 ‘FromISR()’ 형태의 API를 사용한다.
- **Tick Timer (시스템 틱 타이머)**
   일정한 주기로 인터럽트를 발생시켜 커널의 시간 기준을 제공한다. 예: 1ms 단위.

------

### 스케줄링 기본 개념

RTOS 스케줄러는 **태스크의 상태(state)** 변화에 따라 실행 대상을 결정한다. 태스크의 주요 상태는 다음과 같다.

- **Running**: 현재 CPU를 점유하고 실행 중
- **Ready**: 실행 가능한 상태이지만 CPU를 점유하지 않음
- **Blocked (Waiting)**: 지연(delay), 세마포어 대기 등으로 대기 중
- **Suspended**: 외부 명령에 의해 일시 정지된 상태

스케줄러는 매 Tick 또는 이벤트 발생 시 다음 규칙으로 동작한다.

1. Ready 리스트에서 가장 높은 우선순위를 가진 태스크 선택
2. 현재 실행 중인 태스크보다 우선순위가 높으면 컨텍스트 스위칭 수행
3. 동일한 우선순위의 태스크가 여러 개면 Round-Robin 방식으로 일정 시간 할당

------

### 스케줄링 알고리즘 유형

- **Priority Preemptive Scheduling**
   가장 일반적인 RTOS 스케줄링 방식. 우선순위가 높은 태스크가 즉시 CPU를 점유한다.
- **Round Robin Scheduling**
   동일 우선순위의 태스크들끼리는 정해진 Time Slice(시간 할당량)만큼 번갈아 실행된다.
- **Cooperative Scheduling (비선점형)**
   태스크가 명시적으로 CPU를 반환할 때만 컨텍스트 스위칭이 발생한다. 단순하지만 응답성이 떨어질 수 있다.

------

### 컨텍스트 스위칭 과정

컨텍스트 스위칭은 실행 중인 태스크의 CPU 레지스터, 스택 포인터 등을 저장하고 다른 태스크의 상태를 복원하는 과정이다. RTOS 커널은 다음 단계를 거쳐 스위칭을 수행한다.

1. 현재 태스크의 컨텍스트(레지스터, PC, SP 등) 저장
2. 새로운 태스크의 컨텍스트 복원
3. 스케줄러가 CPU 제어권을 새로운 태스크로 넘김

컨텍스트 스위칭 시간은 RTOS의 성능을 결정짓는 중요한 지표로, FreeRTOS 등에서는 수 µs 수준까지 최적화되어 있다.

------

### 실시간성 보장을 위한 설계 원칙

- ISR 내부에서 커널 API 호출 최소화
- 높은 우선순위 태스크의 실행 시간 최소화
- 공유 자원 접근 시 Mutex 또는 Critical Section 사용
- 커널 Tick 주기 조정 (예: 1ms → 0.5ms로 세분화)
- 우선순위 역전(Priority Inversion) 방지를 위한 Priority Inheritance 사용

------

### 예시: FreeRTOS 기반 스케줄링 구조

- **SysTick Handler**: 1ms마다 호출되어 커널 Tick 증가
- **xTaskCreate()**: 태스크 생성 및 Ready 리스트 등록
- **vTaskDelay()**: 현재 태스크를 Block 상태로 전환
- **xSemaphoreGiveFromISR()**: ISR에서 태스크를 Ready 상태로 복귀
- **vTaskSwitchContext()**: 우선순위에 따라 새로운 태스크로 컨텍스트 스위칭

------

### 결론

RTOS의 스케줄링 원리는 시스템의 실시간성과 안정성을 결정하는 핵심 요소이다.
 효율적인 태스크 우선순위 설계, 짧은 ISR 처리, 그리고 적절한 동기화 메커니즘을 통해
 시스템은 예측 가능한 시간 내에 모든 이벤트를 처리할 수 있다.

실시간 임베디드 시스템에서는 이러한 RTOS 스케줄링 구조를 명확히 이해하고
 태스크 실행 주기, 응답 시간, 자원 공유 정책을 체계적으로 설계해야 한다.

## 16.2 Task 생성 / 삭제 / 우선순위

RTOS에서 **태스크(Task)**는 독립적인 실행 단위를 의미하며, 각각 고유한 스택(Stack), 상태(State), 우선순위(Priority)를 가진다.
 태스크는 커널의 스케줄러에 의해 관리되며, 시스템 내에서 동시 다중 실행을 실현한다.
 이 절에서는 FreeRTOS를 기준으로 태스크의 생성, 삭제, 우선순위 관리 및 관련 내부 동작 원리를 상세히 다룬다.

------

### Task의 개념 및 구조

태스크는 일반적으로 다음과 같은 속성을 가진다.

| 항목                                          | 설명                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| **태스크 함수 (Task Function)**               | 무한 루프 형태의 함수로, 주기적으로 실행되거나 특정 이벤트에 반응한다. |
| **스택(Stack)**                               | 지역 변수 및 함수 호출 정보를 저장하는 독립된 메모리 공간.   |
| **우선순위(Priority)**                        | 스케줄러가 어떤 태스크를 먼저 실행할지를 결정하는 기준.      |
| **태스크 제어 블록(TCB, Task Control Block)** | 태스크의 상태, 스택 포인터, 우선순위, 실행 시간 등의 정보를 포함하는 커널 내부 구조체. |

FreeRTOS의 경우 각 태스크는 `TCB_t` 구조체로 표현되며, 태스크 생성 시 커널 힙(heap)에서 동적으로 할당된다.

------

### Task 생성 (Creation)

#### API: `xTaskCreate()`

```
BaseType_t xTaskCreate(
    TaskFunction_t pvTaskCode,
    const char * const pcName,
    configSTACK_DEPTH_TYPE usStackDepth,
    void *pvParameters,
    UBaseType_t uxPriority,
    TaskHandle_t *pxCreatedTask
);
```

#### 주요 인자 설명

| 인자            | 설명                          |
| --------------- | ----------------------------- |
| `pvTaskCode`    | 태스크로 실행될 함수의 포인터 |
| `pcName`        | 디버깅용 태스크 이름 (문자열) |
| `usStackDepth`  | 스택 크기 (워드 단위)         |
| `pvParameters`  | 태스크 함수로 전달할 매개변수 |
| `uxPriority`    | 태스크의 우선순위             |
| `pxCreatedTask` | 태스크 핸들 저장용 포인터     |

#### 동작 원리

1. FreeRTOS 커널은 힙에서 TCB 및 스택 영역을 동적으로 할당한다.
2. TCB 초기화 후 태스크는 Ready 상태 리스트에 추가된다.
3. 스케줄러가 활성화되면 해당 태스크는 우선순위에 따라 실행된다.

#### 예제

```
void SensorTask(void *pvParameters)
{
    for(;;)
    {
        ReadSensor();
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void main(void)
{
    xTaskCreate(SensorTask, "Sensor", 128, NULL, 2, NULL);
    vTaskStartScheduler();
}
```

위 예제에서는 1초마다 센서 값을 읽는 태스크를 생성하였다.
 스케줄러가 시작되면 `SensorTask`는 주기적으로 실행된다.

------

### Task 삭제 (Deletion)

#### API: `vTaskDelete()`

```
void vTaskDelete(TaskHandle_t xTaskToDelete);
```

#### 동작 과정

1. 삭제 요청을 받은 태스크는 Ready, Blocked, Suspended 리스트에서 제거된다.
2. FreeRTOS 커널은 해당 TCB와 스택 메모리를 해제한다.
3. 만약 현재 실행 중인 태스크를 삭제할 경우, `vTaskDelete(NULL)` 형태로 호출하며
    스케줄러는 즉시 컨텍스트 스위칭을 수행한다.

#### 주의 사항

- 삭제된 태스크의 핸들은 더 이상 유효하지 않다.
- 메모리 해제는 커널이 관리하지만, 동적 힙이 부족한 경우 실패할 수 있다.
- 일부 시스템에서는 `configSUPPORT_DYNAMIC_ALLOCATION` 설정이 필요하다.

------

### Task 우선순위 (Priority)

FreeRTOS는 정수형 우선순위 체계를 사용한다.
 값이 **높을수록 높은 우선순위**를 의미하며, `configMAX_PRIORITIES` 값에 의해 제한된다.

#### API

```
vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority);
UBaseType_t uxTaskPriorityGet(TaskHandle_t xTask);
```

#### 동작 원리

1. 스케줄러는 항상 Ready 리스트 중 가장 높은 우선순위를 가진 태스크를 실행한다.
2. 동일한 우선순위의 태스크가 여러 개일 경우, Round-Robin 방식으로 실행된다.
3. 우선순위 변경 시 스케줄러는 즉시 재평가를 수행하여 필요한 경우 컨텍스트 스위칭을 유발한다.

#### 예제

```
xTaskCreate(TaskA, "A", 128, NULL, 3, &handleA);
xTaskCreate(TaskB, "B", 128, NULL, 2, &handleB);

// 실행 중 우선순위 변경
vTaskPrioritySet(handleB, 4);
```

위 코드에서는 `TaskB`의 우선순위를 4로 높임으로써
 스케줄러는 즉시 `TaskA`를 중단하고 `TaskB`를 실행한다.

------

### 태스크 상태 전이 (State Transition)

태스크는 다음 네 가지 주요 상태 간 전이를 가진다.

| 상태          | 설명                                |
| ------------- | ----------------------------------- |
| **Running**   | CPU를 점유하고 실행 중              |
| **Ready**     | 실행 대기 중 (스케줄러가 선택 대기) |
| **Blocked**   | Delay, Queue 대기 등으로 블록 상태  |
| **Suspended** | 수동으로 일시 정지된 상태           |

스케줄러는 매 Tick마다 Ready 리스트를 검사하여 가장 높은 우선순위의 태스크를 실행한다.

------

### 우선순위 역전(Priority Inversion) 문제

우선순위가 낮은 태스크가 공유 자원을 점유하고 있을 때,
 높은 우선순위 태스크가 그 자원을 기다리며 대기 상태가 되는 현상을 말한다.

#### 해결 방법

- **Priority Inheritance (우선순위 상속)**:
   커널이 자동으로 낮은 우선순위 태스크의 우선순위를 일시적으로 상속시켜 문제를 완화.
- **Mutex 사용**:
   세마포어 대신 Mutex를 사용하면 커널 수준에서 Priority Inheritance가 활성화된다.

------

### 정적(Static) vs 동적(Dynamic) 태스크 생성

| 구분          | 특징                            | 예시                  |
| ------------- | ------------------------------- | --------------------- |
| **동적 생성** | 런타임 중 힙에서 메모리 할당    | `xTaskCreate()`       |
| **정적 생성** | 컴파일 시 미리 정의된 배열 사용 | `xTaskCreateStatic()` |

정적 생성은 힙 메모리 부족 문제를 방지하며, 안전성이 요구되는 시스템(예: 산업 제어)에 적합하다.

------

### 결론

태스크의 생성과 관리, 그리고 우선순위 구조는 RTOS의 핵심이며 시스템의 실시간성에 직접적인 영향을 미친다.
 적절한 우선순위 설계, 메모리 관리, 그리고 태스크 삭제 시점 제어는 시스템의 안정성과 예측성을 확보하는 기본이다.
 특히 FreeRTOS 기반 설계에서는 태스크 간 의존성과 실행 주기를 명확히 정의해야
 스케줄링 지연이나 자원 경합 문제를 예방할 수 있다.

## 16.3 Queue, Semaphore, Mutex

RTOS에서는 다수의 태스크가 동시에 실행되므로 **데이터 교환**과 **자원 보호**를 위한 동기화(Synchronization) 메커니즘이 필수적이다.
 FreeRTOS는 이러한 기능을 **Queue**, **Semaphore**, **Mutex**를 통해 제공하며, 이들은 커널 내부적으로 모두 **Queue Control Structure (큐 제어 구조체)** 기반으로 구현되어 있다.
 이 절에서는 각 객체의 역할, 사용 방식, 내부 구조, 동작 원리를 상세히 다룬다.

------

### Queue (큐)

Queue는 태스크 간 데이터를 안전하게 주고받기 위한 **FIFO(First In, First Out)** 형식의 버퍼이다.
 FreeRTOS의 Queue는 단순한 메모리 버퍼가 아니라, **스레드 안전한 동기화 객체**이며, 동시에 다중 태스크 접근을 제어한다.

#### 주요 특징

- 태스크 간 또는 ISR과 태스크 간 데이터 전달 가능
- 복수 개의 송신자(Sender)와 수신자(Receiver) 지원
- 블로킹(blocking) 동작 지원 (`xQueueSend`, `xQueueReceive`)
- ISR에서 사용 가능한 별도 API 제공 (`xQueueSendFromISR`)

#### API 예시

```
QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);
BaseType_t xQueueSend(QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait);
BaseType_t xQueueReceive(QueueHandle_t xQueue, void * pvBuffer, TickType_t xTicksToWait);
```

#### 예제

```
QueueHandle_t sensorQueue;

void ProducerTask(void *pvParameters)
{
    int sensorData;
    for(;;)
    {
        sensorData = ReadSensor();
        xQueueSend(sensorQueue, &sensorData, portMAX_DELAY);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void ConsumerTask(void *pvParameters)
{
    int recvData;
    for(;;)
    {
        if (xQueueReceive(sensorQueue, &recvData, portMAX_DELAY) == pdTRUE)
        {
            ProcessData(recvData);
        }
    }
}

void main(void)
{
    sensorQueue = xQueueCreate(10, sizeof(int));
    xTaskCreate(ProducerTask, "Producer", 128, NULL, 2, NULL);
    xTaskCreate(ConsumerTask, "Consumer", 128, NULL, 2, NULL);
    vTaskStartScheduler();
}
```

이 예제에서 `ProducerTask`는 센서 데이터를 큐에 송신하고,
 `ConsumerTask`는 큐로부터 데이터를 수신하여 처리한다.
 큐가 가득 찬 경우 송신자는 지정된 시간만큼 대기할 수 있다.

------

### Semaphore (세마포어)

세마포어는 **이벤트 동기화**나 **자원 접근 제한**을 위해 사용되는 동기화 객체이다.
 FreeRTOS에서는 **Binary Semaphore**, **Counting Semaphore** 두 가지 유형을 제공한다.

#### Binary Semaphore (이진 세마포어)

- 값이 0 또는 1만을 가지는 세마포어.
- 일반적으로 **태스크 간 이벤트 신호 전달**에 사용된다.
- ISR에서 신호를 보내고(Task Unblock), 태스크는 그 신호를 기다린다.

##### 예제

```
SemaphoreHandle_t xBinarySemaphore;

void ISR_Handler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

void TaskA(void *pvParameters)
{
    for(;;)
    {
        if (xSemaphoreTake(xBinarySemaphore, portMAX_DELAY) == pdTRUE)
        {
            HandleEvent();
        }
    }
}

void main(void)
{
    xBinarySemaphore = xSemaphoreCreateBinary();
    xTaskCreate(TaskA, "Handler", 128, NULL, 2, NULL);
    vTaskStartScheduler();
}
```

이 구조는 하드웨어 인터럽트와 태스크 간의 **비동기 이벤트 처리**에 매우 유용하다.

------

#### Counting Semaphore (카운팅 세마포어)

- 내부 카운터가 0 이상 N 이하의 정수 값을 가진다.
- 공유 자원이 여러 개 존재할 때 사용된다 (예: 버퍼 풀, 연결 슬롯 등).
- 카운터가 0이 되면 자원이 모두 사용 중이므로 태스크는 대기한다.

##### 예제

```
SemaphoreHandle_t xCountSemaphore;

void main(void)
{
    xCountSemaphore = xSemaphoreCreateCounting(5, 5); // 총 5개의 자원
}

void ResourceTask(void *pvParameters)
{
    if (xSemaphoreTake(xCountSemaphore, portMAX_DELAY) == pdTRUE)
    {
        UseResource();
        xSemaphoreGive(xCountSemaphore);
    }
}
```

------

### Mutex (뮤텍스)

Mutex는 **상호 배제(Mutual Exclusion)**를 위해 사용되며, 공유 자원을 동시에 접근하지 못하도록 보호한다.
 세마포어와 비슷하지만, 커널 수준에서 **Priority Inheritance (우선순위 상속)** 기능이 추가되어
 **Priority Inversion (우선순위 역전)** 문제를 완화한다.

#### 주요 특징

- 오직 한 태스크만이 Mutex를 소유할 수 있음
- 동일 태스크에 의해 중복 획득 가능 (재귀적 Mutex는 `xSemaphoreCreateRecursiveMutex()`)
- Mutex는 소유한 태스크가 반드시 해제해야 함

#### 예제

```
SemaphoreHandle_t xMutex;

void SharedTask(void *pvParameters)
{
    for(;;)
    {
        if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE)
        {
            AccessSharedResource();
            xSemaphoreGive(xMutex);
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void main(void)
{
    xMutex = xSemaphoreCreateMutex();
    xTaskCreate(SharedTask, "Task1", 128, NULL, 2, NULL);
    xTaskCreate(SharedTask, "Task2", 128, NULL, 2, NULL);
    vTaskStartScheduler();
}
```

이 코드에서는 `Task1`과 `Task2`가 동일한 자원에 접근하지만,
 Mutex를 통해 한 번에 하나의 태스크만 접근하도록 제어한다.

------

### Queue vs Semaphore vs Mutex 비교

| 항목          | Queue                | Binary Semaphore | Mutex     |
| ------------- | -------------------- | ---------------- | --------- |
| 주요 목적     | 데이터 전달          | 이벤트 동기화    | 자원 보호 |
| 데이터 저장   | 가능 (FIFO 버퍼)     | 없음             | 없음      |
| 우선순위 상속 | 없음                 | 없음             | 있음      |
| 소유 개념     | 없음                 | 없음             | 있음      |
| ISR 사용      | 가능 (`FromISR` API) | 가능             | 불가능    |
| 블로킹 지원   | 가능                 | 가능             | 가능      |

------

### 내부 구조 및 동작 메커니즘

FreeRTOS의 Queue, Semaphore, Mutex는 모두 동일한 **Queue Control Structure (`xQUEUE`)**를 기반으로 동작한다.

- `uxMessagesWaiting` : 큐 내 저장된 메시지 개수
- `pcHead`, `pcTail` : 데이터 저장 위치 포인터
- `xTasksWaitingToSend`, `xTasksWaitingToReceive` : 블로킹된 태스크 리스트
- Semaphore와 Mutex는 메시지 크기가 0인 특수한 Queue 형태로 관리된다.

커널은 다음과 같은 단계로 동작한다.

1. 태스크가 `xQueueSend()` 또는 `xSemaphoreGive()` 호출
2. 큐 또는 세마포어 상태 검사 후 Ready 리스트 갱신
3. 필요 시 컨텍스트 스위칭 발생 (ISR 또는 태스크 레벨)

------

### 설계 시 주의사항

- ISR에서는 Mutex 사용 불가 (`xSemaphoreTakeFromISR` 없음)
- Deadlock 회피를 위해 항상 일정한 자원 획득 순서를 유지할 것
- 큐의 크기를 충분히 확보하고, 송신/수신 속도 차이를 고려해야 함
- 긴 시간 Mutex 점유는 실시간성 저하를 유발함
- 세마포어는 신호(Signaling)용, Mutex는 보호(Protection)용으로 구분해서 사용해야 함

------

### 결론

Queue, Semaphore, Mutex는 RTOS 기반 시스템에서 태스크 간 협력과 자원 관리의 핵심이다.
 이들을 적절히 설계하지 않으면, 교착상태(Deadlock), 우선순위 역전, 데이터 손실 등의 문제가 발생할 수 있다.
 FreeRTOS는 이러한 메커니즘을 효율적으로 구현할 수 있는 API 세트를 제공하며,
 개발자는 각 객체의 목적과 한계를 명확히 이해한 후 시스템에 적용해야 한다.

## 16.4 Timer / EventGroup

### FreeRTOS Timer 개요

FreeRTOS의 소프트웨어 타이머(Software Timer)는 하드웨어 타이머 인터럽트를 직접 사용하는 대신, 커널의 틱 인터럽트(Tick Interrupt)를 기반으로 동작하는 추상화된 타이밍 기능이다.
 주요 목적은 특정 시간 간격 후에 함수(Callback)를 자동으로 실행하거나, 주기적인 작업을 스케줄링하는 것이다.

하드웨어 타이머와 달리 커널의 틱(Tick) ISR 내에서 실행되지 않고, 전용 **Timer Service Task**(또는 Timer Daemon Task)에 의해 관리되므로 실시간성은 다소 낮지만 안정적이다.

### 소프트웨어 타이머의 종류

- **One-shot Timer**
   지정된 시간이 경과하면 한 번만 콜백이 호출되고 자동으로 비활성화된다.
- **Auto-reload Timer**
   지정된 주기마다 자동으로 재시작되어 콜백이 주기적으로 실행된다.

### 타이머 생성 및 관리 API

FreeRTOS에서는 다음과 같은 API를 통해 타이머를 제어한다.

- `xTimerCreate()` : 타이머 객체 생성
- `xTimerStart()` / `xTimerStop()` : 타이머 시작/정지
- `xTimerReset()` : 타이머 주기 초기화 및 재시작
- `xTimerChangePeriod()` : 타이머 주기 변경
- `xTimerDelete()` : 타이머 삭제

#### 예제

```
void vTimerCallback(TimerHandle_t xTimer) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // LED 토글
}

void Timer_Init(void) {
    TimerHandle_t ledTimer = xTimerCreate(
        "LED_Timer", pdMS_TO_TICKS(1000), pdTRUE, 0, vTimerCallback);
    xTimerStart(ledTimer, 0);
}
```

#### 내부 동작 구조

- 타이머는 **Timer Command Queue**를 통해 Timer Service Task에 명령을 전달한다.
- Timer Service Task는 Tick Count를 기반으로 활성 타이머 목록을 주기적으로 확인하며, 만료된 타이머의 콜백을 실행한다.
- Timer Service Task의 우선순위가 낮을 경우 콜백 실행이 지연될 수 있다.

------

### Event Group 개요

Event Group은 여러 Task 간의 **이벤트 상태 플래그 비트**를 공유하기 위한 동기화 메커니즘이다.
 이벤트 플래그는 32비트 비트맵 형태로 표현되며, Task 간 신호 전달이나 상태 대기를 효율적으로 구현할 수 있다.

일반적으로 Binary Semaphore나 Flag 대신 사용되며, 여러 비트 상태를 한 번에 감시하거나, 특정 조건(AND / OR)으로 대기할 수 있다는 장점이 있다.

### 주요 API

- `xEventGroupCreate()` : 이벤트 그룹 생성
- `xEventGroupSetBits()` : 비트 설정
- `xEventGroupClearBits()` : 비트 해제
- `xEventGroupWaitBits()` : 특정 비트가 설정될 때까지 대기
- `xEventGroupSync()` : 여러 Task 간 동기화

#### 예제

```
EventGroupHandle_t xEventGroup;

#define BIT_UART_RX  (1 << 0)
#define BIT_ADC_DONE (1 << 1)

void UART_Task(void *pvParameters) {
    while (1) {
        if (UART_Receive()) {
            xEventGroupSetBits(xEventGroup, BIT_UART_RX);
        }
    }
}

void ADC_Task(void *pvParameters) {
    while (1) {
        if (ADC_ConvertDone()) {
            xEventGroupSetBits(xEventGroup, BIT_ADC_DONE);
        }
    }
}

void Main_Task(void *pvParameters) {
    for (;;) {
        EventBits_t uxBits = xEventGroupWaitBits(
            xEventGroup, BIT_UART_RX | BIT_ADC_DONE,
            pdTRUE, pdTRUE, portMAX_DELAY);
        ProcessData();
    }
}
```

이 예제는 UART 수신과 ADC 완료 이벤트가 모두 발생할 때(`AND` 조건)만 데이터를 처리한다.

------

### Event Group vs Semaphore 비교

| 항목        | Event Group             | Semaphore / Mutex |
| ----------- | ----------------------- | ----------------- |
| 비트 수     | 최대 32개               | 단일 신호만       |
| 조건 처리   | AND / OR 지원           | 단일 이벤트       |
| 사용 목적   | 복합 이벤트 동기화      | 단일 자원 보호    |
| ISR 사용    | SetBitsFromISR()로 가능 | 일부 제한적 사용  |
| 자동 클리어 | WaitBits 시 선택 가능   | 자동 해제 불가    |

------

### 통합 예제: 타이머 + 이벤트 그룹

타이머를 통해 주기적으로 이벤트를 발생시키고, 여러 Task가 이를 감시하는 구조를 만들 수 있다.

```
EventGroupHandle_t xSysEvent;

#define BIT_SENSOR_READ (1 << 0)
#define BIT_DISPLAY_REFRESH (1 << 1)

void vSensorTimerCallback(TimerHandle_t xTimer) {
    xEventGroupSetBits(xSysEvent, BIT_SENSOR_READ);
}

void vDisplayTimerCallback(TimerHandle_t xTimer) {
    xEventGroupSetBits(xSysEvent, BIT_DISPLAY_REFRESH);
}

void vSystemTask(void *pvParameters) {
    for (;;) {
        EventBits_t uxBits = xEventGroupWaitBits(
            xSysEvent, BIT_SENSOR_READ | BIT_DISPLAY_REFRESH,
            pdTRUE, pdFALSE, portMAX_DELAY);
        if (uxBits & BIT_SENSOR_READ) Sensor_Read();
        if (uxBits & BIT_DISPLAY_REFRESH) Display_Update();
    }
}
```

이 구조는 타이머 기반 이벤트를 중앙 Task에서 통합 처리하는 패턴이며, 전력 효율적이고 코드 가독성이 높다.

------

### 주의사항 및 베스트 프랙티스

- 소프트웨어 타이머의 콜백 내에서 **블로킹 함수**를 호출하지 않는다.
- Event Group의 비트를 여러 Task가 동시에 조작할 경우, 적절한 임계 구역(Critical Section) 처리를 고려한다.
- Timer Service Task 우선순위를 시스템 내 중간 수준 이상으로 설정하여 이벤트 지연을 방지한다.
- ISR에서 이벤트 설정 시 반드시 `xEventGroupSetBitsFromISR()`를 사용한다.
- 타이머를 통한 주기 작업은 Tick 주기보다 짧은 주기를 설정하지 않는다.

이 장에서는 타이머와 이벤트 그룹을 통해 FreeRTOS의 비동기적 시간 기반 제어와 이벤트 동기화를 결합하는 핵심 메커니즘을 다룬다.
 이 두 기능은 RTOS 기반 시스템에서 **정확한 주기 제어**, **멀티태스킹 이벤트 조정**, **비동기 데이터 처리**에 필수적으로 사용된다.

## 16.5 Task 간 통신 (UART Queue, ADC 공유)

### 개요

FreeRTOS 기반 시스템에서 여러 Task는 독립적으로 실행되므로, 서로 데이터를 주고받기 위해서는 명시적인 통신 메커니즘이 필요하다.
 대표적인 방법은 **Queue**, **Semaphore**, **Message Buffer**, **Stream Buffer**, **Event Group** 등을 이용하는 것이다.
 이 중에서 Queue는 가장 일반적인 Task 간 데이터 교환 수단으로, 특히 UART 수신 데이터나 ADC 변환 결과를 다른 Task로 전달하는 데 적합하다.

------

### Queue를 이용한 Task 간 통신 구조

Queue는 FIFO(First-In, First-Out) 형태의 자료 구조로, 한 Task가 데이터를 전송(`xQueueSend`)하고 다른 Task가 이를 수신(`xQueueReceive`)한다.
 Queue 내부에는 데이터 복사본이 저장되므로, 데이터 손실 없이 안전하게 Task 간 정보를 전달할 수 있다.

#### 주요 API

- `xQueueCreate(uxQueueLength, uxItemSize)` : 큐 생성
- `xQueueSend()` / `xQueueSendFromISR()` : 데이터 전송
- `xQueueReceive()` : 데이터 수신
- `xQueuePeek()` : 큐를 비우지 않고 데이터 확인
- `uxQueueMessagesWaiting()` : 큐에 남은 메시지 개수 확인

------

### UART Task 통신 예제

UART 통신에서 수신된 데이터를 Queue를 통해 처리 Task로 전달하는 구조를 예로 들면 다음과 같다.

#### 구조 개요

- **UART_RX_Task** : UART 인터럽트 또는 HAL 콜백을 통해 수신된 데이터를 Queue에 저장
- **Command_Task** : Queue에서 데이터를 읽어 명령어를 파싱하고 동작 수행

#### 코드 예제

```
QueueHandle_t uartQueue;

typedef struct {
    uint8_t data[32];
    uint8_t length;
} UartPacket_t;

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    static UartPacket_t packet;
    packet.length = 1;
    packet.data[0] = rxBuffer;
    xQueueSendFromISR(uartQueue, &packet, NULL);
    HAL_UART_Receive_IT(&huart1, &rxBuffer, 1);
}

void UART_RX_Task(void *pvParameters) {
    HAL_UART_Receive_IT(&huart1, &rxBuffer, 1);
    for (;;) {
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void Command_Task(void *pvParameters) {
    UartPacket_t recv;
    for (;;) {
        if (xQueueReceive(uartQueue, &recv, portMAX_DELAY) == pdPASS) {
            ProcessCommand(recv.data, recv.length);
        }
    }
}

void UART_TaskInit(void) {
    uartQueue = xQueueCreate(32, sizeof(UartPacket_t));
    xTaskCreate(UART_RX_Task, "UART_RX", 256, NULL, 2, NULL);
    xTaskCreate(Command_Task, "CMD", 256, NULL, 2, NULL);
}
```

#### 설명

- `HAL_UART_RxCpltCallback()` : UART 인터럽트 완료 시 큐에 데이터 삽입.
- `Command_Task()` : 큐에서 데이터를 대기(`portMAX_DELAY`) 후 처리.
- 수신과 처리를 분리함으로써, UART 인터럽트의 부하를 최소화하고 실시간성을 확보한다.

------

### ADC 공유 데이터 통신 예제

ADC 변환 결과를 여러 Task가 공유해야 하는 경우, 직접 변환 결과를 읽는 대신 **Queue** 또는 **전역 변수 + Mutex 보호**를 통해 접근한다.

#### 구조 개요

- **ADC_Task** : 주기적으로 ADC 변환 수행 후 결과를 Queue에 송신
- **Logger_Task** : 수신된 데이터를 로깅
- **Controller_Task** : 변환된 값을 바탕으로 제어 로직 수행

#### 코드 예제 (Queue 기반)

```
QueueHandle_t adcQueue;

typedef struct {
    uint16_t channel;
    uint16_t value;
} AdcData_t;

void ADC_Task(void *pvParameters) {
    AdcData_t adcData;
    for (;;) {
        adcData.channel = 0;
        adcData.value = HAL_ADC_GetValue(&hadc1);
        xQueueSend(adcQueue, &adcData, 0);
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

void Logger_Task(void *pvParameters) {
    AdcData_t recv;
    for (;;) {
        if (xQueueReceive(adcQueue, &recv, portMAX_DELAY)) {
            printf("ADC[%d] = %d\r\n", recv.channel, recv.value);
        }
    }
}

void ADC_CommInit(void) {
    adcQueue = xQueueCreate(16, sizeof(AdcData_t));
    xTaskCreate(ADC_Task, "ADC", 256, NULL, 2, NULL);
    xTaskCreate(Logger_Task, "Logger", 256, NULL, 2, NULL);
}
```

#### 설명

- `ADC_Task()`는 주기적으로 ADC 변환을 수행하고 결과를 Queue로 전송.
- `Logger_Task()`는 변환된 데이터를 출력 또는 저장.
- 실시간 로깅, 모니터링, 제어를 분리하여 구조적 확장성을 확보.

------

### 공유 메모리 + Mutex 보호 방식

Queue를 사용하지 않고 전역 버퍼를 공유할 때는 데이터 경합(Race Condition)을 방지하기 위해 Mutex를 사용한다.

```
typedef struct {
    uint16_t value;
} AdcShared_t;

AdcShared_t adcShared;
SemaphoreHandle_t adcMutex;

void ADC_Task(void *pvParameters) {
    for (;;) {
        uint16_t val = HAL_ADC_GetValue(&hadc1);
        xSemaphoreTake(adcMutex, portMAX_DELAY);
        adcShared.value = val;
        xSemaphoreGive(adcMutex);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void Control_Task(void *pvParameters) {
    uint16_t readVal;
    for (;;) {
        xSemaphoreTake(adcMutex, portMAX_DELAY);
        readVal = adcShared.value;
        xSemaphoreGive(adcMutex);
        ApplyControl(readVal);
    }
}
```

이 방식은 데이터 전송이 매우 빈번하거나 작은 데이터(예: 단일 센서 값)일 때 효율적이다.
 Queue 오버헤드 없이 공유 메모리에 직접 접근하지만, 반드시 Mutex로 보호해야 한다.

------

### UART + ADC 통합 예시 구조

| Task         | 역할                 | 통신 방식      |
| ------------ | -------------------- | -------------- |
| UART_RX_Task | UART 인터럽트 수신   | ISR → Queue    |
| Command_Task | 명령어 파싱 및 처리  | Queue 수신     |
| ADC_Task     | 주기적 ADC 변환      | Queue 송신     |
| Control_Task | ADC 데이터 기반 제어 | Queue or Mutex |
| Logger_Task  | UART / ADC 상태 출력 | Queue 수신     |

이 구조는 UART와 ADC를 각각 독립 Task로 분리하고, Queue를 통해 상호 통신하도록 설계되어 있다.
 UART 인터럽트의 ISR 처리 부담을 줄이고, ADC 변환과 로깅을 비동기적으로 수행할 수 있다.

------

### 베스트 프랙티스

- ISR 내부에서는 반드시 `xQueueSendFromISR()`을 사용해야 하며, 일반 `xQueueSend()`를 사용하면 커널 동작이 불안정해진다.
- Queue 크기는 예상되는 통신량에 따라 충분히 설정할 것. Queue가 가득 차면 송신 Task가 블로킹될 수 있다.
- 주기적 ADC 변환 데이터처럼 타이밍이 중요한 경우, Queue 전송 전에 DMA 완료 인터럽트를 활용하면 CPU 부하를 줄일 수 있다.
- Mutex는 데이터 무결성을 보장하지만, 높은 주기적 접근에서는 오버헤드가 발생하므로 주기와 데이터량에 따라 Queue 또는 Mutex 중 선택한다.
- 모든 통신 구조는 **비동기, 논블로킹, 데이터 무결성 보장**을 목표로 설계해야 한다.

------

이 절에서는 FreeRTOS 환경에서의 UART 및 ADC Task 간 통신 구조를 Queue와 Mutex 중심으로 설명하였다.
 실제 프로젝트에서는 이 통신 패턴이 **센서 수집 → 처리 → 전송**과 같은 파이프라인 아키텍처의 기반이 되며, 시스템의 실시간성과 안정성을 결정짓는 핵심 요소이다.

## 16.6 FreeRTOS + HAL 연동 주의점

### 개요

STM32에서 **HAL(Hardware Abstraction Layer)** 과 **FreeRTOS(Real-Time Operating System)** 을 함께 사용하는 경우,
 각각의 실행 컨텍스트(인터럽트, 커널 Task, HAL 콜백)의 **스케줄링 규칙과 동기화 방식**이 다르기 때문에 주의가 필요하다.
 HAL은 기본적으로 **폴링(Polling)** 또는 **인터럽트 기반(IT/DMA)** 동작을 수행하며, FreeRTOS는 **Task 스케줄러**에 의해
 시간 분할로 동작하므로, 두 시스템 간의 경계에서 **타이밍 문제**, **임계 구역 충돌**, **블로킹 함수 호출** 등이 발생할 수 있다.

------

### 인터럽트 우선순위 설정 주의점

HAL은 대부분의 주변장치를 인터럽트로 처리하므로, FreeRTOS와 통합할 때 **NVIC 우선순위** 설정이 가장 중요하다.
 특히 FreeRTOS는 내부적으로 임계 구역 보호 및 API 호출 허용 범위를 NVIC 우선순위에 따라 제한한다.

#### 핵심 규칙

- FreeRTOS의 설정 파일(`FreeRTOSConfig.h`)에는 다음 매크로가 정의되어 있다.

```
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  5
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY       15
```

- **우선순위 숫자가 작을수록 높은 우선순위**임에 유의해야 한다.
- FreeRTOS API(`xQueueSendFromISR`, `xSemaphoreGiveFromISR` 등)를 호출할 수 있는 인터럽트는
   **NVIC 우선순위 ≥ configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY** 여야 한다.
   (즉, 우선순위 값이 더 큼 → 실제로는 낮은 우선순위여야 함)

#### 잘못된 예

```
HAL_NVIC_SetPriority(USART1_IRQn, 3, 0); // 너무 높은 우선순위
```

→ FreeRTOS API를 호출하면 시스템 크래시 발생 가능.

#### 올바른 예

```
HAL_NVIC_SetPriority(USART1_IRQn, 6, 0); // FreeRTOS 허용 범위 내
HAL_NVIC_EnableIRQ(USART1_IRQn);
```

#### 참고

FreeRTOS의 ISR-safe API들은 `FromISR()` 접미사가 반드시 붙어야 하며,
 해당 인터럽트는 커널 크리티컬 섹션과 충돌하지 않도록 위 범위 내에서만 호출되어야 한다.

------

### HAL Delay 함수 사용 금지

`HAL_Delay()`는 내부적으로 **SysTick** 인터럽트를 이용한 **Busy-wait(바쁜 대기)** 방식으로 동작한다.
 FreeRTOS에서는 SysTick이 **커널 Tick**으로 이미 점유되어 있으므로, Task 내에서 HAL_Delay를 호출하면
 스케줄링이 중단되고 전체 Task 응답성이 저하된다.

#### 잘못된 예

```
void vLedTask(void *pvParameters) {
    for (;;) {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        HAL_Delay(500); // FreeRTOS 내에서는 비권장
    }
}
```

#### 올바른 예

```
void vLedTask(void *pvParameters) {
    for (;;) {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        vTaskDelay(pdMS_TO_TICKS(500)); // 커널 Tick 기반 Delay
    }
}
```

→ **HAL_Delay() → vTaskDelay()** 로 반드시 대체해야 함.

------

### HAL과 FreeRTOS Tick 충돌 방지

HAL과 FreeRTOS 모두 SysTick을 사용하는 경우, Tick 중복 초기화로 충돌이 발생할 수 있다.
 일반적으로 FreeRTOS가 SysTick을 관리하도록 설정하고, HAL의 SysTick 콜백은 FreeRTOS 내부 Tick Hook으로 연결한다.

#### 설정 예시

`stm32fxx_it.c`에서 다음 코드를 수정한다.

```
void SysTick_Handler(void) {
    HAL_IncTick();      // HAL Tick 증가
    osSystickHandler(); // FreeRTOS Tick 증가
}
```

또는 CubeMX 설정 시

- **CMSIS-RTOS v2** 사용 시 자동으로 `osSystickHandler()` 가 호출됨
- **Bare FreeRTOS** 사용 시 수동 연결 필요

------

### HAL 콜백 내 FreeRTOS API 호출 주의

HAL 콜백(예: `HAL_UART_TxCpltCallback`, `HAL_ADC_ConvCpltCallback`)은 대부분 **ISR 컨텍스트**에서 실행된다.
 따라서 FreeRTOS의 일반 API(`xQueueSend`, `xSemaphoreGive`, `vTaskDelay` 등)는 절대 호출하면 안 된다.

#### 잘못된 예

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    xQueueSend(uartQueue, &rxData, 0); // 일반 API → 오류 발생
}
```

#### 올바른 예

```
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xQueueSendFromISR(uartQueue, &rxData, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

ISR-safe API를 사용해야 하며, 인터럽트 종료 시 **컨텍스트 스위칭(portYIELD_FROM_ISR)** 을 반드시 고려한다.

------

### DMA + FreeRTOS 연동 시 고려사항

HAL DMA 전송 완료 콜백은 역시 인터럽트 컨텍스트에서 호출된다.
 Queue나 Semaphore를 이용하여 Task로 신호를 전달할 수 있으나,
 DMA 콜백 내에서 직접 블로킹 함수 호출은 금지되어야 한다.

#### 예제

```
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(adcDoneSemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

void ADC_Task(void *pvParameters) {
    for (;;) {
        if (xSemaphoreTake(adcDoneSemaphore, portMAX_DELAY) == pdTRUE) {
            ProcessADC();
        }
    }
}
```

이 방식은 DMA 완료 시점을 Task 레벨로 안전하게 전달한다.

------

### 임계 구역(Critical Section) 충돌 주의

HAL 내부 함수 중 일부(`HAL_I2C_Master_Transmit`, `HAL_SPI_TransmitReceive`)는
 전송 완료를 기다리는 동안 내부적으로 **Polling 또는 Busy-wait** 를 수행한다.
 이 구간에서 FreeRTOS 스케줄러가 멈추면 전체 Task의 응답이 지연될 수 있다.

#### 해결 방법

- 가능한 경우 **비동기 방식(Interrupt/DMA)** 사용
- HAL 함수 호출 전후로 `taskENTER_CRITICAL()` / `taskEXIT_CRITICAL()` 사용 금지
- 장시간 블로킹되는 HAL 함수는 **전용 Task**로 분리

------

### 메모리 관리 주의

FreeRTOS의 동적 메모리 할당(`pvPortMalloc`)과 HAL 라이브러리의 동적 구조체 사용(`malloc`)을 동시에 사용할 경우,
 동일한 힙 영역을 공유하지 않도록 주의해야 한다.
 CubeIDE 프로젝트에서는 `heap_4.c` 또는 `heap_5.c` 를 사용하는 것이 일반적이며,
 `FreeRTOSConfig.h`의 `configTOTAL_HEAP_SIZE` 값이 충분히 확보되어야 한다.

#### 권장 설정

- HAL 구조체(`UART_HandleTypeDef`, `DMA_HandleTypeDef`)는 전역 정적 할당
- Task Stack은 `xTaskCreate()` 시 FreeRTOS 내부에서 별도 관리
- malloc/free는 가급적 사용하지 않음

------

### 디버깅 시 주의사항

FreeRTOS가 실행 중일 때 **HAL_Delay()**, **Breakpoint** 등을 무분별하게 사용하면
 커널 Tick이 멈추고, Watchdog이 오작동할 수 있다.

- **FreeRTOS-aware Debugging** 기능 사용 (CubeIDE > Debug Configurations > RTOS 탭)
- `configASSERT()` 활성화로 커널 에러 감지
- `vTaskGetInfo()` 또는 `uxTaskGetSystemState()`를 이용한 Task 모니터링

------

### 정리

| 항목              | 주의 내용                | 대체 / 권장 방법                 |
| ----------------- | ------------------------ | -------------------------------- |
| SysTick 충돌      | HAL과 FreeRTOS Tick 중복 | HAL Tick → osSystickHandler 연결 |
| HAL_Delay 사용    | Busy-wait로 커널 정지    | vTaskDelay 사용                  |
| ISR 내 API 호출   | 일반 API 사용 금지       | FromISR() 계열 API 사용          |
| 인터럽트 우선순위 | FreeRTOS 제한 범위 준수  | NVIC 우선순위 ≥ MAX_SYSCALL      |
| DMA 콜백 처리     | Task 내부 직접 호출 금지 | Semaphore로 신호 전달            |
| Polling HAL 함수  | 스케줄링 블로킹 위험     | DMA/IT 모드로 변경               |
| malloc/free 혼용  | 힙 오염 가능성           | FreeRTOS heap 함수만 사용        |

------

이 절에서는 HAL과 FreeRTOS의 통합 시 발생할 수 있는 주요 충돌 요인을 체계적으로 정리하였다.
 올바른 Tick 연동, ISR-safe API 사용, 인터럽트 우선순위 관리, 그리고 블로킹 함수 회피는 안정적인 RTOS 시스템 구현의 핵심이다.
 특히 STM32 HAL과 FreeRTOS를 함께 사용하는 경우, **HAL은 하드웨어 제어의 최소 단위**, **FreeRTOS는 동시성 관리의 상위 레벨**로 역할을 명확히 구분해야 한다.

## 16.7 Low Power + RTOS 실습

### 개요

STM32에서 FreeRTOS를 사용하면서 저전력 모드를 구현할 때는 **커널 Tick 유지**, **Task 대기 상태 관리**, **클럭 소스 절전화**가 핵심이다.
 FreeRTOS는 주기적인 Tick 인터럽트를 기반으로 스케줄링을 수행하므로, 일반적인 Sleep 모드처럼 단순히 CPU 클럭을 차단하면 커널이 멈춘다.
 따라서 저전력 모드에서도 Tick 타이머 동작을 유지하거나, Idle 상태에서 자동으로 Sleep에 진입하는 **Tickless Idle 모드**를 활용해야 한다.

------

### Tickless Idle 모드 개요

FreeRTOS의 **Tickless Idle**은 시스템이 일정 시간 동안 Task 전환이 필요하지 않을 때,
 커널 Tick을 일시 중지하고 MCU를 저전력 모드로 진입시키는 기능이다.

#### 동작 순서

1. 모든 Task가 **Blocked/Waiting 상태**에 진입
2. Idle Task가 실행되며 다음 이벤트 발생까지 남은 시간을 계산
3. SysTick 타이머를 중지하고 MCU를 Sleep 모드로 전환
4. 타이머 인터럽트 혹은 외부 이벤트 발생 시 깨어나며 Tick 재설정
5. 남은 Tick을 계산하여 커널 시간 동기화

이 방식은 **스케줄러와 저전력 관리가 직접 통합된 구조**로, CPU 유휴 시간을 전력 절감에 활용한다.

------

### FreeRTOSConfig 설정

#### Tickless Idle 활성화

`FreeRTOSConfig.h` 파일에 다음 매크로를 추가 또는 수정한다.

```
#define configUSE_TICKLESS_IDLE          1
#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP  2
```

`configUSE_TICKLESS_IDLE`은 Tickless 기능 활성화,
 `configEXPECTED_IDLE_TIME_BEFORE_SLEEP`은 Idle 상태 유지 예상 Tick 수를 설정한다.

#### SysTick 소스 조정

Tickless Idle에서는 `SysTick` 대신 **RTC 또는 LPTIM**을 커널 타이머로 사용하는 것이 일반적이다.
 이 경우 다음 매크로를 추가하여 Tickless 함수 훅을 직접 구현한다.

```
#define configPRE_SLEEP_PROCESSING(x)    PreSleepProcessing(x)
#define configPOST_SLEEP_PROCESSING(x)   PostSleepProcessing(x)
```

------

### Tickless Sleep 동작 흐름

#### PreSleepProcessing()

Sleep 진입 전 수행할 사용자 정의 함수이다.
 보통 외부 인터페이스 차단, GPIO 출력 설정, 클럭 분주 조정 등을 수행한다.

```
void PreSleepProcessing(uint32_t ulExpectedIdleTime) {
    /* 저전력 진입 전 처리 */
    HAL_SuspendTick();        // SysTick 정지
    __HAL_RCC_GPIOB_CLK_DISABLE(); // 불필요한 GPIO 클럭 차단
}
```

#### PostSleepProcessing()

Sleep 복귀 직후 수행할 함수로, Tick 재개 및 주변장치 복원을 담당한다.

```
void PostSleepProcessing(uint32_t ulExpectedIdleTime) {
    /* 저전력 복귀 후 처리 */
    HAL_ResumeTick();         // SysTick 재개
    __HAL_RCC_GPIOB_CLK_ENABLE();
}
```

이 두 함수는 FreeRTOS 커널이 자동으로 호출하며,
 `__WFI()` 또는 `__WFE()` 명령은 FreeRTOS 내부 Idle Task에서 실행된다.

------

### Idle Task 훅 기반 Sleep 진입

FreeRTOS의 `vApplicationIdleHook()`를 활용하면
 Tickless Idle 외에도 조건부 Sleep 진입 로직을 추가할 수 있다.

```
void vApplicationIdleHook(void) {
    __WFI();  // CPU Sleep 진입 (인터럽트 발생 시 복귀)
}
```

단, 이 방식은 단순 Sleep으로 Tickless Idle보다 전력 절감 효과가 낮지만,
 디버깅이 용이하고 HAL 함수와의 충돌이 적다.

------

### HAL + FreeRTOS Sleep 연동 구조

STM32의 HAL 드라이버는 Sleep 진입 시 클럭 중단, GPIO 레벨 유지, RTC 활성화를 관리한다.
 FreeRTOS는 내부적으로 `eTaskConfirmSleepModeStatus()`를 통해 Sleep 진입 가능 여부를 판단한다.

#### Sleep 허용 조건

- 모든 Task가 Blocked 상태
- Queue, Semaphore, Timer에 Pending 없음
- ISR 실행 중이 아님

#### Sleep 불가 조건

- DMA, UART 통신 중
- Timer ISR 또는 Callback 실행 중
- Critical Section 내 코드

이 조건을 충족해야 HAL의 `HAL_PWR_EnterSLEEPMode()` 호출이 정상적으로 수행된다.

------

### 저전력 모드 종류 및 전력 수준

| 모드    | 전력 소비 | RAM 유지 | RTC 동작   | 복귀 시간 | 주요 특징          |
| ------- | --------- | -------- | ---------- | --------- | ------------------ |
| Sleep   | 중간      | 유지     | 유지       | 매우 짧음 | CPU 클럭만 정지    |
| Stop    | 낮음      | 유지     | 선택적     | 중간      | 대부분의 클럭 차단 |
| Standby | 매우 낮음 | 미유지   | RTC만 유지 | 김        | 전원 거의 차단     |

FreeRTOS와 통합 시 주로 **Sleep 또는 Stop 모드**를 사용한다.
 Standby는 RTOS 커널 상태가 초기화되므로 부적합하다.

------

### 실습 예제 – Stop 모드에서 FreeRTOS 유지

#### 초기 설정

```
void SystemClock_Config(void);
void MX_RTC_Init(void);

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_RTC_Init();

    osKernelInitialize();
    osThreadNew(StartTask, NULL, NULL);
    osKernelStart();

    while (1);
}
```

#### Idle Hook 기반 Stop 모드 진입

```
void vApplicationIdleHook(void)
{
    /* 모든 Task가 대기 중일 때만 Stop 모드 진입 */
    __disable_irq();
    HAL_SuspendTick();
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    HAL_ResumeTick();
    __enable_irq();

    SystemClock_Config(); // 클럭 복구
}
```

이 코드는 RTOS 스케줄링 중 Idle Task가 동작할 때
 MCU를 Stop 모드로 전환하고, 인터럽트 발생 시 즉시 복귀한다.

------

### RTC 기반 Tickless 동작

SysTick 대신 RTC를 커널 타이머로 사용하는 구성은
 초저전력 응용(배터리 동작, 장기 로거)에 적합하다.

#### 설정 요약

1. RTC Clock Source: LSE (32.768kHz)
2. FreeRTOS Tick 주기 계산: `tick_rate_hz = 1000 / RTC_Prescaler`
3. Tickless Idle 시 RTC Alarm을 다음 Task 기상 시간으로 설정

#### 코드 예시

```
void vPortSuppressTicksAndSleep(TickType_t xExpectedIdleTime)
{
    uint32_t ulReloadValue = RTC_Convert_ms_to_Ticks(xExpectedIdleTime);
    RTC_SetWakeUpTimer(ulReloadValue);
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    RTC_ClearWakeUpFlag();
}
```

------

### 디버깅 및 검증 포인트

- Idle Hook 호출 주기 확인 (`traceTASK_SWITCHED_IN`)
- `uxTaskGetSystemState()`로 Task 상태 모니터링
- RTC Clock 정확도 측정 (LSE/LSI 사용 시 보정 필요)
- Stop/Resume 후 클럭 재설정 확인 (`SystemClock_Config`)
- 전류 측정기로 Sleep/Stop 모드별 전력 비교

------

### 정리

| 항목          | FreeRTOS 구성 요소         | HAL 연계 포인트              | 주의사항          |
| ------------- | -------------------------- | ---------------------------- | ----------------- |
| Idle Sleep    | vApplicationIdleHook       | HAL_PWR_EnterSLEEPMode       | SysTick 유지      |
| Tickless Idle | configUSE_TICKLESS_IDLE    | Pre/Post Sleep Hook          | RTC/LPTIM 기반    |
| Stop 모드     | Idle Hook 내 Stop 진입     | HAL_SuspendTick / ResumeTick | 복귀 시 클럭 복원 |
| RTC 기반 Tick | vPortSuppressTicksAndSleep | RTC Alarm                    | 오차 보정 필수    |

FreeRTOS와 HAL을 연동한 저전력 설계에서는
 **Tickless Idle 기반 Sleep 진입**과 **RTC 타이머 기반 Wake-up 관리**가 전력 절감의 핵심이다.
 Task 스케줄링, 클럭 복원, 인터럽트 타이밍을 정밀하게 제어하면
 배터리 구동 환경에서도 안정적인 RTOS 동작을 유지할 수 있다.