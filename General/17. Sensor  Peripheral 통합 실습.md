# 17. Sensor / Peripheral 통합 실습

## 17.1 온습도 / 기압 센서 (DHT22, BME280)

### 개요

온도·습도·기압 센서는 환경 모니터링, IoT 데이터 로깅, 자동 제어 시스템에서 핵심적인 역할을 수행한다.
 STM32 환경에서는 **DHT22**(단일 와이어 디지털 센서)와 **BME280**(I²C/SPI 인터페이스 기반 고정밀 센서)가 대표적으로 사용된다.
 이 장에서는 두 센서의 동작 원리, 통신 방식, HAL 기반 코드 구현, FreeRTOS 연동, 데이터 보정 및 필터링 절차를 다룬다.

------

### DHT22 (AM2302)

#### 센서 개요

- 측정 범위: 온도 -40~80℃, 습도 0~100% RH
- 정확도: ±0.5℃, ±2% RH
- 데이터 인터페이스: **Single-wire Digital Protocol**
- 전원: 3.3V / 5V 호환
- 측정 주기: 최소 2초 간격

#### 통신 방식

DHT22는 전용 디지털 프로토콜을 사용하며, MCU와 단일 데이터 핀으로 통신한다.

- MCU가 Start 신호(LOW 1ms)를 전송
- 센서가 응답 신호를 보냄
- 이후 40비트 데이터(16bit 습도 + 16bit 온도 + 8bit Checksum) 전송

#### 타이밍 다이어그램

| 단계              | 신호       | 지속시간                | 설명                                 |
| ----------------- | ---------- | ----------------------- | ------------------------------------ |
| MCU Start         | LOW        | ≥1ms                    | 센서에 측정 요청                     |
| Sensor Response   | LOW + HIGH | 약 80µs + 80µs          | 응답 준비                            |
| Data Transmission | HIGH/LOW   | 40bit (26~28µs or 70µs) | 비트 구분 (HIGH 길이로 ‘1’/‘0’ 판별) |

#### HAL 기반 GPIO 비트뱅잉 예시

```
#define DHT22_PORT GPIOA
#define DHT22_PIN  GPIO_PIN_1

uint8_t DHT22_ReadByte(void);
void DHT22_Start(void);
uint8_t DHT22_CheckResponse(void);

void DHT22_Start(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = DHT22_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    HAL_GPIO_Init(DHT22_PORT, &GPIO_InitStruct);

    HAL_GPIO_WritePin(DHT22_PORT, DHT22_PIN, GPIO_PIN_RESET);
    HAL_Delay(1);
    HAL_GPIO_WritePin(DHT22_PORT, DHT22_PIN, GPIO_PIN_SET);
    delay_us(30);
}

uint8_t DHT22_CheckResponse(void) {
    uint8_t response = 0;
    delay_us(40);
    if (!HAL_GPIO_ReadPin(DHT22_PORT, DHT22_PIN)) {
        delay_us(80);
        if (HAL_GPIO_ReadPin(DHT22_PORT, DHT22_PIN)) response = 1;
    }
    while (HAL_GPIO_ReadPin(DHT22_PORT, DHT22_PIN));
    return response;
}
```

#### 측정 데이터 파싱

```
uint8_t DHT22_Data[5];
float Temperature, Humidity;

Humidity = ((DHT22_Data[0] << 8) | DHT22_Data[1]) / 10.0;
Temperature = ((DHT22_Data[2] << 8) | DHT22_Data[3]) / 10.0;
```

#### FreeRTOS 연동 예시

```
void DHT22_Task(void *argument) {
    while (1) {
        if (DHT22_ReadData(&Temperature, &Humidity) == DHT22_OK) {
            printf("Temp: %.1f°C, Humi: %.1f%%\r\n", Temperature, Humidity);
        }
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}
```

#### 주의사항

- DMA, 인터럽트 기반 구현이 불가(정밀한 타이밍 필요).
- 2초 이하의 연속 측정 시 데이터 오류 발생.
- FreeRTOS 환경에서는 `vTaskDelay()`로 주기 제어.

------

### BME280 (Bosch Environmental Sensor)

#### 센서 개요

- 측정 항목: 온도, 습도, 기압
- 인터페이스: I²C / SPI
- 전압: 1.8V ~ 3.6V
- 측정 주기: 최대 1Hz (Normal mode)
- 내부 보정 파라미터 저장

#### I²C 연결 예시

| BME280 Pin | STM32 연결     | 설명   |
| ---------- | -------------- | ------ |
| VCC        | 3.3V           | 전원   |
| GND        | GND            | 접지   |
| SCL        | PB8 (I2C1_SCL) | 클럭   |
| SDA        | PB9 (I2C1_SDA) | 데이터 |

#### HAL 초기화 예시

```
#define BME280_ADDR 0xEC  // 7-bit address << 1

uint8_t BME280_Init(void) {
    uint8_t id;
    HAL_I2C_Mem_Read(&hi2c1, BME280_ADDR, 0xD0, 1, &id, 1, 100);
    if (id != 0x60) return HAL_ERROR;

    uint8_t ctrl_hum = 0x01;   // Humidity oversampling x1
    uint8_t ctrl_meas = 0x27;  // Temp/Press oversampling x1, Normal mode
    uint8_t config = 0xA0;     // Standby 1000ms, Filter off

    HAL_I2C_Mem_Write(&hi2c1, BME280_ADDR, 0xF2, 1, &ctrl_hum, 1, 100);
    HAL_I2C_Mem_Write(&hi2c1, BME280_ADDR, 0xF4, 1, &ctrl_meas, 1, 100);
    HAL_I2C_Mem_Write(&hi2c1, BME280_ADDR, 0xF5, 1, &config, 1, 100);

    return HAL_OK;
}
```

#### 보정 파라미터 읽기

BME280 내부에는 각 센서별 보정 데이터가 저장되어 있으며,
 보정 값을 이용해 Raw ADC 데이터를 실제 온도/습도/기압으로 환산한다.

```
typedef struct {
    uint16_t dig_T1;
    int16_t dig_T2;
    int16_t dig_T3;
    // ...
} BME280_CalibData;

BME280_CalibData calib;
HAL_I2C_Mem_Read(&hi2c1, BME280_ADDR, 0x88, 1, (uint8_t*)&calib, 26, 100);
```

#### 온도/습도/기압 계산

```
float BME280_ReadTemperature(void);
float BME280_ReadHumidity(void);
float BME280_ReadPressure(void);
```

보정식은 Bosch 공식 데이터시트의 정수 연산 기반 알고리즘을 그대로 사용해야 한다.
 부동소수점 변환 시 오차가 누적될 수 있으므로, 정밀 응용에서는 정수 연산 방식 유지가 권장된다.

------

### FreeRTOS 기반 BME280 주기 측정 태스크 예시

```
void BME280_Task(void *argument) {
    float temp, hum, press;
    BME280_Init();

    for (;;) {
        temp = BME280_ReadTemperature();
        hum = BME280_ReadHumidity();
        press = BME280_ReadPressure();

        printf("T: %.2f°C  H: %.2f%%  P: %.2fhPa\r\n", temp, hum, press);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

------

### 데이터 필터링 및 안정화

센서 측정값은 전원 노이즈, I²C 간섭, 환경적 변동 등으로 불안정할 수 있다.
 FreeRTOS 환경에서는 **Moving Average 필터** 또는 **Low-pass Digital Filter**를 적용한다.

```
float MovingAverageFilter(float *buf, int len, float newValue) {
    float sum = 0;
    for (int i = len - 1; i > 0; i--) buf[i] = buf[i - 1];
    buf[0] = newValue;
    for (int i = 0; i < len; i++) sum += buf[i];
    return sum / len;
}
```

------

### DHT22 vs BME280 비교

| 항목            | DHT22                  | BME280                  |
| --------------- | ---------------------- | ----------------------- |
| 측정 항목       | 온도, 습도             | 온도, 습도, 기압        |
| 인터페이스      | 단일 와이어            | I²C / SPI               |
| 응답 속도       | 느림 (2s 이상)         | 빠름 (1Hz 이상)         |
| 정확도          | ±0.5℃ / ±2%            | ±0.2℃ / ±1% / ±1hPa     |
| 보정 지원       | 없음                   | 내부 EEPROM 보정 데이터 |
| FreeRTOS 적합성 | 타이밍 제약으로 비추천 | 완전 호환               |

------

### 실습 포인트

- DHT22는 비트뱅잉 정확도가 중요하므로 SysTick 오차 최소화
- BME280은 HAL I²C DMA 모드 사용 시 CPU 부하 감소
- 측정 태스크를 독립 Task로 두고, Queue를 통해 Display Task로 전달
- FreeRTOS의 Software Timer로 주기 제어 가능

------

### 요약

DHT22는 단순 환경 센싱에 적합하지만, 정밀도와 응답 속도 면에서는 BME280이 우수하다.
 FreeRTOS 기반 시스템에서는 BME280을 I²C 통신으로 구현하여
 센싱 → 큐 전송 → 디스플레이/로깅 구조를 구성하는 것이 안정적이다.
 센서 전원 제어 핀을 활용해 Sleep 모드 진입 시 전력 절감 효과도 얻을 수 있다.

## 17.2 조도 센서 (BH1750)

### 개요

BH1750은 **로옴(ROHM)** 사의 디지털 조도 센서로, **I²C 인터페이스**를 통해 실시간 광도(Lux) 값을 직접 제공한다.
 내부 ADC를 통해 **광다이오드(Photodiode)**의 아날로그 전류를 16bit 디지털 값으로 변환하며, 보정된 Lux 단위를 출력하기 때문에
 MCU 측에서 추가적인 계산이 거의 필요하지 않다.

- 측정 단위: Lux (lx)
- 측정 범위: 1 lx ~ 65,535 lx
- 전원 전압: 2.4V ~ 3.6V
- 인터페이스: I²C (최대 400kHz)
- 동작 전류: 약 0.12mA (Continuous Mode)
- 대기 전류: 약 0.01µA (Power Down Mode 지원)

------

### 하드웨어 연결

| BH1750 Pin | STM32 연결     | 설명                           |
| ---------- | -------------- | ------------------------------ |
| VCC        | 3.3V           | 전원 공급                      |
| GND        | GND            | 접지                           |
| SDA        | PB9 (I2C1_SDA) | 데이터 라인                    |
| SCL        | PB8 (I2C1_SCL) | 클럭 라인                      |
| ADDR       | GND or VCC     | I²C 주소 선택 (0x23 또는 0x5C) |

#### I²C 주소

- ADDR = LOW → 0x23 (기본 주소)
- ADDR = HIGH → 0x5C

------

### 내부 동작 구조

BH1750은 내부적으로 다음 단계를 거쳐 조도를 측정한다.

1. **ADC 변환 시작**: I²C 명령으로 측정 모드 설정
2. **광전류 측정**: 내부 포토다이오드가 빛의 세기를 전류로 변환
3. **16bit 디지털 변환**: ADC를 통해 조도값을 디지털로 변환
4. **Lux 계산**: 측정 데이터 × 1.2 (기본 보정계수)

------

### 주요 명령어

| 명령어 코드 | 동작                          | 설명                             |
| ----------- | ----------------------------- | -------------------------------- |
| 0x00        | Power Down                    | 저전력 모드                      |
| 0x01        | Power On                      | 전원 활성화                      |
| 0x10        | Continuous H-Resolution Mode  | 1 lx, 120ms                      |
| 0x11        | Continuous H-Resolution Mode2 | 0.5 lx, 120ms                    |
| 0x13        | Continuous L-Resolution Mode  | 4 lx, 16ms                       |
| 0x20        | One Time H-Resolution Mode    | 1 lx, 120ms 후 자동 Power Down   |
| 0x21        | One Time H-Resolution Mode2   | 0.5 lx, 120ms 후 자동 Power Down |
| 0x23        | One Time L-Resolution Mode    | 4 lx, 16ms 후 자동 Power Down    |

------

### HAL 기반 초기화 및 측정 코드

```
#include "stm32f1xx_hal.h"

#define BH1750_ADDR (0x23 << 1)
extern I2C_HandleTypeDef hi2c1;

void BH1750_Init(void) {
    uint8_t cmd = 0x01;  // Power ON
    HAL_I2C_Master_Transmit(&hi2c1, BH1750_ADDR, &cmd, 1, HAL_MAX_DELAY);
    cmd = 0x10;          // Continuous H-Resolution Mode
    HAL_I2C_Master_Transmit(&hi2c1, BH1750_ADDR, &cmd, 1, HAL_MAX_DELAY);
}

uint16_t BH1750_ReadRaw(void) {
    uint8_t data[2];
    HAL_I2C_Master_Receive(&hi2c1, BH1750_ADDR, data, 2, HAL_MAX_DELAY);
    return (data[0] << 8) | data[1];
}

float BH1750_ReadLux(void) {
    uint16_t raw = BH1750_ReadRaw();
    return (float)raw / 1.2f; // Lux 계산
}
```

------

### FreeRTOS 기반 조도 측정 태스크 예시

```
void BH1750_Task(void *argument) {
    float lux;
    BH1750_Init();

    while (1) {
        lux = BH1750_ReadLux();
        printf("Light: %.2f lx\r\n", lux);

        // 데이터 필터링 및 Queue 전송
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}
```

조도 데이터는 Display Task, Logging Task, IoT 전송 Task 등으로 Queue를 통해 전달할 수 있다.
 주기적 샘플링은 FreeRTOS의 Software Timer 또는 `vTaskDelay()`로 제어한다.

------

### 측정 모드 비교

| 모드          | 해상도 | 변환 시간 | 연속 측정 | 소비 전류 | 비고              |
| ------------- | ------ | --------- | --------- | --------- | ----------------- |
| H-Resolution  | 1 lx   | 약 120ms  | O         | 낮음      | 일반 사용         |
| H-Resolution2 | 0.5 lx | 약 120ms  | O         | 낮음      | 고정밀 측정       |
| L-Resolution  | 4 lx   | 약 16ms   | O         | 매우 낮음 | 빠른 반응 필요 시 |
| One Time      | 동일   | 자동 종료 | X         | 매우 낮음 | 전력 절감용       |

------

### 응용 및 활용

#### 1. 자동 밝기 제어

BH1750로 측정한 Lux 값을 기준으로 LCD/OLED 백라이트, 조명, LED 밝기를 자동 조절할 수 있다.

```
if (lux < 100) Set_Backlight(100);
else if (lux < 500) Set_Backlight(50);
else Set_Backlight(10);
```

#### 2. 에너지 절약형 시스템

One Time 모드를 사용하면 측정 후 자동으로 Power Down 상태로 전환되어 Sleep 모드와 연동 가능하다.
 FreeRTOS의 **Tickless Idle Mode**와 조합하면 배터리 기반 IoT 시스템의 소비 전력을 극적으로 줄일 수 있다.

#### 3. 환경 로깅 시스템

RTC와 FATFS를 함께 사용하면 시간별 조도 변화를 SD 카드에 기록할 수 있다.

```
fprintf(fp, "%02d:%02d %.2f lx\n", hour, min, lux);
```

------

### 노이즈 및 정확도 향상 팁

- I²C 라인에 4.7kΩ 풀업 저항 필수
- 센서 근처 전원 노이즈 제거용 0.1µF 바이패스 콘덴서 추가
- 외부 조명 간섭이 심한 경우 투명 실리콘 커버 사용
- 데이터 안정화를 위해 Moving Average 필터 적용

```
float Lux_Filter(float *buf, int len, float newValue) {
    float sum = 0;
    for (int i = len - 1; i > 0; i--) buf[i] = buf[i - 1];
    buf[0] = newValue;
    for (int i = 0; i < len; i++) sum += buf[i];
    return sum / len;
}
```

------

### 디버깅 포인트

- I²C 통신 오류 발생 시 `HAL_I2C_IsDeviceReady()`로 주소 확인
- Lux 값이 0 또는 최대값(65535)으로 고정될 경우 전원/타이밍 문제 가능성
- FreeRTOS 태스크 간 데이터 공유 시 Queue 또는 Mutex로 보호

------

### 요약

BH1750은 단순한 I²C 명령만으로 조도(Lux)를 직접 읽을 수 있는 고정밀 디지털 센서이다.
 HAL 기반 환경에서는 초기화 후 바로 Lux 데이터를 얻을 수 있으며, FreeRTOS와 결합하면
 **주기적 조도 측정**, **조명 제어**, **환경 로깅 시스템** 등을 손쉽게 구축할 수 있다.

전력 효율이 높고 응답 속도가 빠르기 때문에, IoT 센서 허브나 스마트홈 시스템에서 필수적으로 사용된다.

## 17.3 가속도 / 자이로 센서 (MPU6050, MPU9250)

### 개요

MPU6050과 MPU9250은 InvenSense사의 **6축(3축 가속도 + 3축 자이로)** 및 **9축(3축 가속도 + 3축 자이로 + 3축 지자기)** 센서이다.
 두 센서는 **I²C 또는 SPI 인터페이스**를 통해 MCU와 통신하며, 내부에 **DMP (Digital Motion Processor)**가 내장되어
 센서 융합 연산(Quaternion, Euler Angle 계산 등)을 하드웨어 수준에서 수행할 수 있다.

- MPU6050: Accelerometer + Gyroscope
- MPU9250: Accelerometer + Gyroscope + Magnetometer (AK8963 내장)
- 출력 단위:
  - 가속도: g 단위 (±2g, ±4g, ±8g, ±16g)
  - 각속도: °/s 단위 (±250, ±500, ±1000, ±2000 °/s)
  - 자기장: µT 단위 (MPU9250만 해당)

------

### 하드웨어 연결

| MPU Pin | STM32 연결     | 설명                   |
| ------- | -------------- | ---------------------- |
| VCC     | 3.3V           | 전원 공급              |
| GND     | GND            | 접지                   |
| SDA     | PB9 (I2C1_SDA) | 데이터 라인            |
| SCL     | PB8 (I2C1_SCL) | 클럭 라인              |
| AD0     | GND (또는 VCC) | I²C 주소 선택          |
| INT     | PA0            | 인터럽트 출력 (선택적) |

#### I²C 주소

- AD0 = LOW → 0x68
- AD0 = HIGH → 0x69

MPU9250의 자기 센서(AK8963)는 내부 I²C 버스에 연결되어 있으며,
 MPU 내부를 통해 간접적으로 접근한다.

------

### 내부 구조

1. **Accelerometer**: 3축 선형 가속도 측정
2. **Gyroscope**: 3축 각속도 측정
3. **Temperature Sensor**: 내부 온도 보정용
4. **DMP (Digital Motion Processor)**: 센서 융합 및 필터 연산 수행
5. **AK8963 (MPU9250 only)**: 3축 자기장 측정

모든 측정값은 내부 16bit ADC를 통해 디지털화되어 레지스터에 저장된다.

------

### 주요 레지스터 요약

| 레지스터     | 주소 | 설명                      |
| ------------ | ---- | ------------------------- |
| WHO_AM_I     | 0x75 | 디바이스 ID (0x68 / 0x71) |
| PWR_MGMT_1   | 0x6B | 전원 관리, 클럭 설정      |
| ACCEL_XOUT_H | 0x3B | 가속도 X축 상위 바이트    |
| GYRO_XOUT_H  | 0x43 | 자이로 X축 상위 바이트    |
| TEMP_OUT_H   | 0x41 | 온도 데이터 상위 바이트   |
| INT_STATUS   | 0x3A | 데이터 준비 인터럽트 상태 |

------

### 초기화 및 기본 측정 코드 (HAL I²C)

```
#include "stm32f1xx_hal.h"

#define MPU_ADDR (0x68 << 1)
extern I2C_HandleTypeDef hi2c1;

void MPU_Init(void) {
    uint8_t data;
    data = 0x00; // Sleep 해제
    HAL_I2C_Mem_Write(&hi2c1, MPU_ADDR, 0x6B, 1, &data, 1, HAL_MAX_DELAY);

    data = 0x00; // Gyro 250dps, Acc ±2g
    HAL_I2C_Mem_Write(&hi2c1, MPU_ADDR, 0x1B, 1, &data, 1, HAL_MAX_DELAY);
    HAL_I2C_Mem_Write(&hi2c1, MPU_ADDR, 0x1C, 1, &data, 1, HAL_MAX_DELAY);
}

void MPU_Read_Raw(int16_t *accel, int16_t *gyro, int16_t *temp) {
    uint8_t buf[14];
    HAL_I2C_Mem_Read(&hi2c1, MPU_ADDR, 0x3B, 1, buf, 14, HAL_MAX_DELAY);
    accel[0] = (buf[0] << 8) | buf[1];
    accel[1] = (buf[2] << 8) | buf[3];
    accel[2] = (buf[4] << 8) | buf[5];
    *temp    = (buf[6] << 8) | buf[7];
    gyro[0]  = (buf[8] << 8) | buf[9];
    gyro[1]  = (buf[10] << 8) | buf[11];
    gyro[2]  = (buf[12] << 8) | buf[13];
}
```

------

### 물리 단위 변환

```
float Accel_Scale = 16384.0f; // ±2g
float Gyro_Scale  = 131.0f;   // ±250°/s

float ax = accel[0] / Accel_Scale;
float ay = accel[1] / Accel_Scale;
float az = accel[2] / Accel_Scale;
float gx = gyro[0] / Gyro_Scale;
float gy = gyro[1] / Gyro_Scale;
float gz = gyro[2] / Gyro_Scale;
float temperature = (*temp) / 340.0f + 36.53f;
```

------

### FreeRTOS 기반 센서 태스크 예시

```
void MPU_Task(void *argument) {
    int16_t accel[3], gyro[3], temp;
    float ax, ay, az, gx, gy, gz;
    MPU_Init();

    while (1) {
        MPU_Read_Raw(accel, gyro, &temp);
        ax = accel[0] / 16384.0f;
        ay = accel[1] / 16384.0f;
        az = accel[2] / 16384.0f;
        gx = gyro[0] / 131.0f;
        gy = gyro[1] / 131.0f;
        gz = gyro[2] / 131.0f;

        printf("A[g]: %.2f %.2f %.2f | G[dps]: %.2f %.2f %.2f\r\n",
               ax, ay, az, gx, gy, gz);

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}
```

------

### DMP (Digital Motion Processor) 활용

MPU6050/9250의 DMP는 내부적으로 가속도 + 자이로 데이터를 융합하여 **자세(Orientation)**를 계산한다.
 이를 통해 소프트웨어 필터 없이도 Quaternion, Euler Angle, Pitch/Roll/Yaw를 직접 얻을 수 있다.

DMP를 활성화하기 위해서는 **InvenSense의 Motion Driver Library** 또는
 오픈소스 라이브러리(`i2cdevlib`, `Jeff Rowberg’s MPU6050 driver`)를 사용한다.

DMP 출력 예시 (Euler Angle 변환):

```
float pitch = atan2(ax, sqrt(ay*ay + az*az)) * 180/M_PI;
float roll  = atan2(ay, sqrt(ax*ax + az*az)) * 180/M_PI;
```

------

### MPU9250의 자기 센서(AK8963) 읽기

MPU9250은 내부 보조 I²C를 통해 AK8963 센서 데이터를 읽는다.
 AK8963의 I²C 주소는 `0x0C`이며, MPU9250의 **I2C_SLV0** 레지스터를 통해 간접 접근한다.

자기장 데이터는 µT 단위로 변환되어 3축 보정에 사용되며,
 지자기 방향(Yaw)을 계산하거나 전자 나침반 기능에 사용된다.

------

### 센서 융합 알고리즘

#### Complementary Filter (기본형)

```
angle = 0.98f * (angle + gyro_rate * dt) + 0.02f * accel_angle;
```

#### Kalman Filter (고정밀)

- 측정값: 가속도 기반 각도
- 예측값: 자이로 적분 결과
- 보정값: 예측 오차 최소화

이 필터를 적용하면 드리프트가 억제되고, 안정된 자세 제어가 가능하다.

------

### 실습 예제

1. **자세 추정**
   - MPU6050을 일정 각도로 기울이며 Pitch/Roll 계산
   - OLED나 시리얼 콘솔에 실시간 각도 표시
2. **자이로 기반 회전 검출**
   - 특정 각속도 이상 시 이벤트 발생 (예: 회전 감지)
3. **센서 융합 기반 로봇 제어**
   - FreeRTOS Task로 MPU 데이터 수집
   - PID 제어기로 모터 PWM 피드백

------

### 주의사항 및 디버깅

- I²C 라인에 4.7kΩ 풀업 저항 필수
- MPU 모듈의 전원 안정화를 위해 0.1µF + 10µF 바이패스 콘덴서 사용
- 데이터 0 또는 65535 반복 시 통신 오류
- FreeRTOS 환경에서는 I²C Mutex 사용 권장
- 자이로 드리프트는 센서 초기화 시 2~3초간 정지하여 기준값 보정 필요

------

### 요약

MPU6050과 MPU9250은 **6축/9축 IMU(Inertial Measurement Unit)**로,
 가속도·자이로·자기장 정보를 통해 **자세, 회전, 운동 상태**를 실시간으로 파악할 수 있다.

STM32 HAL 환경에서는 I²C 기반으로 손쉽게 접근할 수 있으며,
 FreeRTOS 기반 구조에서는 독립된 센서 태스크로 주기적 샘플링 및 큐 전송이 효율적이다.

센서 융합 알고리즘(Complementary / Kalman Filter)과 결합하면
 **자세 제어, 로봇 균형 유지, 드론 안정화 시스템** 등 고급 제어 응용에 필수적으로 사용된다.

## 17.4 무게 측정 센서 (HX711 + 로드셀)

### 개요

HX711은 로드셀(Load Cell)의 미세한 아날로그 전압 출력을 정밀하게 디지털로 변환하기 위한 **24비트 ADC(Analog-to-Digital Converter)** 모듈이다.
 로드셀은 구조적으로 **Wheatstone Bridge** 형태의 스트레인 게이지(Strain Gauge)로 구성되어,
 하중(Force)이 가해질 때 전기 저항의 변화로 인한 전압 변화를 출력한다.

STM32와 HX711을 결합하면 **전자저울**, **압력 감지**, **중량 로깅 시스템** 등을 구현할 수 있다.

------

### 시스템 구성

- **로드셀 (Load Cell)**: 아날로그 전압 변화를 발생시키는 센서
- **HX711 모듈**: 로드셀 출력을 증폭(최대 128배) 후 디지털 변환
- **STM32 (MCU)**: 데이터 수집, 보정, 표시, 로깅 등 수행

#### HX711 주요 특징

- 24-bit ADC (고해상도)
- 내장 PGA (128배 / 64배 이득 설정)
- 2채널 입력 (Channel A/B)
- 저전력 동작 모드
- CLK 신호에 따라 데이터 읽기 및 샘플링 속도 제어 (10 Hz / 80 Hz)

------

### 하드웨어 연결

| HX711 Pin    | STM32 연결                     | 설명        |
| ------------ | ------------------------------ | ----------- |
| VCC          | 3.3V                           | 전원 공급   |
| GND          | GND                            | 접지        |
| DT (DOUT)    | PB7                            | 데이터 출력 |
| SCK (PD_SCK) | PB6                            | 클럭 입력   |
| E+ / E-      | 로드셀 Excitation 전원 (+ / −) |             |
| A+ / A−      | 로드셀 Signal 입력 (+ / −)     |             |

#### 로드셀 배선 예시 (4선식)

| 색상 | 기능              |
| ---- | ----------------- |
| 빨강 | E+ (Excitation +) |
| 검정 | E− (Excitation −) |
| 흰색 | A− (Signal −)     |
| 초록 | A+ (Signal +)     |

------

### 내부 동작 원리

1. 로드셀에 하중이 가해지면 스트레인 게이지의 저항이 변함.
2. Wheatstone Bridge 출력 전압이 미세하게 변동함 (μV 단위).
3. HX711의 내부 PGA가 해당 전압을 증폭 (최대 128배).
4. 증폭된 전압을 24비트 ADC로 변환하여 직렬로 MCU에 전송.
5. MCU는 CLK 신호를 토글하여 데이터 비트를 순차적으로 수신.

------

### 기본 타이밍 시퀀스

HX711은 **DOUT (DT)** 라인이 LOW가 되면 데이터가 준비되었음을 의미한다.
 그 후 MCU가 **SCK를 24회 펄스** 주면 데이터가 전송된다.
 마지막 25~27번째 펄스 개수로 입력 채널 및 게인 설정이 결정된다.

| 펄스 수 | 채널 | 이득 |
| ------- | ---- | ---- |
| 25      | A    | 128  |
| 26      | B    | 32   |
| 27      | A    | 64   |

------

### STM32 HAL 기반 코드 예시

```
#include "stm32f1xx_hal.h"

#define HX711_DT_Pin  GPIO_PIN_7
#define HX711_SCK_Pin GPIO_PIN_6
#define HX711_Port    GPIOB

void HX711_Delay(void) { for (volatile int i = 0; i < 50; i++); }

uint32_t HX711_Read(void) {
    uint32_t data = 0;
    while (HAL_GPIO_ReadPin(HX711_Port, HX711_DT_Pin)); // 데이터 준비 대기

    for (int i = 0; i < 24; i++) {
        HAL_GPIO_WritePin(HX711_Port, HX711_SCK_Pin, GPIO_PIN_SET);
        HX711_Delay();
        data = (data << 1) | HAL_GPIO_ReadPin(HX711_Port, HX711_DT_Pin);
        HAL_GPIO_WritePin(HX711_Port, HX711_SCK_Pin, GPIO_PIN_RESET);
        HX711_Delay();
    }

    // 채널/이득 설정 (A채널, 128배)
    HAL_GPIO_WritePin(HX711_Port, HX711_SCK_Pin, GPIO_PIN_SET);
    HX711_Delay();
    HAL_GPIO_WritePin(HX711_Port, HX711_SCK_Pin, GPIO_PIN_RESET);
    HX711_Delay();

    // 부호 처리 (24bit → 32bit)
    if (data & 0x800000)
        data |= 0xFF000000;
    return data;
}
```

------

### 보정 및 영점 조정 절차

1. **제로(Zero) 캘리브레이션**
   - 아무 하중이 없는 상태에서 여러 번 샘플링
   - 평균값을 `offset`으로 저장
2. **스팬(Span) 보정**
   - 기준 중량(예: 1kg)을 올려서 측정
   - 측정값과 실제 무게의 비율로 `scale` 계산
3. **보정식 적용**

```
long offset = 8300000;
float scale = 2280.0f;

float Read_Weight(void) {
    long raw = HX711_Read();
    return (float)(raw - offset) / scale;
}
```

------

### FreeRTOS 기반 측정 태스크 예시

```
void LoadCell_Task(void *argument) {
    float weight;
    while (1) {
        weight = Read_Weight();
        printf("Weight: %.2f g\r\n", weight * 1000);
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}
```

------

### 실습 예제

1. **기본 전자저울 구현**
   - HX711에서 주기적으로 데이터 읽기
   - OLED 또는 UART로 무게 표시
2. **Zero 보정 버튼 추가**
   - 버튼 입력 시 offset 재보정 수행
3. **FreeRTOS 기반 데이터 필터링**
   - Moving Average Filter 적용
   - 노이즈 최소화 및 안정된 측정값 유지
4. **BLE/UART 전송**
   - 가중 데이터를 BLE 혹은 시리얼로 송신하여 PC나 안드로이드 앱에서 표시

------

### 노이즈 억제 및 안정화 팁

- 전원 노이즈를 최소화하기 위해 **별도의 3.3V LDO** 사용
- DT/SCK 라인에 **100Ω 직렬 저항 + 100nF 필터 커패시터** 삽입
- 하중 측정 시 진동 최소화 및 기계적 고정 필요
- 평균 필터, 이동평균(Moving Average), 중위값 필터(Median Filter) 적용 시 안정적

------

### 교정 데이터 저장

보정 파라미터(offset, scale)는 **EEPROM 또는 Flash**에 저장하여
 시스템 재부팅 후에도 유지되도록 한다.

```
typedef struct {
    long offset;
    float scale;
} HX711_Calibration;

HX711_Calibration cal;

void Save_Calibration(void) {
    HAL_FLASH_Unlock();
    // Flash Write 예시
    // ...
    HAL_FLASH_Lock();
}
```

------

### FreeRTOS + 센서 융합 응용

- RTOS 태스크 구조 예시:
  - `LoadCellTask`: 무게 측정 및 필터링
  - `DisplayTask`: OLED 출력
  - `CommTask`: UART/BLE 전송
  - 큐(Queue)로 센서 데이터를 안전하게 공유

------

### 고급 응용 예시

- **커피 머신 / 제빵기 무게 감지**
- **자동 계량 시스템 (Gravimetric Feeder)**
- **무게 기반 충전량 제어**
- **스마트 IoT 저울 (Wi-Fi, BLE 연동)**

------

### 요약

HX711 + 로드셀 조합은 **고해상도, 저비용 중량 측정 시스템**을 구현할 수 있는 가장 일반적인 방식이다.
 STM32 HAL을 통해 GPIO 기반으로 간단히 제어 가능하며,
 보정 및 필터링 절차를 거치면 ±1g 수준의 정밀도를 확보할 수 있다.

FreeRTOS 환경에서는 주기적 샘플링, 큐 기반 데이터 교환,
 보정값 저장 및 통신 인터페이스 연동으로 산업용 계량 시스템 수준의 구조로 확장 가능하다.

## 17.5 거리 / 근접 센서 (HC-SR04, VL53L0X)

### 개요

거리 센서는 물체와의 거리를 비접촉 방식으로 측정하기 위한 장치로,
 대표적으로 **초음파 센서(HC-SR04)** 와 **레이저 ToF(Time of Flight) 센서(VL53L0X)** 가 널리 사용된다.

- **HC-SR04**: 초음파 펄스를 발사 후 반사되어 돌아오는 시간을 이용해 거리를 계산 (공기 중 음속 기반)
- **VL53L0X**: 적외선 레이저의 비행 시간을 직접 측정하여 mm 단위의 정밀 거리 계산

STM32 환경에서는 두 센서를 각각 **Timer Capture**, **I²C 인터페이스**를 이용해 구현한다.

------

## HC-SR04 초음파 거리 센서

### 동작 원리

HC-SR04는 송신부(Trig)에서 40kHz 초음파를 발사하고,
 물체에 반사되어 돌아오는 시간(에코 시간)을 측정하여 거리를 계산한다.

거리 계산식:
$$
\text{Distance (cm)} = \frac{\text{Echo Time (µs)} \times 0.0343}{2}
$$
(음속 343m/s 기준, 왕복 시간이므로 2로 나눔)

------

### 하드웨어 연결

| HC-SR04 Pin | STM32 연결 | 설명                                        |
| ----------- | ---------- | ------------------------------------------- |
| VCC         | 5V         | 전원 공급                                   |
| GND         | GND        | 접지                                        |
| TRIG        | PA1        | 트리거 출력 핀                              |
| ECHO        | PA2        | Echo 입력 (Timer Capture 또는 GPIO Polling) |

> Echo 출력은 5V이므로 STM32 입력 핀 보호를 위해 **1kΩ + 2kΩ 분압 저항** 사용 권장.

------

### 타이머 입력 캡처 방식

STM32의 **TIM Input Capture 모드**를 이용하면 Echo 펄스의 길이를 정확히 측정할 수 있다.
 Timer의 카운터 값 차이를 계산하여 Echo 지속 시간을 구한다.

#### 주요 절차

1. Trig 핀 HIGH 유지 (10µs 이상)
2. Echo Rising Edge → Timer Capture Start
3. Echo Falling Edge → Timer Capture Stop
4. 두 Capture 값의 차이 = Echo Duration (µs)

------

### HAL 기반 코드 예시

```
#define TRIG_Pin GPIO_PIN_1
#define TRIG_Port GPIOA

extern TIM_HandleTypeDef htim2;
uint32_t ic_val1 = 0, ic_val2 = 0;
uint8_t is_first_captured = 0;
float distance = 0.0f;

void HCSR04_Trigger(void) {
    HAL_GPIO_WritePin(TRIG_Port, TRIG_Pin, GPIO_PIN_SET);
    delay_us(10);
    HAL_GPIO_WritePin(TRIG_Port, TRIG_Pin, GPIO_PIN_RESET);
}

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) {
    if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {
        if (!is_first_captured) {
            ic_val1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            is_first_captured = 1;
            __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_FALLING);
        } else {
            ic_val2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            __HAL_TIM_SET_COUNTER(htim, 0);
            uint32_t diff = (ic_val2 > ic_val1) ? (ic_val2 - ic_val1) : ((0xFFFF - ic_val1) + ic_val2);
            distance = diff * 0.0343f / 2.0f; // cm
            is_first_captured = 0;
            __HAL_TIM_SET_CAPTUREPOLARITY(htim, TIM_CHANNEL_1, TIM_INPUTCHANNELPOLARITY_RISING);
            HAL_TIM_IC_Stop_IT(htim, TIM_CHANNEL_1);
        }
    }
}
```

------

### FreeRTOS 기반 거리 측정 태스크

```
void Ultrasonic_Task(void *argument) {
    while (1) {
        HCSR04_Trigger();
        HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
        vTaskDelay(pdMS_TO_TICKS(100));
        printf("Distance: %.2f cm\r\n", distance);
    }
}
```

------

### 오차 요인 및 보정

- 온도 변화에 따라 음속이 달라짐 (약 0.6 m/s/°C 보정 필요)
- 작은 물체나 흡음재는 반사 약함 → 감지 실패 가능
- Echo 신호 반사각이 크면 측정 불안정

------

## VL53L0X 레이저 ToF 거리 센서

### 개요

VL53L0X는 STMicroelectronics의 ToF(Time of Flight) 센서로,
 적외선 레이저를 발사 후 반사되어 돌아오는 시간을 **ns 단위로 직접 측정**하여 거리를 계산한다.

- 통신 인터페이스: I²C
- 동작 전압: 2.6~3.5V
- 측정 범위: 20mm ~ 2000mm
- 분해능: ±3mm 수준
- 장점: 표면 반사율, 각도에 덜 민감 / 직진성 우수

------

### 하드웨어 연결

| VL53L0X Pin | STM32 연결 | 설명                     |
| ----------- | ---------- | ------------------------ |
| VIN         | 3.3V       | 전원                     |
| GND         | GND        | 접지                     |
| SDA         | PB9        | I2C1_SDA                 |
| SCL         | PB8        | I2C1_SCL                 |
| XSHUT       | PB7        | 하드웨어 리셋 (Optional) |

------

### 초기화 및 측정 절차

1. I²C 통신 초기화
2. VL53L0X 모듈 초기화 (`VL53L0X_Init()`)
3. 측정 모드 설정 (단일 / 연속)
4. 거리 데이터 읽기 (`VL53L0X_ReadRangeContinuousMillimeters()`)

------

### HAL 기반 코드 예시 (ST 라이브러리 사용)

```
#include "vl53l0x_api.h"

VL53L0X_Dev_t vl53_dev;
VL53L0X_RangingMeasurementData_t measure;

void VL53L0X_InitSensor(void) {
    vl53_dev.I2cDevAddr = 0x52;
    vl53_dev.comms_type = 1;
    vl53_dev.comms_speed_khz = 400;
    VL53L0X_DataInit(&vl53_dev);
    VL53L0X_StaticInit(&vl53_dev);
    VL53L0X_PerformRefCalibration(&vl53_dev, NULL, NULL);
    VL53L0X_SetDeviceMode(&vl53_dev, VL53L0X_DEVICEMODE_CONTINUOUS_RANGING);
    VL53L0X_StartMeasurement(&vl53_dev);
}

uint16_t VL53L0X_ReadDistance(void) {
    VL53L0X_GetRangingMeasurementData(&vl53_dev, &measure);
    return measure.RangeMilliMeter;
}
```

------

### FreeRTOS 기반 측정 태스크

```
void VL53L0X_Task(void *argument) {
    VL53L0X_InitSensor();
    while (1) {
        uint16_t dist = VL53L0X_ReadDistance();
        printf("Laser Distance: %d mm\r\n", dist);
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}
```

------

### 두 센서 비교

| 항목       | HC-SR04            | VL53L0X               |
| ---------- | ------------------ | --------------------- |
| 측정 원리  | 초음파 반사 시간   | 레이저 비행 시간(ToF) |
| 인터페이스 | GPIO / Timer       | I²C                   |
| 측정 범위  | 2cm ~ 400cm        | 2cm ~ 200cm           |
| 해상도     | 약 3mm             | 약 1mm                |
| 응답 속도  | 느림 (수 ms)       | 빠름 (수백 µs)        |
| 환경 영향  | 온도, 습도 영향 큼 | 영향 적음             |
| 전원       | 5V                 | 3.3V                  |
| 장점       | 단가 저렴          | 고정밀, 빠른 응답     |
| 단점       | 반사체 영향 큼     | I²C 제어 복잡         |

------

### 통합 실습 예시

1. **HC-SR04 + VL53L0X 이중 센서 측정**
   - 근거리(0~50cm): VL53L0X 사용
   - 장거리(>50cm): HC-SR04 전환
2. **OLED 표시 / UART 출력**
   - 거리값을 주기적으로 화면 표시 및 로그 전송
3. **장애물 감지 시스템**
   - 일정 거리 이하 감지 시 LED 또는 부저 활성화
4. **RTOS 병렬 구조 예시**
   - `UltrasonicTask`: HC-SR04 데이터 수집
   - `ToFTask`: VL53L0X 데이터 수집
   - `DisplayTask`: 거리 정보 표시
   - `CommTask`: BLE/UART 전송

------

### 오차 보정 및 안정화

- HC-SR04의 경우 온도센서(DHT22 등) 연동하여 **음속 보정**
- VL53L0X는 반사율이 낮은 검은 물체에 대해 거리값이 불안정할 수 있음 → 평균 필터 적용
- FreeRTOS에서 측정 주기 보장은 Software Timer 사용 권장

------

### 요약

HC-SR04는 **저가형 근거리 거리 측정**에 적합하고,
 VL53L0X는 **고정밀 ToF 기반 측정**으로 **로봇, 드론, 장애물 감지 시스템**에 자주 사용된다.

STM32 HAL 환경에서 두 센서를 함께 사용하면
 **장단거리 복합 거리 측정 시스템**, **스마트 주차 감지**, **로봇 매핑** 등 고급 응용이 가능하다.

## 17.6 공기질 / 가스 센서 (MQ-135, CCS811)

공기질 및 가스 센서는 휘발성 유기화합물(VOC), CO₂, 암모니아(NH₃), 메탄(CH₄), 일산화탄소(CO) 등 다양한 기체를 감지하여 공기 오염도를 측정하는 센서이다.
 STM32 환경에서는 I²C 혹은 아날로그 입력을 통해 데이터를 수집하며, 센서별 보정 및 온습도 보정이 필수적이다.
 본 절에서는 대표적인 공기질 센서인 **MQ-135 (아날로그형)** 및 **CCS811 (디지털형, I²C 인터페이스)** 의 동작 원리, 하드웨어 연결, 펌웨어 구현, 그리고 보정 방법을 다룬다.

------

### MQ-135 원리 및 특성

- MQ-135는 SnO₂(이산화주석) 기반의 반도체형 가스 센서로, 특정 가스 농도에 따라 저항값이 변화한다.
- 출력은 아날로그 전압 형태로 제공되며, **ADC 입력으로 읽어** 공기질을 추정한다.
- 측정 가능한 주요 가스: NH₃, NOx, 알코올, 벤젠, CO₂ 등.
- **Ro (Clean Air Resistance)** 값의 보정이 중요하며, 데이터시트의 비선형 곡선을 이용해 농도(ppm)를 계산한다.
- 동작 전압: 5V / 예열 시간(Warm-up) 약 24시간 필요.

------

### MQ-135 하드웨어 연결

- **VCC** → 5V
- **GND** → GND
- **AO (Analog Output)** → STM32의 ADC 입력핀 (예: `PA0`)
- **DO (Digital Output)** → 임계값 비교용 (미사용 가능)

------

### MQ-135 ADC 측정 및 보정

```
#define RL 10.0  // Load Resistance (kΩ)
#define Ro 76.63 // Clean Air Resistance (kΩ), 보정 필요

float readMQ135()
{
    uint32_t adcVal = HAL_ADC_GetValue(&hadc1);
    float sensorVoltage = (adcVal / 4095.0f) * 3.3f;
    float rs = (3.3f - sensorVoltage) * RL / sensorVoltage;
    float ratio = rs / Ro;

    // 공기 중 CO2 농도 근사식 (예: 데이터시트 참고)
    float ppm = 116.6020682 * pow(ratio, -2.769034857);
    return ppm;
}
```

- 초기 보정 시 깨끗한 공기 중에서 여러 번 측정하여 `Ro` 값을 평균화해야 한다.
- `ratio` → `ppm` 변환은 센서마다 다르며, 데이터시트의 곡선을 기반으로 근사식을 사용한다.
- 온도/습도 변화에 따른 보정이 필요할 수 있다.

------

### CCS811 원리 및 특징

- CCS811은 **I²C 기반 디지털 공기질 센서**로, eCO₂(equivalent CO₂) 및 TVOC(Total Volatile Organic Compounds)를 계산하여 제공한다.
- 내부적으로 가스 감지 소자 및 온습도 보정 회로를 포함한다.
- I²C 주소: 0x5A 또는 0x5B
- 동작 전압: 1.8~3.6V (3.3V 권장)
- 필요 시 보조 온습도 센서(BME280 등)로 보정 가능.

------

### CCS811 하드웨어 연결

- **VCC** → 3.3V
- **GND** → GND
- **SCL** → `PB8` (I²C1_SCL)
- **SDA** → `PB9` (I²C1_SDA)
- **nWAKE** → GND (항상 활성화 상태 유지)

------

### CCS811 초기화 및 데이터 읽기 예제

```
#include "ccs811.h"

void CCS811_Init()
{
    HAL_Delay(100);
    CCS811_Reset();
    CCS811_AppStart();

    uint8_t status = CCS811_ReadStatus();
    if (!(status & 0x10))
        Error_Handler();  // App not valid

    CCS811_SetMode(CCS811_MODE_1SEC);
}

void CCS811_Read()
{
    uint16_t eco2, tvoc;
    if (CCS811_DataReady())
    {
        CCS811_ReadData(&eco2, &tvoc);
        printf("eCO2: %d ppm, TVOC: %d ppb\r\n", eco2, tvoc);
    }
}
```

- CCS811은 펌웨어 내장형으로, App start 명령을 실행해야 데이터가 유효해진다.
- 데이터 읽기 주기는 최소 1초이며, 온습도 보정을 추가할 수 있다.

------

### 온습도 보정 적용 (CCS811 + BME280)

```
float temperature = BME280_ReadTemp();
float humidity = BME280_ReadHum();
CCS811_SetEnvironmentalData(humidity, temperature);
```

- 보정값을 제공하면 eCO₂ 및 TVOC 계산 정확도가 향상된다.
- CCS811 내부 NTC 센서만 사용할 경우 정확도가 낮을 수 있다.

------

### FreeRTOS 기반 주기적 측정 태스크 예시

```
void vGasSensorTask(void *argument)
{
    CCS811_Init();
    for (;;)
    {
        CCS811_Read();
        vTaskDelay(pdMS_TO_TICKS(1000)); // 1초 주기 측정
    }
}
```

- 주기적 데이터 취득, 큐를 통한 다른 태스크로의 전송, UART/BLE 전송에 활용할 수 있다.

------

### 데이터 해석 및 통합

- MQ-135 → ADC 기반 농도 계산
- CCS811 → eCO₂ / TVOC 직접 출력
- 두 센서를 조합하면 정성적/정량적 공기질 분석 가능
- 장기 사용 시 히터 소자 노화 및 드리프트 발생 → 정기 보정 필요

------

### 주의사항

- MQ-135는 예열 시간 후 안정화되어야 정확한 값을 출력한다.
- CCS811은 지속적인 측정 시 내부 온도 상승으로 값이 변동될 수 있음.
- 센서 출력은 절대적인 측정보다는 상대적 경향 분석에 적합하다.
- 측정 데이터를 저장하거나 BLE/UART로 전송할 때, 평균값 필터링 및 시간 스탬프 처리가 유용하다.

## 17.7 인체 감지 센서 (PIR HC-SR501)

PIR(Passive Infrared) 센서는 인체가 방출하는 적외선(IR)의 변화량을 감지하여 동작을 판단하는 센서이다.
 HC-SR501은 대표적인 PIR 센서 모듈로, 인체의 움직임이 감지되면 디지털 신호(High)를 출력한다.
 이 장에서는 HC-SR501의 동작 원리, 하드웨어 연결, CubeIDE를 통한 HAL 기반 코드 구현, 감도 및 지연 시간 조정, 그리고 FreeRTOS 환경에서의 활용 방법을 다룬다.

------

### 동작 원리

- PIR 센서는 **Pyroelectric Infrared Sensor**를 이용해 주변의 적외선 변화량을 감지한다.
- 사람이나 동물의 움직임에 따라 적외선 패턴이 변화하면 내부 증폭회로가 이를 감지하여 디지털 출력을 생성한다.
- **HC-SR501**은 렌즈, 비교기, 증폭 회로, 제어 칩을 포함한 모듈 형태로 제공된다.
- 감지 결과는 High/Low로 출력되며, MCU의 GPIO 입력으로 처리한다.

------

### 주요 사양

| 항목         | 값                                                       |
| ------------ | -------------------------------------------------------- |
| 동작 전압    | 4.5V ~ 20V (일반적으로 5V 사용)                          |
| 감지 거리    | 약 3 ~ 7 m (렌즈 조정 가능)                              |
| 감지 각도    | 약 120°                                                  |
| 출력 형태    | 디지털 (High = 감지, Low = 비감지)                       |
| 출력 핀 전압 | High ≈ 3.3V                                              |
| 트리거 모드  | 반복(Repeatable) / 비반복(Non-repeatable) 모드 선택 가능 |
| Warm-up 시간 | 약 30초 (초기 안정화 필요)                               |

------

### 하드웨어 연결

- **VCC** → 5V
- **OUT** → STM32 GPIO 입력 핀 (예: `PA1`)
- **GND** → GND
- 점퍼 설정:
  - **L 모드 (Non-repeatable)** → 감지 후 일정 시간 Low
  - **H 모드 (Repeatable)** → 감지 지속 시 High 유지
- 가변 저항 2개:
  - **SENS** → 감도 조절 (거리 조정)
  - **TIME** → 출력 유지 시간 조절 (약 0.5초~300초)

------

### HAL 기반 단일 감지 코드 예시

```
#include "main.h"

#define PIR_PIN GPIO_PIN_1
#define PIR_PORT GPIOA

void PIR_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOA_CLK_ENABLE();

    GPIO_InitStruct.Pin = PIR_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(PIR_PORT, &GPIO_InitStruct);
}

void PIR_Check(void)
{
    if (HAL_GPIO_ReadPin(PIR_PORT, PIR_PIN) == GPIO_PIN_SET)
    {
        printf("Motion Detected!\r\n");
    }
    else
    {
        printf("No Motion\r\n");
    }
}
```

- 단순 디지털 입력 방식으로 동작하며, ADC나 I²C 설정이 필요 없다.
- 노이즈에 의해 간헐적 False Trigger가 발생할 수 있으므로, 소프트웨어 디바운싱이나 평균화 처리가 유용하다.

------

### 인터럽트 기반 감지 예시

```
void PIR_InterruptInit(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_AFIO_CLK_ENABLE();

    GPIO_InitStruct.Pin = PIR_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(PIR_PORT, &GPIO_InitStruct);

    HAL_NVIC_SetPriority(EXTI1_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
}

void EXTI1_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(PIR_PIN);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == PIR_PIN)
    {
        printf("PIR Interrupt: Motion Detected!\r\n");
    }
}
```

- Rising Edge를 기준으로 인터럽트를 발생시켜 실시간으로 인체 감지 가능.
- 필요에 따라 Falling Edge 또는 Rising-Falling 모두 감지하도록 설정할 수 있다.
- 감지 이벤트 발생 시 LED 점등, 부저 동작, UART/BLE 알림 송신 등으로 연계할 수 있다.

------

### FreeRTOS 기반 태스크 예시

```
void vPIRTask(void *argument)
{
    for (;;)
    {
        if (HAL_GPIO_ReadPin(PIR_PORT, PIR_PIN) == GPIO_PIN_SET)
        {
            printf("Motion Detected\r\n");
            vTaskDelay(pdMS_TO_TICKS(5000)); // 감지 후 5초 대기
        }
        else
        {
            vTaskDelay(pdMS_TO_TICKS(500)); // 주기적 검사
        }
    }
}
```

- FreeRTOS에서는 인터럽트 대신 주기적 감시(Task polling) 방식도 자주 사용한다.
- 이벤트 발생 시 큐(Queue)를 통해 다른 태스크(예: 경보, 로그 저장 등)로 메시지를 전달할 수 있다.

------

### 출력 필터링 및 안정화 처리

- PIR 센서는 환경(온도, 조명, 전원 노이즈)에 따라 감도 편차가 크므로 다음과 같은 방법을 사용한다.
  - **Warm-up 후 사용 (약 30초 이상)**
  - **소프트웨어 필터링 (N회 연속 감지 시 유효 처리)**
  - **디바운싱 타이머 사용**
  - **Shielding 처리** : 태양광, 히터 등 적외선 간섭 최소화

```
uint8_t PIR_DetectedStable(void)
{
    static uint8_t detect_count = 0;
    if (HAL_GPIO_ReadPin(PIR_PORT, PIR_PIN) == GPIO_PIN_SET)
    {
        detect_count++;
        if (detect_count > 3) return 1;
    }
    else
    {
        detect_count = 0;
    }
    return 0;
}
```

------

### 응용 예시

- 인체 감지 자동 조명 시스템
- 보안 감시 및 경보 시스템
- 전력 절약형 IoT 장치 (Sleep → Wake on Motion)
- 스마트 홈 자동화 (조명, 에어컨, 팬 제어 등)

------

### 저전력 동작과의 연계

- PIR 센서는 별도의 동작 전류가 크지 않으므로, **STM32의 Sleep/Stop 모드와 연계**할 수 있다.
- EXTI 인터럽트를 이용해 인체 감지 시 MCU를 깨우는 구조로 설계 가능하다.

```
void Enter_StopMode(void)
{
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
}
```

- MCU가 대기 상태일 때 PIR 센서 출력이 High로 전환되면 EXTI 신호로 즉시 복귀 가능.
- 이를 통해 배터리 기반 시스템의 소비 전력을 크게 줄일 수 있다.

------

### 요약

- **HC-SR501**은 간단한 하드웨어와 디지털 출력만으로 인체 감지 가능.
- 인터럽트 기반 감지 및 FreeRTOS 태스크 모두 구현 용이.
- Warm-up, 노이즈, 감도 조정 등 실제 환경 보정이 필요.
- Sleep/Stop 모드와 연계하면 저전력 IoT 시스템에서 매우 유용하게 사용된다.

## 17.8 사운드 / 진동 감지 센서 (KY-037, SW-420)

사운드 센서(KY-037)와 진동 센서(SW-420)는 외부 환경의 물리적 변화를 감지하여 디지털 또는 아날로그 신호로 MCU에 전달하는 센서이다.
 KY-037은 마이크로폰을 이용하여 음압(소리 세기)을 감지하고, SW-420은 진동이나 충격을 검출하는 스위치형 센서이다.
 본 절에서는 두 센서의 원리, 하드웨어 연결, HAL 코드 구현, 임계값 설정, FreeRTOS 응용 및 신호 안정화 처리 방안을 다룬다.

------

### 사운드 센서 (KY-037) 개요

- KY-037은 콘덴서 마이크와 OP-AMP를 내장하여 음성 신호를 증폭한 후 **아날로그 출력(A0)**과 **디지털 출력(D0)**을 제공한다.
- 소리 세기에 따라 전압이 변하며, 디지털 출력은 조정 가능한 임계값 이상일 때 High를 출력한다.
- 감도는 모듈의 가변 저항(Potentiometer)으로 조절 가능하다.

------

### KY-037 주요 사양

| 항목        | 값                                       |
| ----------- | ---------------------------------------- |
| 동작 전압   | 3.3V ~ 5V                                |
| 출력 방식   | 아날로그(음압 크기), 디지털(임계값 초과) |
| 출력 전압   | 0 ~ 3.3V (ADC 입력 가능)                 |
| 감지 주파수 | 약 20Hz ~ 20kHz                          |
| 응답 속도   | 수 ms 단위                               |

------

### KY-037 하드웨어 연결

- **VCC** → 3.3V
- **GND** → GND
- **A0** → STM32 ADC 입력 핀 (예: `PA0`)
- **D0** → STM32 GPIO 입력 핀 (예: `PA1`)

------

### KY-037 ADC 측정 예시

```
uint16_t Read_SoundLevel(void)
{
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint16_t adcValue = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    return adcValue;
}
```

- ADC 값을 기반으로 일정 임계값을 초과할 경우 소리를 감지했다고 판단한다.
- 실험적으로 주변 소음 환경에 맞게 기준값(`THRESHOLD`)을 설정한다.

```
#define SOUND_THRESHOLD 2000

void Check_Sound(void)
{
    uint16_t level = Read_SoundLevel();
    if (level > SOUND_THRESHOLD)
        printf("Sound Detected! (ADC: %d)\r\n", level);
}
```

------

### KY-037 디지털 출력 감지 (D0)

```
#define SOUND_PIN GPIO_PIN_1
#define SOUND_PORT GPIOA

void Sound_DigitalInit(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOA_CLK_ENABLE();

    GPIO_InitStruct.Pin = SOUND_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(SOUND_PORT, &GPIO_InitStruct);
}

void Check_SoundDigital(void)
{
    if (HAL_GPIO_ReadPin(SOUND_PORT, SOUND_PIN) == GPIO_PIN_SET)
        printf("Loud Sound Detected!\r\n");
}
```

- 단순한 박수, 충격음 등 짧은 펄스에 빠르게 반응.
- LED 점등, 이벤트 트리거 등에 적합하다.

------

### 진동 센서 (SW-420) 개요

- SW-420은 내부 스프링과 금속 접촉부를 이용해 진동이나 충격 발생 시 회로가 순간적으로 닫히는 구조를 가진다.
- 감지 신호는 디지털 출력으로 제공되며, **Low → High 변화**로 진동 발생을 인식한다.
- OP-AMP와 비교기를 포함하여 감도 조절이 가능하다.

------

### SW-420 주요 사양

| 항목      | 값                           |
| --------- | ---------------------------- |
| 동작 전압 | 3.3V ~ 5V                    |
| 출력 형태 | 디지털 High/Low              |
| 감도 조절 | Potentiometer (보드 내장)    |
| 감지 방식 | 진동 → 접점 폐쇄 → 출력 High |
| 응답 속도 | 약 0.1초 이내                |

------

### SW-420 하드웨어 연결

- **VCC** → 3.3V
- **GND** → GND
- **DO** → STM32 GPIO 입력 핀 (예: `PB1`)

------

### SW-420 디지털 감지 예시

```
#define VIB_PIN GPIO_PIN_1
#define VIB_PORT GPIOB

void Vibration_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStruct.Pin = VIB_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VIB_PORT, &GPIO_InitStruct);
}

void Vibration_Check(void)
{
    if (HAL_GPIO_ReadPin(VIB_PORT, VIB_PIN) == GPIO_PIN_SET)
        printf("Vibration Detected!\r\n");
}
```

------

### 인터럽트 기반 진동 감지

```
void Vibration_InterruptInit(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStruct.Pin = VIB_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VIB_PORT, &GPIO_InitStruct);

    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 0);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
}

void EXTI1_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(VIB_PIN);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == VIB_PIN)
        printf("Vibration Event!\r\n");
}
```

- 외부 인터럽트를 이용하면 MCU가 저전력 상태에서도 진동 이벤트에 즉시 반응 가능하다.
- 필터링 회로가 없을 경우 짧은 노이즈에 의한 다중 트리거 발생 가능 → 디바운싱 필요.

------

### 디바운싱 및 필터링

진동 감지 시 노이즈에 의해 다중 이벤트가 발생할 수 있으므로, 소프트웨어 필터링을 통해 안정화한다.

```
uint8_t Vibration_StableDetect(void)
{
    static uint8_t cnt = 0;
    if (HAL_GPIO_ReadPin(VIB_PORT, VIB_PIN) == GPIO_PIN_SET)
    {
        cnt++;
        if (cnt > 2) return 1;
    }
    else cnt = 0;
    return 0;
}
```

- 일정 횟수 연속 감지 시에만 유효 이벤트로 판단.
- FreeRTOS에서는 이벤트 플래그(EventGroup)를 활용하여 멀티 태스크 간 진동 상태를 공유할 수 있다.

------

### FreeRTOS 기반 사운드 / 진동 모니터 태스크 예시

```
void vSensorMonitorTask(void *argument)
{
    for (;;)
    {
        uint16_t sound = Read_SoundLevel();
        uint8_t vib = HAL_GPIO_ReadPin(VIB_PORT, VIB_PIN);

        if (sound > SOUND_THRESHOLD)
            printf("[ALERT] Sound detected: %d\r\n", sound);

        if (vib == GPIO_PIN_SET)
            printf("[ALERT] Vibration detected\r\n");

        vTaskDelay(pdMS_TO_TICKS(200));
    }
}
```

- 일정 주기마다 센서 값을 읽고 이벤트를 출력.
- 이벤트 발생 시 BLE/UART 송신, 로그 저장, LED/부저 알림 등으로 확장 가능.

------

### 실습 및 응용 예제

- **사운드 감지 자동 조명 시스템**: 박수 소리를 감지하여 조명 ON/OFF 제어
- **진동 기반 경보 시스템**: 외부 충격이나 문 개폐 감지 시 경보 출력
- **기계 상태 모니터링**: 모터나 펌프의 진동 이상 감지
- **보안 시스템**: 소리 및 진동 이중 트리거를 통한 오경보 최소화

------

### 주의사항

- KY-037은 외부 전자 노이즈와 전원 간섭에 민감하므로, GND 공유 및 ADC 필터링(커패시터 병렬)이 필요하다.
- SW-420은 기계식 접점 구조이므로 충격 후 반동에 따른 여러 신호가 발생할 수 있다.
- 두 센서 모두 **디바운싱, 평균 필터, 임계값 보정** 과정을 통해 오동작을 줄일 수 있다.
- 실제 응용에서는 **PIR + 사운드 + 진동 센서**를 결합하여 인체 감지나 이상 상황 감시의 신뢰성을 높인다.

## 17.9 무선 통신 모듈 (HM-10, ESP8266, NEO-6M)

무선 통신 모듈은 외부 장치와 데이터를 송수신하기 위한 인터페이스 장치로, MCU의 UART 또는 SPI를 통해 제어된다.
 본 절에서는 대표적인 세 가지 모듈 — **HM-10 (BLE)**, **ESP8266 (Wi-Fi)**, **NEO-6M (GPS)** — 의 구조, 통신 방식, 초기 설정, 펌웨어 제어, HAL 코드 예제, 및 FreeRTOS 기반 통신 설계 방안을 다룬다.

------

### HM-10 BLE 모듈

HM-10은 BLE 4.0 기반의 저전력 Bluetooth 모듈로, 스마트폰 또는 BLE 디바이스와 UART를 통해 데이터 교환을 수행한다.
 AT 명령어를 통해 이름, Baudrate, 연결 모드 등을 설정하며, BLE Peripheral 역할로 주로 사용된다.

------

### HM-10 주요 사양

| 항목       | 내용                          |
| ---------- | ----------------------------- |
| 칩셋       | TI CC2541                     |
| 인터페이스 | UART (TX, RX)                 |
| 동작 전압  | 3.3V                          |
| 통신 속도  | 기본 9600bps (AT로 변경 가능) |
| 동작 모드  | Master / Slave (기본 Slave)   |
| BLE 버전   | Bluetooth 4.0 (BLE)           |

------

### HM-10 기본 연결

| 핀   | 연결 대상               |
| ---- | ----------------------- |
| VCC  | 3.3V                    |
| GND  | GND                     |
| TX   | STM32 RX (예: `PA10`)   |
| RX   | STM32 TX (예: `PA9`)    |
| EN   | 3.3V (활성 상태 유지용) |

------

### HM-10 UART 초기화 및 송수신

```
void HM10_SendString(char *str)
{
    HAL_UART_Transmit(&huart1, (uint8_t *)str, strlen(str), 100);
}

void HM10_ReadResponse(void)
{
    uint8_t rxBuf[64];
    HAL_UART_Receive(&huart1, rxBuf, sizeof(rxBuf), 1000);
    printf("BLE: %s\r\n", rxBuf);
}
```

------

### HM-10 AT 명령어 예시

| 명령                | 설명                      |
| ------------------- | ------------------------- |
| `AT`                | 연결 테스트 (응답: OK)    |
| `AT+NAME?`          | 현재 장치 이름 조회       |
| `AT+NAME=STM32_BLE` | 장치 이름 변경            |
| `AT+BAUD8`          | Baudrate 변경 (115200bps) |
| `AT+ADDR?`          | MAC 주소 확인             |
| `AT+ROLE0`          | Slave 모드 설정           |

------

### BLE 데이터 송수신 흐름

1. 스마트폰 BLE 앱(예: nRF Connect)에서 HM-10 검색 및 연결
2. BLE 연결 완료 시 HM-10 LED 점멸 → 점등 상태로 변경
3. STM32 → BLE → 스마트폰으로 문자열 전송
4. 스마트폰에서 입력 시 HM-10 → STM32로 수신

------

### HM-10 BLE 예제 코드

```
void BLE_Task(void *argument)
{
    char msg[] = "BLE Connected!\r\n";
    for (;;)
    {
        HM10_SendString(msg);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

------

### ESP8266 Wi-Fi 모듈

ESP8266은 UART 기반의 Wi-Fi 통신 모듈로, TCP/IP 스택을 내장하고 있다.
 AT 명령어로 Wi-Fi 연결, 서버 통신, MQTT, HTTP 요청 등을 수행할 수 있다.

------

### ESP8266 주요 사양

| 항목          | 내용                     |
| ------------- | ------------------------ |
| 칩셋          | ESP8266EX                |
| 인터페이스    | UART, SPI                |
| 동작 전압     | 3.3V (500mA 이상 필요)   |
| 기본 Baudrate | 115200bps                |
| 펌웨어        | AT Command Firmware      |
| 동작 모드     | Station / SoftAP / Mixed |

------

### ESP8266 기본 연결

| 핀         | 연결 대상              |
| ---------- | ---------------------- |
| VCC        | 3.3V                   |
| GND        | GND                    |
| TX         | STM32 RX               |
| RX         | STM32 TX               |
| CH_PD / EN | 3.3V                   |
| RST        | 리셋 제어 핀 (필요 시) |

> ESP8266은 전류 소모가 크므로 LDO 또는 별도의 전원 레귤레이터를 사용하는 것이 권장된다.

------

### ESP8266 AT 명령어 예시

| 명령                                    | 설명                      |
| --------------------------------------- | ------------------------- |
| `AT`                                    | 응답 테스트               |
| `AT+RST`                                | 모듈 리셋                 |
| `AT+CWMODE=1`                           | Station 모드 설정         |
| `AT+CWJAP="SSID","PWD"`                 | Wi-Fi 접속                |
| `AT+CIFSR`                              | IP 주소 조회              |
| `AT+CIPSTART="TCP","192.168.0.10",8080` | TCP 서버 연결             |
| `AT+CIPSEND=20`                         | 20바이트 데이터 전송 시작 |
| `AT+CIPCLOSE`                           | 연결 종료                 |

------

### ESP8266 UART 송수신 코드

```
void ESP8266_Send(char *cmd)
{
    HAL_UART_Transmit(&huart2, (uint8_t *)cmd, strlen(cmd), 100);
    HAL_UART_Transmit(&huart2, (uint8_t *)"\r\n", 2, 100);
}

void ESP8266_ReadResponse(void)
{
    uint8_t buf[256];
    HAL_UART_Receive(&huart2, buf, sizeof(buf), 1000);
    printf("Wi-Fi: %s\r\n", buf);
}
```

------

### Wi-Fi 통신 예제

```
void WiFi_Connect(void)
{
    ESP8266_Send("AT");
    ESP8266_Send("AT+CWMODE=1");
    ESP8266_Send("AT+CWJAP=\"MyWiFi\",\"12345678\"");
    ESP8266_ReadResponse();
}
```

------

### FreeRTOS 기반 Wi-Fi Task 예시

```
void vWiFiTask(void *argument)
{
    WiFi_Connect();

    for (;;)
    {
        ESP8266_Send("AT+CIPSTART=\"TCP\",\"192.168.0.50\",8080");
        ESP8266_Send("AT+CIPSEND=12");
        ESP8266_Send("Hello Server!");
        ESP8266_ReadResponse();
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}
```

------

### NEO-6M GPS 모듈

NEO-6M은 UART 기반의 GPS 수신 모듈로, 위성으로부터 수신된 위치, 시간, 속도 등의 정보를 NMEA 프로토콜 형식으로 전달한다.
 STM32는 UART 수신을 통해 이 데이터를 파싱하여 실시간 위치 정보를 획득한다.

------

### NEO-6M 주요 사양

| 항목          | 내용               |
| ------------- | ------------------ |
| 인터페이스    | UART               |
| 동작 전압     | 3.3V ~ 5V          |
| 기본 Baudrate | 9600bps            |
| 출력 형식     | NMEA (GGA, RMC 등) |
| 정확도        | ±2.5m              |
| Cold Start    | 약 30초            |
| Warm Start    | 약 1초             |

------

### NEO-6M 기본 연결

| 핀   | 연결 대상                     |
| ---- | ----------------------------- |
| VCC  | 3.3V                          |
| GND  | GND                           |
| TX   | STM32 RX                      |
| RX   | STM32 TX                      |
| PPS  | GPS 동기화 신호 (선택적 사용) |

------

### NMEA 데이터 예시

```
$GPGGA,123519,3723.2475,N,12158.3416,W,1,08,0.9,545.4,M,46.9,M,,*47
$GPRMC,123520,A,3723.2475,N,12158.3416,W,000.5,054.7,191194,020.3,E*68
```

- `$GPGGA`: 위치 및 위성 상태 정보
- `$GPRMC`: 시간, 위도, 경도, 속도 등 주요 항목

------

### GPS 데이터 수신 예제

```
void GPS_Read(void)
{
    uint8_t rx;
    static char buffer[128];
    static uint8_t idx = 0;

    if (HAL_UART_Receive(&huart3, &rx, 1, 100) == HAL_OK)
    {
        if (rx == '\n')
        {
            buffer[idx] = '\0';
            printf("GPS: %s\r\n", buffer);
            idx = 0;
        }
        else if (idx < sizeof(buffer) - 1)
        {
            buffer[idx++] = rx;
        }
    }
}
```

------

### GPS 데이터 파싱 (간단한 예)

```
void GPS_ParseGGA(char *nmea)
{
    if (strstr(nmea, "$GPGGA") != NULL)
    {
        char *token = strtok(nmea, ",");
        int field = 0;
        while (token != NULL)
        {
            if (field == 2) printf("Latitude: %s\r\n", token);
            if (field == 4) printf("Longitude: %s\r\n", token);
            token = strtok(NULL, ",");
            field++;
        }
    }
}
```

------

### FreeRTOS 기반 GPS Task 예시

```
void vGPSTask(void *argument)
{
    for (;;)
    {
        GPS_Read();
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}
```

------

### 통합 실습 예제

- BLE (HM-10) → 스마트폰 BLE 앱으로 데이터 전송
- Wi-Fi (ESP8266) → MQTT 또는 HTTP 서버 전송
- GPS (NEO-6M) → 현재 좌표를 BLE 및 Wi-Fi를 통해 송신

------

### 통합 데이터 전송 구조

```
[Sensor Data] → [STM32] → [BLE/Wi-Fi] → [App or Server]
                            ↑
                        [GPS 위치정보]
```

- 센서 데이터 + GPS 좌표를 주기적으로 BLE 또는 Wi-Fi를 통해 전송
- FreeRTOS Task 간 Queue를 사용하여 BLE/Wi-Fi 송신 스레드로 통합 관리

------

### 주의사항

- HM-10과 ESP8266은 동일 UART를 공유할 수 없으므로 각각 다른 UART 채널 사용 필요.
- NEO-6M은 초기 수신 시 GPS Lock 시간이 필요하며, 실내에서는 신호 수신이 어렵다.
- ESP8266은 전류 소모가 높아 전원 불안정 시 재부팅이 발생할 수 있으므로 100µF 이상 캐패시터 추가 권장.
- BLE와 Wi-Fi를 동시에 운용할 경우 RTOS 기반의 스케줄링 및 DMA/UART 우선순위 조정이 중요하다.

## 17.10 디스플레이 (OLED SSD1306, LCD1602, ST7735 TFT)

임베디드 시스템에서 디스플레이는 시스템 상태를 시각적으로 표시하거나 센서 데이터를 사용자에게 전달하는 핵심 인터페이스 역할을 한다.
 본 절에서는 STM32 환경에서 널리 사용되는 **OLED SSD1306 (I²C/SPI)**, **LCD1602 (HD44780 기반, 병렬/ I²C 변환형)**, **ST7735 TFT (SPI 기반 컬러 디스플레이)** 를 중심으로 하드웨어 연결, 초기화 절차, 표시 방식, 폰트 렌더링, 그리고 HAL 기반 제어 코드를 다룬다.

------

### OLED SSD1306 (128×32 / 128×64)

SSD1306은 소형 OLED 모듈로, I²C 또는 SPI 인터페이스를 통해 STM32와 직접 통신한다.
 자체 발광 방식으로 백라이트가 필요 없으며, 낮은 전력 소비와 높은 명암비를 가진다.

#### 주요 특징

- 해상도: 128×32 또는 128×64
- 인터페이스: I²C (기본 주소 0x3C) 또는 SPI
- 전원: 3.3V ~ 5V
- 라이브러리: `Adafruit_SSD1306`, `u8g2`, `ssd1306.c` 등 사용 가능

#### I²C 하드웨어 연결

- **VCC** → 3.3V
- **GND** → GND
- **SCL** → `PB8` (I²C1_SCL)
- **SDA** → `PB9` (I²C1_SDA)

#### 초기화 및 텍스트 표시 예제

```
#include "ssd1306.h"
#include "fonts.h"

void OLED_Init_Display()
{
    ssd1306_Init();
    ssd1306_Fill(Black);
    ssd1306_SetCursor(0, 0);
    ssd1306_WriteString("STM32 OLED Test", Font_7x10, White);
    ssd1306_UpdateScreen();
}
```

#### 주요 제어 함수

- `ssd1306_Fill(color)` → 전체 화면 채움
- `ssd1306_SetCursor(x, y)` → 텍스트 시작 위치 설정
- `ssd1306_WriteString(text, font, color)` → 문자열 출력
- `ssd1306_DrawPixel(x, y, color)` → 단일 픽셀 제어
- `ssd1306_UpdateScreen()` → 버퍼 내용을 디스플레이에 반영

#### FreeRTOS 연동 예시

```
void vOledTask(void *argument)
{
    ssd1306_Init();
    for (;;)
    {
        ssd1306_Fill(Black);
        ssd1306_SetCursor(0, 0);
        ssd1306_WriteString("Temp:", Font_7x10, White);
        ssd1306_SetCursor(60, 0);
        char buf[10];
        sprintf(buf, "%.1fC", tempValue);
        ssd1306_WriteString(buf, Font_7x10, White);
        ssd1306_UpdateScreen();
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

------

### LCD1602 (HD44780 기반)

LCD1602는 가장 보편적인 문자 디스플레이로, 2행 × 16자 구조를 가진다.
 기본적으로 4비트 병렬 인터페이스를 사용하지만, I²C 변환 모듈(PCF8574)을 이용하면 I²C로 제어 가능하다.

#### 주요 특징

- 해상도: 16×2 문자
- 인터페이스: 4-bit 병렬 / I²C (PCF8574)
- 전원: 5V (3.3V 논리 호환)
- 백라이트 및 명도 조절 가능

#### I²C 연결 (PCF8574 사용 시)

- **VCC** → 5V
- **GND** → GND
- **SCL** → `PB8`
- **SDA** → `PB9`
- 주소: 0x27 또는 0x3F

#### I²C 제어 예제

```
#include "i2c-lcd.h"

void LCD_Init_Display()
{
    lcd_init();
    lcd_send_string("STM32 LCD1602");
    lcd_put_cur(1, 0);
    lcd_send_string("Hello World!");
}
```

#### 주요 함수

- `lcd_init()` → 초기화
- `lcd_clear()` → 전체 지움
- `lcd_put_cur(row, col)` → 커서 이동
- `lcd_send_string(text)` → 문자열 출력

------

### ST7735 TFT (SPI 기반, 1.44~1.8인치)

ST7735는 SPI 기반 컬러 TFT 디스플레이로, 텍스트와 그래픽을 모두 표시할 수 있다.
 간단한 GUI, 센서 그래프, 아이콘 표시 등에 적합하다.

#### 주요 특징

- 해상도: 128×128 또는 160×128
- 인터페이스: SPI
- 전원: 3.3V (5V 비호환)
- 라이브러리: `Adafruit_ST7735`, `TFT_eSPI`, 또는 HAL용 `st7735.c`

#### SPI 하드웨어 연결

- **VCC** → 3.3V
- **GND** → GND
- **SCL (CLK)** → `PA5` (SPI1_SCK)
- **SDA (MOSI)** → `PA7` (SPI1_MOSI)
- **RES** → `PA1`
- **DC** → `PA2`
- **CS** → `PA4`

#### 초기화 및 출력 예제

```
#include "st7735.h"
#include "fonts.h"

void TFT_Init_Display()
{
    ST7735_Init();
    ST7735_FillScreen(ST7735_BLACK);
    ST7735_WriteString(10, 10, "STM32 TFT Test", Font_11x18, ST7735_WHITE, ST7735_BLACK);
}
```

#### 그래픽 출력

- `ST7735_DrawPixel(x, y, color)`
- `ST7735_DrawLine(x1, y1, x2, y2, color)`
- `ST7735_FillRectangle(x, y, w, h, color)`
- `ST7735_DrawImage()`
- `ST7735_WriteString(x, y, text, font, fg, bg)`

------

### 세 디스플레이 비교 요약

| 항목       | OLED SSD1306     | LCD1602     | ST7735 TFT            |
| ---------- | ---------------- | ----------- | --------------------- |
| 인터페이스 | I²C / SPI        | I²C / 4-bit | SPI                   |
| 표시 형식  | 모노크롬 그래픽  | 문자 전용   | 컬러 그래픽           |
| 해상도     | 128×64           | 16×2 문자   | 128×128               |
| 전압       | 3.3V~5V          | 5V          | 3.3V                  |
| 장점       | 고명암비, 저전력 | 단순, 저가  | 그래픽 표시 가능      |
| 단점       | 작은 화면        | 문자만 표시 | 전력 소비 상대적 증가 |

------

### 통합 예시: 센서 데이터 시각화

```
// 예: BME280 온습도 + CCS811 공기질 표시 (SSD1306)
ssd1306_Fill(Black);
ssd1306_SetCursor(0, 0);
ssd1306_WriteString("Temp: 24.3C", Font_7x10, White);
ssd1306_SetCursor(0, 12);
ssd1306_WriteString("Humi: 48%", Font_7x10, White);
ssd1306_SetCursor(0, 24);
ssd1306_WriteString("CO2: 412ppm", Font_7x10, White);
ssd1306_UpdateScreen();
```

- 실시간 센서 데이터를 시각적으로 표현하여 디버깅 및 현장 테스트에 유용하다.
- FreeRTOS 환경에서는 표시 주기를 별도의 Task로 관리하여 데이터 수집과 분리할 수 있다.

------

### 주의사항

- OLED는 정적 화면을 장시간 표시 시 번인 현상이 발생할 수 있다.
- ST7735는 5V 입력 시 손상될 수 있으므로 반드시 3.3V만 사용한다.
- LCD1602의 I²C 주소는 모듈 제조사마다 다르므로 스캔 도구(`i2cdetect`)로 확인한다.
- 각 디스플레이의 업데이트 주기를 적절히 제한하여 CPU 부하를 줄인다.

## 17.11 입력 장치 (Keypad, 조이스틱, 로터리 인코더)

입력 장치는 사용자가 시스템과 상호작용할 수 있도록 하는 하드웨어 인터페이스이며, 마이크로컨트롤러 기반 시스템에서는 버튼, 키패드, 조이스틱, 로터리 인코더 등이 주로 사용된다.
 본 절에서는 **4×4 Keypad**, **Analog 조이스틱**, **Rotary Encoder (A/B Phase, SW)** 의 동작 원리, 하드웨어 연결, 신호 처리 알고리즘, HAL 기반 코드 구현, FreeRTOS 연동 방법을 상세히 다룬다.

------

### Keypad (4×4 매트릭스 키패드)

#### 동작 원리

Keypad는 행(Row)과 열(Column)의 교차점에 스위치를 배치하여 구성된다.
 STM32에서는 행/열 핀을 번갈아 설정하며, 눌린 위치를 디지털 스캔 방식으로 판별한다.

- 예: 4행 × 4열 → 16개의 키 입력 가능
- 스캔 주기를 수 ms 단위로 설정해 폴링 방식으로 처리
- 키 채터링 방지를 위해 소프트웨어 디바운싱 적용 필요

#### 하드웨어 연결 예시

| 기능  | STM32 핀  |
| ----- | --------- |
| R1~R4 | `PA0~PA3` |
| C1~C4 | `PA4~PA7` |

#### 키 매핑 예시

|      | C1   | C2   | C3   | C4   |
| ---- | ---- | ---- | ---- | ---- |
| R1   | 1    | 2    | 3    | A    |
| R2   | 4    | 5    | 6    | B    |
| R3   | 7    | 8    | 9    | C    |
| R4   | *    | 0    | #    | D    |

#### 키 스캔 코드 예제

```
uint8_t Keypad_Scan(void)
{
    for (int row = 0; row < 4; row++)
    {
        HAL_GPIO_WritePin(GPIOA, (0x0F << 4), GPIO_PIN_SET); // 모든 열 High
        HAL_GPIO_WritePin(GPIOA, (1 << row), GPIO_PIN_RESET); // 해당 행만 Low

        for (int col = 0; col < 4; col++)
        {
            if (!HAL_GPIO_ReadPin(GPIOA, (1 << (col + 4))))
            {
                HAL_Delay(20); // 디바운스
                if (!HAL_GPIO_ReadPin(GPIOA, (1 << (col + 4))))
                    return (row * 4 + col); // 키 인덱스 반환
            }
        }
    }
    return 0xFF; // no key
}
```

#### 디바운싱 및 큐 전송 (FreeRTOS)

```
void vKeypadTask(void *argument)
{
    for (;;)
    {
        uint8_t key = Keypad_Scan();
        if (key != 0xFF)
            xQueueSend(keyQueueHandle, &key, 0);
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}
```

------

### 조이스틱 (2축 아날로그 + 스위치)

#### 동작 원리

조이스틱은 내부에 2개의 포텐셔미터(X, Y 축)와 1개의 푸시 버튼으로 구성되어 있다.
 아날로그 전압을 ADC로 읽어 X/Y 방향을 감지하며, 중앙값(약 1.65V)을 기준으로 상하좌우를 구분한다.

#### 하드웨어 연결

| 기능 | STM32 핀          |
| ---- | ----------------- |
| VRx  | `PA0` (ADC_IN0)   |
| VRy  | `PA1` (ADC_IN1)   |
| SW   | `PA2` (GPIO 입력) |

#### ADC 기반 값 읽기

```
uint16_t joyX, joyY;

void Joystick_Read(void)
{
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    joyX = HAL_ADC_GetValue(&hadc1);

    HAL_ADC_Start(&hadc2);
    HAL_ADC_PollForConversion(&hadc2, HAL_MAX_DELAY);
    joyY = HAL_ADC_GetValue(&hadc2);
}
```

#### 방향 판정 예시

```
char* Joystick_Direction(void)
{
    if (joyX < 1000) return "LEFT";
    if (joyX > 3000) return "RIGHT";
    if (joyY < 1000) return "DOWN";
    if (joyY > 3000) return "UP";
    return "CENTER";
}
```

#### 실시간 조이스틱 태스크

```
void vJoystickTask(void *argument)
{
    for (;;)
    {
        Joystick_Read();
        printf("%s\r\n", Joystick_Direction());
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}
```

------

### 로터리 인코더 (Rotary Encoder)

#### 동작 원리

로터리 인코더는 **A, B 두 위상 신호(Quadrature Signal)** 를 이용하여 회전 방향과 단계를 검출한다.
 회전 시 A, B 신호의 위상 차에 따라 CW(시계방향) / CCW(반시계방향)를 구분할 수 있다.

#### 하드웨어 연결

| 기능 | STM32 핀            |
| ---- | ------------------- |
| A    | `PB6` (EXTI)        |
| B    | `PB7` (GPIO 입력)   |
| SW   | `PB8` (버튼 스위치) |

#### 타이머 엔코더 모드 설정

STM32는 하드웨어적으로 엔코더 입력을 처리할 수 있는 **Encoder Interface Mode** 를 제공한다.

```
TIM_HandleTypeDef htim3;

void Encoder_Init(void)
{
    htim3.Instance = TIM3;
    htim3.Init.Period = 65535;
    htim3.Init.Prescaler = 0;
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.EncoderMode = TIM_ENCODERMODE_TI12;
    HAL_TIM_Encoder_Init(&htim3, NULL);
    HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
}
```

#### 엔코더 값 읽기

```
int16_t Encoder_GetValue(void)
{
    return __HAL_TIM_GET_COUNTER(&htim3);
}
```

#### 회전 방향 및 이벤트 처리

```
int16_t lastValue = 0;

void vEncoderTask(void *argument)
{
    Encoder_Init();
    for (;;)
    {
        int16_t newValue = Encoder_GetValue();
        if (newValue != lastValue)
        {
            if (newValue > lastValue)
                printf("CW Rotation\r\n");
            else
                printf("CCW Rotation\r\n");
            lastValue = newValue;
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
```

------

### 입력 장치 통합 및 응용

- **Keypad** → 메뉴 선택, 비밀번호 입력
- **Joystick** → 커서 이동, 아날로그 제어
- **Encoder** → 메뉴 스크롤, 값 조정, UI 다이얼

#### 통합 예시

```
void vInputManagerTask(void *argument)
{
    for (;;)
    {
        uint8_t key;
        if (xQueueReceive(keyQueueHandle, &key, 0) == pdPASS)
            Menu_Select(key);

        Joystick_Read();
        Process_Joystick(Joystick_Direction());

        int16_t encoder = Encoder_GetValue();
        Adjust_Value(encoder);

        vTaskDelay(pdMS_TO_TICKS(50));
    }
}
```

------

### 주의사항

- 키패드의 스캔 주기는 너무 짧으면 디바운싱 문제를 야기할 수 있음.
- 조이스틱의 전원 잡음은 ADC 측정 오차를 유발할 수 있으므로 RC 필터를 추가하는 것이 좋다.
- 로터리 인코더는 기계적 바운스를 줄이기 위해 인터럽트 대신 하드웨어 인코더 모드를 활용하는 것이 바람직하다.
- 입력 이벤트는 **Queue 또는 EventGroup** 으로 관리하면 FreeRTOS 시스템에서 안정적인 병렬 처리가 가능하다.

## 17.12 액추에이터 (Servo, DC Motor, Relay, Buzzer)

액추에이터(Actuator)는 전기적 신호를 물리적 동작으로 변환하는 장치로, 임베디드 시스템에서 **출력 제어의 핵심 구성 요소**에 해당한다.
 본 절에서는 **서보모터, DC 모터, 릴레이, 버저** 의 구동 원리와 STM32에서의 제어 방법, PWM 및 GPIO 인터페이스, 하드웨어 드라이버 회로, 실시간 제어 구조를 상세히 다룬다.

------

### 서보모터 (Servo Motor)

#### 동작 원리

서보모터는 내부에 **DC 모터 + 기어 + 위치 피드백 회로(Potentiometer)** 로 구성되어 있으며, **PWM 신호의 펄스 폭(1~2ms)** 으로 각도를 제어한다.

- 1.0 ms → 0°
- 1.5 ms → 90°
- 2.0 ms → 180°

#### 하드웨어 연결 예시

| 핀       | 연결 대상    |
| -------- | ------------ |
| PWM 출력 | Servo Signal |
| VCC      | +5V          |
| GND      | GND          |

※ STM32는 3.3V 출력이므로, 5V Servo 사용 시 **레벨시프터 또는 드라이버 트랜지스터** 필요.

#### PWM 설정 예시 (TIM3_CH1, 50Hz)

```
htim3.Instance = TIM3;
htim3.Init.Prescaler = 71;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 19999; // 20ms 주기 (50Hz)
HAL_TIM_PWM_Init(&htim3);

TIM_OC_InitTypeDef sConfigOC = {0};
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 1500; // 1.5ms (중립 위치)
HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
```

#### 각도 제어 함수

```
void Servo_SetAngle(uint8_t angle)
{
    uint16_t pulse = 1000 + (angle * 1000) / 180; // 1~2ms 범위
    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);
}
```

------

### DC 모터 (DC Motor)

#### 동작 원리

DC 모터는 전압 또는 PWM 듀티비에 따라 회전 속도가 비례적으로 변하며, H-Bridge 회로를 통해 정·역방향 구동이 가능하다.

#### 드라이버 예시 (L298N, TB6612FNG)

| STM32 핀 | L298N 핀  | 설명      |
| -------- | --------- | --------- |
| PA0      | IN1       | 방향 제어 |
| PA1      | IN2       | 방향 제어 |
| PA2      | ENA (PWM) | 속도 제어 |
| +12V     | VCC       | 모터 전원 |

#### PWM 기반 속도 제어

```
void Motor_SetSpeed(int16_t speed)
{
    if (speed >= 0)
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
    }
    else
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET);
        speed = -speed;
    }
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, speed);
}
```

#### FreeRTOS 제어 태스크

```
void vMotorTask(void *argument)
{
    for (;;)
    {
        int16_t cmd;
        if (xQueueReceive(motorQueueHandle, &cmd, portMAX_DELAY) == pdPASS)
            Motor_SetSpeed(cmd);
    }
}
```

------

### 릴레이 (Relay)

#### 동작 원리

릴레이는 전자석의 자기력을 이용하여 기계적 접점을 여닫는 스위치로, MCU의 GPIO 출력으로 **고전압/고전류 부하를 제어**할 수 있다.

#### 회로 구성

- 트랜지스터(NPN, 예: 2N2222)로 릴레이 코일 구동
- **역기전력 보호용 다이오드(1N4007)** 필수
- 외부 전원(VCC 5V, 12V)에 따라 코일 규격 선택

#### 제어 예제

```
#define RELAY_PIN GPIO_PIN_5
#define RELAY_PORT GPIOB

void Relay_On(void)
{
    HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_SET);
}

void Relay_Off(void)
{
    HAL_GPIO_WritePin(RELAY_PORT, RELAY_PIN, GPIO_PIN_RESET);
}
```

#### 상태 제어 태스크

```
void vRelayTask(void *argument)
{
    for (;;)
    {
        Relay_On();
        vTaskDelay(pdMS_TO_TICKS(2000));
        Relay_Off();
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}
```

------

### 버저 (Buzzer)

#### 동작 원리

버저는 소리를 발생시키는 출력 장치로, **수동형(Passive)** 과 **능동형(Active)** 두 종류가 있다.

- **능동형**: 전원 인가 시 일정 주파수로 자동 발진 (GPIO High/Low)
- **수동형**: PWM 주파수에 따라 음정 제어 가능

#### 수동형 버저 PWM 제어 예시

```
void Buzzer_PlayTone(uint16_t freq, uint16_t duration)
{
    uint32_t period = 1000000 / freq; // 주기 (μs)
    __HAL_TIM_SET_AUTORELOAD(&htim4, period - 1);
    __HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, period / 2);
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
    HAL_Delay(duration);
    HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_1);
}
```

#### 멜로디 시퀀스 예제

```
typedef struct {
    uint16_t freq;
    uint16_t duration;
} Tone;

Tone melody[] = {
    {262, 300}, {294, 300}, {330, 300}, {349, 300}, {392, 400}
};

void Buzzer_PlayMelody(void)
{
    for (int i = 0; i < sizeof(melody)/sizeof(Tone); i++)
        Buzzer_PlayTone(melody[i].freq, melody[i].duration);
}
```

------

### 통합 제어 및 응용 예시

#### Actuator Manager Task

```
void vActuatorTask(void *argument)
{
    for (;;)
    {
        // 서보 각도 조정
        Servo_SetAngle(90);
        vTaskDelay(pdMS_TO_TICKS(1000));
        Servo_SetAngle(0);

        // 모터 구동
        Motor_SetSpeed(800);
        vTaskDelay(pdMS_TO_TICKS(2000));
        Motor_SetSpeed(0);

        // 릴레이 스위칭
        Relay_On();
        vTaskDelay(pdMS_TO_TICKS(1000));
        Relay_Off();

        // 버저 알람
        Buzzer_PlayTone(1000, 300);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

------

### 하드웨어 주의사항

- 서보모터 및 DC 모터는 **별도의 전원(5V~12V)** 을 사용하고 GND를 공통으로 연결해야 한다.
- 릴레이 구동 시 **플라이백 다이오드** 를 반드시 추가해야 MCU가 보호된다.
- 버저의 PWM 주파수는 1~4kHz 사이가 일반적이며, 주파수에 따라 음색이 달라진다.
- FreeRTOS 환경에서 액추에이터를 제어할 때는 **큐 기반 비동기 명령 처리 구조**를 사용하는 것이 바람직하다.

------

### 종합 응용 시나리오

- **스마트 홈 시스템**: 릴레이로 조명 제어, 서보로 문 개폐, 버저로 알람 표시
- **로봇 제어**: DC 모터로 이동, 서보모터로 방향 전환, 버저로 상태 피드백
- **IoT 장비**: MQTT 명령 수신 → Actuator Manager Task에서 구동 신호 분기

이와 같이 STM32의 PWM, GPIO, Timer, FreeRTOS 기능을 결합하여 다양한 액추에이터를 안정적으로 제어할 수 있다.