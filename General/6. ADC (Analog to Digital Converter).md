# 6. ADC (Analog to Digital Converter)

## 6.1 ADC 원리 및 샘플링 속도

**ADC(Analog-to-Digital Converter)**는 아날로그 전압 신호를 디지털 값으로 변환하는 하드웨어 블록이다. STM32의 ADC는 SAR(Successive Approximation Register) 방식으로 동작하며, 전압을 샘플링 후 디지털 비트로 근사하여 변환 결과를 출력한다.

#### 1) ADC 변환 과정

1. **샘플링(Sampling)**: 입력 전압을 내부 샘플 홀드 회로(S/H: Sample & Hold)로 유지한다.
2. **근사(Approximation)**: SAR 로직이 내부 DAC를 통해 입력 전압을 점진적으로 비교하며 디지털 값을 찾아간다.
3. **변환(Conversion)**: N비트 해상도의 디지털 결과가 변환 레지스터(ADC_DR)에 저장된다.

#### 2) 해상도(Resolution)

- STM32 시리즈는 **6, 8, 10, 12, 14, 16비트** 해상도를 지원하며, 일반적으로 **12비트(0–4095)** 사용이 기본이다.
- 해상도가 높을수록 측정 정밀도가 높아지지만, 변환 시간과 연산량이 증가한다.

#### 3) 변환 속도(Conversion Time)

ADC 변환 시간은 다음 식으로 결정된다.
$$
T_{conv} = T_{sample} + (N_{bit} + 1) \times T_{ADCclock}
$$

- **T_sample**: 샘플링 시간 (ADC_SMPRx로 설정, 단위는 ADC 클록 사이클)
- **T_ADCclock**: ADC 클록 주기 (APB 클록 분주로 결정됨)
- **N_bit**: 변환 비트수

예를 들어, 12비트 ADC에서 샘플링 15클록, ADC 클록 12MHz라면,
$$
T_{conv} = (15 + 12 + 1) / 12\,MHz = 2.33\,µs
$$
즉, 약 429kSPS의 샘플 속도를 얻는다.

#### 4) 샘플링 속도에 영향을 주는 요인

- **ADC 클록 속도 (ADC Clock Prescaler)**
- **샘플링 시간 설정 (Sampling Time Register)**
- **DMA 사용 여부** (변환 후 CPU 개입 최소화)
- **연속 변환 모드 / 스캔 모드 설정**

#### 5) ADC 전압 기준 (Vref)

- 변환 결과는 입력전압 $V_{in}$과 기준전압 $V_{ref}$에 따라 비례한다.

$$
Digital = \frac{V_{in}}{V_{ref}} \times (2^{N} - 1)
$$

- 내부 기준전압(1.2V), 외부 VREF+, 또는 VDD를 참조전압으로 선택 가능하다.

#### 6) 전압 정확도 및 잡음

- 입력 임피던스가 높거나 샘플링 시간이 짧을 경우 오차가 커진다.
- 노이즈 감소를 위해 ADC 입력핀 근처에 RC 필터(저역통과 필터)를 추가하는 것이 일반적이다.

------

## 6.2 Single / Continuous / Scan 모드

STM32의 ADC는 여러 동작 모드를 제공하며, 단일 측정, 연속 변환, 멀티채널 스캔 등으로 구분된다.

#### 1) **Single Conversion Mode**

- 한 번의 변환 요청(소프트웨어 트리거나 하드웨어 트리거)으로 하나의 채널을 변환하고 정지한다.
- 변환 완료 시 EOC(End of Conversion) 플래그가 세트된다.
- 주로 간헐적인 측정, 센서값 주기적 갱신 등에 사용된다.

```
HAL_ADC_Start(&hadc1);
HAL_ADC_PollForConversion(&hadc1, 100);
uint32_t value = HAL_ADC_GetValue(&hadc1);
HAL_ADC_Stop(&hadc1);
```

#### 2) **Continuous Conversion Mode**

- 변환이 완료되면 자동으로 다음 변환을 연속 수행한다.
- EOC마다 DMA 또는 인터럽트로 데이터를 읽을 수 있다.
- CPU 개입 없이 ADC_DR → DMA로 자동 전송 가능.

```
ADC_HandleTypeDef hadc1;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
```

#### 3) **Scan Conversion Mode**

- 여러 채널을 순차적으로 변환하며, 각 채널 결과는 순서대로 저장된다.
- ADC_SQRx 레지스터를 통해 변환 순서 정의.
- DMA 연동 시 여러 센서 입력을 동시에 수집할 수 있다.

```
hadc1.Init.ScanConvMode = ENABLE;
hadc1.Init.NbrOfConversion = 3;
```

#### 4) **Discontinuous Mode**

- 스캔 모드 중 일부 채널만 묶어서 그룹 단위로 변환한다.
- 주로 트리거 이벤트에 따라 구간별 샘플링을 수행할 때 사용.

#### 5) **Trigger Source (External / Timer Trigger)**

- 변환 시작을 **소프트웨어 트리거** 또는 **하드웨어 트리거(TIMx_TRGO, EXTI 등)** 로 제어 가능.
- 예: PWM 신호의 상승엣지마다 ADC 변환 시작 (동기화된 샘플링).

#### 6) **DMA 연동 시퀀스**

1. 여러 채널을 스캔하도록 설정
2. DMA를 활성화하여 변환결과를 자동 메모리 저장
3. CPU는 버퍼 데이터만 주기적으로 확인

#### 7) **응용 예시**

- Single: 온도센서, 배터리 전압 측정
- Continuous: 조이스틱, 센서 실시간 모니터링
- Scan + DMA: 멀티채널 데이터 로깅 시스템

## 6.3 DMA 연동 ADC

DMA(Direct Memory Access)는 주변장치(ADC, UART 등)와 메모리 간의 데이터 전송을 CPU 개입 없이 수행하는 하드웨어 모듈이다.
 ADC와 DMA를 연동하면 변환 결과를 자동으로 메모리에 저장할 수 있어, 변환 속도 향상과 CPU 부하 감소를 동시에 달성할 수 있다.

#### 1) DMA 동작 개요

- **CPU 비개입 전송**: ADC 변환 완료 시 DMA가 자동으로 결과 레지스터(ADC_DR)의 값을 지정된 버퍼에 복사한다.
- **인터럽트 발생**: 지정한 데이터 개수만큼 전송되면 DMA 전송 완료 인터럽트(DMA_TCIF)가 발생한다.
- **지속적 수집 가능**: Circular 모드를 활성화하면 버퍼 끝에서 자동으로 다시 처음으로 돌아가 연속 측정이 가능하다.

#### 2) 주요 설정 단계 (CubeMX 기준)

1. ADC 설정 탭에서 **DMA Continuous Requests = Enabled**
2. DMA 설정 탭에서
   - **Mode**: Circular (지속 변환용) 또는 Normal (1회성)
   - **Data Width**: Peripheral = Half Word (16bit), Memory = Half Word
   - **Increment Mode**: Memory Increment = Enable
   - **Priority**: Medium 또는 High
3. 코드 자동 생성 후 `HAL_ADC_Start_DMA()` 호출

#### 3) 예제 코드 (연속 변환 DMA 모드)

```
#define ADC_BUF_LEN 16
uint16_t adc_buf[ADC_BUF_LEN];

void ADC_DMA_Start(void)
{
    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buf, ADC_BUF_LEN);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    // DMA 버퍼가 가득 차면 자동 호출됨
    // 예: 평균값 계산 또는 필터링 수행
}
```

#### 4) DMA 전송 모드 비교

| 모드              | 설명                            | 용도                |
| ----------------- | ------------------------------- | ------------------- |
| **Normal**        | 지정된 데이터 개수 전송 후 종료 | 단발성 변환         |
| **Circular**      | 끝까지 도달 시 자동 재시작      | 지속적 샘플링       |
| **Double Buffer** | 두 개의 버퍼를 번갈아 사용      | 실시간 분석 및 로깅 |

#### 5) DMA 인터럽트 처리

DMA 완료 시 자동으로 콜백 함수 호출:

- `HAL_ADC_ConvCpltCallback()` : 전송 완료 시
- `HAL_ADC_ConvHalfCpltCallback()` : 버퍼 절반 채워질 때
   이 구조를 이용하면 실시간 필터링이나 데이터 스트리밍 구현이 가능하다.

#### 6) 장점

- CPU 부하 최소화
- 샘플링 주기 안정성 향상
- 멀티채널 연속 측정에 유리

#### 7) 주의점

- DMA와 ADC 클록 설정이 맞지 않으면 오버런(Overrun) 발생 가능
- Circular 모드 사용 시 버퍼 오버플로우를 방지해야 함
- DMA 전송 중 ADC 설정 변경은 금지

------

## 6.4 여러 채널(멀티채널) 읽기

ADC의 **Scan Mode**를 활용하면 여러 입력 채널을 순차적으로 자동 변환할 수 있다. 이 기능은 센서 배열, 전압 모니터링, 멀티입력 데이터 로깅 등에서 필수적이다.

#### 1) 기본 개념

멀티채널 변환은 하나의 변환 시퀀스(Regular Sequence)에 여러 채널을 등록하여 순서대로 측정하는 구조다.
 ADC는 각 채널을 내부적으로 순차 샘플링하여 결과를 DMA 버퍼나 ADC_DR에 저장한다.

#### 2) CubeMX 설정 단계

1. **Scan Conversion Mode = Enabled**
2. **Continuous Conversion Mode = Enabled (선택적)**
3. **DMA Continuous Requests = Enabled**
4. **Regular Channel 탭**에서 변환 순서를 설정
   - Rank1 → Channel0
   - Rank2 → Channel1
   - Rank3 → Channel4 …

#### 3) 변환 순서와 SQRx 레지스터

- ADC_SQR1, SQR2, SQR3 레지스터는 변환 순서를 정의한다.
- 각 Rank에 채널 번호가 매핑되어 순서대로 변환된다.
- 예: Rank1=ADC_IN0, Rank2=ADC_IN1, Rank3=ADC_IN4

```
hadc1.Init.ScanConvMode = ENABLE;
hadc1.Init.NbrOfConversion = 3;
```

#### 4) 예제 코드 (DMA + Multi Channel)

```
#define ADC_CH_NUM 3
uint16_t adc_data[ADC_CH_NUM];

void ADC_Start_Multi(void)
{
    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_data, ADC_CH_NUM);
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    float ch0 = adc_data[0] * 3.3f / 4095.0f;
    float ch1 = adc_data[1] * 3.3f / 4095.0f;
    float ch2 = adc_data[2] * 3.3f / 4095.0f;
    // 각 채널의 전압값 계산
}
```

#### 5) 내부 채널 예시

STM32는 외부 입력 외에도 내부 측정용 ADC 채널을 제공한다.

| 채널     | 기능          | 설명                 |
| -------- | ------------- | -------------------- |
| ADC_IN16 | 내부 온도센서 | MCU 온도 측정        |
| ADC_IN17 | VREFINT       | 내부 기준전압        |
| ADC_IN18 | VBAT          | 배터리 전압 모니터링 |

#### 6) 변환 시퀀스 예시

| 순서(Rank) | 채널    | 의미        |
| ---------- | ------- | ----------- |
| 1          | ADC_IN0 | 조도 센서   |
| 2          | ADC_IN1 | 온도 센서   |
| 3          | ADC_IN4 | 배터리 전압 |

#### 7) 멀티채널 DMA 버퍼 구조

DMA 버퍼는 각 변환 결과를 순서대로 저장한다.
 예:
 `adc_buf[0]` → CH0
 `adc_buf[1]` → CH1
 `adc_buf[2]` → CH2
 DMA가 Circular 모드로 동작할 경우, 각 변환 주기마다 이 순서가 반복된다.

#### 8) 응용 예시

- **배터리/센서 통합 모니터링 시스템**
- **멀티 ADC 로깅 (ADC + DMA + SD카드)**
- **ADC 데이터 실시간 BLE 전송**
- **센서 융합 기반 제어 시스템 (PID 제어 입력값)**

#### 9) 주의사항

- 각 채널의 샘플링 시간이 다르면 오차 발생 가능
- 내부 채널과 외부 채널 혼합 시 샘플링 시간 조정 필수
- DMA 버퍼 크기는 변환 채널 수와 동일해야 함

### 6.5 센서값 필터링 (Moving Average / Kalman)

ADC를 통해 읽은 센서 값은 전원 노이즈, 샘플링 지터, 아날로그 회로 잡음 등으로 인해 불안정하게 변화한다.
 이러한 노이즈를 완화하고 신뢰도 높은 값을 얻기 위해 **필터링(Filter)** 과정을 수행한다.
 대표적인 필터링 기법으로는 **이동평균(Moving Average)** 과 **칼만필터(Kalman Filter)** 가 있다.

------

### 이동평균 필터 (Moving Average Filter)

이동평균은 가장 단순하면서도 효과적인 디지털 필터이다.
 최근 N개의 샘플을 합산하여 평균을 구함으로써 순간적인 변동을 완화한다.

```
#define FILTER_SIZE 10
uint16_t adc_buffer[FILTER_SIZE];
uint8_t idx = 0;

float MovingAverageFilter(uint16_t new_sample) {
    adc_buffer[idx++] = new_sample;
    if (idx >= FILTER_SIZE) idx = 0;

    uint32_t sum = 0;
    for (int i = 0; i < FILTER_SIZE; i++) sum += adc_buffer[i];
    return (float)sum / FILTER_SIZE;
}
```

#### **특징**

- 계산이 단순하고 구현이 매우 용이
- 일정한 샘플 지연(Latency)이 존재
- 급격한 값 변화(스텝 입력)에 대한 응답 속도가 느림

#### **응용**

- 온도, 조도, 전압 등 느리게 변하는 센서 신호에 적합
- 고주파 노이즈 제거

------

### 가중 이동평균 (Weighted Moving Average)

최근 데이터에 더 큰 가중치를 두는 방식으로, 반응 속도와 안정성을 절충한다.

```
float WeightedAverageFilter(uint16_t *buf, uint8_t len) {
    float weight_sum = 0, val_sum = 0;
    for (int i = 0; i < len; i++) {
        float w = (float)(i + 1); // 최근일수록 높은 가중치
        val_sum += buf[i] * w;
        weight_sum += w;
    }
    return val_sum / weight_sum;
}
```

------

### 칼만 필터 (Kalman Filter)

칼만필터는 확률적 추정 기반의 고급 필터로,
 센서의 측정 잡음을 통계적으로 모델링하여 실제 값(상태)을 추정한다.
 특히 가속도, 자이로, 거리센서 등 **시간적 연속성**을 갖는 신호에서 매우 효과적이다.

#### 수학적 개요

칼만 필터는 **예측(Prediction)** 과 **갱신(Update)** 두 단계로 구성된다.

1. #### **예측 단계**

   ```
   xₖ⁻ = xₖ₋₁ + u
   Pₖ⁻ = Pₖ₋₁ + Q
   ```

   - `xₖ⁻`: 예측된 상태
   - `Pₖ⁻`: 예측 오차 공분산
   - `Q`: 프로세스 노이즈

2. #### **갱신 단계**

   ```
   Kₖ = Pₖ⁻ / (Pₖ⁻ + R)
   xₖ = xₖ⁻ + Kₖ(zₖ - xₖ⁻)
   Pₖ = (1 - Kₖ)Pₖ⁻
   ```

   - `zₖ`: 측정값
   - `R`: 측정 노이즈
   - `Kₖ`: 칼만 이득

#### 예제 구현 (1차 단일 변수)

```
typedef struct {
    float Q;  // Process noise covariance
    float R;  // Measurement noise covariance
    float X;  // Estimated value
    float P;  // Estimation error covariance
    float K;  // Kalman gain
} Kalman_t;

void Kalman_Init(Kalman_t *k, float q, float r, float p, float x0) {
    k->Q = q; k->R = r; k->P = p; k->X = x0;
}

float Kalman_Update(Kalman_t *k, float z) {
    // 예측 단계
    k->P += k->Q;
    // 갱신 단계
    k->K = k->P / (k->P + k->R);
    k->X += k->K * (z - k->X);
    k->P *= (1 - k->K);
    return k->X;
}
```

#### **응용 사례**

- 자이로 + 가속도 융합 (IMU)
- 초음파 거리 측정 안정화
- 전압/전류 제어 루프에서의 잡음 억제

------

### 필터 비교

| 구분             | 이동평균  | 가중평균 | 칼만필터  |
| ---------------- | --------- | -------- | --------- |
| 계산량           | 낮음      | 중간     | 높음      |
| 응답속도         | 느림      | 중간     | 빠름      |
| 구현 난이도      | 매우 쉬움 | 쉬움     | 복잡      |
| 노이즈 제거 성능 | 중간      | 중간     | 매우 우수 |
| 실시간성         | 보통      | 좋음     | 매우 좋음 |

------

## 6.6 Internal Sensor (Vrefint, Temperature Sensor)

STM32는 내부에 **전압 기준(Vrefint)** 및 **온도 센서(Temperature Sensor)** 를 포함하고 있으며,
 ADC를 통해 이를 읽어 MCU 자체 상태를 모니터링할 수 있다.

------

### Vrefint (Reference Voltage)

Vrefint는 내부 기준 전압으로, 일반적으로 **1.20V (±1%)** 로 고정되어 있다.
 이를 이용해 **VDD(전원 전압)** 를 간접적으로 계산할 수 있다.

#### 원리

ADC 변환 공식:
$$
V_{in} = \frac{ADC_{value}}{4095} \times V_{REF+}
$$
여기서 $V_{in} = V_{REFINT}$ 이므로,
$$
V_{DD} = \frac{V_{REFINT(cal)}}{ADC_{VREFINT}/4095}
$$
이 식으로 현재 MCU의 전원 전압을 측정할 수 있다.

#### 예제 코드

```
uint16_t vref_adc = 0;
float vdd = 0;

void Read_Vref(void) {
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    vref_adc = HAL_ADC_GetValue(&hadc1);
    vdd = 1.21f * 4095.0f / vref_adc; // 내부 기준 1.21V 기준
}
```

#### **용도**

- 전원 안정성 모니터링
- 배터리 방전 감지
- ADC 정확도 보정

------

### Temperature Sensor (TS)

내부 온도센서는 MCU 다이(die)의 온도를 측정하며, 일반적으로 `ADC_IN16` 채널에 연결되어 있다.

#### 계산식 (Datasheet 기준)

$$
T(°C) = \frac{(V_{SENSE} - V_{25})}{Avg\_Slope} + 25
$$

- $V_{SENSE}$: ADC 측정값
- $V_{25}$: 25°C에서의 센서 전압 (약 0.76V)
- $Avg\_Slope$: 온도 변화당 전압 변화량 (약 2.5 mV/°C)

#### 예제 코드

```
uint16_t adc_val = 0;
float temp = 0;

void Read_TempSensor(void) {
    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    adc_val = HAL_ADC_GetValue(&hadc1);

    float Vsense = (adc_val * 3.3f) / 4095.0f;
    temp = ((Vsense - 0.76f) / 0.0025f) + 25.0f;
}
```

#### **특징**

- 정밀도는 낮지만, MCU 과열 감지용으로 충분
- 외부 온도센서(예: LM35, TMP36) 교정용으로 사용 가능

------

### 정리

| 센서                   | 채널     | 기준 전압      | 주요 용도      |
| ---------------------- | -------- | -------------- | -------------- |
| **Vrefint**            | ADC_IN17 | 1.20V          | 전원전압 보정  |
| **Temperature Sensor** | ADC_IN16 | 약 0.76V @25°C | 내부 온도 측정 |

## 6.7 ADC Calibration 및 보정

ADC(Analog-to-Digital Converter)의 보정(Calibration)은 변환 오차를 최소화하고, 실제 전압과 디지털 값 간의 일치도를 향상시키기 위해 수행되는 필수 절차이다. STM32 MCU는 내부적으로 **Offset 보정(Offset Calibration)** 및 **Gain 보정(Gain Calibration)** 기능을 제공하며, 일부 시리즈에서는 자동 보정 루틴을 내장하고 있다.

ADC 보정은 특히 **온도 변화**, **전원 전압 변동**, **개별 디바이스 간 편차**에 의해 생기는 오차를 줄이는 데 중요하며, 정밀 측정이나 센서 보정이 필요한 응용(예: 온도계, 전력 모니터링)에 필수적으로 수행된다.

------

### 6.7.1 보정의 필요성

ADC는 내부 회로 특성상 다음과 같은 오차를 가진다.

1. **Offset Error**
   - 입력 전압이 0V일 때, 이론상 출력은 0이 되어야 하지만 실제로는 일정한 오프셋 전압에 의해 0이 아닌 값이 출력됨.
   - 보정 전후의 측정 차이는 수 mV 단위로 나타날 수 있으며, 저전압 신호를 다루는 경우 치명적인 오차로 이어진다.
2. **Gain Error**
   - 입력 전압 대비 출력 비율이 이상적인 선형 관계를 벗어나는 현상.
   - 보정되지 않은 Gain Error는 전체 측정 범위에서 비례적인 오차를 유발한다.
3. **Temperature Drift**
   - 내부 기준 전압원(Vrefint) 및 비교기 회로가 온도에 따라 특성이 변함.
   - 보정 후 주기적 재보정(Periodic Recalibration)이 필요할 수 있다.

------

### 6.7.2 STM32 HAL 기반 보정 절차

#### ① HAL 초기화 및 보정 순서

STM32 HAL에서는 `HAL_ADCEx_Calibration_Start()` API를 통해 하드웨어 보정을 수행한다.
 이 함수는 내부 보정 회로를 활성화하여 오프셋 및 이득 보정을 자동으로 실행한다.

**기본 순서 예시:**

```
HAL_ADC_DeInit(&hadc1);
HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED);
HAL_ADC_Init(&hadc1);
HAL_ADC_Start(&hadc1);
```

- **DeInit()**: 보정 전에 ADC를 초기화 해제하여 클린 상태로 준비
- **Calibration_Start()**: 내부 보정 회로 구동
- **Init()**: 보정 완료 후 ADC 재초기화
- **Start()**: 정상 변환 시작

#### ② 보정 시간

- 보정은 일반적으로 **수십 μs~수백 μs** 소요된다.
- 보정 완료 후에는 자동으로 ADC Ready Flag가 세트되며, 이후 정상 변환 가능.

------

### 6.7.3 Vrefint 기반 소프트웨어 보정

ADC 내부에는 **Vrefint (Internal Reference Voltage)** 가 존재하며, MCU 전원전압(Vdda)의 변동을 감지하고 보정할 수 있다.

**보정 수식 예시:**
$$
V_{IN} = \frac{ADC_{DATA}}{ADC_{MAX}} \times V_{REF}
$$
그러나 Vref가 변동하면 실제 전압 계산이 오차를 포함하게 되므로, **Vrefint 채널을 주기적으로 측정하여 교정**한다.

**예시 코드:**

```
uint16_t vref_data = Read_ADC_Channel(ADC_CHANNEL_VREFINT);
float vdda = 3.3f * (VREFINT_CAL / vref_data);
```

여기서 `VREFINT_CAL`은 제조 시 보정된 기준값으로, Flash 메모리에 저장되어 있다.

------

### 6.7.4 사용자 정의 소프트웨어 보정

#### (1) Offset 보정

0V 입력 상태에서 ADC 결과를 측정하고, 이를 보정 상수로 저장한다.

```
offset = Read_ADC_Channel(ADCx);
corrected_value = raw_adc - offset;
```

#### (2) Gain 보정

기준 전압(예: 3.0V)을 인가한 뒤, 실제 변환값과 이론값을 비교하여 보정 계수를 계산한다.

```
gain = reference_voltage / measured_voltage;
corrected_value = raw_adc * gain;
```

#### (3) EEPROM/Flash 저장

보정 후 얻은 `offset` 및 `gain` 계수를 Flash 또는 EEPROM에 저장하여 부팅 시 자동 적용한다.

```
EEPROM_WriteFloat(OFFSET_ADDR, offset);
EEPROM_WriteFloat(GAIN_ADDR, gain);
```

------

### 6.7.5 실험 예시

| 항목               | 보정 전 | 보정 후 |
| ------------------ | ------- | ------- |
| 0V 입력 시 출력    | 0.027 V | 0.002 V |
| 1.65V 입력 시 출력 | 1.63 V  | 1.65 V  |
| 3.3V 입력 시 출력  | 3.25 V  | 3.30 V  |

**결론:** 보정 적용 시 전체 측정 오차가 약 ±20mV 수준으로 개선됨.

------

### 6.7.6 정기적 재보정 (Recalibration)

- 장시간 동작 시 온도 상승, 전원 드리프트 등으로 ADC 성능이 저하됨.
- **주기적 보정 주기:** 10분~1시간마다, 혹은 온도 변화 5°C 이상 발생 시 수행.
- FreeRTOS 환경에서는 보정 Task를 별도로 생성하여 주기적 실행 가능.

------

### 6.7.7 보정 데이터 관리 구조

#### 보정 데이터 구조체 예시

```
typedef struct {
    float offset;
    float gain;
    float vref;
    uint32_t last_cal_time;
} ADC_Calibration_t;
```

#### Flash 저장 및 로드 루틴

```
void ADC_SaveCalibration(ADC_Calibration_t *cal) {
    Flash_Write(FLASH_CAL_ADDR, (uint8_t*)cal, sizeof(ADC_Calibration_t));
}

void ADC_LoadCalibration(ADC_Calibration_t *cal) {
    Flash_Read(FLASH_CAL_ADDR, (uint8_t*)cal, sizeof(ADC_Calibration_t));
}
```

------

### 6.7.8 참고 사항

- 일부 STM32 시리즈(H7, L4, G4)는 **자동 Calibration** 기능 내장.
- ADC 보정 시 반드시 변환 중지 상태에서 수행해야 함.
- DMA 사용 시 보정 전후에 **ADC_Stop_DMA() / ADC_Start_DMA()** 순서 확인 필요.
- 온도 센서 측정 시, Vref 보정과 병행해야 정확한 절대온도 계산 가능.

------

#### ✅ 요약

| 구분            | 주요 내용                             |
| --------------- | ------------------------------------- |
| 보정 목적       | 오프셋 및 게인 오차 제거              |
| 주요 API        | `HAL_ADCEx_Calibration_Start()`       |
| 소프트웨어 보정 | Vrefint, Offset, Gain                 |
| 저장 방식       | Flash / EEPROM                        |
| 적용 주기       | 부팅 시 1회 + 주기적 재보정           |
| 권장 사례       | 정밀 센서, 전압 측정, 배터리 모니터링 |

---

## **6A. HAL 구조 및 내부 동작**

- ## 6A.1 HAL의 계층 구조 (CMSIS ↔ HAL ↔ User Code)

  STM32 펌웨어 프레임워크는 **하드웨어 독립성과 유지보수성**을 확보하기 위해 여러 계층(Layer)으로 구성되어 있다.
   이 중 핵심은 **CMSIS**, **HAL**, **User Application** 세 부분으로 나뉘며, 각 계층은 역할이 명확하게 구분된다.

  ------

  ### 6A.1.1 계층 구조 개요

  STM32 펌웨어 아키텍처는 다음과 같은 3계층 구조로 이해할 수 있다:

  ```
  ┌──────────────────────────────┐
  │         User Code            │
  │  (Application Layer)         │
  ├──────────────────────────────┤
  │             HAL              │
  │ (Hardware Abstraction Layer) │
  ├──────────────────────────────┤
  │            CMSIS             │
  │ (Cortex Microcontroller SW   │
  │   Interface Standard)        │
  ├──────────────────────────────┤
  │          Hardware            │
  └──────────────────────────────┘
  ```

  각 계층은 아래와 같은 기능을 담당한다.

  | 계층          | 주요 역할                                    | 구성 요소                          |
  | ------------- | -------------------------------------------- | ---------------------------------- |
  | **User Code** | 사용자 응용 로직, 센서 제어, UI, FreeRTOS 등 | `main.c`, `app_xxx.c`              |
  | **HAL**       | 하드웨어 제어 추상화, 레지스터 접근 캡슐화   | `stm32f1xx_hal_*.c`                |
  | **CMSIS**     | CPU, 코어 레벨 접근, NVIC/SysTick 정의       | `core_cm3.h`, `system_stm32f1xx.c` |
  | **Hardware**  | 실제 MCU 하드웨어 (CPU, GPIO, ADC, Timer 등) | 실리콘 회로                        |

  ------

  ### 6A.1.2 CMSIS (Cortex Microcontroller Software Interface Standard)

  CMSIS는 ARM에서 정의한 **표준 Cortex-M 마이크로컨트롤러 인터페이스**이다.
   STM32뿐 아니라 NXP, TI, Microchip 등 모든 Cortex-M 기반 MCU가 동일한 CMSIS 구조를 따른다.

  #### 주요 구성 요소

  | 파일                    | 설명                                               |
  | ----------------------- | -------------------------------------------------- |
  | `core_cm3.h`            | Cortex-M3 코어 레지스터, NVIC, SysTick 구조체 정의 |
  | `cmsis_gcc.h`           | 컴파일러별 어셈블리 인라인 정의                    |
  | `system_stm32f1xx.c`    | 클럭 초기화 및 시스템 주파수 설정                  |
  | `startup_stm32f103xb.s` | 벡터 테이블 및 리셋 핸들러                         |

  #### 주요 기능

  - **코어 접근:** `__NVIC_EnableIRQ()`, `__get_PRIMASK()` 등 코어 레벨 접근 제공
  - **시스템 틱 타이머:** SysTick 구성 (`SysTick_Config()`)
  - **레지스터 매크로 접근:** CMSIS 구조체 기반 접근 (예: `GPIOA->ODR = 0x01;`)

  ------

  ### 6A.1.3 HAL (Hardware Abstraction Layer)

  HAL은 STMicroelectronics가 제공하는 **하드웨어 추상화 계층**으로,
   직접적인 레지스터 접근 없이 **함수 기반의 하드웨어 제어**를 가능하게 한다.

  #### HAL의 주요 특징

  - **하드웨어 독립성 확보:** MCU 세부 레지스터 구조를 몰라도 제어 가능
  - **코드 이식성 향상:** 동일한 코드가 STM32 시리즈 간 쉽게 이동 가능
  - **CMSIS 상위 계층에서 동작:** CMSIS 레지스터 정의를 기반으로 동작

  #### HAL 내부 구조 예시

  | 모듈 | 주요 파일              | 기능                             |
  | ---- | ---------------------- | -------------------------------- |
  | GPIO | `stm32f1xx_hal_gpio.c` | 핀 모드 설정, 입력/출력 제어     |
  | ADC  | `stm32f1xx_hal_adc.c`  | 샘플링, 변환 시작/정지, DMA 연동 |
  | TIM  | `stm32f1xx_hal_tim.c`  | 타이머, PWM, Input Capture 제어  |
  | UART | `stm32f1xx_hal_uart.c` | 직렬 통신 제어                   |
  | DMA  | `stm32f1xx_hal_dma.c`  | 메모리 ↔ 주변장치 데이터 전송    |

  #### HAL 호출 흐름

  예를 들어 GPIO 출력을 제어할 때 다음과 같이 호출이 진행된다.

  ```
  User Code → HAL_GPIO_WritePin() → CMSIS GPIO 레지스터 → 하드웨어 반영
  ```

  즉, 사용자는 HAL 함수만 호출하면 내부에서 CMSIS 구조체(`GPIO_TypeDef`)를 통해
   실제 하드웨어 레지스터에 접근하게 된다.

  ------

  ### 6A.1.4 User Code Layer

  사용자 레벨의 Application 코드는 CubeIDE에서 자동 생성된 프레임워크 위에 작성된다.

  #### CubeIDE 자동 생성 구조 예시

  ```
  Core/
   ├─ Src/
   │   ├─ main.c
   │   ├─ stm32f1xx_hal_msp.c
   │   └─ stm32f1xx_it.c
   └─ Inc/
       ├─ main.h
       ├─ stm32f1xx_hal_conf.h
       └─ stm32f1xx_it.h
  ```

  #### User Code 영역

  CubeIDE는 HAL 초기화 코드 사이에 `/* USER CODE BEGIN */` 블록을 제공한다.
   이 영역 안에 작성된 코드는 코드 생성 시 자동으로 보호된다.

  ```
  /* USER CODE BEGIN 2 */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
  /* USER CODE END 2 */
  ```

  ------

  ### 6A.1.5 계층 간 데이터 흐름

  아래는 ADC 변환 결과를 예로 든 전체 흐름이다.

  ```
  [User Code]
    ↓ HAL_ADC_GetValue()
  [HAL Layer]
    ↓ HAL 내부에서 CMSIS 구조체 접근
  [CMSIS Layer]
    ↓ ADC1->DR 레지스터 직접 접근
  [Hardware]
    ↓ 변환된 디지털 값이 저장됨
  ```

  즉, **User → HAL → CMSIS → HW** 방향으로 명령이 전달되고,
   **HW → CMSIS → HAL → User** 방향으로 데이터가 반환된다.

  ------

  ### 6A.1.6 HAL과 LL(Low Layer)의 관계

  STM32는 HAL보다 하위 수준의 API로 **LL(Low Layer)** 도 제공한다.
   이는 **CMSIS 바로 위 계층**으로, 성능을 중시하는 코드에 적합하다.

  | 구분        | HAL                      | LL                    |
  | ----------- | ------------------------ | --------------------- |
  | 추상화 수준 | 높음                     | 낮음                  |
  | 사용 난이도 | 쉬움                     | 어려움                |
  | 코드 크기   | 큼                       | 작음                  |
  | 실행 속도   | 느림                     | 빠름                  |
  | 용도        | 빠른 개발, 유지보수 용이 | 고성능, 실시간 제어   |
  | 예시        | `HAL_ADC_Start()`        | `LL_ADC_Enable(ADC1)` |

  ------

  ### 6A.1.7 계층 구조 요약

  | 계층     | 주요 역할             | 대표 파일           | 예시 함수              |
  | -------- | --------------------- | ------------------- | ---------------------- |
  | User     | 응용 로직 작성        | `main.c`            | `HAL_GPIO_TogglePin()` |
  | HAL      | 하드웨어 추상화       | `stm32f1xx_hal_*.c` | `HAL_ADC_Start()`      |
  | CMSIS    | 코어 및 레지스터 정의 | `core_cm3.h`        | `__NVIC_EnableIRQ()`   |
  | Hardware | 실제 MCU 회로         | —                   | —                      |

  ------

  ### ✅ 핵심 요약

  - HAL은 **CMSIS 위에 위치한 하드웨어 추상화 계층**이다.
  - CMSIS는 **ARM에서 정의한 코어 접근 표준**, HAL은 **ST가 제공하는 드라이버 계층**이다.
  - User Code는 HAL을 통해 하드웨어를 제어하며, 직접 레지스터 접근이 필요 없다.
  - LL은 HAL보다 **빠르고 저수준**이지만, 코드 복잡도가 높다.

- ## 6A.2 HAL 드라이버 파일 구조 (`stm32f1xx_hal_xxx.c/h`)

  STM32 HAL(Hardware Abstraction Layer)은 STMicroelectronics가 제공하는 **하드웨어 제어용 C 기반 API 계층**이다.
   모든 HAL 모듈은 **일관된 파일 구조와 네이밍 규칙**을 따르며, 각 주변장치(Peripheral)별로 독립된 `.c` / `.h` 파일 세트로 구성된다.
   이 구조를 이해하면 **CubeIDE 자동 생성 코드의 내부 동작 원리**와 **디버깅 경로**를 명확히 파악할 수 있다.

  ------

  ### 6A.2.1 HAL 폴더 구조 개요

  CubeIDE 프로젝트 생성 시, HAL 드라이버들은 다음 경로 구조로 구성된다:

  ```
  STM32F1xx_HAL_Driver/
   ├── Inc/
   │   ├── stm32f1xx_hal.h
   │   ├── stm32f1xx_hal_gpio.h
   │   ├── stm32f1xx_hal_adc.h
   │   ├── stm32f1xx_hal_tim.h
   │   ├── stm32f1xx_hal_uart.h
   │   ├── stm32f1xx_hal_rcc.h
   │   ├── stm32f1xx_hal_conf_template.h
   │   └── ...
   └── Src/
       ├── stm32f1xx_hal.c
       ├── stm32f1xx_hal_gpio.c
       ├── stm32f1xx_hal_adc.c
       ├── stm32f1xx_hal_tim.c
       ├── stm32f1xx_hal_uart.c
       ├── stm32f1xx_hal_rcc.c
       └── ...
  ```

  - `Inc/`: 헤더 파일 폴더 — 외부 코드(User code)에서 include 가능
  - `Src/`: 구현부 소스 파일 — HAL 내부 동작 로직 포함
  - 모든 HAL 파일명은 `stm32f1xx_hal_<module>.c/h` 형식을 따른다.

  ------

  ### 6A.2.2 핵심 구성 파일 및 역할

  | 파일명                         | 주요 역할                         | 비고                      |
  | ------------------------------ | --------------------------------- | ------------------------- |
  | **`stm32f1xx_hal.h`**          | HAL 전체 모듈의 공통 include 헤더 | 모든 HAL 모듈의 상위 헤더 |
  | **`stm32f1xx_hal_conf.h`**     | HAL 활성화 모듈 정의, 설정        | CubeMX에서 자동 생성      |
  | **`stm32f1xx_hal_def.h`**      | 공통 매크로, 구조체, 에러 정의    | HAL 공용 타입 정의        |
  | **`stm32f1xx_hal_<module>.h`** | 개별 모듈의 외부 선언부           | API, 구조체, 매크로 정의  |
  | **`stm32f1xx_hal_<module>.c`** | 모듈 내부 구현부                  | 초기화, 제어 함수 포함    |
  | **`stm32f1xx_hal_msp.c`**      | MCU Support Package               | 클럭/핀/IRQ 초기화 함수   |
  | **`system_stm32f1xx.c`**       | 시스템 클럭 설정 (CMSIS 계층)     | HAL 하위 계층에서 사용    |

  ------

  ### 6A.2.3 `stm32f1xx_hal_conf.h` — HAL 설정 중심 파일

  이 파일은 CubeMX 프로젝트 생성 시 자동으로 `Core/Inc` 폴더에 생성된다.
   HAL 모듈의 **활성화 여부, 클럭 설정, 모듈 버퍼 크기 등**을 제어한다.

  #### 예시:

  ```
  /* stm32f1xx_hal_conf.h */
  
  #define HAL_MODULE_ENABLED
  #define HAL_GPIO_MODULE_ENABLED
  #define HAL_ADC_MODULE_ENABLED
  #define HAL_TIM_MODULE_ENABLED
  #define HAL_UART_MODULE_ENABLED
  /* #define HAL_SPI_MODULE_ENABLED */  // 비활성화됨
  
  /* System Configuration */
  #define HSE_VALUE    ((uint32_t)8000000U)
  #define LSE_VALUE    ((uint32_t)32768U)
  ```

  - `HAL_<MODULE>_MODULE_ENABLED` 매크로로 모듈 활성화 여부를 제어한다.
  - CubeIDE에서 모듈을 해제하면 이 매크로가 주석 처리되어 컴파일 제외된다.
  - 클럭 주파수, 타임아웃 설정 등도 이 파일에서 전역 정의된다.

  ------

  ### 6A.2.4 `stm32f1xx_hal_def.h` — 공통 정의 및 에러 코드

  모든 HAL 모듈이 공통적으로 include하는 파일로,
   **상태 코드, 데이터 타입, 구조체, 매크로** 등을 정의한다.

  #### 주요 정의 항목

  ```
  typedef enum
  {
    HAL_OK       = 0x00U,
    HAL_ERROR    = 0x01U,
    HAL_BUSY     = 0x02U,
    HAL_TIMEOUT  = 0x03U
  } HAL_StatusTypeDef;
  
  #define UNUSED(x) ((void)(x))
  #define __HAL_LOCK(__HANDLE__)   ((__HANDLE__)->Lock = HAL_LOCKED)
  #define __HAL_UNLOCK(__HANDLE__) ((__HANDLE__)->Lock = HAL_UNLOCKED)
  ```

  - `HAL_StatusTypeDef`: 모든 HAL 함수의 반환 타입으로, 오류 처리의 표준화에 사용됨.
  - `__HAL_LOCK()`, `__HAL_UNLOCK()`: 동시 접근 방지용 매크로 (멀티스레드 안정성).
  - HAL 내부에서는 대부분의 함수가 `HAL_OK`, `HAL_ERROR` 등을 반환한다.

  ------

  ### 6A.2.5 `stm32f1xx_hal_gpio.c` 예시 구조

  GPIO HAL 소스파일의 실제 구조를 보면 HAL 모듈의 전형적인 구성 패턴을 이해할 수 있다.

  ```
  HAL_StatusTypeDef HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)
  {
    /* 1. 입력 유효성 검증 */
    assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    
    /* 2. 클럭 활성화 */
    if (GPIOx == GPIOA) __HAL_RCC_GPIOA_CLK_ENABLE();
  
    /* 3. 모드, 출력 타입, 풀업/풀다운 설정 */
    tmpreg = GPIO_Init->Mode & GPIO_MODE;
    GPIOx->CRL = tmpreg; // 레지스터 접근 (CMSIS 구조체 기반)
  
    return HAL_OK;
  }
  ```

  - 각 HAL 함수는 **입력 검증 → 클럭 설정 → 레지스터 설정 → 반환**의 패턴을 따른다.
  - 내부에서 CMSIS 구조체(`GPIO_TypeDef`)를 직접 조작한다.

  ------

  ### 6A.2.6 `stm32f1xx_hal_msp.c` — MSP(MCU Support Package)

  MSP 파일은 **MCU 주변장치의 하드웨어 초기화 루틴**을 담당한다.
   HAL 계층에서 각 모듈이 Init 함수 호출 시 MSP 콜백이 자동 실행된다.

  #### 예시: UART MSP 초기화

  ```
  void HAL_UART_MspInit(UART_HandleTypeDef *huart)
  {
    if (huart->Instance == USART1)
    {
      __HAL_RCC_USART1_CLK_ENABLE();
      __HAL_RCC_GPIOA_CLK_ENABLE();
  
      GPIO_InitTypeDef GPIO_InitStruct = {0};
      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  
      HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
      HAL_NVIC_EnableIRQ(USART1_IRQn);
    }
  }
  ```

  이 구조는 모든 HAL 모듈 공통으로 존재하며,
   `HAL_ADC_MspInit()`, `HAL_TIM_MspInit()`, `HAL_SPI_MspInit()` 등 동일한 패턴으로 구성된다.

  ------

  ### 6A.2.7 HAL 드라이버의 호출 흐름

  HAL의 초기화 및 제어 함수는 아래의 흐름으로 작동한다.

  ```
  User Code
    ↓ HAL_<Module>_Init()
  HAL_<Module>.c
    ↓ HAL_<Module>_MspInit()
    ↓ CMSIS 레지스터 접근
    ↓ 하드웨어 설정 완료
  ```

  예를 들어, `HAL_ADC_Init()`을 호출하면 내부적으로 다음이 실행된다:

  1. `HAL_ADC_MspInit()` — 클럭 및 핀 설정
  2. `__HAL_RCC_ADC1_CLK_ENABLE()` — RCC 레지스터 설정
  3. `ADC1->CR1` 등 CMSIS 레지스터 직접 접근
  4. `HAL_OK` 반환

  ------

  ### 6A.2.8 HAL 전역 설정 헤더 (`stm32f1xx_hal.h`)

  모든 HAL 모듈의 상위 include 파일로, 각 모듈의 헤더를 한 번에 불러온다.

  ```
  #include "stm32f1xx_hal_conf.h"
  #include "stm32f1xx_hal_gpio.h"
  #include "stm32f1xx_hal_adc.h"
  #include "stm32f1xx_hal_tim.h"
  #include "stm32f1xx_hal_uart.h"
  ```

  - 사용자는 일반적으로 `#include "stm32f1xx_hal.h"` 한 줄만으로 전체 HAL 기능 사용 가능.
  - CubeIDE의 `main.c`에서는 기본적으로 이 헤더가 포함되어 있다.

  ------

  ### 6A.2.9 모듈 간 의존 관계

  | 모듈 | 종속 모듈       | 예시                            |
  | ---- | --------------- | ------------------------------- |
  | ADC  | RCC, DMA, GPIO  | ADC 클럭, DMA 전송, 입력핀 설정 |
  | TIM  | RCC, NVIC       | 타이머 클럭 및 인터럽트 설정    |
  | UART | RCC, GPIO, NVIC | TX/RX 핀 설정, IRQ 핸들러 등록  |
  | SPI  | RCC, GPIO       | MOSI/MISO/SCK 핀 및 클럭 설정   |
  | DMA  | RCC             | 독립적 전송 엔진으로 사용       |

  즉, HAL은 각 주변장치의 동작을 **RCC, NVIC, GPIO 등 하위 모듈과 결합**하여 구현한다.

  ------

  ### 6A.2.10 요약

  - HAL은 모듈 단위(`stm32f1xx_hal_<module>.c/h`)로 구성되어 있으며,
     CubeMX에서 활성화된 모듈만 컴파일된다.
  - `stm32f1xx_hal_conf.h`는 전체 HAL 모듈의 **활성화 설정 중심 파일**이다.
  - 모든 HAL 함수는 내부적으로 **CMSIS 구조체를 기반으로 하드웨어를 조작**한다.
  - `stm32f1xx_hal_msp.c`는 실제 핀, 클럭, IRQ 초기화를 수행한다.

- ## 6A.3 HAL_Init()과 SystemClock_Config() 분석

  STM32 HAL 기반 프로젝트에서 모든 시스템 초기화의 출발점은 `main()` 함수 내의
   `HAL_Init()`과 `SystemClock_Config()` 호출이다.
   이 두 함수는 **MCU의 핵심 동작 환경을 구성하는 필수 초기화 루틴**으로,
   CPU, 클럭, SysTick, NVIC, Flash Wait State 등의 설정을 담당한다.

  CubeIDE가 생성하는 기본 코드에서도 다음과 같은 형태로 항상 등장한다.

  ```
  int main(void)
  {
    HAL_Init();               // HAL 및 기본 하드웨어 초기화
    SystemClock_Config();     // 클럭 트리 구성 (PLL, HSE, HSI 등)
    MX_GPIO_Init();           // 주변장치 초기화
    MX_USART1_UART_Init();    // UART 초기화
    while (1)
    {
      // 사용자 코드
    }
  }
  ```

  ------

  ### 6A.3.1 HAL_Init() 개요

  `HAL_Init()`은 HAL 계층의 **전역 초기화 함수**로,
   다음과 같은 일련의 하드웨어 및 소프트웨어 초기 작업을 수행한다.

  #### 주요 기능 흐름

  ```
  HAL_Init()
   ├─ HAL_InitTick()         → SysTick 타이머 초기화 (1ms Tick)
   ├─ HAL_NVIC_SetPriorityGrouping() → 인터럽트 그룹 우선순위 설정
   ├─ HAL_MspInit()          → MCU Support Package 초기화 (클럭/IRQ)
   └─ HAL_EnableDBGStopMode() (선택) → 디버그 중단 모드 설정
  ```

  ------

  ### 6A.3.2 HAL_Init() 내부 구조 분석

  아래는 `stm32f1xx_hal.c`의 실제 구현 코드 일부이다.

  ```
  HAL_StatusTypeDef HAL_Init(void)
  {
    /* 1. NVIC Priority Group 설정 */
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  
    /* 2. SysTick Timer 초기화 */
    HAL_InitTick(TICK_INT_PRIORITY);
  
    /* 3. HAL MSP 초기화 (사용자 정의 콜백) */
    HAL_MspInit();
  
    return HAL_OK;
  }
  ```

  #### (1) NVIC 우선순위 그룹 설정

  `HAL_NVIC_SetPriorityGrouping()`은 Cortex-M의 **중첩 인터럽트 컨트롤러(NVIC)**의
   우선순위 그룹을 설정한다.

  ```
  #define NVIC_PRIORITYGROUP_0  ((uint32_t)0x07U) /* 0 bits for pre-emption priority */
  #define NVIC_PRIORITYGROUP_4  ((uint32_t)0x03U) /* 4 bits for pre-emption priority */
  ```

  STM32F1 시리즈에서는 **Group 4 (0x03)**가 기본값으로 사용된다.
   이때, Pre-emption(중첩 우선순위)과 Subpriority(동등 레벨) 비율이 결정된다.

  #### (2) HAL_InitTick() — SysTick 타이머 설정

  HAL은 내부적으로 `SysTick`을 이용해 **1ms 단위의 시스템 타이머**를 구성한다.
   이 타이머는 `HAL_Delay()`와 `HAL_GetTick()` 함수의 시간 기준으로 사용된다.

  ```
  HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
  {
    HAL_SYSTICK_Config(SystemCoreClock / 1000U);
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    return HAL_OK;
  }
  ```

  - `SystemCoreClock`: 현재 CPU 클럭 주파수 (Hz 단위)
  - `/1000U`: 1초(1000ms)당 SysTick 인터럽트 1,000회 발생
  - 결과적으로 1ms 주기의 HAL 타이머가 생성된다.

  #### (3) HAL_MspInit() — 하드웨어 초기화 루틴 호출

  MSP(MCU Support Package)는 **사용자 하드웨어 레벨 초기화 콜백**을 제공한다.
   이 함수는 `stm32f1xx_hal_msp.c`에서 구현되며, HAL이 자동으로 호출한다.

  ```
  void HAL_MspInit(void)
  {
    __HAL_RCC_AFIO_CLK_ENABLE();
    __HAL_RCC_PWR_CLK_ENABLE();
  
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
    HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
  }
  ```

  ------

  ### 6A.3.3 HAL_Init() 실행 후 시스템 상태

  | 항목           | 설정 결과                      |
  | -------------- | ------------------------------ |
  | SysTick 타이머 | 1ms 주기로 동작                |
  | NVIC 우선순위  | Group 4 (4비트 프리엠션)       |
  | MSP 초기화     | RCC / PWR / AFIO 클럭 활성화   |
  | HAL Tick       | `uwTick` 변수로 시간 관리 시작 |
  | HAL Delay      | HAL_GetTick 기반으로 활성화    |

  #### HAL Delay 동작 예시

  ```
  for (;;) {
    HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    HAL_Delay(1000); // 1초 지연
  }
  ```

  - 내부적으로 `uwTick` 변수가 SysTick 인터럽트마다 +1 증가한다.
  - `HAL_Delay()`는 이 변수를 감시하여 1ms 단위 지연을 구현한다.

  ------

  ### 6A.3.4 SystemClock_Config() 개요

  `SystemClock_Config()`는 MCU의 전체 **클럭 트리(Clock Tree)**를 설정하는 함수이다.
   CubeMX가 자동 생성하며, `system_stm32f1xx.c` 및 `stm32f1xx_hal_rcc.c` 내부의 HAL RCC 함수들을 호출한다.

  주요 목적은 다음과 같다:

  - HSI / HSE / PLL 기반의 System Clock 설정
  - AHB / APB1 / APB2 분주비 결정
  - Flash Wait State 조정
  - Peripheral Clock Source 설정

  ------

  ### 6A.3.5 SystemClock_Config() 코드 분석 (예시: 72MHz PLL 구성)

  ```
  void SystemClock_Config(void)
  {
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  
    /* 1. HSE (8MHz) 활성화 및 PLL 구성 */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
    HAL_RCC_OscConfig(&RCC_OscInitStruct);
  
    /* 2. 클럭 트리 구성 */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK |
                                  RCC_CLOCKTYPE_SYSCLK |
                                  RCC_CLOCKTYPE_PCLK1 |
                                  RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  
    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
  }
  ```

  ------

  ### 6A.3.6 SystemClock_Config() 동작 단계

  #### (1) HSE (High Speed External Clock) 설정

  - 외부 크리스털(8MHz)을 사용하도록 설정
  - 안정화될 때까지 PLL 설정은 보류

  #### (2) PLL 구성

  - PLL 입력: HSE (8MHz)
  - PLL 배수: ×9
  - PLL 출력: 8MHz × 9 = **72MHz (System Clock)**

  #### (3) 클럭 소스 전환

  - `RCC_SYSCLKSOURCE_PLLCLK` 설정으로 PLL 출력을 SYSCLK으로 사용

  #### (4) AHB/APB 분주비 설정

  | 버스       | 분주비 | 실제 주파수 |
  | ---------- | ------ | ----------- |
  | SYSCLK     | /1     | 72 MHz      |
  | AHB (HCLK) | /1     | 72 MHz      |
  | APB1       | /2     | 36 MHz      |
  | APB2       | /1     | 72 MHz      |

  #### (5) Flash Wait State 설정

  72MHz 동작 시, Flash 메모리 액세스 지연(Wait State)을 2로 설정해야 안정적이다.

  ------

  ### 6A.3.7 HAL_RCC_OscConfig() 내부 구조

  이 함수는 RCC 레지스터(`RCC->CR`, `RCC->CFGR`)를 제어하여 오실레이터 및 PLL을 구성한다.

  ```
  HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct)
  {
    if (RCC_OscInitStruct->OscillatorType == RCC_OSCILLATORTYPE_HSE)
    {
      SET_BIT(RCC->CR, RCC_CR_HSEON);  // HSE Enable
      while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U); // 안정화 대기
    }
  
    if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMULL, RCC_CFGR_PLLMULL9);
      SET_BIT(RCC->CR, RCC_CR_PLLON);
      while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U);
    }
  
    return HAL_OK;
  }
  ```

  ------

  ### 6A.3.8 HAL_RCC_ClockConfig() 내부 구조

  이 함수는 SYSCLK 소스와 버스 분주비를 적용한다.

  ```
  HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency)
  {
    /* Flash Wait State 설정 */
    __HAL_FLASH_SET_LATENCY(FLatency);
  
    /* SYSCLK Source 변경 */
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
  
    /* 분주비 설정 */
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
  
    return HAL_OK;
  }
  ```

  ------

  ### 6A.3.9 SystemClock_Config() 실행 결과 요약

  | 항목             | 설정 값                |
  | ---------------- | ---------------------- |
  | SYSCLK Source    | PLL (HSE × 9)          |
  | System Clock     | 72 MHz                 |
  | AHB Clock        | 72 MHz                 |
  | APB1 Clock       | 36 MHz                 |
  | APB2 Clock       | 72 MHz                 |
  | Flash Wait State | 2                      |
  | SysTick          | 1 ms (72,000 tick/sec) |

  ------

  ### 6A.3.10 HAL_Init() + SystemClock_Config() 전체 시퀀스

  ```
  main()
   ├─ HAL_Init()
   │   ├─ NVIC 설정
   │   ├─ SysTick 초기화 (1ms)
   │   └─ HAL_MspInit()
   ├─ SystemClock_Config()
   │   ├─ HSE/PLL 설정
   │   ├─ Clock Divider 설정
   │   └─ Flash Wait State 구성
   └─ MX_GPIO_Init() 등 주변장치 초기화
  ```

  이 두 함수가 성공적으로 수행되어야 이후의 모든 HAL API(`HAL_Delay`, `HAL_UART_Transmit`, `HAL_ADC_Start` 등)가 정상 동작한다.

  ------

  ### ✅ 핵심 요약

  - `HAL_Init()`은 NVIC, SysTick, HAL Tick, MSP 초기화를 수행한다.
  - `SystemClock_Config()`은 HSE/PLL 기반의 시스템 클럭 트리 전체를 구성한다.
  - HAL 타이머의 기준은 SysTick(1ms)이며, 클럭 안정화 후에 정확하게 동작한다.
  - 두 함수는 CubeMX 자동 생성 코드에서 항상 세트로 호출되어야 한다.

- ## 6A.4 Peripheral Handle 구조체 이해 (`ADC_HandleTypeDef`, `UART_HandleTypeDef`)

  STM32 HAL은 **주변장치(Peripheral)별 상태 관리와 데이터 통신을 추상화하기 위해**
   각 주변장치마다 전용 “핸들 구조체(Handle Structure)”를 사용한다.
   이 구조체는 **레지스터 포인터 + 상태 변수 + 설정 정보 + DMA 포인터** 등을 모두 포함한다.

  즉, `ADC_HandleTypeDef`, `UART_HandleTypeDef`, `I2C_HandleTypeDef`, `TIM_HandleTypeDef` 등은
   **HAL 계층의 핵심 데이터 구조체**로서, 모든 HAL 함수 호출 시 인자로 전달된다.

  ------

  ### 6A.4.1 HAL Peripheral Handle의 개념

  #### ✅ 목적

  - MCU 하드웨어 리소스를 **소프트웨어 객체로 추상화**
  - HAL 함수 간 **공통 인터페이스** 제공
  - 주변장치 상태, 설정값, DMA 연결, Lock 상태 등을 **일괄 관리**

  #### ✅ 구조적 역할

  ```
  [HAL Peripheral Handle]
   ├─ Instance        → 실제 하드웨어 레지스터 베이스 주소
   ├─ Init            → 초기화 파라미터 (보통 Init 구조체)
   ├─ State           → 현재 HAL 상태 (READY, BUSY 등)
   ├─ Lock            → 동시 접근 방지용 잠금
   ├─ DMA_Handle      → DMA 채널 연결 시 참조
   └─ 기타 Callback 포인터 등
  ```

  ------

  ### 6A.4.2 ADC_HandleTypeDef 구조

  `stm32f1xx_hal_adc.h` 내부에 정의된 HAL ADC 핸들 구조체는 다음과 같다.

  ```
  typedef struct __ADC_HandleTypeDef
  {
    ADC_TypeDef                 *Instance;     /*!< ADC 레지스터 베이스 주소 */
    ADC_InitTypeDef             Init;          /*!< 초기화 설정 구조체 */
    __IO uint32_t               NbrOfCurrentConversionRank; /*!< 현재 변환 순서 인덱스 */
    DMA_HandleTypeDef           *DMA_Handle;   /*!< DMA 핸들 포인터 */
    HAL_LockTypeDef             Lock;          /*!< 동시 접근 제어 */
    __IO HAL_ADC_StateTypeDef   State;         /*!< ADC 동작 상태 */
    __IO uint32_t               ErrorCode;     /*!< 에러 코드 플래그 */
  #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    void (*ConvCpltCallback)(struct __ADC_HandleTypeDef *hadc); /*!< 변환 완료 콜백 */
    void (*ErrorCallback)(struct __ADC_HandleTypeDef *hadc);    /*!< 에러 콜백 */
  #endif
  } ADC_HandleTypeDef;
  ```

  ------

  ### 6A.4.3 주요 멤버 설명

  | 필드               | 설명                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `Instance`         | ADC1, ADC2 등 실제 하드웨어의 베이스 주소 (ex: `ADC1_BASE`)  |
  | `Init`             | `ADC_InitTypeDef` 구조체로 해상도, 샘플링 시간, 데이터 정렬 등 설정 |
  | `DMA_Handle`       | DMA 연동 시 사용하는 포인터 (ex: ADC DMA 전송용)             |
  | `Lock`             | `HAL_LOCKED / HAL_UNLOCKED` 상태 관리                        |
  | `State`            | `HAL_ADC_STATE_BUSY`, `HAL_ADC_STATE_READY`, `HAL_ADC_STATE_EOC` 등 |
  | `ErrorCode`        | `HAL_ADC_ERROR_DMA`, `HAL_ADC_ERROR_INTERNAL` 등 오류 코드   |
  | `ConvCpltCallback` | 변환 완료 시 호출되는 사용자 콜백 함수 포인터                |

  ------

  ### 6A.4.4 ADC 핸들의 사용 흐름

  #### (1) 선언 및 초기화

  ```
  ADC_HandleTypeDef hadc1;
  
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  HAL_ADC_Init(&hadc1);
  ```

  #### (2) 내부에서 수행되는 작업 (`HAL_ADC_Init`)

  ```
  HAL_ADC_Init(&hadc1)
   ├─ HAL_ADC_MspInit(&hadc1) → GPIO, Clock, NVIC 설정
   ├─ ADC_Enable()             → ADON 비트 설정
   └─ ADC 상태값(State) = READY
  ```

  #### (3) 변환 및 데이터 획득

  ```
  HAL_ADC_Start(&hadc1);
  HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
  uint32_t val = HAL_ADC_GetValue(&hadc1);
  ```

  #### (4) DMA 방식 사용 시 연결

  ```
  DMA_HandleTypeDef hdma_adc1;
  hadc1.DMA_Handle = &hdma_adc1;
  HAL_ADC_Start_DMA(&hadc1, buffer, length);
  ```

  ------

  ### 6A.4.5 UART_HandleTypeDef 구조

  UART 드라이버에서도 유사한 패턴의 핸들 구조체가 사용된다.
   `stm32f1xx_hal_uart.h` 내 정의는 다음과 같다.

  ```
  typedef struct __UART_HandleTypeDef
  {
    USART_TypeDef            *Instance;     /*!< UART 하드웨어 베이스 주소 */
    UART_InitTypeDef         Init;          /*!< BaudRate, Parity, StopBits 등 설정 */
    uint8_t                  *pTxBuffPtr;   /*!< 송신 버퍼 포인터 */
    uint16_t                 TxXferSize;    /*!< 송신 데이터 크기 */
    uint16_t                 TxXferCount;   /*!< 송신 진행 카운터 */
    uint8_t                  *pRxBuffPtr;   /*!< 수신 버퍼 포인터 */
    uint16_t                 RxXferSize;    /*!< 수신 데이터 크기 */
    uint16_t                 RxXferCount;   /*!< 수신 진행 카운터 */
    DMA_HandleTypeDef        *hdmatx;       /*!< TX용 DMA 핸들 */
    DMA_HandleTypeDef        *hdmarx;       /*!< RX용 DMA 핸들 */
    HAL_LockTypeDef          Lock;          /*!< 동시 접근 방지 */
    __IO HAL_UART_StateTypeDef  gState;     /*!< 전송 상태 */
    __IO HAL_UART_StateTypeDef  RxState;    /*!< 수신 상태 */
    __IO uint32_t            ErrorCode;     /*!< 에러 코드 */
  } UART_HandleTypeDef;
  ```

  ------

  ### 6A.4.6 UART 핸들의 내부 상태 관리

  | 상태 플래그 | 설명                                                       |
  | ----------- | ---------------------------------------------------------- |
  | `gState`    | 전송(TX) 관련 상태 (`BUSY_TX`, `READY`)                    |
  | `RxState`   | 수신(RX) 관련 상태 (`BUSY_RX`, `READY`)                    |
  | `Lock`      | HAL 레벨에서 다중 접근을 방지하는 스핀락                   |
  | `ErrorCode` | `HAL_UART_ERROR_FE`, `HAL_UART_ERROR_ORE` 등 하드웨어 오류 |

  ------

  ### 6A.4.7 UART 동작 흐름

  #### (1) 선언 및 초기화

  ```
  UART_HandleTypeDef huart1;
  
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  HAL_UART_Init(&huart1);
  ```

  #### (2) 내부 처리

  `HAL_UART_Init()` 내부에서는 다음과 같은 함수 호출이 일어난다.

  ```
  HAL_UART_Init()
   ├─ HAL_UART_MspInit()
   │   ├─ RCC Clock Enable
   │   ├─ GPIO Pin 설정 (TX/RX)
   │   └─ NVIC 설정
   ├─ UART_Enable()
   └─ State = READY
  ```

  #### (3) 송신 및 수신

  ```
  HAL_UART_Transmit(&huart1, (uint8_t*)"Hello\n", 6, 100);
  HAL_UART_Receive(&huart1, rx_buf, 10, 100);
  ```

  #### (4) 인터럽트 또는 DMA 방식

  ```
  HAL_UART_Transmit_IT(&huart1, tx_buf, len);
  HAL_UART_Receive_DMA(&huart1, rx_buf, len);
  ```

  ------

  ### 6A.4.8 Handle 기반 HAL 함수 구조 예시

  HAL 함수는 거의 모든 경우 다음 패턴을 따른다.

  ```
  HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
  {
    /* Lock */
    __HAL_LOCK(huart);
  
    /* 상태 변경 */
    huart->gState = HAL_UART_STATE_BUSY_TX;
  
    /* 실제 데이터 전송 */
    for (i = 0; i < Size; i++)
    {
      huart->Instance->DR = pData[i];
      while(!(huart->Instance->SR & USART_SR_TXE));
    }
  
    /* 상태 복원 */
    huart->gState = HAL_UART_STATE_READY;
    __HAL_UNLOCK(huart);
  
    return HAL_OK;
  }
  ```

  핸들 구조체는 HAL 함수 내부에서 **상태 관리와 하드웨어 접근 통로**로 사용된다.

  ------

  ### 6A.4.9 HAL_Handle의 공통 규칙

  | 항목                                                         | 설명 |
  | ------------------------------------------------------------ | ---- |
  | 핸들은 항상 `&handle` 형태로 전달된다.                       |      |
  | 각 HAL 함수는 내부에서 `Lock → 작업 → Unlock` 구조를 따른다. |      |
  | DMA 사용 시 `DMA_Handle` 필드에 연결된다.                    |      |
  | 상태(`State`)는 HAL이 자동으로 관리하지만, 사용자가 확인 가능하다. |      |
  | MSP 함수(`HAL_xxx_MspInit`)는 핸들을 인자로 받는다.          |      |

  ------

  ### 6A.4.10 핵심 요약

  - `*_HandleTypeDef`는 HAL의 **상태 저장 및 하드웨어 참조 구조체**이다.
  - `Instance`가 실제 레지스터 주소이며, `Init`은 설정값을 보유한다.
  - HAL은 모든 함수 호출 시 이 핸들을 전달받아 내부 상태를 제어한다.
  - DMA, Interrupt, Polling 모두 동일한 핸들 구조를 기반으로 동작한다.
  - CubeIDE의 `MX_..._Init()` 함수는 핸들 초기화를 자동으로 수행한다.

- ## 6A.5 HAL 상태 플래그 (`HAL_OK`, `HAL_BUSY`, `HAL_ERROR`, `HAL_TIMEOUT`)

  HAL 레벨에서 모든 함수는 공통적으로 **`HAL_StatusTypeDef`** 형태의 리턴 값을 가진다.
   이는 HAL 함수가 실행된 결과 상태를 명확히 구분하기 위한 표준화된 상태 코드로,
   **펌웨어 레벨에서 에러 처리, 동기화 제어, 타임아웃 감지의 핵심 역할**을 한다.

  이 구조는 HAL 계층 전반에 걸쳐 사용되며,
   특히 **I²C, UART, SPI, ADC, DMA, FLASH** 등 비동기 주변장치 제어 루틴에서 필수적이다.

  ------

  ### 6A.5.1 HAL_StatusTypeDef 정의

  `stm32f1xx_hal_def.h` 또는 `stm32xx_hal_def.h` 내부에 다음과 같이 정의되어 있다.

  ```
  typedef enum
  {
    HAL_OK       = 0x00U, /*!< 정상 완료 */
    HAL_ERROR    = 0x01U, /*!< 일반 오류 */
    HAL_BUSY     = 0x02U, /*!< 리소스 사용 중 */
    HAL_TIMEOUT  = 0x03U  /*!< 지정된 시간 내 완료되지 않음 */
  } HAL_StatusTypeDef;
  ```

  #### 구조적 특징

  - `enum`으로 정의되어 정수형 상수로 취급된다.
  - HAL의 거의 모든 함수 (`HAL_xxx_Init`, `HAL_xxx_Transmit`, `HAL_xxx_Start_DMA` 등)가 이 값을 반환한다.
  - 함수 호출 후 항상 `if (status == HAL_OK)` 형태로 결과를 검사해야 한다.

  ------

  ### 6A.5.2 HAL_OK

  #### 의미

  - 요청한 작업이 정상적으로 수행되었음을 나타냄.
  - 함수의 **성공적인 완료** 상태.

  #### 예시

  ```
  if (HAL_UART_Transmit(&huart1, txData, len, 100) == HAL_OK)
  {
      // 정상 송신 완료
  }
  ```

  #### 내부 조건

  - 모든 하드웨어 플래그가 기대한 순서로 동작
  - DMA 전송 또는 폴링이 성공적으로 종료됨
  - Lock, ErrorCode, Timeout 조건 없음

  ------

  ### 6A.5.3 HAL_ERROR

  #### 의미

  - 함수 수행 중 **비정상 상태** 또는 **하드웨어 오류** 발생.
  - 주로 잘못된 초기화, 핸들 손상, 클럭 미설정, 통신 실패 등에서 발생.

  #### 발생 원인 예시

  | 모듈 | 원인                                |
  | ---- | ----------------------------------- |
  | ADC  | 변환 중단, 정렬 오류, DMA 설정 오류 |
  | UART | 프레이밍 에러, 패리티 에러          |
  | I2C  | NACK 수신, Bus Error                |
  | SPI  | CRC 불일치                          |
  | DMA  | 전송 중 충돌                        |

  #### 예시 코드

  ```
  HAL_StatusTypeDef status = HAL_ADC_Start(&hadc1);
  if (status == HAL_ERROR)
  {
      // ADC 하드웨어 또는 설정 오류
  }
  ```

  #### 내부 처리

  - 대부분의 HAL 함수는 내부적으로 `ErrorCode` 필드를 설정한다.
  - 예: `hadc1.ErrorCode = HAL_ADC_ERROR_DMA;`

  ------

  ### 6A.5.4 HAL_BUSY

  #### 의미

  - 요청한 리소스(주변장치, DMA, Lock 등)가 **이미 사용 중**임을 의미.
  - 병렬 접근이나 중첩 호출을 방지하기 위한 보호 상태.

  #### 발생 조건

  | 조건                    | 설명                                  |
  | ----------------------- | ------------------------------------- |
  | HAL Lock이 이미 설정됨  | `__HAL_LOCK(handle)` 호출로 잠김 상태 |
  | DMA 전송 중             | 동일한 핸들에 새로운 요청 발생        |
  | 인터럽트 전송 완료 대기 | IRQ 기반 전송 중 재요청 발생          |

  #### 예시

  ```
  if (HAL_UART_Transmit(&huart1, txData, len, 100) == HAL_BUSY)
  {
      // UART 포트가 전송 중 → 나중에 다시 시도
  }
  ```

  #### 내부 메커니즘

  ```
  __HAL_LOCK(huart);
  ...
  __HAL_UNLOCK(huart);
  ```

  이 Lock/Unlock 매크로에 의해 `HAL_BUSY` 상태가 결정된다.

  #### 동작 흐름 예시

  ```
  HAL_UART_Transmit()
   ├─ __HAL_LOCK(huart) → 이미 LOCKED 상태면 HAL_BUSY 리턴
   ├─ 데이터 전송 수행
   └─ __HAL_UNLOCK(huart)
  ```

  ------

  ### 6A.5.5 HAL_TIMEOUT

  #### 의미

  - 지정된 시간 내에 하드웨어 응답이 오지 않았음을 의미.
  - 폴링 기반 루프에서 플래그가 조건을 만족하지 못한 경우 발생.

  #### 예시 코드

  ```
  HAL_StatusTypeDef status;
  status = HAL_UART_Receive(&huart1, rxBuf, 10, 1000);
  if (status == HAL_TIMEOUT)
  {
      // 1초 내 데이터 미수신
  }
  ```

  #### 내부 동작

  ```
  while(!(huart->Instance->SR & USART_SR_RXNE))
  {
    if((HAL_GetTick() - tickstart) > Timeout)
    {
      return HAL_TIMEOUT;
    }
  }
  ```

  #### 주의 사항

  - `HAL_GetTick()` 함수는 SysTick 타이머를 기반으로 한다.
  - 따라서 SysTick이 정지된 저전력 모드에서는 **HAL_TIMEOUT이 무효**가 될 수 있음.
  - 실시간 응용에서는 타임아웃을 반드시 명시적으로 설정해야 한다.

  ------

  ### 6A.5.6 HAL 상태 코드 활용 패턴

  #### ✅ 기본 형태

  ```
  HAL_StatusTypeDef ret;
  
  ret = HAL_I2C_Master_Transmit(&hi2c1, addr, buf, len, 100);
  
  switch (ret)
  {
    case HAL_OK:
      // 성공 처리
      break;
  
    case HAL_BUSY:
      // 재시도 또는 대기
      break;
  
    case HAL_TIMEOUT:
      // 타임아웃 처리
      break;
  
    case HAL_ERROR:
    default:
      // 에러 로그 및 복구 시도
      break;
  }
  ```

  #### ✅ 에러 코드와 함께 사용

  ```
  if (HAL_ADC_Start_DMA(&hadc1, data, 10) != HAL_OK)
  {
      printf("ADC Error: 0x%08lx\n", hadc1.ErrorCode);
  }
  ```

  ------

  ### 6A.5.7 각 상태의 상호 관계

  | 상태        | 의미        | 재시도 가능성 | 원인                       |
  | ----------- | ----------- | ------------- | -------------------------- |
  | HAL_OK      | 정상 완료   | N/A           | 없음                       |
  | HAL_ERROR   | 치명적 오류 | 낮음          | 설정 불량, 하드웨어 이상   |
  | HAL_BUSY    | 일시적 점유 | 높음          | 타 스레드 혹은 DMA 사용 중 |
  | HAL_TIMEOUT | 응답 지연   | 보통          | 통신 불안정, 신호 누락     |

  ------

  ### 6A.5.8 내부 함수와의 연결

  #### `HAL_GetTick()`

  - `SysTick_Handler()`에서 증가하는 전역 Tick 카운터.
  - HAL의 모든 타임아웃 감시 루틴은 이 Tick을 참조함.

  #### `__HAL_LOCK()` / `__HAL_UNLOCK()`

  - HAL 내부 Lock 관리 매크로.
  - `Lock` 필드를 `HAL_LOCKED`로 설정하여 재진입 방지.

  ------

  ### 6A.5.9 예제: UART 송신 상태 처리

  ```
  HAL_StatusTypeDef status;
  
  status = HAL_UART_Transmit(&huart1, (uint8_t*)"Hello\n", 6, 100);
  
  if (status == HAL_OK)
      printf("TX OK\n");
  else if (status == HAL_BUSY)
      printf("UART Busy, retry later\n");
  else if (status == HAL_TIMEOUT)
      printf("TX Timeout\n");
  else
      printf("TX Error (code: 0x%08lx)\n", huart1.ErrorCode);
  ```

  ------

  ### 6A.5.10 요약

  | 상태 코드     | 값   | 설명                     |
  | ------------- | ---- | ------------------------ |
  | `HAL_OK`      | 0x00 | 함수가 정상적으로 완료됨 |
  | `HAL_ERROR`   | 0x01 | 하드웨어/설정 오류       |
  | `HAL_BUSY`    | 0x02 | 리소스 사용 중           |
  | `HAL_TIMEOUT` | 0x03 | 지정 시간 내 작업 미완료 |

  **핵심 포인트:**

  - HAL 함수 호출 시 항상 반환값 검사 필수.
  - `HAL_BUSY` 상태는 즉시 재시도 금지 — Lock 해제 후 재호출.
  - `HAL_TIMEOUT`은 시스템 타이머(`HAL_GetTick`)에 의존.
  - `HAL_ERROR` 발생 시 `ErrorCode` 필드를 반드시 참조해야 함.

- ## 6A.6 Callback 메커니즘 (`HAL_xxx_MspInit`, `HAL_xxx_IRQHandler`)

  ### 개요

  HAL 계층은 하드웨어 의존성을 최소화하기 위해 **콜백 함수(Callback Function)** 구조를 도입한다.
   이 구조는 주변장치 초기화와 인터럽트 처리 시 사용자가 개입할 수 있는 후크(Hook) 포인트를 제공한다.

  ### 주요 Callback 유형

  #### 1. MSP (MCU Support Package) 콜백

  - HAL 초기화 과정에서 하드웨어 자원을 구성하기 위한 콜백
  - 함수명 규칙: `HAL_<PERIPH>_MspInit()` / `HAL_<PERIPH>_MspDeInit()`
  - 주로 다음 항목을 설정
    - GPIO 핀 모드 및 클록 활성화
    - NVIC 인터럽트 설정
    - DMA 채널 연결

  ```
  void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
  {
      if(hadc->Instance == ADC1)
      {
          __HAL_RCC_ADC1_CLK_ENABLE();
          __HAL_RCC_GPIOA_CLK_ENABLE();
  
          GPIO_InitTypeDef GPIO_InitStruct = {0};
          GPIO_InitStruct.Pin  = GPIO_PIN_0;
          GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
          HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      }
  }
  ```

  #### 2. IRQ (Interrupt Service) 콜백

  - 인터럽트 핸들러 내부에서 호출되는 사용자 정의 후처리 함수
  - 함수명 규칙: `HAL_<PERIPH>_IRQHandler()` → 내부에서 `HAL_<PERIPH>_XXX_Callback()` 호출

  ```
  void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
  {
      adc_ready_flag = 1;   // 변환 완료 신호
  }
  ```

  ### 호출 흐름 예시 (ADC 변환 완료)

  1. ADC 하드웨어가 변환 완료 인터럽트를 발생시킴
  2. NVIC → `ADC1_IRQHandler()` 호출
  3. HAL 레벨 → `HAL_ADC_IRQHandler()`
  4. 내부 로직에서 변환 상태 확인 후 `HAL_ADC_ConvCpltCallback()` 호출
  5. 사용자는 Callback 함수 내부에서 데이터 후처리 수행

  ### 주의사항

  - Callback 함수는 인터럽트 컨텍스트에서 실행되므로 **블로킹 코드나 HAL_Delay()** 사용은 금지된다.
  - 필요 시 **flag set / RTOS event / queue push** 형태로 메인 루프 또는 Task로 이벤트를 전달한다.

  ### 정리

  | 구분         | 함수명 예시                 | 호출 시점          | 목적             |
  | ------------ | --------------------------- | ------------------ | ---------------- |
  | MSP Init     | `HAL_UART_MspInit()`        | Peripheral Init 시 | 하드웨어 설정    |
  | MSP DeInit   | `HAL_UART_MspDeInit()`      | Peripheral 해제 시 | 자원 반환        |
  | IRQ Callback | `HAL_UART_TxCpltCallback()` | 인터럽트 후        | 사용자 동작 수행 |

  ### 확장 예시 (사용자 정의 Callback 등록)

  일부 HAL 드라이버는 **Register Callback API**를 제공한다.

  ```
  HAL_UART_RegisterCallback(&huart2, HAL_UART_TX_COMPLETE_CB_ID, User_UART_TxCpltCallback);
  ```

  이는 코드 생성 시 자동 콜백 대신 **동적 콜백 등록 구조**를 허용하여 모듈화를 강화한다.

------

## **6B. HAL API 설계 원리 및 디버깅**

- ## 6B.1 HAL 함수 호출 흐름 (Init → Config → Start → Callback)

  ### 개요

  HAL 드라이버는 주변장치 초기화에서 동작 완료까지 일련의 **단계적 함수 호출 흐름**을 따른다.
   모든 HAL 기반 주변장치(ADC, UART, TIMER 등)는 다음 4단계 패턴을 공통적으로 사용한다.

  ------

  ### 1️⃣ Initialization 단계 — `HAL_<PERIPH>_Init()`

  주변장치의 **핸들 구조체(Handle)** 를 초기화하고, 내부 하드웨어 자원을 구성한다.

  - 주요 역할
    - MSP 초기화(`HAL_<PERIPH>_MspInit()` 호출)
    - 레지스터 기본값 설정
    - 클록 및 GPIO 활성화

  ```
  ADC_HandleTypeDef hadc1;
  
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  HAL_ADC_Init(&hadc1);
  ```

  - 내부 흐름

    ```
    HAL_ADC_Init()
     ├─> HAL_ADC_MspInit()
     ├─> __HAL_RCC_ADC_CLK_ENABLE()
     ├─> Configure ADC Registers
     └─> Return HAL_OK
    ```

  ------

  ### 2️⃣ Configuration 단계 — `HAL_<PERIPH>_ConfigChannel()`

  주변장치 내부의 특정 기능(채널, 타이머 모드 등)을 구성한다.

  - 예시 (ADC 채널 설정)

  ```
  ADC_ChannelConfTypeDef sConfig = {0};
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
  ```

  - 내부 처리
    - 선택된 채널의 샘플링 시간 설정
    - 변환 순서(Rank) 및 트리거 소스 지정

  ------

  ### 3️⃣ Start 단계 — `HAL_<PERIPH>_Start()` 또는 비동기 함수(`_Start_IT`, `_Start_DMA`)

  주변장치의 동작을 시작한다.
   사용 모드에 따라 **Polling / Interrupt / DMA** 방식으로 나뉜다.

  | 모드      | 함수명 예시           | 특징                  |
  | --------- | --------------------- | --------------------- |
  | Polling   | `HAL_ADC_Start()`     | 동기식, 블로킹 호출   |
  | Interrupt | `HAL_ADC_Start_IT()`  | 인터럽트 기반, 비동기 |
  | DMA       | `HAL_ADC_Start_DMA()` | DMA 전송 기반, 비동기 |

  - 예시

  ```
  HAL_ADC_Start_IT(&hadc1);  // ADC 변환 시작 (인터럽트 모드)
  ```

  ------

  ### 4️⃣ Callback 단계 — `HAL_<PERIPH>_XXX_Callback()`

  비동기 모드(IT, DMA)에서 동작 완료 후 호출되는 **사용자 정의 콜백 함수**.

  - 예시 (ADC 변환 완료 콜백)

  ```
  void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
  {
      adc_result = HAL_ADC_GetValue(hadc);
  }
  ```

  - 내부 호출 흐름

    ```
    HAL_ADC_Start_IT()
     └─> ADC 하드웨어 변환 완료
          └─> ADC_IRQHandler()
               └─> HAL_ADC_IRQHandler()
                    └─> HAL_ADC_ConvCpltCallback()
    ```

  ------

  ### 전체 호출 흐름 요약

  ```
  ┌────────────────────┐
  │ HAL_ADC_Init()     │ → MSP Init + Clock 설정
  └──────┬─────────────┘
         ↓
  ┌─────────────────────────┐
  │ HAL_ADC_ConfigChannel() │ → ADC 입력 채널/샘플링 설정
  └──────┬──────────────────┘
         ↓
  ┌────────────────────┐
  │ HAL_ADC_Start_IT() │ → 변환 시작
  └──────┬─────────────┘
         ↓
  ┌──────────────────────┐
  │ HAL_ADC_IRQHandler() │ → 인터럽트 진입
  └──────┬───────────────┘
         ↓
  ┌────────────────────────────┐
  │ HAL_ADC_ConvCpltCallback() │ → 사용자 코드 실행
  └────────────────────────────┘
  ```

  ------

  ### 참고 사항

  - HAL은 상태 기반 동작을 하므로 `HAL_GetState()` 로 주변장치의 상태를 확인 가능하다.
  - `HAL_OK`, `HAL_BUSY`, `HAL_TIMEOUT` 등의 리턴값을 반드시 체크해야 한다.
  - DMA/IT 모드 사용 시 콜백 내 연산은 최소화하고, **Flag 또는 Queue 전달 방식**을 권장한다.

- ## 6B.2 HAL과 LL, Register 직접 접근 비교

  ### 개요

  STM32 마이크로컨트롤러는 주변장치를 제어하기 위한 여러 수준의 소프트웨어 접근 방식을 제공한다.
   대표적으로 **HAL (Hardware Abstraction Layer)**, **LL (Low Layer)**, 그리고 **레지스터 직접 접근(Register-level)** 방법이 있다.
   각 방식은 추상화 수준, 코드 이식성, 성능, 제어 자유도에서 차이가 있으며, 프로젝트 성격에 따라 적절한 접근 방식을 선택해야 한다.

  ------

  ### HAL (Hardware Abstraction Layer)

  #### 개념

  HAL은 STMicroelectronics에서 공식 제공하는 **고수준 하드웨어 추상화 API**로, 모든 MCU 라인업(F0~H7 등)에 대해 공통 인터페이스를 제공한다.
   코드의 **이식성(Portability)** 과 **개발 생산성(Productivity)** 을 높이는 것이 주요 목적이다.

  #### 특징

  - 주변장치 초기화 및 제어를 함수 기반으로 단순화 (`HAL_GPIO_WritePin`, `HAL_ADC_Start_IT` 등)
  - CMSIS 레벨과 하드웨어 레지스터 접근을 내부적으로 캡슐화
  - 자동 생성 코드 (`MX_GPIO_Init`, `MX_USART2_UART_Init`) 와의 호환성 보장
  - 내부적으로 구조체(`Handle`) 기반의 상태 관리

  #### 장점

  - 코드 가독성 높음
  - CubeMX 자동 코드 생성과 연동
  - 유지보수 용이 (MCU 변경 시 코드 수정 최소화)

  #### 단점

  - 추상화 오버헤드로 인한 실행 속도 저하
  - 콜백 구조에 따른 디버깅 복잡성
  - 인터럽트 응답 지연 및 DMA 처리 부담 증가

  #### 예시

  ```
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
  HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
  ```

  ------

  ### LL (Low Layer)

  #### 개념

  LL은 HAL보다 하위 수준의 **경량(low-overhead)** 하드웨어 접근 레이어이다.
   직접적인 레지스터 접근을 함수화한 수준으로, **성능**과 **제어 세밀도**를 모두 확보할 수 있다.

  #### 특징

  - HAL 대비 코드 실행 속도 빠름
  - CMSIS 구조를 기반으로 하며, 함수 호출이 최소화
  - 자동 코드 생성 지원 (CubeMX → LL 드라이버 선택 가능)
  - ISR(Interrupt Service Routine) 내부 등 실시간성이 중요한 부분에서 적합

  #### 장점

  - 빠른 실행 속도 (HAL 대비 20~40% 향상)
  - 세밀한 하드웨어 제어 가능
  - HAL과 혼용 가능 (부분 최적화 용도)

  #### 단점

  - 코드 이식성 낮음 (MCU 라인별 레지스터 차이 반영 필요)
  - 함수 이름 및 인자 구조 복잡
  - 문서화가 HAL보다 상대적으로 부족

  #### 예시

  ```
  LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_5);
  LL_GPIO_ResetOutputPin(GPIOA, LL_GPIO_PIN_5);
  ```

  ------

  ### Register 직접 접근

  #### 개념

  레지스터 직접 접근은 CMSIS에서 정의된 주변장치 구조체를 통해
   MCU 하드웨어 레벨의 **레지스터 필드(bit field)** 에 직접 접근하는 방식이다.
   최고의 성능과 제어 자유도를 제공하지만, 코드 이식성이 거의 없다.

  #### 특징

  - 하드웨어 동작을 완전히 직접 제어
  - CMSIS 디바이스 헤더(`stm32f1xx.h`) 기반으로 동작
  - 타 MCU 이식 불가 (레지스터 이름, 비트 필드 구조 다름)

  #### 장점

  - 가장 빠른 실행 속도 (함수 오버헤드 없음)
  - 모든 하드웨어 기능 제어 가능 (HAL/LL 미지원 기능 포함)
  - 실시간 제어, 커스텀 드라이버 제작에 유리

  #### 단점

  - 코드 가독성 및 유지보수성 낮음
  - 실수로 잘못된 비트 조작 시 MCU 오동작 위험
  - 디버깅 및 확장성 낮음

  #### 예시

  ```
  GPIOA->BSRR = GPIO_BSRR_BS5;    // PA5 Set
  GPIOA->BSRR = GPIO_BSRR_BR5;    // PA5 Reset
  ```

  ------

  ### 비교 요약 표

  | 구분             | HAL                       | LL                       | Register 직접 접근                  |
  | ---------------- | ------------------------- | ------------------------ | ----------------------------------- |
  | 추상화 수준      | 높음                      | 중간                     | 낮음                                |
  | 속도             | 느림                      | 빠름                     | 매우 빠름                           |
  | 코드 가독성      | 매우 높음                 | 보통                     | 낮음                                |
  | 이식성           | 매우 높음                 | 중간                     | 매우 낮음                           |
  | 제어 세밀도      | 낮음                      | 중간~높음                | 최고                                |
  | CubeMX 자동 생성 | 지원                      | 지원                     | 미지원                              |
  | 사용 난이도      | 쉬움                      | 중간                     | 어려움                              |
  | 주요 용도        | 일반 애플리케이션, 교육용 | 실시간 제어, 최적화 구간 | 커스텀 드라이버, 실시간 제어 핵심부 |

  ------

  ### 선택 가이드

  | 상황                                             | 권장 접근 방식         |
  | ------------------------------------------------ | ---------------------- |
  | 교육, 프로토타이핑, 빠른 개발                    | **HAL**                |
  | 실시간 성능이 중요한 제어 루프 (PWM, Encoder 등) | **LL**                 |
  | 극한의 성능 최적화, 드라이버 직접 작성           | **Register 접근**      |
  | HAL의 일부 기능 최적화 필요                      | **HAL + LL 혼합 사용** |

  ------

  ### 결론

  STM32 개발에서 HAL은 개발 효율성과 이식성을,
   LL과 레지스터 접근은 성능과 제어 세밀도를 제공한다.
   프로젝트 특성에 따라 HAL로 전체 프레임워크를 구성하고,
   핵심 타이밍 루프나 인터럽트 루틴에는 **LL 또는 Register 접근을 병행**하는 하이브리드 접근이 가장 실용적이다.

- ## 6B.3 HAL 디버깅 실습 (Break, Watch Variable)

  ### 개요

  STM32CubeIDE 환경에서 HAL 기반 프로젝트를 디버깅하는 것은 코드 흐름, 변수 상태, 인터럽트 동작을 명확히 이해하기 위한 핵심 과정이다.
   본 절에서는 **브레이크포인트(Breakpoint)** 와 **Watch Variable** 기능을 중심으로 HAL 코드 디버깅 방법을 단계별로 설명한다.

  ------

  ### 1️⃣ 디버깅 준비

  #### 프로젝트 빌드 모드 확인

  - **Run → Debug Configurations → MCU Debugging** 메뉴에서 설정 확인
  - “**Debug/Release**” 빌드 중 `Debug` 구성 선택
  - 컴파일러 옵션:
    - `-g3` (디버그 심볼 포함)
    - `-O0` (최적화 비활성화, 코드 흐름 유지)

  #### 디버그 프로브 설정

  - ST-Link, J-Link, CMSIS-DAP 등 사용 가능
  - 기본 포트: SWD (Serial Wire Debug)
  - CubeIDE 상단의 “Bug 아이콘” → “Debug as STM32 MCU Application” 실행

  ------

  ### 2️⃣ Breakpoint 설정 및 활용

  #### 개념

  Breakpoint는 특정 코드 라인에 CPU 실행을 중단시키는 디버깅 포인트로, **HAL 함수 내부 흐름**을 추적할 때 유용하다.

  #### 설정 방법

  1. 코드 에디터 왼쪽 라인 넘버 영역 클릭 → 빨간 점 생성
  2. “Run → Resume (F8)” 실행 시 해당 라인에서 일시 중단
  3. 중단 후 변수/레지스터 상태, 콜스택(Call Stack) 확인

  #### 실습 예시

  ```
  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  HAL_Delay(100);
  ```

  - `HAL_GPIO_TogglePin()` 라인에 브레이크포인트 설정
  - “Resume(F8)” 실행 → MCU 실행 중단
  - “Step Into(F5)”로 HAL 함수 내부 진입

  #### 내부 동작 추적

  1. `HAL_GPIO_TogglePin()`
  2. → `GPIOx->ODR` 레지스터 조작 확인
  3. “SFRs(특수 기능 레지스터)” 창에서 실제 비트 토글 상태 확인

  ------

  ### 3️⃣ Step Over / Step Into / Step Out

  | 명령          | 단축키 | 설명                               |
  | ------------- | ------ | ---------------------------------- |
  | **Step Over** | F6     | 현재 함수 실행 후 다음 줄로 이동   |
  | **Step Into** | F5     | 함수 내부로 진입                   |
  | **Step Out**  | F7     | 현재 함수 종료 후 상위 함수로 복귀 |
  | **Resume**    | F8     | 다음 브레이크포인트까지 실행       |

  #### 활용 포인트

  - HAL 내부 함수 흐름 추적: `Step Into`
  - 사용자 루프 단위 디버깅: `Step Over`
  - 인터럽트 후 복귀 동작 확인: `Step Out`

  ------

  ### 4️⃣ Watch Variable 설정

  #### 개념

  Watch Variable은 코드 실행 중 실시간으로 특정 변수의 값을 추적하는 기능이다.
   ADC 변환값, 타이머 카운트, 상태 플래그 등의 변화를 관찰할 때 활용된다.

  #### 설정 방법

  1. “Variables” 창 → 우클릭 → “Add Watch Expression”
  2. 모니터링할 변수 입력 (예: `adc_value`, `htim2.Instance->CNT`)
  3. 실시간 값 갱신 확인

  #### 예시

  ```
  volatile uint32_t adc_value = 0;
  
  HAL_ADC_Start(&hadc1);
  HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
  adc_value = HAL_ADC_GetValue(&hadc1);
  ```

  - `adc_value` 변수를 Watch Expression으로 등록
  - 디버깅 중 변환값 변화 실시간 확인

  #### 주의사항

  - **최적화(`-O2`)가 켜진 경우**, 일부 변수는 Watch 창에 표시되지 않음
  - `volatile` 키워드를 사용하여 최적화 제거 방지

  ------

  ### 5️⃣ Peripheral Register 확인

  #### SFR (Special Function Register) 창

  - CubeIDE 하단의 “SFRs” 탭 → 주변장치별 레지스터 구조 표시
  - 실시간으로 레지스터 비트 토글, 플래그 상태 확인 가능
  - 예: `GPIOA->ODR`, `ADC1->DR`, `TIM2->CNT`

  #### Peripheral View

  - “Window → Show View → Peripherals” 선택
  - 시각적으로 주변장치 상태(Enable, Flag, Mode 등) 모니터링

  ------

  ### 6️⃣ Call Stack / Breakpoint / Expression 창 활용

  #### Call Stack

  - 현재 실행 중 함수의 호출 계층 구조 표시
  - `HAL_ADC_IRQHandler()` → `ADC1_2_IRQHandler()` → `main()` 등 순서 추적

  #### Breakpoint 창

  - 모든 브레이크포인트 리스트 관리
  - 개별 활성화/비활성화 및 조건부 중단 설정 가능

  #### Expression 창

  - Watch Variable보다 심화된 조건식 모니터링 가능
  - 예: `adc_value > 1000` 또는 `htim2.Instance->CNT == 5000`

  ------

  ### 7️⃣ 디버깅 중 실시간 메모리 관찰

  - “Memory” 창에서 주소 직접 입력 (`&hadc1`, `0x40012400`)
  - Flash, SRAM, Peripheral 영역 모두 접근 가능
  - 메모리 뷰를 통한 핸들 구조체(`ADC_HandleTypeDef`) 내부 값 확인

  ------

  ### 8️⃣ 디버깅 자동화 팁

  #### Conditional Breakpoint

  특정 조건에서만 중단되도록 설정

  - 예: `adc_value > 2000` 일 때만 Break

  #### Hit Count

  몇 번째 루프 실행 시 중단할지 지정

  - 예: 루프 100회째 실행 시 중단

  #### Live Expressions

  실행 중 변수 값을 실시간 그래프로 표시

  - “Live Expressions” 창에서 주기적 폴링 기반 표시

  ------

  ### 결론

  HAL 디버깅은 단순히 오류를 찾는 행위가 아니라,
   **하드웨어 레벨의 동작 흐름과 펌웨어 구조를 시각적으로 검증**하는 과정이다.
   CubeIDE의 Breakpoint, Watch, Peripheral View, Call Stack을 종합적으로 활용하면
   HAL 함수의 내부 동작, 레지스터 변화, 인터럽트 처리 과정을 완벽히 추적할 수 있다.

- ## 6B.4 HAL Delay / Tick 기반 구조 (`SysTick_Handler`, `uwTick`)

  ### 개요

  HAL 라이브러리에서 **시간 지연(Delay)** 과 **주기적 타이밍 이벤트**는 `SysTick` 타이머를 기반으로 동작한다.
   `HAL_Delay()`, `HAL_GetTick()`, 그리고 내부 전역 변수 `uwTick` 은 모두 이 **SysTick 기반 시간 관리 구조**를 중심으로 동작하며,
   FreeRTOS를 포함한 시스템 타이밍 제어의 핵심 메커니즘으로 사용된다.

  ------

  ### 1️⃣ SysTick Timer 개요

  #### 정의

  SysTick은 ARM Cortex-M 코어에 내장된 24비트 **다운 카운터(Decrementing Counter)** 로,
   정확한 주기적 인터럽트를 발생시켜 시스템 틱(System Tick)을 제공한다.

  - 레지스터: `SYST_CSR`, `SYST_RVR`, `SYST_CVR`
  - 동작 주파수: 일반적으로 **1ms 주기(1kHz)** 로 설정
  - NVIC 인터럽트 벡터: `SysTick_Handler()`

  #### 주요 기능

  - 일정한 주기로 인터럽트 발생 (기본: 1ms)
  - `uwTick` 변수를 1씩 증가시켜 **시스템 시간 기반** 생성
  - HAL 타이머 및 Delay 함수에 공통 사용

  ------

  ### 2️⃣ HAL Tick 구조

  HAL은 내부적으로 다음과 같은 시간 관리 흐름을 가진다.

  ```
  SysTick_Handler() → HAL_IncTick() → uwTick 증가 → HAL_Delay() 참조
  ```

  #### 주요 구성 요소

  | 함수 / 변수              | 역할                                 |
  | ------------------------ | ------------------------------------ |
  | `uwTick`                 | HAL 전역 시간 카운터 (ms 단위)       |
  | `HAL_IncTick()`          | SysTick 인터럽트마다 `uwTick++` 수행 |
  | `HAL_GetTick()`          | 현재 Tick 값 반환 (ms 단위)          |
  | `HAL_Delay(uint32_t ms)` | `uwTick` 기반 지연 함수              |

  ------

  ### 3️⃣ SysTick 초기화 과정

  `HAL_Init()` 내부에서 `HAL_InitTick()` 함수가 호출되어 SysTick이 설정된다.

  ```
  HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
  {
      HAL_SYSTICK_Config(SystemCoreClock / 1000U); // 1ms 주기
      HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
      return HAL_OK;
  }
  ```

  #### 세부 동작

  - `SystemCoreClock / 1000` → 1ms 주기 인터럽트 설정
  - `SysTick_IRQn` 인터럽트 우선순위 지정
  - `SysTick_Handler()` → HAL_IncTick() 호출로 연결

  ------

  ### 4️⃣ SysTick 인터럽트 처리 흐름

  ```
  void SysTick_Handler(void)
  {
      HAL_IncTick();     // 1ms마다 uwTick 증가
      HAL_SYSTICK_IRQHandler();  // 추가 사용자 Hook 처리
  }
  ```

  #### HAL_IncTick()

  ```
  void HAL_IncTick(void)
  {
      uwTick += uwTickFreq;
  }
  ```

  - `uwTickFreq` 기본값: 1 (즉, 1ms 단위 증가)
  - 사용자가 `HAL_SetTickFreq()` 로 주기를 변경 가능 (예: 10Hz, 100Hz 등)

  ------

  ### 5️⃣ HAL_Delay() 동작 원리

  `HAL_Delay(ms)` 는 `uwTick` 변수를 지속적으로 폴링(polling) 하여 일정 시간이 지날 때까지 대기한다.

  ```
  void HAL_Delay(uint32_t Delay)
  {
      uint32_t tickstart = HAL_GetTick();
      while((HAL_GetTick() - tickstart) < Delay)
      {
          __NOP(); // CPU 대기
      }
  }
  ```

  #### 특징

  - **블로킹(Blocking)** 함수: CPU가 Delay 동안 다른 작업 수행 불가
  - FreeRTOS 환경에서는 `vTaskDelay()` 로 대체 필요
  - 정확도는 SysTick 주기(1ms)와 클록 정확도에 의존

  ------

  ### 6️⃣ HAL_GetTick() 사용

  `HAL_GetTick()` 함수는 현재 시스템 시간을 밀리초 단위로 반환한다.
   이는 소프트웨어 타이머, 디버깅 타임스탬프, 이벤트 간격 측정 등에 활용된다.

  ```
  uint32_t time1 = HAL_GetTick();
  // some operation
  uint32_t time2 = HAL_GetTick();
  printf("Elapsed = %lu ms\n", (time2 - time1));
  ```

  ------

  ### 7️⃣ 사용자 Tick Hook

  #### 1. SysTick_Handler() 확장

  사용자는 `HAL_SYSTICK_Callback()` 함수를 구현하여 주기적 작업을 수행할 수 있다.
   (예: LED 토글, 주기적 ADC 샘플링 등)

  ```
  void HAL_SYSTICK_Callback(void)
  {
      HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  }
  ```

  #### 2. HAL_IncTick() 오버라이드

  사용자가 HAL Tick 증분 방식을 직접 제어하고 싶을 경우 `HAL_IncTick()` 을 재정의 가능하다.
   예: FreeRTOS Tick에 맞춰 HAL Tick 동기화

  ```
  __weak void HAL_IncTick(void)
  {
      uwTick += 2; // 2ms 단위로 증가시키는 예시
  }
  ```

  ------

  ### 8️⃣ FreeRTOS와 HAL Tick 동기화

  FreeRTOS 사용 시 HAL의 SysTick은 RTOS의 Tick과 충돌할 수 있다.
   이를 해결하기 위해 HAL은 `configUSE_TICK_HOOK` 또는 `osSystickHandler()` 를 통해 Tick 통합을 지원한다.

  ```
  void SysTick_Handler(void)
  {
      HAL_IncTick();    // HAL tick
      osSystickHandler(); // FreeRTOS tick
  }
  ```

  - FreeRTOS가 SysTick을 소유하도록 설정 시 `HAL_Delay()` 는 RTOS Delay API로 대체됨
  - HAL tick은 여전히 HAL 내부 함수에서 사용 가능

  ------

  ### 9️⃣ Tick 주파수 변경

  `HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)` 함수를 통해 Tick 빈도를 조정할 수 있다.

  | 인자                    | 주기(ms) | 설명      |
  | ----------------------- | -------- | --------- |
  | `HAL_TICK_FREQ_10HZ`    | 100ms    | 저속      |
  | `HAL_TICK_FREQ_100HZ`   | 10ms     | 중간 속도 |
  | `HAL_TICK_FREQ_1KHZ`    | 1ms      | 기본      |
  | `HAL_TICK_FREQ_DEFAULT` | 1ms      | 기본값    |

  예시:

  ```
  HAL_SetTickFreq(HAL_TICK_FREQ_100HZ); // 10ms 주기로 변경
  ```

  ------

  ### 1️⃣0️⃣ 디버깅 시 Tick 정지 방지

  디버그 중 Break 상태에서는 SysTick이 멈춰서 HAL_Delay() 가 무한 루프에 빠질 수 있다.
   이 경우 `DBGMCU->CR` 레지스터에서 SysTick 동작을 유지하도록 설정할 수 있다.

  ```
  __HAL_DBGMCU_FREEZE_TIM1(); // 예: 특정 타이머 동작 유지
  ```

  또는 IDE 설정 → “Debug Configuration → Debugger → Stop watchdogs while halted” 옵션 해제

  ------

  ### 결론

  HAL의 Tick 구조는 SysTick 타이머를 기반으로 시스템 시간, Delay, 주기적 이벤트를 관리한다.
   이 구조를 이해하면 단순한 `HAL_Delay()` 지연뿐만 아니라, **타이밍 기반 이벤트 처리, FreeRTOS Tick 연동, 저전력 동작 최적화**까지 효율적으로 제어할 수 있다.
   즉, SysTick과 `uwTick`은 HAL 전반의 시간 관리 중심축이다.

- ## 6B.5 HAL Library 버전 확인 및 업데이트

  ### HAL 라이브러리 버전의 중요성

  STM32 HAL( Hardware Abstraction Layer )은 STMicroelectronics가 제공하는 하드웨어 추상화 계층으로, MCU의 레지스터 접근을 캡슐화하여 펌웨어 개발을 단순화한다.
   HAL 라이브러리는 주기적으로 업데이트되며, 각 버전은 다음과 같은 이유로 중요하다:

  - 새로운 MCU 제품군 및 주변장치 지원 추가
  - 기존 드라이버 버그 수정 및 안정성 향상
  - 코드 최적화 및 기능 개선
  - CubeMX, CubeIDE와의 호환성 유지

  따라서 프로젝트의 장기 유지보수 및 재빌드 시, HAL 버전의 관리가 필수적이다.

  ------

  ### HAL 버전 확인 방법

  #### 1. 코드 내부에서 확인

  프로젝트 내 HAL 버전은 일반적으로 `stm32f1xx_hal_conf.h` 또는 `stm32f1xx_hal.h`에서 정의되어 있다.

  ```
  #define __STM32F1xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
  #define __STM32F1xx_HAL_VERSION_SUB1   (0x08U) /*!< [23:16] sub1 version */
  #define __STM32F1xx_HAL_VERSION_SUB2   (0x00U) /*!< [15:8]  sub2 version */
  #define __STM32F1xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
  #define __STM32F1xx_HAL_VERSION        ((__STM32F1xx_HAL_VERSION_MAIN << 24)\
                                         |(__STM32F1xx_HAL_VERSION_SUB1 << 16)\
                                         |(__STM32F1xx_HAL_VERSION_SUB2 << 8 )\
                                         |(__STM32F1xx_HAL_VERSION_RC))
  ```

  또는 코드 실행 중 아래처럼 직접 출력할 수 있다.

  ```
  printf("HAL Version: 0x%08lX\r\n", HAL_GetHalVersion());
  ```

  #### 2. CubeIDE에서 확인

  1. `Project Explorer` → `Drivers` → `STM32F1xx_HAL_Driver` 폴더 확인
  2. `Release_Notes.html` 또는 `stm32f1xx_hal.c` 파일 상단 주석에 버전 정보 명시

  예시:

  ```
  * @file    stm32f1xx_hal.c
  * @version V1.8.0
  * @date    23-September-2022
  ```

  ------

  ### HAL 라이브러리 업데이트 절차

  #### 1. CubeMX 패키지 업데이트

  - CubeIDE 또는 CubeMX 실행
  - 상단 메뉴: **Help → Manage embedded software packages**
  - 사용 중인 MCU 시리즈(F1, F4, H7 등)의 최신 버전 다운로드

  #### 2. 프로젝트 내 HAL 교체

  - CubeIDE에서 `Drivers/STM32F1xx_HAL_Driver` 폴더 삭제
  - CubeMX에서 **Project → Generate Code** 재실행
  - 새로운 HAL 버전의 드라이버 파일이 자동 생성됨

  #### 3. 호환성 점검

  - 주요 함수명, 구조체 변경 여부 확인
  - `stm32f1xx_hal_conf.h` 비교
  - 이전 버전에서 deprecated된 API 사용 여부 점검

  ------

  ### 버전 관리 권장 사항

  - **Git 태그 지정:** 각 HAL 버전별 프로젝트 태그 지정 (`v1.7.10_hal_v1.8.0`)
  - **문서화:** 프로젝트 README 또는 기술 문서에 HAL 버전 기록
  - **CI 환경 고정:** 빌드 서버나 Jenkins 등에서 HAL 버전을 명시적으로 지정
  - **장기 유지보수(LTS) 버전 선택:** 실제품은 안정성이 검증된 버전 사용 권장

  ------

  ### HAL 버전 관리 예시

  | 항목         | 예시 값        |
  | ------------ | -------------- |
  | MCU          | STM32F103C8T6  |
  | HAL 버전     | v1.8.0         |
  | CubeMX 버전  | v6.11.1        |
  | CubeIDE 버전 | v1.16.0        |
  | 빌드 날짜    | 2025-11-11     |
  | 상태         | Stable Release |

  ------

  ### 결론

  HAL 버전은 단순한 라이브러리 수준의 변경이 아니라, MCU 펌웨어의 안정성과 호환성에 직결되는 요소이다.
   CubeIDE, CubeMX, HAL이 동일한 생태계 버전 라인에서 맞물릴 때, 가장 안정적이고 재현 가능한 개발 환경이 유지된다.
   따라서 프로젝트 초기 설계 단계에서 HAL 버전을 고정하고, 이후 업데이트는 체계적인 검증 절차를 거쳐 수행해야 한다.

- ## 6B.6 사용자 확장 HAL 함수 작성 (Custom HAL Layer)

  ### 개요

  HAL(Hardware Abstraction Layer)은 ST에서 제공하는 MCU 주변장치 제어의 기본 계층으로, 대부분의 하드웨어 접근은 HAL API를 통해 이루어진다.
   그러나 프로젝트 요구사항에 따라 HAL이 제공하지 않는 기능(특수한 초기화, 비표준 타이밍, 최적화된 레지스터 접근 등)을 구현해야 하는 경우가 발생한다.
   이때 **사용자 확장 HAL 함수(Custom HAL Layer)**를 정의하면, HAL의 구조를 유지하면서도 사용자 정의 동작을 추가할 수 있다.

  ------

  ### HAL 사용자 확장의 목적

  - HAL 기본 함수에 없는 세부 제어 기능 구현 (예: ADC 샘플링 순서 고정, DMA 트리거 조건 변경)
  - 특정 하드웨어 조합 또는 PCB 설계에 맞춘 맞춤형 동작 추가
  - HAL 내부 코드 수정 없이 확장 (업데이트 시 충돌 방지)
  - 코드 유지보수성 및 재사용성 향상

  ------

  ### HAL 구조 내 확장 포인트

  #### 1. `stm32f1xx_hal_xxx.c/h` 내부 구조

  HAL은 기본적으로 다음 계층 구조로 나뉜다:

  ```
  User Code (main.c)
   └── HAL Layer (stm32f1xx_hal_xxx.c)
        ├── HAL_Init(), HAL_DeInit()
        ├── HAL_Config(), HAL_Start(), HAL_Stop()
        ├── HAL_IRQHandler(), HAL_Callback()
        └── 내부 static 함수 (Private Function)
  ```

  사용자는 `stm32f1xx_hal_xxx.c` 파일을 직접 수정하지 않고, 다음 영역을 통해 확장할 수 있다.

  ------

  ### HAL 확장 방법

  #### 1. User Code 영역 활용

  HAL 소스 내 대부분의 파일에는 아래와 같은 “사용자 코드 영역”이 있다.

  ```
  /* USER CODE BEGIN 0 */
  
  /* Custom Extension Function */
  HAL_StatusTypeDef HAL_ADC_CustomCalibrate(ADC_HandleTypeDef *hadc)
  {
      if (hadc == NULL) return HAL_ERROR;
      /* 사용자 정의 ADC 보정 알고리즘 */
      MODIFY_REG(hadc->Instance->CR2, ADC_CR2_CAL, 0);
      SET_BIT(hadc->Instance->CR2, ADC_CR2_CAL);
      while (READ_BIT(hadc->Instance->CR2, ADC_CR2_CAL));
      return HAL_OK;
  }
  
  /* USER CODE END 0 */
  ```

  이처럼 HAL 소스에 직접 코드를 삽입하지 않고, **별도의 C 파일**에서 `extern`으로 핸들을 참조하여 확장하는 것이 권장된다.

  ------

  #### 2. Custom HAL Layer 분리 구조

  프로젝트 구조 예시:

  ```
  Core/
   ├── Src/
   │   ├── main.c
   │   ├── stm32f1xx_it.c
   │   └── hal_custom_adc.c     ← 사용자 HAL 확장 계층
   └── Inc/
       └── hal_custom_adc.h
  ```

  `hal_custom_adc.h`:

  ```
  #ifndef __HAL_CUSTOM_ADC_H__
  #define __HAL_CUSTOM_ADC_H__
  
  #include "stm32f1xx_hal.h"
  
  HAL_StatusTypeDef HAL_ADC_ReadAverage(ADC_HandleTypeDef *hadc, uint16_t *value, uint8_t samples);
  HAL_StatusTypeDef HAL_ADC_SetChannelFast(ADC_HandleTypeDef *hadc, uint32_t channel);
  
  #endif
  ```

  `hal_custom_adc.c`:

  ```
  #include "hal_custom_adc.h"
  
  HAL_StatusTypeDef HAL_ADC_ReadAverage(ADC_HandleTypeDef *hadc, uint16_t *value, uint8_t samples)
  {
      uint32_t sum = 0;
      for (uint8_t i = 0; i < samples; i++)
      {
          HAL_ADC_Start(hadc);
          HAL_ADC_PollForConversion(hadc, HAL_MAX_DELAY);
          sum += HAL_ADC_GetValue(hadc);
      }
      *value = (uint16_t)(sum / samples);
      return HAL_OK;
  }
  ```

  ------

  ### Custom HAL 네이밍 규칙

  | 구분               | 규칙                 | 예시                                     |
  | ------------------ | -------------------- | ---------------------------------------- |
  | 확장 함수 접두어   | HAL_XXX_             | HAL_UART_Flush(), HAL_GPIO_TogglePulse() |
  | 비공식 내부 함수   | *HAL_XXX*            | _HAL_ADC_CalibrationStep()               |
  | 비공개 내부 Helper | static               | static void _ADC_ResetSeq()              |
  | Callback           | HAL_XXX_UserCallback | HAL_ADC_UserCallback()                   |

  이 규칙을 따르면 HAL 내부 함수와의 충돌을 피하고 코드 가독성을 유지할 수 있다.

  ------

  ### HAL 확장 시 주의사항

  1. **원본 HAL 파일 직접 수정 금지**
     - ST의 HAL 업데이트 시 덮어쓰기될 수 있음
     - CubeMX 코드 생성 시 자동 삭제될 위험
  2. **핸들 구조체(HAL_HandleTypeDef) 일관성 유지**
     - 사용자 함수에서도 동일한 핸들을 사용해야 함
     - 전역 핸들(`extern ADC_HandleTypeDef hadc1;`) 활용
  3. **인터럽트 기반 코드와의 충돌 방지**
     - Polling 기반 확장 함수 작성 시 IRQ 중복 처리 금지
     - DMA, Interrupt, Polling 모드 동시 사용 금지
  4. **HAL State 및 Lock 관리**
     - HAL은 내부적으로 `Lock` 매크로(`__HAL_LOCK`, `__HAL_UNLOCK`)를 사용
     - 확장 함수에서도 동일한 Lock 보호를 적용해야 안전

  ------

  ### 고급 확장 예시

  #### DMA 기반 Custom 송신 함수 예시

  ```
  HAL_StatusTypeDef HAL_UART_TransmitDMA_Fast(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
  {
      if (huart->gState == HAL_UART_STATE_BUSY_TX)
          return HAL_BUSY;
  
      __HAL_LOCK(huart);
      huart->gState = HAL_UART_STATE_BUSY_TX;
  
      /* DMA 설정 */
      HAL_DMA_Start(huart->hdmatx, (uint32_t)pData, (uint32_t)&huart->Instance->DR, Size);
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
  
      return HAL_OK;
  }
  ```

  ------

  ### Custom HAL Layer의 장점

  - HAL 원본 유지 및 업데이트 용이
  - 기능 확장 및 재사용성 향상
  - Layered Architecture 유지 (HAL → Custom HAL → Application)
  - 팀 프로젝트 협업 시 모듈화 및 테스트 용이

  ------

  ### 결론

  사용자 확장 HAL Layer는 HAL 구조를 직접 손상시키지 않으면서 프로젝트별 맞춤 기능을 추가할 수 있는 핵심적인 확장 방식이다.
   STM32CubeIDE 기반 프로젝트에서는 **“Custom HAL” 폴더를 별도로 두고 확장함수를 정의**하는 것이 이상적이며,
   이를 통해 ST의 코드 생성 및 업데이트 과정에서도 안정적인 유지보수가 가능하다.

------

## **6C. HAL 실습 및 문제 해결**

- ## 6C.1 GPIO / UART / ADC HAL 내부 동작 분석

  ### 개요

  HAL(Hardware Abstraction Layer)은 하드웨어 레지스터 접근을 추상화하여, 동일한 코드 구조로 다양한 STM32 시리즈를 지원하도록 설계된 계층이다.
   GPIO, UART, ADC와 같은 주변장치(Peripheral)는 HAL을 통해 초기화, 데이터 송수신, 인터럽트 관리가 수행된다.
   이 절에서는 각 주변장치별 HAL 내부 함수의 실제 동작 흐름과 주요 데이터 구조를 분석한다.

  ------

  ### HAL 동작 계층 요약

  ```
  Application (main.c)
   └── HAL Layer (stm32f1xx_hal_*.c)
        ├── HAL_Init(), HAL_Config(), HAL_Start()
        ├── HAL_IRQHandler(), HAL_Callback()
        └── LL (Low Layer) / Register 접근
             └── 하드웨어 레지스터
  ```

  HAL 함수는 대부분 다음 흐름을 따른다.

  1. **Handle 구조체 확인 및 초기화**
  2. **Register Level 설정 (LL 함수 호출)**
  3. **상태(State) 및 Lock 설정**
  4. **인터럽트 or Polling 모드 수행**
  5. **Callback 또는 Return 처리**

  ------

  ### GPIO HAL 내부 동작

  #### 주요 파일

  - `stm32f1xx_hal_gpio.c`
  - `stm32f1xx_hal_gpio_ex.c`
  - `stm32f1xx_hal_gpio.h`

  #### 대표 구조체

  ```
  typedef struct
  {
    uint32_t Pin;        /*!< GPIO 핀 번호 (GPIO_PIN_0~15) */
    uint32_t Mode;       /*!< GPIO 모드 (Input, Output, AF, Analog) */
    uint32_t Pull;       /*!< 풀업/풀다운 설정 */
    uint32_t Speed;      /*!< 출력 속도 */
  } GPIO_InitTypeDef;
  ```

  #### 초기화 함수 내부

  ```
  void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)
  {
      uint32_t position = 0x00u;
      uint32_t config = 0x00u;
      uint32_t currentmode = 0x00u;
  
      /* 1. 각 핀의 설정 비트 계산 */
      while (((GPIO_Init->Pin) >> position) != 0)
      {
          if ((GPIO_Init->Pin) & (1u << position))
          {
              /* 2. 모드에 따라 CNF[1:0], MODE[1:0] 설정 */
              currentmode = GPIO_Init->Mode;
              if ((currentmode & GPIO_MODE) == GPIO_MODE_OUTPUT_PP)
              {
                  config = GPIO_MODE_OUTPUT_PP | GPIO_Init->Speed;
              }
  
              /* 3. CRL 또는 CRH 레지스터 구성 */
              MODIFY_REG(GPIOx->CRL, (0xFu << (position * 4)), config << (position * 4));
  
              /* 4. 풀업/풀다운 설정 */
              if (GPIO_Init->Pull == GPIO_PULLUP)
                  SET_BIT(GPIOx->BSRR, (1u << position));
              else if (GPIO_Init->Pull == GPIO_PULLDOWN)
                  SET_BIT(GPIOx->BRR, (1u << position));
          }
          position++;
      }
  }
  ```

  #### 동작 요약

  1. 입력된 `GPIO_InitTypeDef` 구조체의 정보를 분석
  2. 해당 핀 위치의 설정 비트를 계산하여 CRL/CRH에 반영
  3. 풀업/풀다운 상태를 `BSRR`, `BRR`로 설정
  4. HAL 레벨에서는 에러 상태나 반환값 관리가 거의 없음 (LL 기반 접근)

  ------

  ### UART HAL 내부 동작

  #### 주요 파일

  - `stm32f1xx_hal_uart.c`
  - `stm32f1xx_hal_uart.h`

  #### 주요 구조체

  ```
  typedef struct
  {
    USART_TypeDef              *Instance;
    UART_InitTypeDef           Init;
    uint8_t                    *pTxBuffPtr;
    uint16_t                   TxXferSize;
    __IO uint16_t              TxXferCount;
    __IO HAL_UART_StateTypeDef gState;
    __IO HAL_UART_StateTypeDef RxState;
  } UART_HandleTypeDef;
  ```

  #### 초기화 함수 내부

  ```
  HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
  {
      /* 1. 주변 클록 활성화 */
      if (huart->Instance == USART1) __HAL_RCC_USART1_CLK_ENABLE();
  
      /* 2. GPIO 및 Peripheral 설정 */
      HAL_UART_MspInit(huart);
  
      /* 3. 레지스터 설정 */
      MODIFY_REG(huart->Instance->CR1, USART_CR1_M, huart->Init.WordLength);
      MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
      MODIFY_REG(huart->Instance->CR1, USART_CR1_PCE, huart->Init.Parity);
      MODIFY_REG(huart->Instance->BRR, 0xFFFFu, UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
  
      /* 4. UART Enable */
      SET_BIT(huart->Instance->CR1, USART_CR1_UE);
  
      return HAL_OK;
  }
  ```

  #### 송신 함수 (Polling 모드)

  ```
  HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
  {
      while (Size--)
      {
          while (!__HAL_UART_GET_FLAG(huart, UART_FLAG_TXE));   // 전송 가능 대기
          huart->Instance->DR = (*pData++ & 0xFF);
      }
      while (!__HAL_UART_GET_FLAG(huart, UART_FLAG_TC));        // 전송 완료 대기
      return HAL_OK;
  }
  ```

  #### 동작 요약

  1. `HAL_UART_Init()`에서 클록, GPIO, Baudrate 설정
  2. 송신 시 `UART_FLAG_TXE`, `UART_FLAG_TC` 플래그 확인
  3. 인터럽트 모드의 경우 `HAL_UART_IRQHandler()`에서 `ISR` 및 `Callback` 처리

  ------

  ### ADC HAL 내부 동작

  #### 주요 파일

  - `stm32f1xx_hal_adc.c`
  - `stm32f1xx_hal_adc_ex.c`

  #### 주요 구조체

  ```
  typedef struct
  {
    ADC_TypeDef                   *Instance;
    ADC_InitTypeDef               Init;
    __IO uint32_t                 State;
    HAL_LockTypeDef               Lock;
  } ADC_HandleTypeDef;
  ```

  #### 초기화 함수

  ```
  HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
  {
      /* 1. 클록 활성화 */
      __HAL_RCC_ADC1_CLK_ENABLE();
  
      /* 2. Calibration 비트 확인 */
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_CAL))
          CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_CAL);
  
      /* 3. Configuration 설정 */
      MODIFY_REG(hadc->Instance->CR2, ADC_CR2_ALIGN, hadc->Init.DataAlign);
      MODIFY_REG(hadc->Instance->CR1, ADC_CR1_SCAN, hadc->Init.ScanConvMode);
  
      return HAL_OK;
  }
  ```

  #### 변환 시작

  ```
  HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef *hadc)
  {
      SET_BIT(hadc->Instance->CR2, ADC_CR2_ADON);   // ADC Enable
      SET_BIT(hadc->Instance->CR2, ADC_CR2_SWSTART); // 소프트웨어 트리거
      return HAL_OK;
  }
  ```

  #### 변환 완료 폴링

  ```
  HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
  {
      while (!(READ_BIT(hadc->Instance->SR, ADC_SR_EOC))); // 변환 완료 대기
      return HAL_OK;
  }
  ```

  #### 값 읽기

  ```
  uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef *hadc)
  {
      return (uint32_t)(hadc->Instance->DR);
  }
  ```

  #### 동작 요약

  1. `HAL_ADC_Init()`에서 클록 및 설정 수행
  2. `HAL_ADC_Start()`으로 변환 시작
  3. `HAL_ADC_PollForConversion()`으로 변환 완료 감시
  4. `HAL_ADC_GetValue()`로 결과값 읽기
  5. 인터럽트 및 DMA 모드는 내부적으로 콜백 기반으로 처리됨 (`HAL_ADC_IRQHandler()` → `HAL_ADC_ConvCpltCallback()` 호출)

  ------

  ### HAL 내부 공통 흐름 요약

  | 단계          | 내용                               | 주요 함수                                  |
  | ------------- | ---------------------------------- | ------------------------------------------ |
  | 초기화        | 주변장치 클록 및 핸들 설정         | HAL_xxx_Init()                             |
  | 동작 시작     | Enable 비트 및 트리거 설정         | HAL_xxx_Start()                            |
  | 상태 모니터링 | Flag / Interrupt 감시              | HAL_xxx_PollForXxx(), HAL_xxx_IRQHandler() |
  | 데이터 처리   | 변환 또는 송수신                   | HAL_xxx_GetValue(), HAL_xxx_Transmit()     |
  | 완료 후 처리  | Callback 또는 상태 플래그 업데이트 | HAL_xxx_CompleteCallback()                 |

  ------

  ### 결론

  GPIO, UART, ADC 등 HAL의 핵심은 **Handle 기반 추상화와 LL 함수 호출을 통한 레지스터 조작 자동화**이다.
   HAL 내부는 대부분의 하드웨어 제어를 **비트 연산과 매크로를 통해 직접 수행**하며,
   사용자는 상위 API만 호출함으로써 하드웨어 세부 구현을 몰라도 된다.
   그러나 시스템 최적화나 디버깅을 위해서는 이러한 내부 구조를 이해하고,
   필요 시 **LL 또는 Register-Level 접근**으로 전환하는 것이 필수적이다.

- ## 6C.2 DMA + HAL 연동 디버깅

  ### 개요

  DMA(Direct Memory Access)는 주변장치(Peripheral)와 메모리 간 데이터 전송을 CPU 개입 없이 수행하는 하드웨어 모듈이다.
   STM32의 HAL은 DMA를 추상화하여, **ADC, UART, SPI, I²C, TIM 등** 다양한 주변장치에서 효율적으로 사용할 수 있도록 통합 인터페이스를 제공한다.
   그러나 DMA 기반 전송은 Polling 또는 Interrupt 모드보다 동작이 복잡하며, HAL 내부 상태 및 인터럽트 흐름을 정확히 이해하지 못하면 디버깅이 어려워진다.
   이 절에서는 HAL 기반 DMA 연동 구조를 분석하고, 디버깅 포인트와 실제 실습 예시를 제시한다.

  ------

  ### DMA 동작 기본 구조

  ```
  Memory <──> DMA Controller <──> Peripheral Register
  ```

  DMA는 다음과 같은 방식으로 작동한다.

  1. 주변장치 또는 소프트웨어에서 DMA 요청 발생 (Trigger)
  2. DMA Controller가 Source와 Destination 주소를 읽음
  3. 설정된 데이터 크기만큼 자동 전송
  4. 전송 완료 후 Interrupt 발생 (`Transfer Complete`, `Half Transfer`, `Error`)
  5. HAL DMA Callback을 통해 애플리케이션에 통보

  ------

  ### HAL DMA 구조

  #### 주요 파일

  - `stm32f1xx_hal_dma.c`
  - `stm32f1xx_hal_dma.h`
  - `stm32f1xx_hal_adc.c`, `stm32f1xx_hal_uart.c` (DMA 연동 부분 포함)

  #### DMA 핸들 구조체

  ```
  typedef struct
  {
    DMA_Channel_TypeDef   *Instance;     /*!< DMA 채널 레지스터 */
    DMA_InitTypeDef       Init;          /*!< 초기화 설정 구조체 */
    HAL_LockTypeDef       Lock;          /*!< 동시 접근 보호 */
    __IO HAL_DMA_StateTypeDef State;     /*!< DMA 상태 (READY/BUSY/ERROR 등) */
    void                  *Parent;       /*!< 상위 주변장치 핸들 참조 */
    void(* XferCpltCallback)(struct __DMA_HandleTypeDef *hdma); /*!< 전송 완료 콜백 */
    void(* XferHalfCpltCallback)(struct __DMA_HandleTypeDef *hdma);
    void(* XferErrorCallback)(struct __DMA_HandleTypeDef *hdma);
  } DMA_HandleTypeDef;
  ```

  DMA 핸들은 HAL 내부에서 각 주변장치 핸들과 연결되어 관리된다.
   예를 들어 `ADC_HandleTypeDef`에는 다음과 같은 멤버가 포함되어 있다.

  ```
  typedef struct
  {
    ADC_TypeDef                   *Instance;
    DMA_HandleTypeDef             *DMA_Handle;     /*!< ADC와 연결된 DMA 핸들 */
  } ADC_HandleTypeDef;
  ```

  ------

  ### DMA 초기화 및 연동 흐름

  #### 1. DMA 인스턴스 생성 및 설정

  ```
  DMA_HandleTypeDef hdma_adc1;
  
  hdma_adc1.Instance = DMA1_Channel1;
  hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
  hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
  hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
  hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
  hdma_adc1.Init.Mode = DMA_CIRCULAR;
  hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
  HAL_DMA_Init(&hdma_adc1);
  ```

  #### 2. 주변장치 핸들과 DMA 핸들 연결

  ```
  __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);
  ```

  이 매크로는 `hadc1->DMA_Handle = &hdma_adc1;` 와 동일하며,
   HAL 내부 콜백 시 DMA 이벤트를 ADC 핸들과 연결해준다.

  #### 3. DMA 및 Peripheral 동시 시작

  ```
  HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adcBuffer, 8);
  ```

  `HAL_ADC_Start_DMA()` 내부 구조:

  ```
  HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
  {
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
  
      /* DMA 전송 시작 */
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
  
      /* ADC 변환 시작 */
      SET_BIT(hadc->Instance->CR2, ADC_CR2_ADON | ADC_CR2_DMA | ADC_CR2_SWSTART);
      return HAL_OK;
  }
  ```

  ------

  ### DMA 인터럽트 흐름

  DMA 인터럽트는 각 채널에 대해 `DMAx_Channelx_IRQHandler()`에서 처리된다.

  1. DMA 전송 완료 → `DMA_FLAG_TC` 세트
  2. HAL DMA IRQ 핸들러 호출
  3. 내부적으로 콜백 함수(`XferCpltCallback`) 호출
  4. ADC/UART 등의 상위 계층으로 이벤트 전달

  ```
  void DMA1_Channel1_IRQHandler(void)
  {
      HAL_DMA_IRQHandler(&hdma_adc1);
  }
  ```

  `HAL_DMA_IRQHandler()` 내부:

  ```
  void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
  {
      if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TC1))
      {
          __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TC1);
          hdma->State = HAL_DMA_STATE_READY;
          if (hdma->XferCpltCallback != NULL)
              hdma->XferCpltCallback(hdma);
      }
  }
  ```

  ADC 예시에서 이 콜백은 `ADC_DMAConvCplt()`를 호출하며,
   이는 다시 `HAL_ADC_ConvCpltCallback()`을 호출한다.

  ------

  ### DMA 디버깅 절차

  #### 1. DMA 채널 매핑 확인

  - CubeMX의 **DMA Settings 탭**에서 Peripheral ↔ DMA Channel 연결 확인
  - 예: `ADC1 → DMA1_Channel1`, `USART1_TX → DMA1_Channel4`

  #### 2. 인터럽트 활성화 확인

  ```
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
  ```

  #### 3. 상태 변수 추적

  디버거에서 `hdma_adc1.State`, `hdma_adc1.ErrorCode`를 관찰

  - `HAL_DMA_STATE_BUSY`: 전송 중
  - `HAL_DMA_STATE_READY`: 완료
  - `HAL_DMA_STATE_ERROR`: 전송 실패

  #### 4. Callback 진입 확인

  `HAL_ADC_ConvCpltCallback()` 브레이크포인트 설정

  - DMA 전송 완료 후 실제 콜백이 호출되는지 확인
  - ADC DMA 전송 길이(`Length`)와 버퍼 크기 일치 여부 점검

  #### 5. NVIC 우선순위 문제 확인

  DMA, ADC, TIM 인터럽트의 우선순위가 잘못될 경우 콜백이 호출되지 않거나 지연됨.
   특히 FreeRTOS와 함께 사용하는 경우, `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY` 이하로 설정 필요.

  ------

  ### DMA 관련 주요 HAL 매크로

  | 매크로                    | 설명                               |
  | ------------------------- | ---------------------------------- |
  | `__HAL_LINKDMA()`         | Peripheral ↔ DMA 핸들 연결         |
  | `__HAL_DMA_ENABLE()`      | DMA 채널 활성화                    |
  | `__HAL_DMA_DISABLE()`     | DMA 채널 비활성화                  |
  | `__HAL_DMA_GET_FLAG()`    | 전송 완료, Half, Error 플래그 확인 |
  | `__HAL_DMA_CLEAR_FLAG()`  | DMA 플래그 클리어                  |
  | `__HAL_DMA_GET_COUNTER()` | 남은 전송 데이터 수 확인           |

  ------

  ### 디버깅 시 자주 발생하는 문제

  | 증상                        | 원인                         | 해결 방법                                                    |
  | --------------------------- | ---------------------------- | ------------------------------------------------------------ |
  | DMA 전송이 시작되지 않음    | 클록 미활성화, NVIC 비활성화 | `__HAL_RCC_DMA1_CLK_ENABLE()` 확인                           |
  | 콜백이 호출되지 않음        | IRQ 핸들 누락                | `DMAx_Channelx_IRQHandler()` 내 `HAL_DMA_IRQHandler()` 호출 여부 확인 |
  | 데이터 손상 또는 오버플로   | Circular 모드 버퍼 크기 오류 | 버퍼 크기와 Length 일치 확인                                 |
  | HAL_DMA_Init() 실패         | 인스턴스 중복                | 동일 채널 중복 초기화 금지                                   |
  | FreeRTOS 환경에서 콜백 누락 | 우선순위 충돌                | DMA IRQ Priority 조정 (configMAX_SYSCALL_INTERRUPT_PRIORITY 이하) |

  ------

  ### DMA 디버깅 실습 예시 — ADC 연속 샘플링

  ```
  uint16_t adcBuffer[16];
  
  void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
  {
      printf("DMA Transfer Complete. Last Value = %d\r\n", adcBuffer[15]);
  }
  
  void ADC_DMA_Test(void)
  {
      HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adcBuffer, 16);
  }
  ```

  - **중단점 설정:** `HAL_ADC_ConvCpltCallback()`
  - **변수 관찰:** `adcBuffer[]`, `hdma_adc1.State`
  - **DMA1_Channel1_IRQHandler()** 호출 여부 확인

  ------

  ### 결론

  HAL 기반 DMA 연동은 Peripheral → DMA → NVIC → Callback 구조로 이루어진다.
   디버깅 시 가장 중요한 점은 **DMA 핸들의 상태(State)와 콜백 흐름을 추적**하는 것이다.
   CubeIDE에서는 **“Peripheral Registers”**, **“Expressions”**, **“NVIC 활성 상태”** 탭을 병행하여
   DMA 동작을 단계별로 확인하면 문제 원인을 빠르게 파악할 수 있다.
   DMA 디버깅을 체계적으로 수행하면 HAL 기반 시스템의 성능과 안정성을 동시에 확보할 수 있다.

- ## 6C.3 Interrupt 기반 HAL 코드 구조 분석

  ### 개요

  STM32 HAL은 **Polling**, **Interrupt**, **DMA** 세 가지 주요 데이터 전송 방식을 제공한다.
   이 중 **Interrupt 기반 구조**는 실시간 응답성과 효율성을 동시에 확보할 수 있어
   GPIO, UART, ADC, TIM, EXTI 등 대부분의 주변장치에서 널리 사용된다.

  이 절에서는 HAL의 **Interrupt 기반 함수 호출 흐름**, **콜백 구조**, **IRQ 핸들러 내부 동작**을
   분석하고, 실제 디버깅 시 확인해야 할 주요 포인트를 정리한다.

  ------

  ### HAL Interrupt 구조의 핵심 개념

  Interrupt 기반 HAL 코드는 다음의 계층으로 구성된다.

  ```
  [Peripheral Hardware]
          │
          ▼
  [IRQ 발생 → NVIC]
          │
          ▼
  HAL_xxx_IRQHandler()
          │
          ▼
  내부 상태 업데이트 및 Callback 호출
          │
          ▼
  사용자 정의 HAL_xxx_Callback()
  ```

  즉, HAL은 **하드웨어 인터럽트를 NVIC → HAL IRQ 핸들러 → 사용자 콜백**으로 전달하는 추상화 계층이다.

  ------

  ### 인터럽트 기반 함수 호출 흐름

  #### 예: UART 수신 (Interrupt 기반)

  1. **사용자 코드**

     ```
     HAL_UART_Receive_IT(&huart1, rxBuffer, 8);
     ```

     - 인터럽트 기반 수신 시작 요청
     - UART 설정, 인터럽트 활성화, 내부 상태 변경 수행

  2. **HAL 내부 초기화 (HAL_UART_Receive_IT)**

     ```
     huart->RxState = HAL_UART_STATE_BUSY_RX;
     __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);   // RX Not Empty 인터럽트 활성화
     __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);    // 에러 인터럽트 활성화
     ```

  3. **하드웨어 이벤트 발생 (데이터 수신)**

     - RXNE(Receive Not Empty) 플래그 세트
     - NVIC가 `USART1_IRQHandler()` 실행

  4. **IRQ Handler → HAL 처리**

     ```
     void USART1_IRQHandler(void)
     {
         HAL_UART_IRQHandler(&huart1);
     }
     ```

  5. **HAL_UART_IRQHandler() 내부 처리**

     - RXNE, TXE, TC, ORE, FE 등 각종 플래그 검사
     - 플래그에 맞는 내부 처리 및 콜백 호출

     ```
     if (__HAL_UART_GET_IT(huart, UART_IT_RXNE) && __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE))
     {
         UART_Receive_IT(huart);
         return;
     }
     ```

  6. **콜백 호출 흐름**

     ```
     static void UART_Receive_IT(UART_HandleTypeDef *huart)
     {
         *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & 0xFF);
         if (--huart->RxXferCount == 0U)
         {
             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
             huart->RxState = HAL_UART_STATE_READY;
             HAL_UART_RxCpltCallback(huart);   // 사용자 콜백 호출
         }
     }
     ```

  7. **사용자 콜백 실행**

     ```
     void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
     {
         printf("UART RX Complete: %s\r\n", rxBuffer);
     }
     ```

  ------

  ### 주요 HAL IRQ 핸들러 구조

  #### 1. EXTI (GPIO Interrupt)

  ```
  void EXTI15_10_IRQHandler(void)
  {
      HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
  }
  ```

  `HAL_GPIO_EXTI_IRQHandler()` 내부:

  ```
  void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
  {
      if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
      {
          __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
          HAL_GPIO_EXTI_Callback(GPIO_Pin);
      }
  }
  ```

  사용자 콜백:

  ```
  void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
  {
      if (GPIO_Pin == GPIO_PIN_13)
          HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  }
  ```

  ------

  #### 2. TIM (Timer Interrupt)

  ```
  void TIM2_IRQHandler(void)
  {
      HAL_TIM_IRQHandler(&htim2);
  }
  ```

  `HAL_TIM_IRQHandler()` 내부:

  ```
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
  {
      if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
      {
          __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
          HAL_TIM_PeriodElapsedCallback(htim);
      }
  }
  ```

  사용자 콜백:

  ```
  void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
  {
      if (htim->Instance == TIM2)
          HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  }
  ```

  ------

  #### 3. ADC (End of Conversion Interrupt)

  ```
  void ADC1_2_IRQHandler(void)
  {
      HAL_ADC_IRQHandler(&hadc1);
  }
  ```

  내부 처리:

  ```
  if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC))
  {
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
      HAL_ADC_ConvCpltCallback(hadc);
  }
  ```

  ------

  ### HAL 콜백 메커니즘 정리

  | 콜백 함수                         | 주변장치 | 호출 시점                |
  | --------------------------------- | -------- | ------------------------ |
  | `HAL_GPIO_EXTI_Callback()`        | GPIO     | 외부 핀 인터럽트 발생 시 |
  | `HAL_UART_TxCpltCallback()`       | UART     | 송신 완료 시             |
  | `HAL_UART_RxCpltCallback()`       | UART     | 수신 완료 시             |
  | `HAL_TIM_PeriodElapsedCallback()` | Timer    | 타이머 주기 도달 시      |
  | `HAL_ADC_ConvCpltCallback()`      | ADC      | 변환 완료 시             |
  | `HAL_I2C_MasterTxCpltCallback()`  | I²C      | 전송 완료 시             |
  | `HAL_SPI_TxRxCpltCallback()`      | SPI      | 송수신 완료 시           |

  이러한 콜백은 `__weak` 키워드로 선언되어 있으며,
   사용자가 동일 이름으로 재정의하면 자동으로 사용자 버전이 호출된다.

  ------

  ### 인터럽트 기반 HAL의 상태 관리

  각 HAL 핸들에는 상태 변수가 존재하여, 동작 중 상태를 추적한다.

  ```
  typedef enum
  {
    HAL_UART_STATE_RESET      = 0x00U,
    HAL_UART_STATE_READY      = 0x20U,
    HAL_UART_STATE_BUSY       = 0x24U,
    HAL_UART_STATE_BUSY_TX    = 0x21U,
    HAL_UART_STATE_BUSY_RX    = 0x22U,
    HAL_UART_STATE_BUSY_TX_RX = 0x23U,
    HAL_UART_STATE_TIMEOUT    = 0xA0U,
    HAL_UART_STATE_ERROR      = 0xE0U
  } HAL_UART_StateTypeDef;
  ```

  디버깅 시 `huart1.gState`, `huart1.RxState`를 확인하면 현재 동작 상태를 파악할 수 있다.

  ------

  ### NVIC 설정 및 우선순위

  Interrupt 기반 HAL 코드가 정상 작동하려면 NVIC 설정이 반드시 필요하다.

  ```
  HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(USART1_IRQn);
  ```

  FreeRTOS와 병행할 경우,
   우선순위는 `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY` 이하로 제한해야 한다.

  ------

  ### 디버깅 절차

  1. **IRQ Handler 등록 확인**
     - `startup_stm32f1xx.s`에서 해당 IRQ 벡터가 `HAL_xxx_IRQHandler()`를 호출하는지 확인
  2. **NVIC 활성화 여부 점검**
     - `HAL_NVIC_EnableIRQ()` 누락 시 인터럽트가 발생하지 않음
  3. **플래그 확인**
     - `__HAL_UART_GET_FLAG()`, `__HAL_GPIO_EXTI_GET_IT()` 등으로 인터럽트 발생 여부 확인
  4. **콜백 진입 확인**
     - `HAL_xxx_CpltCallback()` 내에 Breakpoint 설정
  5. **상태 변수 모니터링**
     - Peripheral Handle의 `.State` 필드 값이 `BUSY`에서 `READY`로 전환되는지 확인

  ------

  ### 예시 실습 — UART Interrupt 수신

  ```
  uint8_t rxBuffer[8];
  
  void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
  {
      HAL_UART_Transmit(&huart1, rxBuffer, 8, 100);
      HAL_UART_Receive_IT(&huart1, rxBuffer, 8);   // 다음 수신 준비
  }
  
  void UART_IT_Test(void)
  {
      HAL_UART_Receive_IT(&huart1, rxBuffer, 8);
  }
  ```

  - USART1 IRQ 발생 시 `USART1_IRQHandler()` → `HAL_UART_IRQHandler()` → `HAL_UART_RxCpltCallback()` 순서로 호출
  - 디버거에서 `rxBuffer` 내용 확인 가능

  ------

  ### 정리

  | 구분        | Polling 모드     | Interrupt 모드        | DMA 모드         |
  | ----------- | ---------------- | --------------------- | ---------------- |
  | CPU 개입    | 매 전송마다 필요 | 이벤트 발생 시만 개입 | 거의 없음        |
  | 응답 지연   | 짧음             | 매우 짧음             | 일정 (버퍼 단위) |
  | 코드 복잡도 | 낮음             | 중간                  | 높음             |
  | 실시간성    | 낮음             | 높음                  | 버퍼 기반        |

  **Interrupt 기반 HAL 코드**는 실시간 처리가 필요한 센서 입력, 버튼 이벤트, UART 통신 등에서
   가장 효율적인 구조이며, HAL 내부 IRQ 핸들러 흐름과 콜백 메커니즘을 이해하면
   모든 주변장치의 동작을 예측 가능하게 제어할 수 있다.

- ## 6C.4 HAL 동작 중단 / 응답 지연 문제 해결

  ### 개요

  임베디드 시스템 개발 과정에서 HAL 기반 코드가 **갑자기 멈추거나 응답이 느려지는 문제**는 빈번하게 발생한다.
   이 현상은 대부분 **인터럽트 처리 누락**, **플래그 오동작**, **버스 충돌**, **DMA 상태 불일치**,
   또는 **Tick(시스템 타이머) 중단** 등으로 인해 발생한다.

  이 절에서는 HAL의 **중단·응답 지연 원인**을 체계적으로 분석하고,
   **디버깅 및 해결 절차**를 단계별로 제시한다.

  ------

  ### 주요 증상 분류

  | 증상                       | 주요 원인                    | 대표 예시                       |
  | -------------------------- | ---------------------------- | ------------------------------- |
  | HAL 함수가 리턴하지 않음   | 내부 Busy/Timeout 대기 루프  | `HAL_UART_Transmit()` 무한 대기 |
  | HAL Delay 작동 안 함       | SysTick 타이머 중단          | RTOS 전환 시 발생               |
  | Callback 호출 안 됨        | NVIC 미설정, 플래그 미클리어 | EXTI, UART IRQ 누락             |
  | DMA 종료 안 됨             | DMA Flag 미처리, ISR 누락    | ADC DMA 전송 완료 안 됨         |
  | HAL 상태가 `HAL_BUSY` 고정 | Handle 상태 미갱신           | UART 수신 중 에러 발생          |

  ------

  ### 1️⃣ HAL 내부 구조상의 Blocking 특성

  #### HAL의 Busy-wait 루프

  많은 HAL 함수는 Polling 기반 대기 루프를 포함한다.
   예를 들어 `HAL_UART_Transmit()`은 전송 완료 플래그가 세트될 때까지 반복 대기한다.

  ```
  while (!__HAL_UART_GET_FLAG(huart, UART_FLAG_TC))
  {
      if (HAL_GetTick() - tickstart > Timeout)
          return HAL_TIMEOUT;
  }
  ```

  #### 문제 원인

  - `SysTick`이 멈추면 `HAL_GetTick()`이 증가하지 않아 Timeout 루프 탈출 불가
  - IRQ 우선순위에 의해 TC 플래그가 갱신되지 않음
  - NVIC 비활성화 상태에서 인터럽트 대기 루프 진입

  #### 해결 방법

  - `SysTick` 또는 타이머 Tick이 정상 동작하는지 확인
  - NVIC 인터럽트 활성화 확인 (`HAL_NVIC_EnableIRQ()`)
  - HAL 함수 내 Timeout 값을 늘리거나, Non-blocking(Interrupt) 모드 사용

  ------

  ### 2️⃣ HAL Delay / Tick 정지 문제

  #### 현상

  `HAL_Delay()`가 작동하지 않거나 무한 대기로 멈춤

  #### 원인

  1. `SysTick_Handler()`가 호출되지 않음
  2. FreeRTOS 사용 중 HAL Tick이 RTOS Tick으로 전환되지 않음
  3. `uwTick` 변수가 증가하지 않음 (전역 Tick 멈춤)

  #### 확인 방법

  ```
  extern __IO uint32_t uwTick;
  printf("Tick: %lu\r\n", uwTick);
  HAL_Delay(1000);
  printf("Tick: %lu\r\n", uwTick);
  ```

  Tick 값이 변하지 않으면 SysTick 정지 상태임

  #### 해결책

  - `SysTick_Config(SystemCoreClock / 1000);` 로 Tick 재설정

  - FreeRTOS 사용 시 `HAL_InitTick()`을 `osSystickHandler()`와 동기화

  - `uwTickPrio` (SysTick 우선순위) 확인

    ```
    HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(SysTick_IRQn);
    ```

  ------

  ### 3️⃣ NVIC 및 인터럽트 관련 문제

  #### 현상

  - Callback이 호출되지 않음
  - IRQ는 등록되어 있으나 실제 벡터에서 핸들러 미연결

  #### 점검 절차

  1. **Startup 파일(`startup_stm32f1xx.s`) 확인**

     ```
     .word USART1_IRQHandler
     ```

     → 해당 IRQ 핸들러가 올바르게 등록되어 있는지 확인

  2. **NVIC 설정 확인**

     ```
     HAL_NVIC_SetPriority(USART1_IRQn, 0, 1);
     HAL_NVIC_EnableIRQ(USART1_IRQn);
     ```

  3. **IRQ Handler 내부 호출 여부**

     ```
     void USART1_IRQHandler(void)
     {
         HAL_UART_IRQHandler(&huart1); // 반드시 포함
     }
     ```

  4. **인터럽트 플래그 클리어 여부**

     - 클리어되지 않으면 IRQ가 반복적으로 호출되거나, 이후 이벤트가 무시됨

     ```
     __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_13);
     __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
     ```

  ------

  ### 4️⃣ DMA 동작 중단 문제

  #### 현상

  ADC 또는 UART DMA 모드 사용 시 전송 완료가 발생하지 않음

  #### 원인

  - DMA 스트림이 올바르게 초기화되지 않음
  - NVIC의 DMA 채널 인터럽트 비활성화
  - DMA 전송 완료 플래그 미처리

  #### 디버깅 방법

  1. DMA 상태 변수 확인

     ```
     printf("DMA State: %d\r\n", hdma_adc1.State);
     ```

  2. DMA IRQ 활성화 여부

     ```
     HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
     ```

  3. DMA 완료 콜백 진입 여부

     ```
     void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
     {
         HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
     }
     ```

  4. DMA 설정 재초기화

     ```
     HAL_DMA_Abort(&hdma_adc1);
     HAL_DMA_DeInit(&hdma_adc1);
     HAL_DMA_Init(&hdma_adc1);
     ```

  ------

  ### 5️⃣ HAL Busy 상태 고착

  #### 현상

  `HAL_UART_Receive_IT()` 호출 후 `HAL_BUSY` 상태에서 해제되지 않음

  #### 원인

  - 수신 완료 플래그 미갱신
  - RXNE 플래그가 지워지지 않음
  - 수신 중간에 프레이밍/오버런 오류 발생

  #### 해결책

  1. 플래그 수동 클리어

     ```
     __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_ORE | UART_FLAG_FE);
     ```

  2. 상태 재설정

     ```
     huart->RxState = HAL_UART_STATE_READY;
     huart->gState  = HAL_UART_STATE_READY;
     ```

  3. DMA/Interrupt 동작 중단 후 재시작

     ```
     HAL_UART_Abort(&huart1);
     HAL_UART_Receive_IT(&huart1, rxBuffer, 8);
     ```

  ------

  ### 6️⃣ 전원 / 클럭 불일치

  #### 현상

  ADC, UART 등 특정 주변장치만 동작하지 않음

  #### 원인

  - RCC 클럭 Enable 누락 (`__HAL_RCC_xxx_CLK_ENABLE()`)
  - PLL/HSE 설정 불일치 → 주파수 mismatch

  #### 점검 항목

  ```
  __HAL_RCC_ADC1_CLK_ENABLE();
  __HAL_RCC_USART1_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  ```

  또한, `SystemClock_Config()` 내에서
   PLL 설정이 실제 MCU 스펙과 맞지 않을 경우
   주변장치의 타이밍 오차로 HAL Delay, UART BaudRate가 모두 비정상 작동할 수 있다.

  ------

  ### 7️⃣ 디버깅 절차 요약

  | 단계 | 점검 항목         | 확인 방법                         |
  | ---- | ----------------- | --------------------------------- |
  | 1    | SysTick 작동 여부 | Tick 증가 확인                    |
  | 2    | NVIC 활성화       | `HAL_NVIC_EnableIRQ()` 호출       |
  | 3    | IRQ Handler 연결  | startup 파일 확인                 |
  | 4    | Flag 처리 여부    | `__HAL_xxx_CLEAR_FLAG()` 호출     |
  | 5    | DMA 동작 확인     | DMA 상태 및 IRQ 활성화            |
  | 6    | HAL 상태 변수     | `.State` 확인 (`HAL_READY` 여부)  |
  | 7    | Clock Enable      | `__HAL_RCC_xxx_CLK_ENABLE()` 확인 |

  ------

  ### 8️⃣ 예시: HAL Delay 멈춤 해결

  #### 문제 코드

  ```
  HAL_Init();
  SystemClock_Config();
  // SysTick 미설정 상태
  HAL_Delay(1000); // 멈춤
  ```

  #### 수정 코드

  ```
  HAL_Init();
  SystemClock_Config();
  SysTick_Config(SystemCoreClock / 1000); // 1ms Tick 설정
  HAL_Delay(1000); // 정상 동작
  ```

  ------

  ### 9️⃣ 예시: UART Interrupt 응답 지연

  ```
  void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
  {
      HAL_UART_Receive_IT(huart, rxBuf, 8); // 다음 수신 즉시 준비
  }
  ```

  - 콜백 내에서 재호출 누락 시 수신 멈춤
  - NVIC 우선순위가 FreeRTOS보다 높으면 Task 전환 지연

  해결:

  ```
  HAL_NVIC_SetPriority(USART1_IRQn, 5, 0); // RTOS 안전 수준
  ```

  ------

  ### 결론

  HAL의 응답 지연 및 중단 문제는
   대부분 **SysTick, NVIC, DMA, State 관리 불일치**로 인한 결과다.

  HAL은 고수준 추상화 계층이지만 내부적으로 **Polling 루프**와 **Interrupt Flag 기반 상태 전이**를 사용하기 때문에,
   이 구조를 명확히 이해하고 각 단계의 **IRQ, Flag, State, Clock**을 체계적으로 점검해야 안정적인 동작을 확보할 수 있다.

- ## 6C.5 HAL Init 순서 오류 / Clock 미설정 사례

  ### 개요

  STM32 HAL 기반 프로젝트에서 `HAL_Init()`과 `SystemClock_Config()`의 **호출 순서나 누락**은 주변장치 초기화 실패, 타이밍 불일치, `HAL_ERROR` 발생 등 다양한 문제를 유발한다. 이 단원에서는 올바른 초기화 순서와 실제 오류 사례를 통해 HAL 초기화 과정을 명확히 이해한다.

  ------

  ### HAL_Init() 이전에 주변장치 접근 시 문제점

  - `HAL_Init()`은 NVIC, SysTick, RCC 등의 **기본 HAL 레이어 초기화**를 담당한다.
  - 이 호출이 누락되거나 GPIO/ADC 초기화보다 뒤에 있으면 다음과 같은 문제가 발생한다:
    - `HAL_GPIO_Init()` 수행 시 **Clock Enable 미완료 오류**
    - `HAL_Delay()` 사용 시 SysTick 미구동으로 **무한 대기 루프 진입**
    - `HAL_UART_Init()` 중 **BRR 레지스터 계산 오류** 발생

  ------

  ### SystemClock_Config() 누락 또는 순서 오류

  - `HAL_Init()` 이후에 반드시 **SystemClock_Config()**가 실행되어야 한다.
  - 이를 누락할 경우 기본적으로 내부 클럭 **HSI(8MHz)**로 동작하며,
     타이머, UART, ADC의 속도 계산이 모두 잘못된다.
  - **PLL 설정 오류**나 **HSE 안정화 지연**은 `HAL_TIMEOUT`을 유발할 수 있다.

  ------

  ### 잘못된 초기화 순서 예시 (오류 케이스)

  ```
  int main(void)
  {
      MX_GPIO_Init();      // ❌ HAL_Init() 전에 주변장치 접근
      HAL_Init();          
      SystemClock_Config();
  }
  ```

  - 결과: GPIO 동작 불안정, HAL 함수 오류 반환 (`HAL_ERROR`)

  ------

  ### 올바른 초기화 순서 예시 (정상 케이스)

  ```
  int main(void)
  {
      HAL_Init();                 // ✅ HAL 구조체 및 SysTick 초기화
      SystemClock_Config();       // ✅ 시스템 클럭 설정
      MX_GPIO_Init();             // ✅ 이후 주변장치 초기화
      MX_ADC1_Init();
  }
  ```

  ------

  ### 디버깅 포인트

  - `HAL_RCC_GetSysClockFreq()` 호출로 실제 시스템 클럭 확인
  - `HAL_StatusTypeDef` 반환값 (`HAL_ERROR`, `HAL_TIMEOUT`) 점검
  - CubeIDE의 **Clock Configuration** 탭에서 PLL 소스, Prescaler 검증

  ------

  ### 실습 과제

  1. `SystemClock_Config()`를 주석 처리하고 타이머 주기를 측정해 실제 주파수 차이 확인
  2. `HSE`, `HSI`, `PLL` 각각의 클럭 설정을 적용해 변화를 비교
  3. `HAL_Init()` 호출 위치를 바꾸어 GPIO 동작 오류를 직접 관찰

- ## 6C.6 Register-Level 코드 변환 실습 (HAL → LL → Register)

  ### 개요

  이 단원에서는 HAL(Hardware Abstraction Layer) 기반 코드가 실제로 어떻게 하드웨어 레지스터를 제어하는지 분석하고, HAL → LL → Register 수준으로 직접 변환하는 과정을 다룬다. 각 계층의 코드 구조, 성능, 제어 자유도를 비교하여 HAL이 감추는 하드웨어 동작을 명확히 이해하는 것을 목표로 한다.

  ------

  ### 학습 목표

  - HAL, LL, Register 레벨 접근 방식의 차이점 이해
  - HAL API 호출의 내부 레지스터 동작 추적
  - LL 및 Register 접근을 통한 성능·자원 최적화 이해
  - CubeIDE 디버깅 도구로 레지스터 상태 실시간 관찰

  ------

  ### HAL ↔ LL ↔ Register 접근 구조

  | 구분     | 특징                                       | 코드 복잡도 | 실행속도  | 유지보수성 |
  | -------- | ------------------------------------------ | ----------- | --------- | ---------- |
  | HAL      | 하드웨어 추상화 계층. 구조체 기반 API 제공 | 높음        | 느림      | 매우 높음  |
  | LL       | 매크로 수준의 저수준 접근. CMSIS 호환      | 중간        | 빠름      | 중간       |
  | Register | 직접 레지스터 접근                         | 낮음        | 매우 빠름 | 낮음       |

  ------

  ### 예제 1: GPIO 출력 토글 비교

  **HAL 방식**

  ```
  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
  ```

  - 내부적으로 `HAL_GPIO_WritePin()` → `BSRR` 레지스터 접근 수행
  - 함수 호출 오버헤드 존재, 코드 가독성 높음

  **LL 방식**

  ```
  LL_GPIO_TogglePin(GPIOC, LL_GPIO_PIN_13);
  ```

  - HAL보다 얇은 추상화 계층
  - 인라인 매크로로 구현되어 성능 손실 거의 없음

  **Register 직접 접근**

  ```
  GPIOC->ODR ^= (1 << 13);
  ```

  - 단일 명령으로 비트 토글
  - 실행속도 최고, 단 유지보수성 낮음

  ------

  ### 예제 2: ADC 단일 변환

  **HAL 코드**

  ```
  HAL_ADC_Start(&hadc1);
  HAL_ADC_PollForConversion(&hadc1, 100);
  adc_val = HAL_ADC_GetValue(&hadc1);
  ```

  **LL 코드**

  ```
  LL_ADC_REG_StartConversionSWStart(ADC1);
  while (!LL_ADC_IsActiveFlag_EOC(ADC1));
  adc_val = LL_ADC_REG_ReadConversionData12(ADC1);
  ```

  **Register 코드**

  ```
  ADC1->CR2 |= ADC_CR2_SWSTART;
  while (!(ADC1->SR & ADC_SR_EOC));
  adc_val = ADC1->DR;
  ```

  ------

  ### 성능 및 코드 크기 비교

  | 접근 방식 | 코드 크기 | 실행 속도 | 유지보수성 | 이식성 | 디버깅 난이도 |
  | --------- | --------- | --------- | ---------- | ------ | ------------- |
  | HAL       | 가장 큼   | 느림      | 매우 높음  | 높음   | 쉬움          |
  | LL        | 중간      | 빠름      | 중간       | 높음   | 중간          |
  | Register  | 가장 작음 | 가장 빠름 | 낮음       | 낮음   | 어려움        |

  ------

  ### 디버깅 포인트

  - `stm32f1xx_hal_gpio.c` 및 `stm32f1xx_ll_gpio.c` 내부 구현 분석
  - CubeIDE “Disassembly View”에서 각 함수 호출 시 어셈블리 명령어 수 비교
  - `GPIOx->ODR`, `RCC->APB2ENR`, `ADCx->CR2` 등 핵심 레지스터 직접 확인
  - Watch / Live Expressions 기능으로 핀 상태 및 레지스터 변화 관찰

  ------

  ### 실습 과제

  1. HAL 기반 GPIO 제어 코드를 LL 및 Register 버전으로 변환
  2. 세 가지 접근 방식의 코드 실행 시간 측정
  3. CubeIDE 디버거에서 `GPIOC->ODR` 레지스터를 모니터링
  4. 각 방식의 코드 크기(`.text` 섹션 크기) 비교 및 리포트 작성

  

