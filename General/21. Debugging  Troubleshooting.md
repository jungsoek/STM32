# 21. Debugging / Troubleshooting

## 21.1 ST-Link / SWD / JTAG 구조

### 개요

ST-Link, SWD(Serial Wire Debug), JTAG(Joint Test Action Group)는 STM32 마이크로컨트롤러의 **프로그램 다운로드, 디버깅, 레지스터 접근**을 수행하기 위한 대표적인 하드웨어 인터페이스이다.
 이들은 MCU 내부의 **CoreSight Debug Interface (ARM Debug Architecture)**를 통해 CPU, 메모리, 주변장치에 직접 접근하며, 개발 중의 코드 제어, 실시간 변수 관찰, 펌웨어 업데이트를 가능하게 한다.

------

### ST-Link 개요

ST-Link는 STMicroelectronics에서 제공하는 **전용 디버그 인터페이스 및 프로그래머**로, SWD와 JTAG 프로토콜을 지원한다.
 개발 보드(Nucleo, Discovery)에 기본 내장되어 있으며, 독립형 장치(ST-Link V2, V3)로도 사용 가능하다.

| 버전       | 주요 특징                            | 인터페이스      | 지원 전압 |
| ---------- | ------------------------------------ | --------------- | --------- |
| ST-Link V1 | 초기형, JTAG 전용                    | JTAG            | 3.3V      |
| ST-Link V2 | SWD + SWV 지원                       | SWD, SWIM       | 1.65~3.6V |
| ST-Link V3 | 고속(USB HS), 가상 COM, 14/20핀 헤더 | SWD, JTAG, UART | 1.65~3.6V |

ST-Link는 **USB-Device Class 기반 CDC(가상 COM) + HID(Debug Interface)**로 동작하며,
 PC에서는 STM32CubeProgrammer, CubeIDE, Keil, IAR 등과 연동하여 사용된다.

------

### SWD (Serial Wire Debug) 구조

SWD는 ARM Cortex-M 계열 MCU에서 JTAG을 대체하기 위해 설계된 **2-wire 디버그 인터페이스**이다.
 전통적인 4~5개의 JTAG 핀 대신 **SWDIO, SWCLK** 두 개의 신호선만으로 동일한 디버그 기능을 수행한다.

| 핀           | 역할                            |
| ------------ | ------------------------------- |
| SWDIO        | 데이터 입출력 (Serial Wire I/O) |
| SWCLK        | 디버그 클록 (Serial Wire Clock) |
| SWO (선택적) | Serial Wire Output / Trace 출력 |
| NRST         | 시스템 리셋 (선택적 연결)       |
| GND          | 공통 접지                       |

#### 내부 동작

- SWD는 ARM Debug Access Port(DAP)를 통해 **Memory Access Port (MEM-AP)**와 **Core Access Port (CPU-AP)**에 접근한다.
- 이를 통해 MCU의 SRAM, Flash, Peripheral Register에 직접 접근이 가능하다.
- 디버거는 SWD를 통해 Breakpoint 설정, 단일 스텝, 변수 감시 등을 수행한다.

#### SWD 신호 타이밍 예시

```
Host → Target : [Start][APnDP][RnW][Addr][Parity][Stop]
Target → Host : [ACK][Data][Parity]
```

ACK 비트는 Target의 응답 상태(OK, WAIT, FAULT)를 의미하며, 오류 발생 시 재시도 로직을 수행한다.

------

### JTAG 구조

JTAG은 IEEE 1149.1 표준으로 정의된 **병렬 Boundary-Scan 디버그 및 테스트 인터페이스**이다.
 SWD보다 많은 핀을 사용하지만, **체인 방식으로 여러 디바이스를 직렬 연결**할 수 있다는 장점이 있다.

| 핀    | 설명             |
| ----- | ---------------- |
| TCK   | Test Clock       |
| TMS   | Test Mode Select |
| TDI   | Test Data In     |
| TDO   | Test Data Out    |
| nTRST | Test Reset       |
| GND   | Ground           |

#### JTAG 체인 연결 예시

```
TDI → [MCU1 TAP] → [MCU2 TAP] → TDO
```

- 각 TAP(Test Access Port)은 내부의 Instruction Register(IR)과 Data Register(DR)를 가진다.
- 디버거는 Shift-IR, Shift-DR 명령을 통해 특정 디바이스를 선택하여 접근한다.

------

### SWD와 JTAG 비교

| 구분          | SWD                   | JTAG                            |
| ------------- | --------------------- | ------------------------------- |
| 표준          | ARM 전용              | IEEE 1149.1                     |
| 신호선 수     | 2 (SWDIO, SWCLK)      | 4~5 (TDI, TDO, TMS, TCK, TRST)  |
| 디바이스 체인 | 단일 디바이스 전용    | 다중 디바이스 체인 가능         |
| 속도          | 약 4~10MHz            | 4~20MHz                         |
| 활용          | 디버깅, 펌웨어 업로드 | 디버깅, 보드 테스트, FPGA, CPLD |
| 지원 환경     | STM32, Cortex-M       | 범용 (MCU, FPGA 등)             |

STM32 시리즈는 대부분 SWD를 기본 활성화하며, 일부 고성능 라인(H7, F7 등)은 JTAG도 선택적으로 지원한다.

------

### ST-Link와 SWD의 연결 예시 (Nucleo / 외부 보드)

```
ST-Link        Target MCU
--------------------------------
SWCLK   ─────▶ SWCLK
SWDIO   ◀────▶ SWDIO
NRST    ─────▶ NRST
GND     ─────▶ GND
3.3V    ─────▶ VDD_TARGET (전압 검출)
```

- SWDIO와 SWCLK은 반드시 **100Ω 저항 직렬 연결** 또는 **리본 케이블 길이 최소화**가 권장된다.
- NRST 연결 시, 디버거에서 리셋 제어 및 펌웨어 진입 안정성을 높일 수 있다.

------

### ST-Link 통신 프로토콜 개요

ST-Link와 CubeIDE 간 통신은 USB HID 프로토콜을 기반으로 하며, 다음과 같은 명령 집합으로 구성된다.

| 명령 코드               | 기능                     |
| ----------------------- | ------------------------ |
| `STLINK_GET_VERSION`    | ST-Link 펌웨어 버전 요청 |
| `STLINK_DEBUG_ENTER`    | 디버그 모드 진입         |
| `STLINK_READMEM_32BIT`  | 32비트 메모리 읽기       |
| `STLINK_WRITEMEM_32BIT` | 32비트 메모리 쓰기       |
| `STLINK_FLASH_ERASE`    | Flash 영역 지우기        |
| `STLINK_FLASH_WRITE`    | Flash 데이터 쓰기        |
| `STLINK_RUN`            | MCU 실행 시작            |
| `STLINK_STEP`           | 단일 스텝 실행           |

------

### SWD를 통한 디버깅 예시 (CubeIDE)

1. **ST-Link 연결 후 MCU 인식 확인**
   - CubeIDE → Run → Debug Configurations → ST-Link 선택
2. **SWD Interface 설정**
   - Interface: SWD
   - Reset Mode: Software System Reset
3. **Flash Programming**
   - Download Firmware → Verify → Run
4. **디버깅 기능 사용**
   - Breakpoint / Watch Window / Peripheral Register View / Memory Dump

------

### 문제 해결 및 트러블슈팅

| 증상                     | 원인                                | 해결 방법                             |
| ------------------------ | ----------------------------------- | ------------------------------------- |
| "No target detected"     | 전원 미인가 또는 SWDIO/SWCLK 오연결 | GND/VDD 확인 및 배선 재검             |
| Flash Write 실패         | Flash Lock 상태                     | CubeProgrammer로 Read/Write Unprotect |
| NRST 미연결 시 리셋 불가 | NRST 핀 비활성                      | NRST 연결 및 설정 확인                |
| 통신 속도 불안정         | 케이블 길이 과도                    | 짧은 케이블, 노이즈 필터 적용         |

------

### 결론

- **ST-Link**는 STM32 개발을 위한 공식 디버그/프로그래밍 도구이며, **SWD**는 ARM Cortex-M MCU에 최적화된 경량 디버그 인터페이스이다.
- **JTAG**은 다중 디바이스 체인과 범용 테스트 환경에서 유용하나, 소형 MCU에서는 SWD가 주로 사용된다.
- 개발 및 디버깅 환경에서 ST-Link + SWD 구성이 가장 안정적이며, CubeIDE와의 호환성이 뛰어나다.

## 21.2 Breakpoint, Watch, Live Expression

### 개요

디버깅 과정에서 Breakpoint, Watch, Live Expression은 MCU 내부의 실행 상태를 **정밀하게 분석**하기 위한 기본적인 도구이다.
 이들은 STM32CubeIDE, Keil, IAR 등과 같은 IDE에서 ST-Link + SWD 인터페이스를 통해 ARM Cortex-M CoreSight 디버그 포트를 조작하여,
 실행 중인 코드의 **정지, 변수 추적, 실시간 데이터 관찰**을 가능하게 한다.

------

### Breakpoint

#### 개념

Breakpoint는 MCU 코드 실행을 특정 명령 위치에서 **의도적으로 중단시키는 디버그 제어점**이다.
 이를 통해 개발자는 프로그램이 해당 지점에 도달했을 때의 **레지스터 상태, 변수 값, 메모리 내용**을 확인할 수 있다.

#### 종류

| 유형                             | 설명                                     | 특징                                     |
| -------------------------------- | ---------------------------------------- | ---------------------------------------- |
| **Software Breakpoint**          | Flash 코드에 `BKPT` 명령 삽입            | 코드 재프로그래밍 필요, Flash 소모 있음  |
| **Hardware Breakpoint**          | MCU의 하드웨어 비교기(Comparator)로 구현 | Flash 수정 없이 실시간 설정 가능         |
| **Conditional Breakpoint**       | 조건문을 만족할 때만 중단                | 디버거에서 연산 비교 수행                |
| **Watchpoint (Data Breakpoint)** | 특정 변수의 읽기/쓰기 시 정지            | DWT(데이터 감시 장치) 하드웨어 기능 사용 |

#### 설정 절차 (STM32CubeIDE 예시)

1. 코드 에디터 좌측 라인 번호 클릭 → **Breakpoints 추가**
2. “Breakpoint Properties”에서 조건 지정
   - Condition: `var_x > 1000`
   - Ignore Count: `5` (5회 실행 후 정지)
3. Debug 실행 시 해당 조건 도달 시 자동 중단

#### 동작 원리

- Cortex-M 코어에는 **Flash Patch and Breakpoint (FPB) Unit**이 존재하며, 최대 6~8개의 하드웨어 브레이크포인트를 설정할 수 있다.
- 실행 중인 명령어 주소가 FPB의 비교기 값과 일치하면 CPU가 Debug Monitor 예외를 발생시켜 즉시 중단한다.

#### 주의사항

- Flash 기반 MCU에서는 소프트웨어 브레이크포인트를 과다하게 설정할 경우 Flash 쓰기 횟수 증가로 수명 저하가 발생할 수 있다.
- 하드웨어 브레이크포인트 수는 제한적이므로 (F1 시리즈: 6개, F4 이상: 8개) 중요한 위치만 선택적으로 사용해야 한다.

------

### Watch

#### 개념

Watch는 디버깅 중 **특정 변수나 표현식의 현재 값**을 지속적으로 모니터링하는 기능이다.
 브레이크포인트 정지 상태뿐만 아니라, 일부 MCU에서는 실시간 추적(SWV)으로 변수 변화를 관찰할 수 있다.

#### Watch Window 사용 절차 (CubeIDE)

1. 디버그 세션 실행
2. `Window → Show View → Expressions` 선택
3. “Add New Expression” 클릭
   - 예: `adc_value`, `motor_speed * 0.1`, `sensor.status == 1`
4. 프로그램 정지 시 자동으로 현재 변수 값 표시

#### 내부 동작

- 디버거가 SWD를 통해 **SRAM 또는 Register 주소를 직접 읽어옴**
- Watch는 정지 상태에서만 접근 가능하며, MCU가 실행 중일 경우 값이 갱신되지 않는다.
- 단, SWV(Serial Wire Viewer)를 활성화하면 **실행 중에도 실시간 변수 모니터링**이 가능하다.

#### Watchpoint와 차이점

| 항목      | Watch               | Watchpoint                |
| --------- | ------------------- | ------------------------- |
| 기능      | 변수 값 관찰        | 변수 접근 시 중단         |
| 동작 시점 | 디버그 중 수동 조회 | MCU 실행 중 자동 정지     |
| 구현 방식 | IDE가 SWD로 읽기    | DWT 하드웨어 트리거       |
| 성능 영향 | 낮음                | 중간 (트리거 비교기 사용) |

------

### Live Expression

#### 개념

Live Expression은 SWV(Serial Wire Viewer) 기능을 이용하여 **코드를 멈추지 않고** 변수 값을 실시간으로 갱신 표시하는 기능이다.
 이는 특히 **FreeRTOS, 센서 데이터 수집, 모터 제어** 등에서 유용하다.

#### 설정 절차 (CubeIDE)

1. **Debug Configurations → SWV Trace 활성화**
   - Debug probe: ST-Link V2/V3
   - Interface: SWD
   - Core Clock: MCU System Clock (예: 72 MHz)
2. Debug 세션 시작 후, “Live Expressions” 창 열기
3. 변수 추가
   - 예: `temperature`, `pid_output`, `motor_pwm`
4. 실행 상태에서도 실시간으로 값이 갱신되는지 확인

#### 내부 구조

- Cortex-M 코어의 **ITM (Instrumentation Trace Macrocell)**과 **SWO(Serial Wire Output)** 핀을 통해 디버그 데이터가 전송된다.
- IDE는 ST-Link를 통해 ITM 채널에서 전송되는 값을 받아 그래프 형태로 시각화한다.

```
[CPU Variable] → [ITM Stimulus Port] → [SWO Pin] → [ST-Link] → [CubeIDE Live Expression]
```

#### 주요 제약

- SWO 핀이 연결되어 있어야 함 (일부 보드에서는 SWO 미배선)
- 전송 속도는 클록에 따라 제한됨 (일반적으로 1~8 MHz 수준)
- ITM 채널 수는 32개까지 지원

------

### 실시간 변수 시각화 예시

CubeIDE에서는 Live Expression 외에도 **SWV Data Trace Graph** 기능을 제공한다.
 다음은 실시간 PID 제어 변수 시각화 예시이다.

| 변수           | 설명           | 범위    |
| -------------- | -------------- | ------- |
| `setpoint`     | 목표값         | 0 ~ 100 |
| `sensor_value` | 입력 피드백 값 | 0 ~ 100 |
| `pid_output`   | 제어 출력      | 0 ~ 255 |

그래프 형태로 시간에 따른 값 변화를 모니터링하며, **오버슈트/지연/포화 구간 분석**이 가능하다.

------

### Breakpoint + Watch + Live Expression 통합 활용 예시

**예제: PWM 피드백 제어 루프 디버깅**

```
while (1) {
    adc_value = Read_ADC();
    pid_output = PID_Compute(setpoint, adc_value);
    Set_PWM(pid_output);
}
```

1. **Breakpoint**
   - `PID_Compute()` 함수 내부에 설정 → 중간 계산 과정 확인
2. **Watch**
   - `adc_value`, `pid_output`, `error` 값 모니터링
3. **Live Expression**
   - 실행 중 `pid_output`의 실시간 변동 확인
4. **결과 분석**
   - Breakpoint 정지 시 변수 상태 확인
   - Live Expression으로 출력 안정성 평가

------

### 문제 해결 팁

| 문제                               | 원인                        | 해결 방법                          |
| ---------------------------------- | --------------------------- | ---------------------------------- |
| Live Expression 값이 갱신되지 않음 | SWO 미연결 / 클록 설정 오류 | SWO 핀 연결 및 CPU Clock 일치 확인 |
| Breakpoint 설정 불가               | FPB 비교기 초과             | 불필요한 Breakpoint 제거           |
| Watch 값이 이상함                  | 최적화(O2 이상) 활성화      | Debug 빌드 (-Og)로 재빌드          |
| 변수 접근 시 하드폴트 발생         | 최적화에 의해 메모리 삭제됨 | `volatile` 지정 또는 Scope 유지    |

------

### 요약

| 항목            | 기능                | 하드웨어 지원                         |
| --------------- | ------------------- | ------------------------------------- |
| Breakpoint      | 코드 실행 중단      | FPB (Flash Patch and Breakpoint Unit) |
| Watch           | 변수 관찰 (정지 시) | SWD Read                              |
| Live Expression | 실행 중 실시간 관찰 | ITM + SWO + ST-Link                   |

이 세 가지 기능을 조합하면, STM32 시스템의 **실행 흐름, 변수 변화, 실시간 동작 상태**를 종합적으로 분석할 수 있다.

## 21.3 ITM / SWO / RTT 디버깅

### ITM (Instrumentation Trace Macrocell) 개요

- ITM은 **ARM Cortex-M 코어에 내장된 실시간 디버깅 및 로깅 인터페이스**로, 코드 실행에 영향을 거의 주지 않으면서 디버그 메시지를 출력할 수 있다.
- **printf 디버깅의 대체 수단**으로 사용되며, `SWO(Single Wire Output)`를 통해 PC로 문자열이나 이벤트를 전송한다.
- HAL 또는 CMSIS 레벨에서 `ITM_SendChar()` 함수를 통해 출력 가능하다.

#### 특징

- CPU 사이클 단위의 이벤트 추적 가능 (Instruction Trace는 ETM 필요)
- UART 대비 매우 빠른 출력 속도
- 최소한의 CPU 부하 (비동기 전송 방식)
- 실시간 운영체제(RTOS) 환경에서도 안정적으로 동작

#### 설정 절차

1. **CubeIDE Debug Configuration → SWV 활성화**

   - Debugger → SWV → Core Clock 입력
   - Port 0 Enable 체크

2. **코드 내 ITM 출력 함수 정의**

   ```
   int _write(int file, char *ptr, int len) {
       for (int i = 0; i < len; i++)
           ITM_SendChar(*ptr++);
       return len;
   }
   ```

3. **SWV Viewer에서 실시간 확인**

   - CubeIDE 상단의 “SWV Console” → Start Trace

------

### SWO (Single Wire Output)

- SWO는 **ITM, DWT, ETM 등 디버그 데이터를 단일 핀으로 출력**하는 기능이다.
- STM32의 경우 **SWCLK / SWDIO 외에 추가로 SWO 핀(PB3 등)** 을 연결해야 동작한다.
- ST-Link V2 이상, CubeIDE, Ozone, Keil uVision 등에서 지원한다.

#### 주요 용도

- **printf 대체 출력 (ITM Channel 0)**
- **변수 실시간 추적 (Data Watchpoint and Trace)**
- **이벤트 카운터 (Exception Entry, Interrupt, Sleep 모드 등)**

#### 설정 예시

- Debugger Interface: SWD + SWO
- ITM Channel 0 → printf 출력
- ITM Channel 1~31 → 사용자 정의 이벤트

------

### RTT (Real-Time Transfer, SEGGER J-Link)

- RTT는 **SEGGER J-Link 디버거에서 제공하는 고속 메모리 기반 로깅 인터페이스**이다.
- SWO보다 더 높은 전송 속도(최대 수 MB/s)를 제공하며, 별도 핀 연결이 필요 없다.
- 디버그 중에도 **RTOS 동작을 멈추지 않고 데이터 송수신**이 가능하다.

#### 원리

- MCU RAM 영역에 **RTT Control Block (Ring Buffer)** 를 생성
- J-Link가 디버그 인터페이스를 통해 해당 버퍼를 직접 읽는다.
- `SEGGER_RTT_WriteString()` 함수를 통해 문자열 출력 가능

#### 코드 예시

```
#include "SEGGER_RTT.h"

void app_log(void) {
    SEGGER_RTT_WriteString(0, "RTT log message\n");
}
```

#### 장점

- CPU 부하가 거의 없음
- 실시간 통신 (printf 블로킹 없음)
- PC에서 **J-Link RTT Viewer**, **Ozone** 등으로 확인 가능

------

### 비교 요약

| 항목          | ITM                    | SWO           | RTT                  |
| ------------- | ---------------------- | ------------- | -------------------- |
| 전송 경로     | SWO 핀                 | 단일 핀 (SWO) | JTAG/SWD 내부 메모리 |
| 속도          | 수백 kbps              | 수백 kbps     | 수 MB/s              |
| CPU 부하      | 매우 낮음              | 낮음          | 매우 낮음            |
| 하드웨어 필요 | SWO 핀 연결            | SWO 핀 필요   | J-Link 필요          |
| 실시간성      | 우수                   | 우수          | 매우 우수            |
| 사용 환경     | ST-Link, Keil, CubeIDE | ST-Link       | J-Link, Ozone        |

------

### 실습: ITM + SWO 디버그 메시지 출력

1. **하드웨어 연결**

   - SWO 핀(PB3 등)을 ST-Link와 연결
   - ST-Link 설정: SWD + SWO

2. **CubeIDE 설정**

   - Project → Properties → Debug Config → SWV 활성화
   - Core Clock 입력 (예: 72MHz)
   - SWO Viewer Enable

3. **코드 작성**

   ```
   #include "stm32f1xx_hal.h"
   #include <stdio.h>
   
   int _write(int file, char *ptr, int len) {
       for (int i = 0; i < len; i++)
           ITM_SendChar(*ptr++);
       return len;
   }
   
   void main(void) {
       HAL_Init();
       printf("System Initialized\n");
       while (1) {
           printf("Loop running...\n");
           HAL_Delay(1000);
       }
   }
   ```

4. **SWV 콘솔 확인**

   - 디버깅 시작 후 SWV Console → Start Trace
   - 실시간 출력 확인

------

### 실습: RTT 로그 출력

1. **J-Link 디버거 연결**

2. **SEGGER RTT 소스 추가 (`SEGGER_RTT.c`, `SEGGER_RTT.h`)**

3. **코드 작성**

   ```
   #include "SEGGER_RTT.h"
   
   int main(void) {
       HAL_Init();
       SEGGER_RTT_WriteString(0, "RTT Start\n");
       while (1) {
           SEGGER_RTT_printf(0, "Counter: %d\n", HAL_GetTick());
           HAL_Delay(1000);
       }
   }
   ```

4. **J-Link RTT Viewer 실행 → 실시간 로그 확인**

------

### 고급 활용

- RTOS Task별 로그 채널 분리 (Channel 0~3)
- 이벤트 기반 트레이싱 (Task Switch, Interrupt 발생 시 로그)
- 실시간 성능 모니터링:
  - DWT_CYCCNT 이용 CPU Load 계산
  - ITM 이벤트 트레이스와 결합하여 실행 시간 측정

## 21.4 HardFault_Handler 분석

### 개요

HardFault는 **ARM Cortex-M 코어에서 발생하는 가장 심각한 예외(Exception)** 중 하나로, 프로그램이 **잘못된 메모리 접근, 명령어 실행, 스택 손상, 버스 에러** 등을 일으킬 때 발생한다.
 이 예외는 시스템 동작을 즉시 중단시키며, **Fault Status Register(SCB 내)** 를 통해 원인을 진단할 수 있다.

HardFault를 정확히 분석하기 위해서는

1. 예외 진입 시점의 **레지스터 상태 복원**,
2. **Fault 관련 레지스터(SCB)** 의 디코딩,
3. **Call Stack 추적**
    이 세 가지를 수행해야 한다.

------

### 예외 발생 구조

#### 1. 예외 벡터 테이블

Cortex-M의 예외는 벡터 테이블에서 지정된다.
 HardFault는 **벡터 테이블의 세 번째 엔트리**에 위치한다.

```
__attribute__((section(".isr_vector")))
const void *g_pfnVectors[] = {
    &_estack,             // 초기 스택 포인터
    Reset_Handler,        // Reset
    NMI_Handler,          // NMI
    HardFault_Handler,    // HardFault (여기!)
    ...
};
```

#### 2. 예외 발생 시 자동 스택 저장 구조

HardFault가 발생하면 CPU는 자동으로 다음 레지스터를 **스택에 푸시(push)** 한다.

- R0, R1, R2, R3
- R12
- LR (Link Register)
- PC (Program Counter)
- xPSR (Program Status Register)

이 정보는 Fault 발생 당시의 실행 지점을 복원하는 데 필수적이다.

------

### 기본 HardFault_Handler 예제

일반적인 기본 핸들러는 다음과 같이 정의되어 있다.

```
void HardFault_Handler(void)
{
    while (1)
    {
        // 무한 루프 — 디버거에서 중단 후 상태 분석
    }
}
```

이 형태는 원인을 추적할 수 없기 때문에, **스택 포인터를 인자로 받아 Fault 당시의 레지스터 상태를 복원하는 커스텀 핸들러**를 작성해야 한다.

------

### 고급 분석용 HardFault 핸들러

#### 1. 스택 포인터 분기 처리

예외 발생 시 MSP(Main Stack Pointer) 또는 PSP(Process Stack Pointer) 중 하나가 사용되므로,
 어떤 스택이 사용 중인지 판단해야 한다.

```
void HardFault_Handler(void)
{
    __asm volatile
    (
        "TST lr, #4            \n"   // LR bit[2] = 0 → MSP, 1 → PSP
        "ITE EQ                \n"
        "MRSEQ r0, MSP         \n"
        "MRSNE r0, PSP         \n"
        "B HardFault_HandlerC  \n"   // C 함수로 분기
    );
}
```

#### 2. C 레벨 분석 함수

스택에 저장된 레지스터를 이용하여 PC, LR, xPSR 등의 값을 분석한다.

```
#include "stm32f1xx.h"
#include <stdio.h>

void HardFault_HandlerC(uint32_t *stack)
{
    uint32_t r0  = stack[0];
    uint32_t r1  = stack[1];
    uint32_t r2  = stack[2];
    uint32_t r3  = stack[3];
    uint32_t r12 = stack[4];
    uint32_t lr  = stack[5];
    uint32_t pc  = stack[6];
    uint32_t psr = stack[7];

    printf("\n[HardFault Detected]\n");
    printf("R0  = 0x%08lX\n", r0);
    printf("R1  = 0x%08lX\n", r1);
    printf("R2  = 0x%08lX\n", r2);
    printf("R3  = 0x%08lX\n", r3);
    printf("R12 = 0x%08lX\n", r12);
    printf("LR  = 0x%08lX\n", lr);
    printf("PC  = 0x%08lX\n", pc);
    printf("xPSR= 0x%08lX\n", psr);

    // SCB Fault Status Register 출력
    printf("CFSR = 0x%08lX\n", SCB->CFSR);
    printf("HFSR = 0x%08lX\n", SCB->HFSR);
    printf("DFSR = 0x%08lX\n", SCB->DFSR);
    printf("AFSR = 0x%08lX\n", SCB->AFSR);
    printf("MMFAR= 0x%08lX\n", SCB->MMFAR);
    printf("BFAR = 0x%08lX\n", SCB->BFAR);

    while (1);
}
```

------

### Fault Status Register 분석

| 레지스터                                      | 의미                                  | 주요 비트                                  |
| --------------------------------------------- | ------------------------------------- | ------------------------------------------ |
| **CFSR (Configurable Fault Status Register)** | Usage, Bus, MemManage Fault 정보 포함 |                                            |
| **HFSR (HardFault Status Register)**          | HardFault 발생 원인                   | `FORCED`(bit 30) : 다른 Fault로부터 전파됨 |
| **MMFAR (MemManage Fault Address Register)**  | 잘못된 메모리 접근 주소               |                                            |
| **BFAR (Bus Fault Address Register)**         | 버스 오류 주소                        |                                            |

#### CFSR 세부 비트 구조

- **Usage Fault (bits 16–25)**
  - `DIVBYZERO`: 0으로 나누기
  - `UNDEFINSTR`: 잘못된 명령어
  - `NOCP`: FPU 명령어 사용 시
- **Bus Fault (bits 8–15)**
  - `PRECISERR`: 정확한 버스 오류 (Faulting PC 식별 가능)
  - `IMPRECISERR`: 비정확한 버스 오류 (DMA 관련 가능성)
- **MemManage Fault (bits 0–7)**
  - `IACCVIOL`: 명령어 접근 위반
  - `DACCVIOL`: 데이터 접근 위반

------

### 디버깅 절차 요약

1. **HardFault 발생 시 디버거 중단**
   - PC 레지스터 위치 확인
   - Fault Status Register(CFSR, HFSR 등) 확인
2. **PC 값을 이용한 원인 코드 추적**
   - `Disassembly View`에서 PC 주소 주변 명령어 확인
   - 잘못된 포인터 접근, NULL Dereference, Stack Overflow 등 판단
3. **Stack Frame 복원**
   - R0~R3, PC, LR, xPSR을 확인하여 함수 호출 경로 추적
   - 필요시 Call Stack 수동 복원
4. **CFSR 비트 디코딩**
   - 해당 비트에 따라 Fault 종류 판별
   - 예: CFSR = 0x01000000 → Division by zero

------

### 예시 1: NULL 포인터 접근

```
uint32_t *ptr = NULL;
*ptr = 0x1234;  // HardFault 발생
```

- CFSR = 0x82 → **PRECISERR** (정확한 버스 오류)
- BFAR = 0x00000000 → 잘못된 주소 접근

------

### 예시 2: Stack Overflow

- LR = 0xFFFFFFFD (Thread 모드)
- PC는 스택 상단을 벗어난 주소
- CFSR = 0x00000001 → **IACCVIOL**

------

### 예시 3: 0으로 나누기

```
int a = 1;
int b = 0;
int c = a / b;
```

- CFSR = 0x02000000 → **DIVBYZERO**
- PC는 해당 명령어 주소를 가리킴

------

### 예시 4: 잘못된 함수 포인터 호출

```
void (*func)(void) = (void *)0x20000001;  // 잘못된 주소
func();
```

- CFSR = 0x00010000 → **UNDEFINSTR** (잘못된 명령어 실행)

------

### HardFault 분석 도구

| 도구                            | 설명                               |
| ------------------------------- | ---------------------------------- |
| **STM32CubeIDE Fault Analyzer** | 자동으로 CFSR/HFSR/PC 해석         |
| **arm-none-eabi-addr2line**     | PC 주소 → 소스 코드 라인 매핑      |
| **Keil / Ozone / J-Link**       | Fault 발생 시 자동 Stack Dump 표시 |

예시:

```
arm-none-eabi-addr2line -e build/project.elf 0x08001234
```

------

### 정리

| 분석 항목      | 내용                                        |
| -------------- | ------------------------------------------- |
| 핵심 원인      | 잘못된 주소 접근, 명령어 오류, 스택 손상 등 |
| 주요 레지스터  | CFSR, HFSR, BFAR, MMFAR                     |
| 복원 정보      | 스택 저장된 R0~PC, xPSR                     |
| 필수 분석 단계 | 스택 복원 → Fault Register 해석 → PC 역추적 |
| CubeIDE 실습   | SWV 콘솔에 Fault 로그 출력                  |

## 21.5 Stack Overflow / Heap Overflow 검출

### 개요

임베디드 시스템에서 **Stack Overflow**와 **Heap Overflow**는 치명적인 오류로, 예측 불가능한 동작(예: HardFault, 데이터 손상, 프로그램 비정상 종료)을 유발한다.
 특히 RTOS(FreeRTOS)나 인터럽트가 많은 환경에서는 **스택 크기 관리**와 **동적 메모리 감시**가 매우 중요하다.

Stack Overflow는 **스택 경계를 초과한 쓰기 연산**,
 Heap Overflow는 **할당된 영역 밖 메모리 쓰기 또는 해제 후 접근(UAF)** 으로 정의된다.

이 절에서는 STM32 및 FreeRTOS 환경에서 Stack/Heap Overflow 검출 방법과 실무적인 방어 기법을 다룬다.

------

### Stack Overflow 검출

#### Stack 구조 개요

STM32의 스택은 **RAM의 상단에서 하단으로 감소하는 방향**으로 성장한다.
 초기 스택 포인터는 벡터 테이블의 첫 번째 엔트리에 정의되어 있으며, `__main_stack_end__` 근처에서 시작한다.

```
RAM 상단 (예: 0x20005000)
│
│   ↓ (감소)
│  ┌──────────────┐
│  │ Stack 영역    │
│  ├──────────────┤
│  │ Heap 영역     │
│  ├──────────────┤
│  │ Data / BSS   │
│  ├──────────────┤
│  │ Vector Table │
│  └──────────────┘
RAM 하단 (예: 0x20000000)
```

------

### 정적 스택 크기 점검

1. **링커 스크립트 확인 (`STM32F103C8_FLASH.ld`)**

   ```
   _Min_Stack_Size = 0x400; /* 1 KB */
   ```

   이 값은 **최소 스택 크기 예약용**으로, 실제 사용량보다 작게 설정 시 Overflow 가능성이 높다.

2. **함수 호출 깊이 분석**
    재귀 호출, 대형 지역 배열 등은 스택 사용량을 급격히 증가시킨다.
    → `arm-none-eabi-size` 및 `arm-none-eabi-nm` 명령으로 확인 가능

------

### FreeRTOS 환경에서 Stack Overflow 검출

FreeRTOS는 태스크별 스택을 개별적으로 관리하며, 각 스택의 경계를 감시하는 메커니즘을 제공한다.

#### 설정

`FreeRTOSConfig.h`에서 다음 매크로를 활성화한다.

```
#define configCHECK_FOR_STACK_OVERFLOW 2
#define configUSE_MALLOC_FAILED_HOOK   1
```

#### 콜백 함수 구현

스택이 초과될 경우 아래의 콜백이 자동 호출된다.

```
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    printf("\n[Stack Overflow Detected] Task: %s\n", pcTaskName);
    taskDISABLE_INTERRUPTS();
    while(1);
}
```

**감시 모드 유형**

- `configCHECK_FOR_STACK_OVERFLOW = 1`: 단순한 스택 경계 체크
- `configCHECK_FOR_STACK_OVERFLOW = 2`: 스택 끝 부분에 보호 패턴을 검사 (추천)

------

### 런타임 스택 사용량 측정

FreeRTOS는 각 태스크별 **최대 스택 사용량(High Water Mark)** 을 측정할 수 있다.

```
UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
printf("Remaining stack words: %lu\n", uxHighWaterMark);
```

또는 모든 태스크에 대해 한 번에 확인:

```
vTaskList(buffer);  // 각 Task의 스택 사용량 출력
```

------

### 하드웨어 기반 보호 (MPU 지원 MCU 한정)

Cortex-M3/M4F 계열 중 일부는 **MPU(Memory Protection Unit)** 를 이용해 스택 접근을 보호할 수 있다.

- 각 Task의 스택 경계에 “No Access Region”을 지정
- 잘못된 접근 시 즉시 **MemManage Fault** 발생

예시:

```
MPU->RBAR = (uint32_t)stack_base;
MPU->RASR = (0x3 << 24) | (0x0 << 8);  // No Access
```

------

### Heap Overflow 검출

#### 1. malloc/free 후 경계 손상 감시

표준 `malloc()`은 메모리 손상 감시 기능이 없으므로, 경계 보호 패턴을 직접 삽입해야 한다.

```
#define HEAP_GUARD 0xDEADBEEF

void *safe_malloc(size_t size)
{
    uint32_t *ptr = (uint32_t *)malloc(size + 8);
    ptr[0] = HEAP_GUARD;
    ptr[(size/4) + 1] = HEAP_GUARD;
    return &ptr[1];
}

void safe_free(void *p, size_t size)
{
    uint32_t *ptr = (uint32_t *)p - 1;
    if (ptr[0] != HEAP_GUARD)
        printf("Heap underflow detected!\n");
    if (ptr[(size/4) + 1] != HEAP_GUARD)
        printf("Heap overflow detected!\n");
    free(ptr);
}
```

------

#### 2. FreeRTOS Heap Allocator 감시

`heap_4.c` 사용 시, FreeRTOS는 내부적으로 메모리 블록의 크기 정보를 저장하므로,
 **잘못된 free() 호출, 중복 해제, NULL free 등**은 자동 검출된다.

`vApplicationMallocFailedHook()`을 정의하여 모니터링 가능하다.

```
void vApplicationMallocFailedHook(void)
{
    printf("[Heap Allocation Failed]\n");
    taskDISABLE_INTERRUPTS();
    for(;;);
}
```

------

### Stack/Heap Overflow 시 증상

| 증상        | 원인                                   |
| ----------- | -------------------------------------- |
| HardFault   | 스택이 인터럽트 컨텍스트 영역 침범     |
| 데이터 손상 | Heap Overflow로 인한 전역 변수 파괴    |
| Task 정지   | FreeRTOS 태스크 스택 초과              |
| MCU 리셋    | Watchdog Reset 또는 Fault Handler 루프 |

------

### 진단 도구

| 도구                                       | 기능                                     |
| ------------------------------------------ | ---------------------------------------- |
| **CubeIDE Live Variables**                 | 스택 포인터, 힙 사용량 실시간 추적       |
| **FreeRTOS+Trace**                         | 각 태스크의 스택 사용 추이 시각화        |
| **Segger SystemView / Ozone**              | Heap Allocation 및 Task Stack Trace 추적 |
| **Static Analyzer (cppcheck, Clang-Tidy)** | 자동화된 포인터 경계 검사                |

------

### 실습 예시

1. **스택 초과 시나리오**

   ```
   void StackTest(void)
   {
       uint8_t buffer[1024]; // Task stack 512B인데 초과
       memset(buffer, 0xFF, sizeof(buffer)); // Overflow 발생
   }
   ```

   → vApplicationStackOverflowHook() 진입
    → CFSR = 0x00008200 (BusFault 발생 가능)

2. **Heap 경계 손상 시나리오**

   ```
   uint8_t *buf = malloc(16);
   for (int i = 0; i < 20; i++) buf[i] = i;  // Overflow
   ```

   → malloc 메타데이터 손상 → 이후 malloc/free 시 HardFault

------

### Overflow 방지 전략 요약

| 구분   | 대책                                                       |
| ------ | ---------------------------------------------------------- |
| Stack  | Task 별 여유 공간 확보, 재귀 최소화, Stack Guard 패턴 삽입 |
| Heap   | 고정 크기 메모리 풀 사용, free() 최소화                    |
| 시스템 | Watchdog + Fault Handler 통합 로그 기록                    |
| 빌드   | `-fstack-protector` 옵션 활성화 (GCC 지원)                 |

------

### 요약

- **Stack Overflow**: 함수 호출 깊이, 지역 변수 크기, 인터럽트 컨텍스트로 인해 발생
- **Heap Overflow**: 잘못된 malloc/free, 경계 초과 쓰기, 메모리 파괴
- **검출 방법**: FreeRTOS Hook, MPU 보호, CRC/Guard Pattern 삽입
- **대응 방법**: 정적 분석 + 런타임 모니터링 + 예외 발생 시 스택 덤프 출력

## 21.6 Logic Analyzer, Oscilloscope 연동

### Logic Analyzer의 개요

Logic Analyzer는 디지털 신호의 논리 레벨(H/L)을 시간축에 따라 기록하고 분석하는 장비로, MCU의 GPIO, 통신 버스(SPI, I²C, UART 등) 신호를 시각화하여 디버깅하는 데 사용한다.
 특히 펌웨어 타이밍, 인터럽트 응답 시간, 통신 프로토콜 검증 등에 필수적이다.

### 주요 사양 및 용어

- **Sampling Rate (샘플링 속도)**: 초당 데이터 캡처 속도. 최소한 대상 신호 주파수의 4~10배 이상 필요 (예: 10 MHz 신호 → ≥ 100 MS/s).
- **Channel 수**: 동시에 관찰 가능한 입력 핀 개수 (8, 16, 32채널 등).
- **Memory Depth**: 저장 가능한 데이터 길이. 긴 캡처나 버스트 신호 분석에 영향.
- **Trigger 조건**: 특정 이벤트(예: Rising Edge, 특정 데이터 패턴) 발생 시 캡처 시작.
- **Protocol Decode 기능**: SPI, UART, I²C, CAN 등 통신 프로토콜을 자동 해석해 파형 위에 데이터 표시.

### STM32와 Logic Analyzer 연결

- MCU의 **디지털 핀 (GPIO, TX/RX, SCL/SDA, SCK/MISO/MOSI 등)** 을 Logic Analyzer의 입력 채널에 연결.
- **공통 GND** 필수 연결.
- 3.3 V TTL 호환 입력 범위 확인 후 연결 (5 V 입력 시 손상 위험).
- 타임크리티컬 신호는 짧은 케이블 사용 권장.

예시:

| MCU 핀 | 신호    | Logic Analyzer 채널 |
| ------ | ------- | ------------------- |
| PA9    | UART TX | CH0                 |
| PA10   | UART RX | CH1                 |
| PB6    | I²C SCL | CH2                 |
| PB7    | I²C SDA | CH3                 |

### 파형 분석 절차

1. **Trigger 설정**: 관심 있는 신호(예: SCL 상승)에 트리거 지정.
2. **Sampling Rate 조정**: MCU 동작 주파수에 따라 적절히 설정.
3. **Capture 시작 및 데이터 저장**.
4. **Protocol Decode 적용**: 통신 파형에서 실제 전송 데이터 확인.
5. **Timing 측정**: 신호 간 지연, 주기, 펄스 폭 분석.

### 대표 소프트웨어

- **Saleae Logic** (Logic 8/Pro 16 하드웨어, GUI 우수, 다양한 디코더 지원)
- **Sigrok / PulseView** (오픈소스, 다양한 하드웨어 호환)
- **LA1010, DSLogic, ZeroPlus** 등 저가형 USB Logic Analyzer 장비도 CubeIDE Debug와 병행 가능.

------

### Oscilloscope의 개요

Oscilloscope는 **전압의 아날로그 변화를 시간축으로 시각화**하는 장비로, PWM, ADC, 전원 안정성, 센서 출력 등의 아날로그 특성을 확인할 수 있다.
 MCU의 PWM 신호, 전원 노이즈, 센서 아날로그 출력 등을 직접 측정해 신뢰성을 확보한다.

### 주요 기능

- **채널 수 (CH1~CH4)**: 다중 신호 동시 관찰.
- **Bandwidth**: 측정 가능한 최대 주파수. 신호의 5배 이상 권장.
- **Trigger**: 상승/하강엣지, 펄스폭, 패턴 등 조건별 캡처.
- **Math / FFT / Cursor** 기능으로 RMS, 주파수, 위상차 분석 가능.

### STM32 신호 측정 예시

- **PWM 출력 (TIMx_CHn)** → 주기, 듀티비 측정.
- **ADC 입력** → 센서 전압 변화 확인.
- **전원핀 (VDD, GND)** → 전압 리플, 노이즈 확인.
- **UART TX** → 전압레벨, 전송 타이밍 검증.

### 실습 예시 – PWM 파형 확인

1. CubeIDE에서 Timer를 PWM Mode로 설정 (예: 1 kHz, 50 %).
2. 출력 핀을 Oscilloscope CH1에 연결.
3. Trigger를 상승엣지로 설정 후 파형 캡처.
4. 파형의 **주기, High Time, Duty Cycle** 측정.
5. CubeIDE 설정값과 실제 측정값 비교해 오차 분석.

------

### Logic Analyzer + Oscilloscope 동시 사용

- **Logic Analyzer**: 디지털 프로토콜 검증 및 타이밍 확인.
- **Oscilloscope**: 신호 품질(노이즈, Slew Rate, 전압레벨) 검증.
- 두 장비의 **공통 GND**를 반드시 연결.
- 고속 PWM, SPI 신호에서는 둘의 동기화(Time Alignment) 분석이 유용하다.

------

### 실습 과제

- I²C 통신을 Logic Analyzer로 캡처하고, SDA/SCL 신호의 Start/Stop Condition 및 ACK 응답 분석.
- PWM 출력을 Oscilloscope로 측정해 CubeIDE에서 설정한 주파수 및 듀티비와 일치하는지 검증.
- UART TX/RX 파형을 Logic Analyzer와 Oscilloscope 동시에 캡처하여 전압레벨 및 Timing Delay 비교.
- SPI 통신 시 MISO 라인의 응답 지연(ns 단위)을 측정해 슬레이브 응답속도 분석.