# **11. í†µí•© ì‹¤ìŠµ í”„ë¡œì íŠ¸**

## 11.1 Smart Tank (ìŠ¤ë§ˆíŠ¸ ìˆ˜ì¡°)

- ## ì´ˆìŒíŒŒ + ìˆ˜ìœ„ì„¼ì„œ + HX711 í†µí•©

  ### 1. ê°œìš”

  ë³¸ ì¥ì—ì„œëŠ” **ì´ˆìŒíŒŒ ê±°ë¦¬ì„¼ì„œ (HC-SR04)**, **ì •ì „ì‹ ìˆ˜ìœ„ì„¼ì„œ (IÂ²C íƒ€ì…)**, **ë¬´ê²Œì„¼ì„œ (HX711)** ë¥¼
   **STM32** ì‹œìŠ¤í…œì—ì„œ í†µí•© ìš´ìš©í•˜ëŠ” êµ¬ì¡°ë¥¼ ì„¤ëª…í•œë‹¤.

  ê° ì„¼ì„œëŠ” ë¬¼ë¦¬ì ìœ¼ë¡œ ì„œë¡œ ë‹¤ë¥¸ ì…ë ¥(ì´ˆìŒíŒŒ: íƒ€ì´ë¨¸, ìˆ˜ìœ„: IÂ²C, ë¬´ê²Œ: SPI ìœ ì‚¬ ì¸í„°í˜ì´ìŠ¤)ì„ ì‚¬ìš©í•˜ì§€ë§Œ,
   ì£¼ê¸°ì  ì¸¡ì • ë£¨í”„ì™€ ë°ì´í„° í•„í„°ë§, Fail-Safe ë³´í˜¸, FreeRTOS ê¸°ë°˜ Task ë³‘ë ¬ ì²˜ë¦¬ë¡œ í†µí•© ì œì–´ê°€ ê°€ëŠ¥í•˜ë‹¤.

  ------

  ### 2. ì‹œìŠ¤í…œ êµ¬ì¡°

  | ì„¼ì„œ                            | ì¸í„°í˜ì´ìŠ¤      | ì£¼ìš” í•¨ìˆ˜                  | ì¸¡ì • ë‹¨ìœ„       | ì£¼ê¸°(ms) |
  | ------------------------------- | --------------- | -------------------------- | --------------- | -------- |
  | ì´ˆìŒíŒŒ(HC-SR04)                 | GPIO + Timer IC | `Ultrasonic_GetDistance()` | mm              | 200      |
  | ìˆ˜ìœ„ì„¼ì„œ(Capacitive, 0x48/0x49) | IÂ²C             | `LevelSensor_ReadAll()`    | ë‹¨ê³„(0~20) â†’ mm | 500      |
  | ë¬´ê²Œì„¼ì„œ(HX711)                 | GPIO(Bit-Bang)  | `HX711_GetWeight()`        | g               | 1000     |

  ------

  ### 3. ë°ì´í„° íë¦„

  ```
  [ì„¼ì„œ ì…ë ¥ ê³„ì¸µ]
     â”œâ”€ Ultrasonic_Read()
     â”œâ”€ I2C_LevelSensor_Read()
     â””â”€ HX711_ReadRaw()
  
         â†“ (ë³´ì •/í•„í„°ë§ ê³„ì¸µ)
     â”œâ”€ Offset & Scale Calibration
     â”œâ”€ Moving Average / Kalman Filter
     â”œâ”€ Timeout & Fail-Safe
  
         â†“ (í†µí•© ë³€í™˜ ê³„ì¸µ)
     â”œâ”€ water_level_mm
     â”œâ”€ tank_height_mm
     â”œâ”€ weight_g
  
         â†“ (ì¶œë ¥/ì œì–´ ê³„ì¸µ)
     â”œâ”€ DisplayTask (UART/OLED)
     â”œâ”€ ControlTask (ë°¸ë¸Œ, íŒí”„)
     â””â”€ RTCTask (ì£¼ê¸° ìŠ¤ì¼€ì¤„ë§)
  ```

  ------

  ### 4. ì„¼ì„œë³„ ì¸¡ì • í•¨ìˆ˜

  #### (1) ì´ˆìŒíŒŒ ê±°ë¦¬ ì¸¡ì •

  ```
  float Ultrasonic_GetDistance(void)
  {
      uint32_t echo_time = Get_Echo_Pulse_Width(); // Timer Input Capture
      if (echo_time == 0) return -1.0f; // Timeout â†’ Fail
      return (float)echo_time * 0.017f; // 340m/s â†’ 0.017 mm/us
  }
  ```

  ------

  #### (2) ìˆ˜ìœ„ì„¼ì„œ IÂ²C ì¸¡ì •

  ```
  float LevelSensor_GetHeight(void)
  {
      uint8_t level_data[20];
      if (HAL_I2C_Master_Receive(&hi2c1, LEVEL_SENSOR_ADDR << 1, level_data, 20, 100) != HAL_OK)
          return -1.0f;
  
      uint8_t last_on = 0;
      for (int i = 0; i < 20; i++)
          if (level_data[i] > THRESHOLD) last_on = i;
  
      return last_on * 5.0f + 3.0f; // 1ë‹¨ â‰ˆ 5mm
  }
  ```

  ------

  #### (3) ë¬´ê²Œì„¼ì„œ (HX711) ì¸¡ì •

  ```
  float HX711_GetWeight(void)
  {
      long raw = HX711_ReadRaw(&hx);
      if (raw == 0) return -1.0f;
  
      float weight = (raw - hx.offset) * hx.scale;
      return ExponentialSmooth(weight, &hx.filter);
  }
  ```

  ------

  ### 5. í†µí•© ë£¨í‹´

  ```
  typedef struct {
      float distance_mm;
      float level_mm;
      float weight_g;
      uint32_t timestamp;
  } SensorData_t;
  
  SensorData_t sensorData;
  
  void Sensor_UpdateAll(void)
  {
      sensorData.distance_mm = Ultrasonic_GetDistance();
      sensorData.level_mm    = LevelSensor_GetHeight();
      sensorData.weight_g    = HX711_GetWeight();
      sensorData.timestamp   = HAL_GetTick();
  
      // Fail-safe ì²˜ë¦¬
      if (sensorData.distance_mm < 0 || sensorData.level_mm < 0 || sensorData.weight_g < 0)
          System_FailSafe("Sensor Read Error");
  }
  ```

  ------

  ### 6. FreeRTOS ê¸°ë°˜ ë³‘ë ¬ Task

  ```
  void SensorTask(void *argument)
  {
      for (;;)
      {
          Sensor_UpdateAll();
          osDelay(500);
      }
  }
  
  void DisplayTask(void *argument)
  {
      for (;;)
      {
          printf("[DIST] %.1f mm | [LEVEL] %.1f mm | [WEIGHT] %.1f g\n",
                 sensorData.distance_mm, sensorData.level_mm, sensorData.weight_g);
  
          OLED_ShowFloat(0, 0, sensorData.distance_mm, 1);
          OLED_ShowFloat(0, 2, sensorData.level_mm, 1);
          OLED_ShowFloat(0, 4, sensorData.weight_g, 1);
          osDelay(1000);
      }
  }
  ```

  ------

  ### 7. ë³´ì • ë° í•„í„°ë§

  | í•­ëª©                      | ë°©ë²•               | í•¨ìˆ˜                  |
  | ------------------------- | ------------------ | --------------------- |
  | **Offset ë³´ì •**           | ë¬´ë¶€í•˜/ê¸°ì¤€ì  ì¸¡ì • | `HX711_SetOffset()`   |
  | **Scale ë³´ì •**            | í‘œì¤€ì¶” ê¸°ë°˜        | `HX711_SetScale()`    |
  | **Exponential Smoothing** | ë‹¨ê¸° ì¡ìŒ ì œê±°     | `ExponentialSmooth()` |
  | **Kalman Filter (1ì°¨)**   | ì¸¡ì • ì•ˆì •í™”        | `Kalman_Update()`     |

  ------

  ### 8. í†µí•© ì œì–´ ë¡œì§ ì˜ˆì‹œ

  ```
  void ControlTask(void *argument)
  {
      for (;;)
      {
          if (sensorData.level_mm < 50.0f)
              Pump_ON();
          else if (sensorData.level_mm > 180.0f)
              Pump_OFF();
  
          if (sensorData.weight_g > MAX_WEIGHT)
              Valve_Close();
  
          osDelay(200);
      }
  }
  ```

  ------

  ### 9. Fail-Safe ì—°ë™

  | ì¡°ê±´              | Fail-Safe ë™ì‘             |
  | ----------------- | -------------------------- |
  | ì´ˆìŒíŒŒ ì‘ë‹µ ì—†ìŒ  | ìµœê·¼ ì •ìƒê°’ ìœ ì§€ í›„ ì¬ì‹œë„ |
  | IÂ²C ìˆ˜ìœ„ì„¼ì„œ NACK | I2C ì¬ì´ˆê¸°í™” ë° ì¬ì‹œë„     |
  | HX711 Deadlock    | GPIO ì¬ì„¤ì • í›„ ë³µêµ¬        |
  | 3íšŒ ì´ìƒ ì‹¤íŒ¨     | System_Reset() í˜¸ì¶œ        |

  ------

  ### 10. ë°ì´í„° ë¡œê·¸ êµ¬ì¡°

  | í•­ëª©     | ë‹¨ìœ„ | ì„¤ëª…                       |
  | -------- | ---- | -------------------------- |
  | Distance | mm   | ì´ˆìŒíŒŒ ê¸°ë°˜ ìˆ˜ë©´~ì„¼ì„œ ê±°ë¦¬ |
  | Level    | mm   | ì •ì „ì‹ ìˆ˜ìœ„ì„¼ì„œ ê¸°ì¤€ ìˆ˜ìœ„  |
  | Weight   | g    | íƒ±í¬ ë¬´ê²Œ (HX711)          |
  | Status   | flag | FAIL / OK                  |
  | Time     | ms   | ì¸¡ì • íƒ€ì„ìŠ¤íƒ¬í”„            |

  UART / EEPROM / BLE ë“± ë‹¤ì–‘í•œ ì¶œë ¥ ì±„ë„ë¡œ ì „ì†¡ ê°€ëŠ¥.

  ------

  ### 11. ì‹œìŠ¤í…œ ìš”ì•½

  | ëª¨ë“ˆ             | ì¸í„°í˜ì´ìŠ¤      | ì£¼ê¸°    | ì˜¤ë¥˜ ë³µêµ¬      |
  | ---------------- | --------------- | ------- | -------------- |
  | HC-SR04          | Timer + GPIO    | 200 ms  | ECHO Timeout   |
  | Capacitive Level | IÂ²C (0x48/0x49) | 500 ms  | Bus Recovery   |
  | HX711            | GPIO Bit-Bang   | 1000 ms | Channel Reset  |
  | Display          | OLED / UART     | 1000 ms | None           |
  | Control          | Relay / Pump    | 200 ms  | Fail-Safe Mode |

  ------

  ### 12. ê²°ë¡ 

  ë³¸ í†µí•© êµ¬ì¡°ëŠ”

  - **ë¹„ë™ê¸° ì¸¡ì • êµ¬ì¡° (FreeRTOS Task)**
  - **í•„í„°ë§ ë° ë³´ì • ì²´ê³„ (Offset, Scale, Kalman)**
  - **Fail-Safe ë³µêµ¬ ë£¨í‹´**
  - **ì£¼ê¸°ì  ë°ì´í„° í†µí•© ë° í‘œì‹œ ë£¨í”„**

  ë¥¼ ëª¨ë‘ í¬í•¨í•˜ëŠ” ì•ˆì •ì ì¸ ì„¼ì„œ ìœµí•© í”„ë ˆì„ì›Œí¬ì´ë‹¤.

  ì´ êµ¬ì¡°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìˆ˜ìœ„ ì œì–´, ìœ ëŸ‰ ê°ì‹œ, íƒ±í¬ ì¶©ì „ëŸ‰ ì¶”ì • ë“±
   ë‹¤ì–‘í•œ **ìŠ¤ë§ˆíŠ¸ ê³„ì¸¡ ì‹œìŠ¤í…œ**ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•˜ë‹¤.

- ## FreeRTOS Task ë³‘ë ¬ ì‹¤í–‰

  ### 1. ê°œìš”

  FreeRTOSëŠ” **ë‹¤ì¤‘ Task ê¸°ë°˜ì˜ ì„ ì í˜•(Preemptive) RTOS ì»¤ë„**ë¡œ,
   ì—¬ëŸ¬ ê°œì˜ ë£¨í”„(íƒœìŠ¤í¬)ë¥¼ ë³‘ë ¬ì ìœ¼ë¡œ ì‹¤í–‰ì‹œì¼œ ê° ê¸°ëŠ¥(ì„¼ì„œ, ë””ìŠ¤í”Œë ˆì´, ì œì–´ ë“±)ì„
   **ë…ë¦½ì ìœ¼ë¡œ ë™ì‘**ì‹œí‚¤ëŠ” êµ¬ì¡°ë¥¼ ì œê³µí•œë‹¤.

  ê° TaskëŠ” ë…ë¦½ì ì¸ **ìŠ¤íƒ ê³µê°„**ê³¼ **ìš°ì„ ìˆœìœ„**ë¥¼ ê°€ì§€ë©°,
   ì»¤ë„ì˜ **ìŠ¤ì¼€ì¤„ëŸ¬(Scheduler)** ê°€ CPUë¥¼ ì‹œë¶„í• (Time Slice)í•˜ì—¬
   ë™ì‹œì— ì‹¤í–‰ë˜ëŠ” ê²ƒì²˜ëŸ¼ ê´€ë¦¬í•œë‹¤.

  ------

  ### 2. Task ìƒì„± êµ¬ì¡°

  #### (1) CMSIS-RTOS2 API ê¸°ë°˜

  STM32CubeMXì—ì„œ FreeRTOSë¥¼ í™œì„±í™”í•˜ë©´,
   `cmsis_os2.h` ê¸°ë°˜ì˜ API(`osThreadNew`, `osDelay` ë“±)ë¥¼ ì‚¬ìš©í•œë‹¤.

  ```
  void SensorTask(void *argument);
  void DisplayTask(void *argument);
  void ControlTask(void *argument);
  
  int main(void)
  {
      HAL_Init();
      SystemClock_Config();
      MX_FREERTOS_Init(); // CubeMX ìƒì„± ì½”ë“œ
  
      osKernelInitialize();
  
      osThreadNew(SensorTask, NULL, NULL);
      osThreadNew(DisplayTask, NULL, NULL);
      osThreadNew(ControlTask, NULL, NULL);
  
      osKernelStart();
  
      while (1); // ì»¤ë„ ì‹œì‘ í›„ ë„ë‹¬í•˜ì§€ ì•ŠìŒ
  }
  ```

  ------

  ### 3. Task ì‹¤í–‰ ì›ë¦¬

  FreeRTOSëŠ” ê¸°ë³¸ì ìœ¼ë¡œ **ì„ ì í˜• ìŠ¤ì¼€ì¤„ë§(Preemptive Scheduling)** ì„ ì‚¬ìš©í•œë‹¤.

  - ë†’ì€ ìš°ì„ ìˆœìœ„ì˜ Taskê°€ ì‹¤í–‰ ì¤‘ì´ë©´ ë‚®ì€ ìš°ì„ ìˆœìœ„ TaskëŠ” ëŒ€ê¸° ìƒíƒœ
  - ë™ì¼ ìš°ì„ ìˆœìœ„ì˜ TaskëŠ” Tick(ê¸°ë³¸ 1ms) ë‹¨ìœ„ë¡œ ì‹œë¶„í• 
  - `osDelay()` ë˜ëŠ” `vTaskDelay()` í˜¸ì¶œ ì‹œ â†’ Task Ready Queueë¡œ ì´ë™

  #### ì‹¤í–‰ ìƒíƒœ ì „ì´ë„

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Ready      â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚(ìŠ¤ì¼€ì¤„ëŸ¬)
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Running    â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚(osDelay, Block)
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Blocked    â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚(Timeout/Event)
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Ready      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ------

  ### 4. Task ê°„ ë³‘ë ¬ ì‹¤í–‰ ì˜ˆì œ

  ```
  void SensorTask(void *argument)
  {
      for (;;)
      {
          Sensor_UpdateAll();     // ì´ˆìŒíŒŒ + ìˆ˜ìœ„ + ë¬´ê²Œ ì„¼ì„œ
          osDelay(200);           // 200ms ì£¼ê¸°
      }
  }
  
  void DisplayTask(void *argument)
  {
      for (;;)
      {
          OLED_ShowSensorData();  // ì„¼ì„œê°’ OLED í‘œì‹œ
          UART_LogSensorData();   // UART ì „ì†¡
          osDelay(1000);
      }
  }
  
  void ControlTask(void *argument)
  {
      for (;;)
      {
          Control_PumpAndValve(); // ìˆ˜ìœ„/ë¬´ê²Œ ê¸°ë°˜ ì œì–´
          osDelay(300);
      }
  }
  ```

  ìœ„ ì„¸ TaskëŠ” ì„œë¡œ ë…ë¦½ì ìœ¼ë¡œ ë³‘ë ¬ ì‹¤í–‰ëœë‹¤.
   ì‹¤ì œ CPUëŠ” ë‹¨ì¼ ì½”ì–´ì§€ë§Œ, RTOS ìŠ¤ì¼€ì¤„ëŸ¬ê°€ **Tick ë‹¨ìœ„ë¡œ Taskë¥¼ ì „í™˜**í•˜ì—¬
   ë…¼ë¦¬ì ìœ¼ë¡œ ë™ì‹œì— ë™ì‘í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì¸ë‹¤.

  ------

  ### 5. Task ìš°ì„ ìˆœìœ„ ì„¤ì •

  ìš°ì„ ìˆœìœ„ëŠ” ê° Task ìƒì„± ì‹œ ì†ì„± êµ¬ì¡°ì²´ë¡œ ì§€ì •í•œë‹¤.

  ```
  const osThreadAttr_t sensorTask_attributes = {
      .name = "SensorTask",
      .priority = (osPriority_t) osPriorityHigh,
      .stack_size = 256 * 4
  };
  
  const osThreadAttr_t displayTask_attributes = {
      .name = "DisplayTask",
      .priority = (osPriority_t) osPriorityLow,
      .stack_size = 256 * 4
  };
  ```

  | Task        | ìš°ì„ ìˆœìœ„ | ì˜ë¯¸                       |
  | ----------- | -------- | -------------------------- |
  | SensorTask  | High     | ì£¼ê¸°ì  ì¸¡ì •, ì‹¤ì‹œê°„ì„± ìš”êµ¬ |
  | ControlTask | Normal   | íŒí”„/ë°¸ë¸Œ ë™ì‘ ì œì–´        |
  | DisplayTask | Low      | í™”ë©´ ì¶œë ¥, ë¡œê·¸ ì²˜ë¦¬       |

  ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” í•­ìƒ **ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„ì˜ Ready ìƒíƒœ Task**ë¥¼ ì‹¤í–‰í•œë‹¤.

  ------

  ### 6. ë³‘ë ¬ ì‹¤í–‰ ì¤‘ ë™ê¸°í™”

  ì—¬ëŸ¬ Taskê°€ ë™ì¼ ìì›(OLED, UART, IÂ²C ë“±)ì„ ê³µìœ í•  ê²½ìš°,
   **Mutex** ë‚˜ **Semaphore** ë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ê¸°í™”í•´ì•¼ í•œë‹¤.

  ```
  osMutexId_t i2cMutex;
  
  void SensorTask(void *argument)
  {
      for (;;)
      {
          osMutexAcquire(i2cMutex, osWaitForever);
          I2C_ReadSensor();
          osMutexRelease(i2cMutex);
          osDelay(500);
      }
  }
  ```

  ì´ë ‡ê²Œ í•˜ë©´ DisplayTaskê°€ ë™ì‹œì— OLEDë¥¼ IÂ²Cë¡œ ì ‘ê·¼í•´ë„ ì¶©ëŒì´ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.

  ------

  ### 7. ë³‘ë ¬ ì‹¤í–‰ íƒ€ì´ë°

  | Task        | ì£¼ê¸°(ms) | CPU ì ìœ ìœ¨(%) | ë™ì‘ ì—­í•                 |
  | ----------- | -------- | ------------- | ------------------------ |
  | SensorTask  | 200      | 30            | ì‹¤ì‹œê°„ ì¸¡ì •              |
  | ControlTask | 300      | 25            | ì•¡ì¶”ì—ì´í„° ì œì–´          |
  | DisplayTask | 1000     | 10            | OLED/UART ì¶œë ¥           |
  | IdleTask    | â€”        | ë‚˜ë¨¸ì§€        | Tickless Sleep, ì „ë ¥ì ˆê° |

  ------

  ### 8. ë³‘ë ¬ ì‹¤í–‰ ëª¨ë‹ˆí„°ë§

  FreeRTOSëŠ” ëŸ°íƒ€ì„ í†µê³„ ê¸°ëŠ¥(`vTaskGetRunTimeStats()`)ì„ ì œê³µí•œë‹¤.

  ```
  char stats[256];
  vTaskGetRunTimeStats(stats);
  printf("%s\n", stats);
  ```

  ì˜ˆì‹œ ì¶œë ¥:

  ```
  Task Name     Time%  
  SensorTask    32.1  
  ControlTask   25.4  
  DisplayTask   12.7  
  IDLE          29.8
  ```

  ì´ë¥¼ í†µí•´ ê° Taskì˜ ì ìœ ìœ¨ê³¼ ìŠ¤ì¼€ì¤„ë§ ìƒíƒœë¥¼ ë¶„ì„í•  ìˆ˜ ìˆë‹¤.

  ------

  ### 9. ë³‘ë ¬ ì‹¤í–‰ì˜ ì´ì 

  | í•­ëª©       | ì„¤ëª…                                                  |
  | ---------- | ----------------------------------------------------- |
  | **ë…ë¦½ì„±** | ê° ê¸°ëŠ¥ ë£¨í”„ê°€ ë¶„ë¦¬ë˜ì–´ ìœ ì§€ë³´ìˆ˜ ìš©ì´                 |
  | **ì‘ë‹µì„±** | ì‹¤ì‹œê°„ ì´ë²¤íŠ¸(IRQ, ì„¼ì„œ ì…ë ¥)ì— ë¹ ë¥´ê²Œ ë°˜ì‘           |
  | **ì•ˆì •ì„±** | í•˜ë‚˜ì˜ Task ì˜¤ë¥˜ê°€ ì „ì²´ ì‹œìŠ¤í…œ ì¤‘ë‹¨ìœ¼ë¡œ ì´ì–´ì§€ì§€ ì•ŠìŒ |
  | **í™•ì¥ì„±** | ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ë£¨í”„ ì˜í–¥ ìµœì†Œí™”             |

  ------

  ### 10. ê²°ë¡ 

  FreeRTOSì˜ **Task ë³‘ë ¬ ì‹¤í–‰ êµ¬ì¡°**ëŠ” STM32 ê¸°ë°˜ ê³„ì¸¡Â·ì œì–´ ì‹œìŠ¤í…œì—ì„œ
   ì„¼ì„œ ì½ê¸°, ë””ìŠ¤í”Œë ˆì´, í†µì‹ , ì œì–´ë¥¼ ì™„ì „íˆ ë…ë¦½ì ìœ¼ë¡œ ë³‘í–‰ ì‹¤í–‰í•˜ê²Œ í•´ì¤€ë‹¤.
  $$
  \boxed{\text{ë…ë¦½ì  ì‹¤í–‰ + ìŠ¤ì¼€ì¤„ë§ ì œì–´ = ì‹¤ì‹œê°„ ë³‘ë ¬ ì‹œìŠ¤í…œ ì™„ì„±}}
  $$
  ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ **ì„¼ì„œ ìœµí•©, ì €ì „ë ¥ ê´€ë¦¬, Fail-Safe ë³´í˜¸** ë“± ê³ ì‹ ë¢° ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ë¡œ ë°œì „ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

- ## RTC ê¸°ë°˜ ì£¼ê¸° ì¸¡ì •

  ### 1. ê°œìš”

  RTC(Real-Time Clock)ëŠ” ì €ì „ë ¥ í•˜ë“œì›¨ì–´ íƒ€ì´ë¨¸ë¡œ,
   ì´ˆ ë‹¨ìœ„ì˜ ì ˆëŒ€ ì‹œê°„ ì¶”ì ë¿ ì•„ë‹ˆë¼ **ì£¼ê¸°ì  ì¸¡ì • ìŠ¤ì¼€ì¤„ë§**ì— í™œìš©í•  ìˆ˜ ìˆë‹¤.
   STM32F103 ì‹œë¦¬ì¦ˆì˜ RTCëŠ” **LSE(32.768 kHz)** í´ëŸ­ì„ ê¸°ì¤€ìœ¼ë¡œ ë™ì‘í•˜ë©°,
   ì „ì›ì´ ì°¨ë‹¨ë˜ì–´ë„ ë°±ì—… ë°°í„°ë¦¬ë¥¼ í†µí•´ ì‹œê°„ì„ ìœ ì§€í•œë‹¤.

  ì£¼ê¸° ì¸¡ì •ì€ RTCë¥¼ ê¸°ì¤€ìœ¼ë¡œ â€œë§¤ nì´ˆë§ˆë‹¤ ì¸¡ì • ë£¨í‹´ ìˆ˜í–‰â€í•˜ë„ë¡ í•˜ì—¬
   FreeRTOSë‚˜ ì¼ë°˜ HAL ë£¨í”„ë³´ë‹¤ **ì •í™•í•˜ê³  ì €ì „ë ¥**ì¸ ì‹œê°„ ê¸°ë°˜ ì œì–´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.

  ------

  ### 2. RTC ì£¼ê¸° ì¸¡ì • ê°œë…

  RTCë¥¼ ì£¼ê¸°ì  íŠ¸ë¦¬ê±°ë¡œ í™œìš©í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

  1. **RTC Alarm ê¸°ëŠ¥ ì‚¬ìš©**
     - íŠ¹ì • ì‹œê°(ì˜ˆ: HH:MM:SS)ì— ì•ŒëŒì„ ì„¤ì •í•˜ê³  ì¸í„°ëŸ½íŠ¸ ë°œìƒ ì‹œ ì¸¡ì • ë£¨í‹´ ì‹¤í–‰
     - ì•ŒëŒ ì™„ë£Œ í›„ ë‹¤ìŒ ì•ŒëŒ ì‹œê°ì„ ê°±ì‹ í•˜ì—¬ ì£¼ê¸°ì  ë™ì‘ êµ¬í˜„
  2. **RTC Wakeup Timer (F4 ì´ìƒ ì‹œë¦¬ì¦ˆ)**
     - STM32F1ì—ëŠ” ì§ì ‘ì  Wakeup Timer ì—†ìŒ â†’ Alarm ë°˜ë³µ ê°±ì‹ ìœ¼ë¡œ ë™ì¼ íš¨ê³¼ êµ¬í˜„

  ê²°ê³¼ì ìœ¼ë¡œ, ì¼ì •í•œ ì‹œê°„ ê°„ê²©(ì˜ˆ: 1ë¶„, 5ë¶„, 10ë¶„ ë“±)ë§ˆë‹¤
   ì„¼ì„œ ì¸¡ì •, ë°ì´í„° ì €ì¥, ì†¡ì‹  ë“±ì„ **RTC ì•ŒëŒ ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•˜ê²Œ ìˆ˜í–‰**í•  ìˆ˜ ìˆë‹¤.

  ------

  ### 3. ì‹œìŠ¤í…œ íë¦„

  ```
  [RTC Tick (ì´ˆ ë‹¨ìœ„)] 
         â†“
  [Alarm Interrupt ë°œìƒ]
         â†“
  [Measurement Task Notify]
         â†“
  [ì„¼ì„œ ì¸¡ì • â†’ OLED í‘œì‹œ â†’ EEPROM ì €ì¥]
         â†“
  [ë‹¤ìŒ ì•ŒëŒ ì„¤ì • (í˜„ì¬ + Î”t)]
  ```

  ------

  ### 4. êµ¬í˜„ ì ˆì°¨

  #### (1) RTC ì´ˆê¸°í™”

  RTCë¥¼ LSE 32.768kHz ê¸°ì¤€ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³ , ì‹œê°„ì„ ì„¤ì •í•œë‹¤.

  ```
  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};
  
  sTime.Hours = 12;
  sTime.Minutes = 0;
  sTime.Seconds = 0;
  HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
  HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
  ```

  #### (2) ì•ŒëŒ ì„¤ì •

  ì£¼ê¸°ì  íŠ¸ë¦¬ê±°ë¥¼ ìœ„í•´ í˜„ì¬ ì‹œê° ê¸°ì¤€ìœ¼ë¡œ Î”t (ì˜ˆ: 10ì´ˆ í›„) ì•ŒëŒì„ ì„¤ì •í•œë‹¤.

  ```
  RTC_AlarmTypeDef sAlarm = {0};
  HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
  
  uint8_t next_sec = (sTime.Seconds + 10) % 60;
  sAlarm.AlarmTime.Hours = sTime.Hours;
  sAlarm.AlarmTime.Minutes = sTime.Minutes;
  sAlarm.AlarmTime.Seconds = next_sec;
  sAlarm.Alarm = RTC_ALARM_A;
  
  HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);
  ```

  #### (3) ì•ŒëŒ ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬

  ì•ŒëŒì´ ë°œìƒí•˜ë©´ ì¸í„°ëŸ½íŠ¸ ì½œë°±ì—ì„œ ì¸¡ì • ë£¨í‹´ì„ í˜¸ì¶œí•˜ê±°ë‚˜
   FreeRTOS Taskì— Notify ì‹ í˜¸ë¥¼ ë³´ë‚¸ë‹¤.

  ```
  void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
  {
      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
      vTaskNotifyGiveFromISR(measureTaskHandle, &xHigherPriorityTaskWoken);
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  }
  ```

  #### (4) ì£¼ê¸°ì  ì•ŒëŒ ê°±ì‹ 

  ì¸¡ì •ì´ ì™„ë£Œë˜ë©´, ë‹¤ì‹œ ë‹¤ìŒ ì£¼ê¸° ì•ŒëŒì„ ì„¤ì •í•œë‹¤.

  ```
  void ScheduleNextAlarm(uint8_t interval_sec)
  {
      RTC_TimeTypeDef now;
      HAL_RTC_GetTime(&hrtc, &now, RTC_FORMAT_BIN);
      RTC_AlarmTypeDef next;
  
      next.AlarmTime.Hours = now.Hours;
      next.AlarmTime.Minutes = now.Minutes;
      next.AlarmTime.Seconds = (now.Seconds + interval_sec) % 60;
      next.Alarm = RTC_ALARM_A;
      HAL_RTC_SetAlarm_IT(&hrtc, &next, RTC_FORMAT_BIN);
  }
  ```

  ------

  ### 5. FreeRTOS ê¸°ë°˜ ì¸¡ì • ë£¨í‹´

  ```
  void MeasureTask(void *argument)
  {
      for (;;)
      {
          ulTaskNotifyTake(pdTRUE, portMAX_DELAY);  // RTC ì•ŒëŒ ì´ë²¤íŠ¸ ëŒ€ê¸°
          PerformSensorMeasurement();               // ì´ˆìŒíŒŒ, ìˆ˜ìœ„, ë¬´ê²Œ ì¸¡ì •
          OLED_DisplayData();
          ScheduleNextAlarm(60);                    // 60ì´ˆ í›„ ì¬ì„¤ì •
      }
  }
  ```

  ì´ êµ¬ì¡°ëŠ” `vTaskDelay()` ëŒ€ì‹  RTC ê¸°ë°˜ ì •í™•í•œ íŠ¸ë¦¬ê±°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ
   **ìŠ¬ë¦½ ëª¨ë“œ ì§„ì… ë° ì €ì „ë ¥ ì£¼ê¸° ë™ì‘**ì´ ê°€ëŠ¥í•˜ë‹¤.

  ------

  ### 6. ì£¼ê¸° ì¸¡ì • ì •í™•ë„

  | í´ëŸ­      | ì£¼íŒŒìˆ˜       | ì˜¤ì°¨(typical) | 1ì‹œê°„ ëˆ„ì  ì˜¤ì°¨ |
  | --------- | ------------ | ------------- | --------------- |
  | LSE       | 32.768 kHz   | Â±20 ppm       | Â±0.072ì´ˆ        |
  | HSE / LSI | 8MHz / 40kHz | Â±1% ì´ìƒ      | Â±36ì´ˆ ì´ìƒ      |

  RTCë¥¼ LSEì— ì—°ê²°í•˜ë©´ ì¥ì‹œê°„ ë™ì‘ ì‹œì—ë„ ì•ˆì •ëœ ì£¼ê¸°ì„±ì„ í™•ë³´í•  ìˆ˜ ìˆë‹¤.

  ------

  ### 7. ì˜ˆì‹œ ë¡œê·¸

  ```
  [RTC] Alarm Triggered @ 12:00:00
  [Measure] Distance=132.4mm, Weight=1.246kg
  [RTC] Next Alarm Set @ 12:01:00
  [Sleep] Entering STOP Mode...
  ```

  ------

  ### 8. ì¥ì  ìš”ì•½

  | í•­ëª©       | ì„¤ëª…                                           |
  | ---------- | ---------------------------------------------- |
  | **ì •í™•ì„±** | 32.768kHz LSE ê¸°ë°˜ìœ¼ë¡œ Â±20ppm ìˆ˜ì¤€ì˜ ì‹œê°„ ì˜¤ì°¨ |
  | **ì €ì „ë ¥** | ë©”ì¸ í´ëŸ­ ë¹„í™œì„± ìƒíƒœì—ì„œë„ RTC ë™ì‘ ìœ ì§€      |
  | **ë…ë¦½ì„±** | FreeRTOS Tickê³¼ ë¬´ê´€í•˜ê²Œ ì‹¤ì‹œê°„ ìŠ¤ì¼€ì¤„ ìœ ì§€    |
  | **ìœ ì—°ì„±** | ë™ì  ê°„ê²© ì¡°ì ˆ ê°€ëŠ¥ (ì˜ˆ: 10ì´ˆ, 1ë¶„, 5ë¶„ ë“±)    |

  ------

  ### 9. ê²°ë¡ 

  RTC ê¸°ë°˜ ì£¼ê¸° ì¸¡ì •ì€ ë‹¨ìˆœí•œ delay ê¸°ë°˜ ì£¼ê¸° ë£¨í”„ë³´ë‹¤ í›¨ì”¬ **ì •í™•í•˜ê³  ì•ˆì •ì **ì´ë©°,
   íŠ¹íˆ ì €ì „ë ¥ ëª¨ë“œ(STOP, STANDBY)ì™€ ê²°í•©í•  ê²½ìš°
   **ë°°í„°ë¦¬ ê¸°ë°˜ ì¥ì‹œê°„ ì„¼ì„œ ë…¸ë“œ** êµ¬í˜„ì˜ í•µì‹¬ì´ ëœë‹¤.
  $$
  \boxed{\text{RTC Alarm + Task Notify = ì •í™•í•˜ê³  ì €ì „ë ¥ì¸ ì£¼ê¸° ì¸¡ì • êµ¬ì¡°}}
  $$

- ## OLED + UART ìƒíƒœ ì¶œë ¥

  ### 1. ê°œìš”

  ì„¼ì„œ ë°ì´í„°ë‚˜ ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•˜ê¸° ìœ„í•´ **OLED(SSD1306)**ì™€ **UART í„°ë¯¸ë„**ì„ ë™ì‹œì— í™œìš©í•  ìˆ˜ ìˆë‹¤.
   ë‘ ì¶œë ¥ì„ ë³‘í–‰í•˜ë©´ â€”

  - OLEDëŠ” **í˜„ì¥ìš© ë””ìŠ¤í”Œë ˆì´**,
  - UARTëŠ” **PC ë””ë²„ê¹… ë¡œê·¸** ì—­í• ì„ í•˜ì—¬
     í…ŒìŠ¤íŠ¸ ë° ìœ ì§€ë³´ìˆ˜ íš¨ìœ¨ì„ í¬ê²Œ ë†’ì¸ë‹¤.

  ------

  ### 2. ì¶œë ¥ êµ¬ì¡°

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  SensorTask â”‚
  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
  â”‚  ê±°ë¦¬, ë¬´ê²Œ, ìˆ˜ìœ„ ì¸¡ì • â”‚
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ DisplayTask â”‚
  â”‚  OLED + UART ì¶œë ¥  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  - `SensorTask`ëŠ” ì£¼ê¸°ì ìœ¼ë¡œ ì„¼ì„œ ë°ì´í„°ë¥¼ ìƒì„±
  - `DisplayTask`ëŠ” Queueë‚˜ ì „ì—­ êµ¬ì¡°ì²´ë¥¼ í†µí•´ ìµœì‹  ê°’ì„ ë°›ì•„ OLEDì™€ UARTë¡œ í‘œì‹œ

  ------

  ### 3. OLED ì´ˆê¸°í™”

  ```
  #include "ssd1306.h"
  #include "fonts.h"
  
  void OLED_Init_Display(void)
  {
      ssd1306_Init();
      ssd1306_Fill(Black);
      ssd1306_UpdateScreen();
  }
  ```

  ------

  ### 4. OLED ì¶œë ¥ í•¨ìˆ˜

  ```
  void OLED_ShowStatus(float distance, float weight, float level)
  {
      ssd1306_Fill(Black);
      ssd1306_SetCursor(0, 0);
      ssd1306_WriteString("SENSOR STATUS", Font_7x10, White);
  
      char buf[32];
      sprintf(buf, "Dist: %.1f mm", distance);
      ssd1306_SetCursor(0, 16);
      ssd1306_WriteString(buf, Font_6x8, White);
  
      sprintf(buf, "Weight: %.3f kg", weight);
      ssd1306_SetCursor(0, 26);
      ssd1306_WriteString(buf, Font_6x8, White);
  
      sprintf(buf, "Level: %.1f mm", level);
      ssd1306_SetCursor(0, 36);
      ssd1306_WriteString(buf, Font_6x8, White);
  
      ssd1306_UpdateScreen();
  }
  ```

  ------

  ### 5. UART ì¶œë ¥ í•¨ìˆ˜

  ```
  void UART_PrintStatus(float distance, float weight, float level)
  {
      char msg[64];
      sprintf(msg, "[DATA] D=%.1fmm, W=%.3fkg, L=%.1fmm\r\n",
              distance, weight, level);
      HAL_UART_Transmit(&huart1, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
  }
  ```

  ------

  ### 6. FreeRTOS DisplayTask

  ```
  void DisplayTask(void *argument)
  {
      SensorData_t data;
  
      for (;;)
      {
          if (xQueueReceive(sensorQueueHandle, &data, portMAX_DELAY) == pdPASS)
          {
              OLED_ShowStatus(data.distance, data.weight, data.level);
              UART_PrintStatus(data.distance, data.weight, data.level);
          }
          osDelay(500); // ë””ìŠ¤í”Œë ˆì´ ê°±ì‹  ì£¼ê¸°
      }
  }
  ```

  ------

  ### 7. í†µí•© ë¡œê·¸ ì˜ˆì‹œ

  **OLED í™”ë©´**

  ```
  SENSOR STATUS
  Dist: 132.4 mm
  Weight: 1.246 kg
  Level: 48.5 mm
  ```

  **UART í„°ë¯¸ë„ (115200bps)**

  ```
  [DATA] D=132.4mm, W=1.246kg, L=48.5mm
  [INFO] RTC Next Alarm: 12:01:00
  ```

  ------

  ### 8. í¬ì¸íŠ¸ ìš”ì•½

  | êµ¬ë¶„     | ê¸°ëŠ¥            | ë¹„ê³                      |
  | -------- | --------------- | ------------------------ |
  | OLED     | í˜„ì¥ ë””ìŠ¤í”Œë ˆì´ | IÂ²C ê¸°ë°˜ SSD1306         |
  | UART     | ì‹¤ì‹œê°„ ë¡œê¹…     | PC ì—°ê²° (115200bps)      |
  | Queue    | ë°ì´í„° ì „ë‹¬     | SensorTask â†’ DisplayTask |
  | FreeRTOS | ë³‘ë ¬ ë™ì‘       | ì£¼ê¸°ë³„ Task ë¶„ë¦¬         |

  ------

  ### 9. ê²°ë¡ 

  `OLED + UART` ë³‘í–‰ ì¶œë ¥ì€
   ì„¼ì„œ ìƒíƒœë¥¼ í˜„ì¥ê³¼ ì›ê²© ì–‘ìª½ì—ì„œ ë™ì‹œì— ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆëŠ” ì‹¤ìš©ì ì¸ êµ¬ì¡°ë‹¤.
  $$
  \boxed{\text{DisplayTask = OLED í‘œì‹œ + UART ë¡œê·¸ ì¶œë ¥}}
  $$

- ## ë°¸ë¸Œ ì œì–´ (Relay/MOSFET)

  ### 1. ê°œìš”

  ë°¸ë¸Œ(Valve) ì œì–´ëŠ” ìœ ì²´, ê³µê¸°, ë˜ëŠ” ì•¡ì²´ì˜ íë¦„ì„ ì œì–´í•˜ê¸° ìœ„í•´ **ë¦´ë ˆì´(ì „ê¸°ì  ìŠ¤ìœ„ì¹˜)** ë˜ëŠ” **MOSFET(ë°˜ë„ì²´ ìŠ¤ìœ„ì¹˜)**ë¥¼ ì´ìš©í•´ ìˆ˜í–‰ëœë‹¤.
   ì„ë² ë””ë“œ ì‹œìŠ¤í…œì—ì„œëŠ” **GPIO í•€ì„ í†µí•´ ë°¸ë¸Œì˜ ì „ì›ì„ ì„ On/Off** í•˜ë©°, ì„¼ì„œ ì…ë ¥(ìˆ˜ìœ„, ì••ë ¥, ì‹œê°„)ì— ë”°ë¼ ìë™ ì œì–´ ë£¨í‹´ì´ ë™ì‘í•œë‹¤.

  ------

  ### 2. í•˜ë“œì›¨ì–´ êµ¬ì„±

  | ì œì–´ ë°©ì‹   | êµ¬ë¶„          | ì œì–´ ì†Œì        | êµ¬ë™ ì „ë¥˜ | íŠ¹ì„±                   |
  | ----------- | ------------- | ---------------- | --------- | ---------------------- |
  | ë¦´ë ˆì´ ë°©ì‹ | ì „ê¸°ì  ì ‘ì    | Mechanical Relay | ìˆ˜ì‹­ mA   | ì ˆì—° ê°•í•¨, ë™ì‘ ëŠë¦¼   |
  | MOSFET ë°©ì‹ | ë°˜ë„ì²´ ìŠ¤ìœ„ì¹­ | N-channel MOSFET | ìˆ˜ mA     | ë¹ ë¥¸ ìŠ¤ìœ„ì¹­, ì†ŒìŒ ì—†ìŒ |

  #### (1) ë¦´ë ˆì´ íšŒë¡œ

  ```
  MCU GPIO â”€â”€> NPN íŠ¸ëœì§€ìŠ¤í„° â”€â”€> ë¦´ë ˆì´ ì½”ì¼
                         â”‚
                      ë‹¤ì´ì˜¤ë“œ(ì—­ê¸°ì „ë ¥ ë³´í˜¸)
  ```

  #### (2) MOSFET íšŒë¡œ

  ```
  MCU GPIO â”€â”€> Gate (10kÎ© Pull-down)
  Drain â”€â”€> ë°¸ë¸Œ ìŒê·¹(âˆ’)
  Source â”€â”€> GND
  ë°¸ë¸Œ ì–‘ê·¹(+) â”€â”€> +12V
  ```

  ------

  ### 3. GPIO ì´ˆê¸°í™” (STM32 HAL ì˜ˆì‹œ)

  ```
  void Valve_GPIO_Init(void)
  {
      GPIO_InitTypeDef GPIO_InitStruct = {0};
  
      __HAL_RCC_GPIOB_CLK_ENABLE();
  
      GPIO_InitStruct.Pin = GPIO_PIN_0;         // ë°¸ë¸Œ ì œì–´ í•€
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);  // ì´ˆê¸° OFF
  }
  ```

  ------

  ### 4. ë°¸ë¸Œ ì œì–´ í•¨ìˆ˜

  ```
  #define VALVE_PORT   GPIOB
  #define VALVE_PIN    GPIO_PIN_0
  
  void Valve_On(void)
  {
      HAL_GPIO_WritePin(VALVE_PORT, VALVE_PIN, GPIO_PIN_SET);
  }
  
  void Valve_Off(void)
  {
      HAL_GPIO_WritePin(VALVE_PORT, VALVE_PIN, GPIO_PIN_RESET);
  }
  ```

  ------

  ### 5. ì œì–´ ë¡œì§ ì˜ˆì‹œ

  #### (1) ë‹¨ìˆœ ìˆ˜ìœ„ ì œì–´

  ```
  if (level < LEVEL_MIN)
      Valve_On();    // ìˆ˜ìœ„ ë¶€ì¡± â†’ ë°¸ë¸Œ ì—´ê¸°
  else if (level > LEVEL_MAX)
      Valve_Off();   // ìˆ˜ìœ„ ì¶©ë¶„ â†’ ë°¸ë¸Œ ë‹«ê¸°
  ```

  #### (2) íƒ€ì´ë¨¸ ê¸°ë°˜ ìë™ ì°¨ë‹¨

  ```
  uint32_t valve_start_time = 0;
  bool valve_active = false;
  
  void Valve_Control_Auto(void)
  {
      if (!valve_active && level < LEVEL_MIN)
      {
          Valve_On();
          valve_start_time = HAL_GetTick();
          valve_active = true;
      }
  
      if (valve_active)
      {
          if (level > LEVEL_MAX || (HAL_GetTick() - valve_start_time > 10000))
          {
              Valve_Off();
              valve_active = false;
          }
      }
  }
  ```

  ------

  ### 6. FreeRTOS Task ì˜ˆì‹œ

  ```
  void ControlTask(void *argument)
  {
      SensorData_t data;
      for (;;)
      {
          if (xQueueReceive(sensorQueueHandle, &data, portMAX_DELAY) == pdPASS)
          {
              if (data.level < 40.0f)      Valve_On();
              else if (data.level > 80.0f) Valve_Off();
          }
          osDelay(200);
      }
  }
  ```

  ------

  ### 7. Fail-Safe ë³´í˜¸ ë¡œì§

  | ì¡°ê±´              | ì œì–´ ë™ì‘          |
  | ----------------- | ------------------ |
  | ì„¼ì„œ í†µì‹  ì˜¤ë¥˜    | ë°¸ë¸Œ ìë™ ì°¨ë‹¨     |
  | ì¸¡ì • íƒ€ì„ì•„ì›ƒ     | ë°¸ë¸Œ Off           |
  | ê³¼ì—´, ê³¼ì „ë¥˜ ê²€ì¶œ | ë°¸ë¸Œ Off           |
  | Watchdog ë¦¬ì…‹     | ì´ˆê¸° Off ìƒíƒœ ìœ ì§€ |

  ```
  void FailSafe_Check(void)
  {
      if (sensor_error || timeout_flag)
      {
          Valve_Off();
          UART_Log("FailSafe: Valve OFF (Sensor Fault)\r\n");
      }
  }
  ```

  ------

  ### 8. PWM ì œì–´ (ë¹„ë¡€ ì œì–´ìš© MOSFET)

  ì¼ë¶€ ì „ìë°¸ë¸ŒëŠ” **ìœ ëŸ‰ì„ ì œì–´í•˜ê¸° ìœ„í•œ ë¹„ë¡€ ì œì–´(PWM Duty)**ë¥¼ ì§€ì›í•œë‹¤.

  ```
  void Valve_PWM_Set(uint16_t duty)
  {
      __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, duty);
  }
  ```

  Duty(%)ë¥¼ ìˆ˜ìœ„ í¸ì°¨ì— ë¹„ë¡€ì‹œì¼œ ë‹¤ìŒê³¼ ê°™ì´ ì ìš©í•  ìˆ˜ ìˆë‹¤.
  $$
  Duty = K_p \times (Level_{target} - Level_{current})
  $$

  ------

  ### 9. ìƒíƒœ í”¼ë“œë°±

  OLED ë° UARTì— ë°¸ë¸Œ ìƒíƒœ í‘œì‹œ:

  ```
  ssd1306_SetCursor(0, 46);
  ssd1306_WriteString(Valve_State() ? "Valve: ON" : "Valve: OFF", Font_6x8, White);
  ```

  UART ë¡œê·¸:

  ```
  [VALVE] ON (Auto Control)
  ```

  ------

  ### 10. ê²°ë¡ 

  ë°¸ë¸Œ ì œì–´ëŠ” ë‹¨ìˆœí•œ GPIO On/Offì´ì§€ë§Œ,
   ì„¼ì„œ í”¼ë“œë°±ãƒ»íƒ€ì´ë¨¸ãƒ»Fail-safe ë¡œì§ì„ ê²°í•©í•˜ë©´ ì•ˆì •ì ì¸ ìë™ ì œì–´ ì‹œìŠ¤í…œì´ ëœë‹¤.
  $$
  \boxed{\text{Valve = Sensor Feedback + Time Limit + Safety Override}}
  $$

## 11.2 Sensor Node (ì €ì „ë ¥ ê³„ì¸¡ ë…¸ë“œ)

- ## RTC ì•ŒëŒ ê¸°ë°˜ Wake-up

  ### 1. ê°œìš”

  **RTC(Real-Time Clock) ì•ŒëŒ ê¸°ë°˜ Wake-up**ì€
   ì €ì „ë ¥ ëª¨ë“œ(SLEEP, STOP, STANDBY)ì—ì„œ ì‹œìŠ¤í…œì„ ì™„ì „íˆ ì •ì§€ì‹œí‚¨ ë’¤,
   RTC ì•ŒëŒ ì‹ í˜¸ë¥¼ ì´ìš©í•´ **ì£¼ê¸°ì ìœ¼ë¡œ MCUë¥¼ ê¹¨ì›Œ ì¸¡ì • ë° ì œì–´ ë£¨í‹´ì„ ìˆ˜í–‰**í•˜ëŠ” ë°©ì‹ì´ë‹¤.

  ì´ ë°©ì‹ì€ **ë°°í„°ë¦¬ êµ¬ë™ í™˜ê²½**ì´ë‚˜ **ì¥ê¸° ë™ì‘ IoT ì‹œìŠ¤í…œ**ì—ì„œ ì „ë ¥ ì†Œëª¨ë¥¼ ê·¹ì ìœ¼ë¡œ ì¤„ì´ê¸° ìœ„í•´ ì‚¬ìš©ëœë‹¤.

  ------

  ### 2. ë™ì‘ ê°œìš”

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚    Active Mode â”‚
  â”‚ - ì„¼ì„œ ì¸¡ì •     â”‚
  â”‚ - OLED/UART ì¶œë ¥ â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Sleep Mode   â”‚
  â”‚ - CPU ì •ì§€      â”‚
  â”‚ - LSE 32.768kHz ìœ ì§€ â”‚
  â”‚ - RTC ì•ŒëŒ ëŒ€ê¸°    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚(RTC Alarm IRQ)
          â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Wake-up       â”‚
  â”‚ - RTC_Alarm_IRQHandler â”‚
  â”‚ - ì¸¡ì • ë£¨í‹´ ì¬ì‹¤í–‰ â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ------

  ### 3. í•˜ë“œì›¨ì–´ ìš”êµ¬ ì¡°ê±´

  | í•­ëª©                   | ì„¤ëª…                                    |
  | ---------------------- | --------------------------------------- |
  | **LSE í¬ë¦¬ìŠ¤í„¸**       | 32.768kHz ì™¸ë¶€ í¬ë¦¬ìŠ¤í„¸ (RTC í´ëŸ­ ì†ŒìŠ¤) |
  | **RTC Alarm A (or B)** | ì•ŒëŒ ì¸í„°ëŸ½íŠ¸ íŠ¸ë¦¬ê±°                    |
  | **NVIC ì„¤ì •**          | `RTC_Alarm_IRQn` Enable                 |
  | **ì „ì› ëª¨ë“œ**          | STOP ë˜ëŠ” STANDBY ì§€ì› MCU              |

  ------

  ### 4. RTC ì•ŒëŒ ì„¤ì • ì½”ë“œ ì˜ˆì‹œ

  ```
  void Set_Alarm_AfterSeconds(uint32_t seconds)
  {
      RTC_AlarmTypeDef sAlarm = {0};
  
      HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
      HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
  
      uint8_t new_seconds = (sTime.Seconds + seconds) % 60;
      uint8_t carry_minutes = (sTime.Seconds + seconds) / 60;
  
      uint8_t new_minutes = (sTime.Minutes + carry_minutes) % 60;
      uint8_t carry_hours  = (sTime.Minutes + carry_minutes) / 60;
  
      uint8_t new_hours = (sTime.Hours + carry_hours) % 24;
  
      sAlarm.AlarmTime.Hours = new_hours;
      sAlarm.AlarmTime.Minutes = new_minutes;
      sAlarm.AlarmTime.Seconds = new_seconds;
      sAlarm.AlarmTime.SubSeconds = 0;
      sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
      sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  
      sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY;
      sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
      sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
      sAlarm.AlarmDateWeekDay = 1;
      sAlarm.Alarm = RTC_ALARM_A;
  
      HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);
  }
  ```

  ------

  ### 5. ì•ŒëŒ ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬

  ```
  void RTC_Alarm_IRQHandler(void)
  {
      HAL_RTC_AlarmIRQHandler(&hrtc);
  }
  
  void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
  {
      // Wake-up ë£¨í‹´ ì§„ì…
      printf("[RTC] Wake-up Alarm Triggered!\r\n");
  
      // í•„ìš”í•œ ì„¼ì„œ ì¸¡ì • ë° Task Notify ìˆ˜í–‰
      xTaskNotifyFromISR(RTCTaskHandle, 0, eNoAction, NULL);
  }
  ```

  ------

  ### 6. ì €ì „ë ¥ ì§„ì…

  ```
  void Enter_LowPower_Mode(void)
  {
      printf("Entering STOP Mode...\r\n");
      HAL_SuspendTick();                      // SysTick ì¤‘ë‹¨
      HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
      HAL_ResumeTick();                       // ì¬ê°œ
      SystemClock_Config();                   // í´ëŸ­ ì¬ì„¤ì •
  }
  ```

  ------

  ### 7. Wake-up íë¦„

  1. `Set_Alarm_AfterSeconds(60);` â€” RTC ì•ŒëŒì„ 60ì´ˆ í›„ë¡œ ì˜ˆì•½
  2. `Enter_LowPower_Mode();` â€” MCU STOP ëª¨ë“œ ì§„ì…
  3. RTCëŠ” ê³„ì† ë™ì‘ (LSE ê¸°ë°˜)
  4. ì•ŒëŒ ë°œìƒ â†’ `RTC_Alarm_IRQHandler()` í˜¸ì¶œ
  5. ì‹œìŠ¤í…œì´ ê¹¨ì–´ë‚˜ë©° ì¸¡ì • Task ì¬ê°œ
  6. ì¸¡ì • ì™„ë£Œ í›„ ë‹¤ì‹œ Sleep ë°˜ë³µ

  ------

  ### 8. FreeRTOS ì—°ë™

  RTC ì¸í„°ëŸ½íŠ¸ ì½œë°± ë‚´ì—ì„œ `xTaskNotifyFromISR()`ì„ ì´ìš©í•´
   **ì¸¡ì • Task**ë¥¼ ê¹¨ì›Œ ì£¼ê¸°ì ìœ¼ë¡œ ë™ì‘ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

  ```
  void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
  {
      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
      vTaskNotifyGiveFromISR(SensorTaskHandle, &xHigherPriorityTaskWoken);
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  }
  ```

  ------

  ### 9. OLED/UART ìƒíƒœ í‘œì‹œ

  ```
  ssd1306_SetCursor(0, 54);
  ssd1306_WriteString("Mode: STOP->WAKE", Font_6x8, White);
  ssd1306_UpdateScreen();
  UART_Log("[RTC] Wake-up from Alarm\r\n");
  ```

  ------

  ### 10. ê²°ë¡ 

  RTC ì•ŒëŒ ê¸°ë°˜ Wake-upì€

  - **ì„¼ì„œ ì£¼ê¸°ì  ë™ì‘**,
  - **ë°°í„°ë¦¬ ì ˆì•½**,
  - **ì •í™•í•œ ì‹œê°„ ê¸°ë°˜ ìŠ¤ì¼€ì¤„ë§**

  ì„ ë™ì‹œì— ë‹¬ì„±í•˜ëŠ” ì €ì „ë ¥ ì„¤ê³„ í•µì‹¬ ê¸°ë²•ì´ë‹¤.
  $$
  \boxed{\text{Sleep â†’ RTC Alarm â†’ Wake â†’ Measure â†’ Sleep}}
  $$

- ## STOP ëª¨ë“œ ì§„ì… / ë³µê·€

  ### 1. ê°œìš”

  **STOP ëª¨ë“œ(Stop Mode)**ëŠ” STM32 ë§ˆì´í¬ë¡œì»¨íŠ¸ë¡¤ëŸ¬ì˜ **ê°€ì¥ ëŒ€í‘œì ì¸ ì €ì „ë ¥ ëª¨ë“œ** ì¤‘ í•˜ë‚˜ë¡œ,
   CPU í´ë¡ê³¼ ëŒ€ë¶€ë¶„ì˜ ì£¼ë³€ì¥ì¹˜ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ë˜, **SRAM, ë ˆì§€ìŠ¤í„°, RTC, ë°±ì—… ë„ë©”ì¸**ì€ ìœ ì§€ë˜ëŠ” ìƒíƒœì´ë‹¤.

  ì´ ëª¨ë“œëŠ” **RTC ì•ŒëŒ, ì™¸ë¶€ ì¸í„°ëŸ½íŠ¸, ë˜ëŠ” íŠ¹ì • ì´ë²¤íŠ¸(EXTI, WKUP í•€ ë“±)** ì— ì˜í•´ ë³µê·€í•  ìˆ˜ ìˆë‹¤.
   ì¼ë°˜ì ìœ¼ë¡œ **RTC ì•ŒëŒ ê¸°ë°˜ Wake-up ì‹œìŠ¤í…œ**ê³¼ ê²°í•©í•˜ì—¬ ì‚¬ìš©í•œë‹¤.

  ------

  ### 2. STOP ëª¨ë“œ íŠ¹ì§•

  | í•­ëª©                  | ì„¤ëª…                               |
  | --------------------- | ---------------------------------- |
  | **ì†Œë¹„ ì „ë¥˜**         | ìˆ˜ì‹­ ÂµA ìˆ˜ì¤€ (MCU ì½”ì–´ ì •ì§€)       |
  | **ìœ ì§€ ìì›**         | SRAM, ë ˆì§€ìŠ¤í„°, ë°±ì—… ë„ë©”ì¸ ìœ ì§€   |
  | **í´ëŸ­ ìƒíƒœ**         | HSI/HSE ì •ì§€, LSE/Lsië§Œ ìœ ì§€ ê°€ëŠ¥  |
  | **ë³µê·€ íŠ¸ë¦¬ê±°**       | RTC ì•ŒëŒ, EXTI ë¼ì¸, WKUP í•€ ë“±    |
  | **ë³µê·€ í›„ ë™ì‘**      | `SystemClock_Config()` ì¬í˜¸ì¶œ í•„ìš” |
  | **ë³µê·€ í›„ ì½”ë“œ ìœ„ì¹˜** | Sleep ì „ ì§€ì  ì´í›„ ì½”ë“œ ê³„ì† ì‹¤í–‰  |

  ------

  ### 3. STOP ëª¨ë“œ ì§„ì… ì ˆì°¨

  1. **ì£¼ìš” ì£¼ë³€ì¥ì¹˜ ì •ì§€**

     - ADC, Timer, IÂ²C, SPI ë“± í´ëŸ­ ì˜ì¡´ ì¥ì¹˜ ì¢…ë£Œ
     - OLED, UART ë“± ë¹„í•„ìˆ˜ ëª¨ë“ˆ Sleep ì²˜ë¦¬

  2. **SysTick ì¤‘ë‹¨**

     ```
     HAL_SuspendTick();
     ```

  3. **STOP ëª¨ë“œ ì§„ì…**

     ```
     HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
     ```

  4. **ë³µê·€ í›„ í´ëŸ­ ë³µì›**

     ```
     SystemClock_Config();
     HAL_ResumeTick();
     ```

  ------

  ### 4. ì˜ˆì œ ì½”ë“œ

  ```
  void Enter_StopMode(void)
  {
      printf("Entering STOP Mode...\r\n");
  
      // ì£¼ë³€ì¥ì¹˜ ë° í†µì‹  ëª¨ë“ˆ ë¹„í™œì„±í™”
      HAL_I2C_DeInit(&hi2c1);
      HAL_UART_DeInit(&huart1);
  
      // SysTick ì¤‘ë‹¨
      HAL_SuspendTick();
  
      // STOP ëª¨ë“œ ì§„ì…
      HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
  
      // ì´í›„ RTC ì•ŒëŒ ë˜ëŠ” EXTIì— ì˜í•´ ë³µê·€
  }
  
  void Exit_StopMode(void)
  {
      // í´ëŸ­ ë³µì›
      SystemClock_Config();
      HAL_ResumeTick();
  
      // ì£¼ë³€ì¥ì¹˜ ì¬ì´ˆê¸°í™”
      MX_I2C1_Init();
      MX_USART1_UART_Init();
  
      printf("Woke up from STOP Mode\r\n");
  }
  ```

  ------

  ### 5. RTC ì•ŒëŒê³¼ ì—°ê³„

  RTC ì•ŒëŒ ì¸í„°ëŸ½íŠ¸ëŠ” STOP ëª¨ë“œì—ì„œë„ ë™ì‘ ê°€ëŠ¥í•˜ë‹¤.
   ì•„ë˜ ìˆœì„œë¡œ êµ¬ì„±í•˜ë©´ ì™„ì „í•œ ì£¼ê¸°ì  Sleep-Wake ì‚¬ì´í´ì´ ê°€ëŠ¥í•˜ë‹¤.

  ```
  // 1. 60ì´ˆ í›„ ì•ŒëŒ ì„¤ì •
  Set_Alarm_AfterSeconds(60);
  
  // 2. STOP ëª¨ë“œ ì§„ì…
  Enter_StopMode();
  
  // 3. ì•ŒëŒ ë°œìƒ ì‹œ RTC_Alarm_IRQHandler() í˜¸ì¶œ
  void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
  {
      Exit_StopMode();
      Sensor_Measure_Routine();
  }
  ```

  ------

  ### 6. ë³µê·€ ë™ì‘ íë¦„

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Active Mode             â”‚
  â”‚ - ì„¼ì„œ ì¸¡ì •, í†µì‹  ìˆ˜í–‰  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ STOP Mode              â”‚
  â”‚ - í´ëŸ­ ì •ì§€ (HSI/HSE)   â”‚
  â”‚ - RTC ë™ì‘ ìœ ì§€         â”‚
  â”‚ - ì „ë ¥ì†Œëª¨ ìµœì†Œí™”       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ (RTC Alarm / EXTI)
                 â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Wake-up                â”‚
  â”‚ - í´ëŸ­ ë³µêµ¬, HAL ì¬ê°œ   â”‚
  â”‚ - ì¸¡ì • ë£¨í‹´ ì¬ì‹¤í–‰      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ------

  ### 7. ì£¼ì˜ì‚¬í•­

  | í•­ëª©                 | ì„¤ëª…                                            |
  | -------------------- | ----------------------------------------------- |
  | **í´ëŸ­ ì¬ì„¤ì •**      | STOP ë³µê·€ ì‹œ `SystemClock_Config()` ë°˜ë“œì‹œ í˜¸ì¶œ |
  | **ë””ë²„ê·¸ ë¶ˆê°€**      | STOP ëª¨ë“œì—ì„œëŠ” JTAG/SWD ì—°ê²°ì´ ì¼ì‹œ ì¤‘ë‹¨ë¨     |
  | **ì „ì› ì•ˆì •ì„±**      | ì™¸ë¶€ ì•ˆì •í™” íšŒë¡œ(ì „ì›, RTC LSE í•„í„° ë“±) í•„ìš”    |
  | **FreeRTOS ì‚¬ìš© ì‹œ** | Idle Taskì—ì„œ Tickless Idle Modeì™€ ë³‘í–‰ ê°€ëŠ¥    |

  ------

  ### 8. FreeRTOS ì—°ë™ ì˜ˆì‹œ

  FreeRTOS í™˜ê²½ì—ì„œëŠ” Idle Taskì—ì„œ STOP ëª¨ë“œ ì§„ì…ì„ ìë™í™”í•  ìˆ˜ ìˆë‹¤.

  ```
  void vApplicationIdleHook(void)
  {
      __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
      HAL_SuspendTick();
      HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
      HAL_ResumeTick();
      SystemClock_Config();
  }
  ```

  ------

  ### 9. ê²°ë¡ 

  STOP ëª¨ë“œëŠ” STM32ì˜ ì „ë ¥ íš¨ìœ¨ì„ ê·¹ëŒ€í™”í•˜ëŠ” í•µì‹¬ ê¸°ëŠ¥ìœ¼ë¡œ,
   RTC ì•ŒëŒ ê¸°ë°˜ Wake-upê³¼ ê²°í•©í•˜ë©´ **ì„¼ì„œ ì¸¡ì • ì£¼ê¸° ì œì–´**, **ë°°í„°ë¦¬ ìˆ˜ëª… ì—°ì¥**,
   **ì™„ì „í•œ ì €ì „ë ¥ IoT ì‹œìŠ¤í…œ êµ¬í˜„**ì´ ê°€ëŠ¥í•˜ë‹¤.
  $$
  \boxed{\text{Active â†’ STOP â†’ RTC Alarm â†’ Wake â†’ Active}}
  $$

- ## ì¸¡ì • â†’ ì „ì†¡ â†’ Sleep

  ### ğŸ§© ê°œìš”

  ì €ì „ë ¥ IoT ì‹œìŠ¤í…œ(ì˜ˆ: ìˆ˜ìœ„ ëª¨ë‹ˆí„°ë§, ë¬´ì„  ë¡œë“œì…€ ë“±)ì€
   â€œ**ì¸¡ì • â†’ ë°ì´í„° ì „ì†¡ â†’ ì ˆì „(Sleep)**â€ ì£¼ê¸°ë¡œ ë™ì‘í•˜ì—¬
   ë°°í„°ë¦¬ ìˆ˜ëª…ì„ ê·¹ëŒ€í™”í•œë‹¤.

  ì´ êµ¬ì¡°ëŠ” **RTC ì•ŒëŒ ê¸°ë°˜ ì£¼ê¸° ì œì–´** + **STOP ëª¨ë“œ ì§„ì…/ë³µê·€** ë¡œ êµ¬í˜„í•œë‹¤.

  ------

  ### âš™ï¸ ì „ì²´ ë™ì‘ íë¦„

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 1. ì¸¡ì • ë‹¨ê³„    â”‚
  â”‚ - ì´ˆìŒíŒŒ ì„¼ì„œ    â”‚
  â”‚ - HX711 ë¡œë“œì…€  â”‚
  â”‚ - RTC íƒ€ì„ìŠ¤íƒ¬í”„ â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 2. ì „ì†¡ ë‹¨ê³„     â”‚
  â”‚ - BLE/UART í†µì‹  â”‚
  â”‚ - OLED ìƒíƒœ í‘œì‹œ â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 3. Sleep ë‹¨ê³„    â”‚
  â”‚ - ì£¼ë³€ì¥ì¹˜ ì¢…ë£Œ   â”‚
  â”‚ - STOP ëª¨ë“œ ì§„ì… â”‚
  â”‚ - RTC ì•ŒëŒ ëŒ€ê¸°  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ------

  ### ğŸ“¡ í•µì‹¬ ìˆœì„œ

  ```
  void Main_Cycle(void)
  {
      /* 1. ì¸¡ì • ë‹¨ê³„ ---------------------------------- */
      Sensor_Read_All();     // ì´ˆìŒíŒŒ + ìˆ˜ìœ„ + HX711
      Process_Data();        // ì˜¤í”„ì…‹/ìŠ¤ë¬´ë”©/ë³´ì •
  
      /* 2. ì „ì†¡ ë‹¨ê³„ ---------------------------------- */
      UART_Send_Data();      // PC/ë¡œê±° ì „ì†¡
      BLE_Transmit_Data();   // ë¬´ì„  ì†¡ì‹ 
      OLED_Display_Status(); // ê°„ëµ ìƒíƒœ í‘œì‹œ
  
      /* 3. Sleep ë‹¨ê³„ ---------------------------------- */
      Prepare_Sleep();       // ì£¼ë³€ì¥ì¹˜ ì¢…ë£Œ, IÂ²C/UART DeInit
      Set_Alarm_AfterSeconds(60); // ë‹¤ìŒ ì£¼ê¸° (ì˜ˆ: 60ì´ˆ)
      Enter_StopMode();      // STOP ëª¨ë“œ ì§„ì…
  }
  ```

  ------

  ### ğŸ§­ 1. ì¸¡ì • ë‹¨ê³„ (Sensor_Read_All)

  ```
  void Sensor_Read_All(void)
  {
      float level = Ultrasonic_GetDistance();     // ì´ˆìŒíŒŒ ê±°ë¦¬
      float weight = HX711_GetWeight();           // ë¡œë“œì…€
      float temp = Read_TempSensor();             // ë³´ì¡° ì„¼ì„œ
  
      data.level = level;
      data.weight = weight;
      data.temp = temp;
  
      printf("Level: %.1f cm, Weight: %.2f kg, Temp: %.1fÂ°C\r\n",
             level, weight, temp);
  }
  ```

  > ğŸ’¡ ë³´ì • ì•Œê³ ë¦¬ì¦˜ (Offset, Kalman, Exponential Smoothing ë“±)ì€
  >  `Process_Data()` ë‚´ë¶€ì—ì„œ ìˆ˜í–‰í•œë‹¤.

  ------

  ### ğŸ”„ 2. ì „ì†¡ ë‹¨ê³„ (BLE/UART)

  ```
  void UART_Send_Data(void)
  {
      char buffer[64];
      sprintf(buffer, "L=%.1f, W=%.2f, T=%.1f\r\n",
              data.level, data.weight, data.temp);
      HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), 100);
  }
  
  void BLE_Transmit_Data(void)
  {
      if (ble_connected)
          BLE_SendMeasurement(data.level, data.weight, data.temp);
  }
  ```

  > OLEDì—ëŠ” â€œì „ì†¡ ì™„ë£Œâ€ ë˜ëŠ” â€œSleep ì§„ì… ì¤‘â€¦â€ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•´
  >  ìƒíƒœ ëª¨ë‹ˆí„°ë§ì„ ì‰½ê²Œ í•  ìˆ˜ ìˆë‹¤.

  ------

  ### ğŸŒ™ 3. Sleep ë‹¨ê³„ (STOP Mode)

  ```
  void Prepare_Sleep(void)
  {
      HAL_I2C_DeInit(&hi2c1);
      HAL_UART_DeInit(&huart1);
      HAL_SuspendTick();
  }
  
  void Enter_StopMode(void)
  {
      printf("Entering STOP Mode...\r\n");
      HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
  }
  
  void Wakeup_From_Stop(void)
  {
      SystemClock_Config();
      HAL_ResumeTick();
      MX_I2C1_Init();
      MX_USART1_UART_Init();
      printf("Wake-up complete\r\n");
  }
  ```

  ------

  ### â° 4. RTC ì•ŒëŒ ê¸°ë°˜ Wake-up

  ```
  void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
  {
      Wakeup_From_Stop();
      Main_Cycle();  // ë‹¤ìŒ ì£¼ê¸° ìˆ˜í–‰
  }
  ```

  ------

  ### ğŸª« ì „ë ¥ ì ˆê° í¬ì¸íŠ¸

  | í•­ëª©     | ì ˆì „ ì¡°ì¹˜                    |
  | -------- | ---------------------------- |
  | OLED     | Sleep ëª…ë ¹ ì „ì†¡ í›„ ì „ì› ì°¨ë‹¨ |
  | UART/BLE | DeInit ë˜ëŠ” ì „ì›ì°¨ë‹¨         |
  | IÂ²C ì„¼ì„œ | ì „ì› GPIO OFF                |
  | MCU      | STOP ëª¨ë“œ ì§„ì…               |
  | RTC      | LSE ê¸°ë°˜ ìœ ì§€, ì•ŒëŒìœ¼ë¡œ ë³µê·€ |

  ------

  ### ğŸ“˜ ì£¼ê¸° ë™ì‘ ê°œë…

  | ìƒíƒœ             | ì „ë ¥ì†Œëª¨ | ì£¼ìš” ë™ì‘              |
  | ---------------- | -------- | ---------------------- |
  | **Active**       | 5â€“15 mA  | ì¸¡ì •, ì—°ì‚°, í†µì‹        |
  | **Sleep (STOP)** | <100 ÂµA  | RTC ìœ ì§€, ëŒ€ê¸°         |
  | **Wake-up**      | 1â€“2 ms   | í´ëŸ­ ì¬ë³µì›, Task ì¬ê°œ |

  ------

  ### âœ… ìµœì¢… êµ¬ì¡° ì˜ˆì‹œ

  ```
  int main(void)
  {
      System_Init();
      RTC_Init();
      OLED_Init();
      BLE_Init();
  
      while (1)
      {
          Main_Cycle();      // ì¸¡ì • â†’ ì „ì†¡ â†’ Sleep
      }
  }
  ```

  ------

  ### ğŸ”‹ ê²°ë¡ 

  ì´ êµ¬ì¡°ëŠ” ë°°í„°ë¦¬ ê¸°ë°˜ IoT ì¥ì¹˜(ì˜ˆ: **ì›ê²© ìˆ˜ìœ„/í•˜ì¤‘ ì¸¡ì •ê¸°**)ì—ì„œ
   **ì¸¡ì • ì •í™•ë„ ìœ ì§€ + ìˆ˜ê°œì›” ì´ìƒ ë™ì‘ ê°€ëŠ¥**í•˜ê²Œ í•˜ëŠ” í•µì‹¬ ë£¨í‹´ì´ë‹¤.
  $$
  \boxed{\text{ì¸¡ì • â†’ ì „ì†¡ â†’ Sleep (RTC ì•ŒëŒ â†’ Wake-up â†’ ì¸¡ì • ë°˜ë³µ)}}
  $$

- ## ì†Œë¹„ì „ë¥˜ ì¸¡ì • ë° ìµœì í™”

  ### ğŸ§­ ê°œìš”

  ì €ì „ë ¥ ì‹œìŠ¤í…œì—ì„œ **ì†Œë¹„ì „ë¥˜(Current Consumption)** ì¸¡ì •ê³¼ ìµœì í™”ëŠ”
   ë°°í„°ë¦¬ ìˆ˜ëª…, ë°œì—´, ì•ˆì •ì„±ì„ ì¢Œìš°í•˜ëŠ” í•µì‹¬ ë‹¨ê³„ë‹¤.

  STM32 ê¸°ë°˜ì˜ IoT/ì„¼ì„œ ì‹œìŠ¤í…œì—ì„œëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ ì¸¡ë©´ì—ì„œ ì ‘ê·¼í•œë‹¤:

  1. **ì •í™•í•œ ì†Œë¹„ì „ë¥˜ ì¸¡ì • ë°©ë²•**
  2. **ì†Œìë³„ ì†Œë¹„ì „ë¥˜ ë¶„ì„**
  3. **íŒì›¨ì–´ ë° í•˜ë“œì›¨ì–´ ìµœì í™” ê¸°ë²•**

  ------

  ### âš™ï¸ 1. ì†Œë¹„ì „ë¥˜ ì¸¡ì • í™˜ê²½ êµ¬ì„±

  #### ì¸¡ì • ë°©ë²•

  | ë°©ë²•                              | ì„¤ëª…                                   | ì¥ì              | ë‹¨ì                              |
  | --------------------------------- | -------------------------------------- | ---------------- | -------------------------------- |
  | **ë©€í‹°ë¯¸í„° ì§ë ¬ ì¸¡ì •**            | ì „ì›ì„ ì— ì§ë ¬ë¡œ ì—°ê²°í•˜ì—¬ DC ì „ë¥˜ ì¸¡ì •  | ê°„ë‹¨, ë¹ ë¦„       | Sleep/Active ì „í™˜ êµ¬ê°„ ì¸¡ì • ë¶ˆê°€ |
  | **ìƒŒë“œìœ„ì¹˜ ì €í•­(Shunt Resistor)** | ì €í•­ì— ê±¸ë¦° ì „ì••ì„ ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ë¡œ ì¸¡ì • | ì‹œê°„ ë¶„í•´ëŠ¥ ë†’ìŒ | ë³´ì • í•„ìš”, íšŒë¡œ ì‚½ì… í•„ìš”        |
  | **ì „ë¥˜ í”„ë¡œë¸Œ (Current Probe)**   | ì „ë¥˜ í´ë¨í”„ ë°©ì‹ìœ¼ë¡œ ë¹„ì ‘ì´‰ ì¸¡ì •       | ë¹„ì¹¨ì…ì‹, ì‹¤ì‹œê°„ | ê³ ê°€, ë…¸ì´ì¦ˆ ë¯¼ê°                |
  | **ì „ë ¥ë¶„ì„ê¸° (Power Analyzer)**   | ì „ë¥˜ + ì „ì•• ë™ì‹œ ë¶„ì„                  | ì •í™•, í†µí•© ë¶„ì„  | ê³ ê°€ ì¥ë¹„ í•„ìš”                   |

  #### ê¸°ë³¸ êµ¬ì„± ì˜ˆì‹œ

  ```
  DC Power Supply (3.3V)
       â”‚
       â”œâ”€â”€â”€[Shunt 1Î©]â”€â”€â”€â–¶ DUT (STM32 ë³´ë“œ)
       â”‚
       â””â”€â”€â”€â–¶ Differential Probe (ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„)
  ```

  > ì €í•­ê°’ì€ 0.1â€“1 Î© ê¶Œì¥.
  >  ì „ì•• ê°•í•˜ ìµœì†Œí™” ë° ì „ë¥˜ ë³€ë™ ë¶„ì„ ê°€ëŠ¥.

  ------

  ### ğŸ§ª 2. ì¸¡ì • ì ˆì°¨

  #### (1) ì‹œìŠ¤í…œ ìƒíƒœë³„ ì „ë¥˜ ì¸¡ì •

  | ìƒíƒœ         | ì£¼ìš” êµ¬ì„±ìš”ì†Œ              | ì˜ˆìƒ ì „ë¥˜ (ì˜ˆì‹œ) |
  | ------------ | -------------------------- | ---------------- |
  | Active Mode  | MCU + OLED + IÂ²C ì„¼ì„œ      | 8â€“15 mA          |
  | Sleep (STOP) | RTC + ë°±ì—…ë ˆì§€ìŠ¤í„° ìœ ì§€    | 50â€“100 ÂµA        |
  | Standby      | RTC Off                    | <10 ÂµA           |
  | Wake-up      | í´ëŸ­ ë³µì›, ì£¼ë³€ì¥ì¹˜ ì´ˆê¸°í™” | 1â€“3 mA (ë‹¨ê¸°)    |

  #### (2) íŒŒí˜• ë¶„ì„

  - **ì¸¡ì • ë„êµ¬:** ì˜¤ì‹¤ë¡œìŠ¤ì½”í”„ + ì°¨ë™ í”„ë¡œë¸Œ
  - **íŒŒí˜• í™•ì¸ í•­ëª©:**
    - ì¸¡ì • ë£¨í‹´ ë™ì•ˆì˜ ì „ë¥˜ í”¼í¬
    - STOP ëª¨ë“œ ì§„ì… í›„ ì•ˆì • ì „ë¥˜
    - Wake-up íŠ¸ëœì§€ì–¸íŠ¸ êµ¬ê°„
    - BLE/UART ì „ì†¡ ì‹œ ìŠ¤íŒŒì´í¬

  > íŒŒí˜• ë¶„ì„ì„ í†µí•´ **ë¶ˆí•„ìš”í•œ ì£¼ë³€ì¥ì¹˜ê°€ Sleep ì¤‘ì—ë„ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€** ì‹ë³„ ê°€ëŠ¥.

  ------

  ### âš¡ 3. ì£¼ìš” ì†Œë¹„ì› ë¶„ì„

  | êµ¬ì„± ìš”ì†Œ                    | ì†Œë¹„ì „ë¥˜                            | ì ˆì „ ë°©ë²•                   |
  | ---------------------------- | ----------------------------------- | --------------------------- |
  | **MCU (STM32F1)**            | 3â€“10 mA (Run) / 20â€“50 ÂµA (STOP)     | HSIâ†’MSI ì „í™˜, STOP ëª¨ë“œ     |
  | **OLED (SSD1306)**           | 5â€“10 mA                             | Sleep ëª…ë ¹, ì „ì› ì°¨ë‹¨       |
  | **HX711 (ADC)**              | 1.5 mA                              | Power Down í•€ ì œì–´          |
  | **VL53L0X (ToF)**            | 10â€“20 mA (Active) / 5 ÂµA (Idle)     | `VL53L0X_StopMeasurement()` |
  | **BLE Module (ESP32-C3 ë“±)** | 40â€“120 mA (Tx) / 10 ÂµA (Deep Sleep) | ì—°ê²° ìœ ì§€ ì‹œê°„ ìµœì†Œí™”       |
  | **RTC**                      | <1 ÂµA                               | ìœ ì§€ í•„ìš”, ë³„ë„ ì ˆì „ ë¶ˆê°€   |

  ------

  ### ğŸ”§ 4. íŒì›¨ì–´ ì ˆì „ ìµœì í™” ê¸°ë²•

  #### (1) í´ëŸ­ ì œì–´

  ```
  __HAL_RCC_GPIOA_CLK_DISABLE();
  __HAL_RCC_SPI1_CLK_DISABLE();
  __HAL_RCC_ADC1_CLK_DISABLE();
  ```

  - ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì£¼ë³€ì¥ì¹˜ í´ëŸ­ ë¹„í™œì„±í™”
  - SystemClock_Config() ë‚´ì—ì„œ PLL/HSI ì£¼íŒŒìˆ˜ ì¡°ì •

  #### (2) GPIO ìƒíƒœ ê´€ë¦¬

  - ë¶ˆí•„ìš”í•œ Floating Input ë°©ì§€ â†’ **Pull-down ì„¤ì •**
  - LED í•€ OFF ìƒíƒœ ìœ ì§€
  - Sensor Power í•€ OFFë¡œ ì „ì› ì°¨ë‹¨

  ```
  HAL_GPIO_WritePin(SENSOR_PWR_GPIO_Port, SENSOR_PWR_Pin, GPIO_PIN_RESET);
  ```

  #### (3) Sleep / STOP / Standby ëª¨ë“œ í™œìš©

  | ëª¨ë“œ        | íŠ¹ì§•                | ë³µê·€ì‹œê°„ | ì†Œë¹„ì „ë¥˜ |
  | ----------- | ------------------- | -------- | -------- |
  | **Sleep**   | CPUë§Œ ì •ì§€          | 1â€“5 Âµs   | ìˆ˜ mA    |
  | **STOP**    | RAM ìœ ì§€, í´ëŸ­ ì •ì§€ | 1â€“2 ms   | ìˆ˜ì‹­ ÂµA  |
  | **Standby** | RAM ì†Œë©¸, ìµœì†Œ ìœ ì§€ | ìˆ˜ì‹­ ms  | ìˆ˜ ÂµA    |

  ```
  HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
  ```

  #### (4) RTC ì•ŒëŒ ê¸°ë°˜ Wake-up

  STOP ëª¨ë“œì—ì„œë„ RTC ìœ ì§€, ì•ŒëŒìœ¼ë¡œ ë³µê·€ ê°€ëŠ¥.

  ```
  Set_Alarm_AfterSeconds(60);
  ```

  ------

  ### ğŸ§® 5. ì¸¡ì • ë°ì´í„° ë¶„ì„ ì˜ˆì‹œ

  | êµ¬ê°„     | ë™ì‘           | ì „ë¥˜ (mA) | ì§€ì†ì‹œê°„ (ms) | ì—ë„ˆì§€ (mC) |
  | -------- | -------------- | --------- | ------------- | ----------- |
  | ì¸¡ì •     | ì´ˆìŒíŒŒ + HX711 | 10.5      | 200           | 2.1         |
  | ì „ì†¡     | BLE Tx         | 40.0      | 50            | 2.0         |
  | Sleep    | STOP ëª¨ë“œ      | 0.05      | 58000         | 2.9         |
  | **í•©ê³„** | 1ë¶„ ì£¼ê¸°       | â€”         | 60000         | **7.0 mC**  |

  > í‰ê·  ì „ë¥˜ = 7.0 mC / 60 s = **0.116 mA**
  >  â†’ 1000 mAh ë°°í„°ë¦¬ ì‚¬ìš© ì‹œ ì•½ **360ì¼** ë™ì‘ ê°€ëŠ¥.

  ------

  ### ğŸ§° 6. í•˜ë“œì›¨ì–´ ì ˆì „ ì„¤ê³„ í¬ì¸íŠ¸

  | í•­ëª©         | ìµœì í™” ë°©ë²•                |
  | ------------ | -------------------------- |
  | ì „ì›ê³µê¸‰     | LDO ëŒ€ì‹  DC-DC ì‚¬ìš©        |
  | ì„¼ì„œ ì „ì›    | MOSFETìœ¼ë¡œ ê°œë³„ ì œì–´       |
  | Pull-up ì €í•­ | 10 kÎ© ì´ìƒìœ¼ë¡œ ìƒí–¥        |
  | LED í‘œì‹œ     | í•„ìš”ì‹œë§Œ ì ë“±              |
  | ë””ì»¤í”Œë§     | ì „ì› ì•ˆì •í™”ìš© 100nF + 10ÂµF |
  | ë°°í„°ë¦¬ ë³´í˜¸  | ì €ì „ì•• ì°¨ë‹¨ íšŒë¡œ           |

  ------

  ### ğŸ“Š 7. ìµœì í™” ê²€ì¦ ë£¨í‹´

  1. **Baseline ì¸¡ì •:** ëª¨ë“  ê¸°ëŠ¥ í™œì„± ìƒíƒœ
  2. **Stop Mode ì¸¡ì •:** MCUë§Œ ì ˆì „
  3. **Peripheral Off ì¸¡ì •:** IÂ²C/OLED ì°¨ë‹¨
  4. **Sleep ë£¨í”„ ë°˜ë³µ:** í‰ê· ê°’ ì‚°ì¶œ
  5. **ê° êµ¬ê°„ ì „ë¥˜ ë¡œê·¸ ì €ì¥** (ì˜ˆ: INA219 ì „ë¥˜ì„¼ì„œ ì‚¬ìš©)

  ------

  ### âœ… ê²°ë¡ 

  STM32 ê¸°ë°˜ ì‹œìŠ¤í…œì—ì„œ ì†Œë¹„ì „ë¥˜ë¥¼ ì¤„ì´ê¸° ìœ„í•´ì„œëŠ”
   í•˜ë“œì›¨ì–´, íŒì›¨ì–´, ì£¼ê¸° ì„¤ê³„ ì„¸ ê°€ì§€ë¥¼ í†µí•©ì ìœ¼ë¡œ ìµœì í™”í•´ì•¼ í•œë‹¤.
  $$
  I_{\text{avg}} = \frac{(I_\text{active} \cdot t_\text{active}) + (I_\text{sleep} \cdot t_\text{sleep})}{T_{\text{cycle}}}
  $$
  ì¦‰,
   **í™œì„± ì‹œê°„(t_active)ì„ ìµœì†Œí™”í•˜ê³ , Sleep ì‹œê°„(t_sleep)ì„ ìµœëŒ€í™”**
   í•˜ëŠ” ê²ƒì´ ì ˆì „ ì„¤ê³„ì˜ í•µì‹¬ì´ë‹¤.

## 11.3 ìë™ ìˆ˜ìœ„ ì œì–´ ì‹œìŠ¤í…œ

- ## ëª©í‘œ ìˆ˜ìœ„ ì…ë ¥

  ### ğŸ§­ ê°œìš”

  ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ ë°¸ë¸Œë‚˜ íŒí”„ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ì„œëŠ”
   ì‚¬ìš©ìê°€ **ëª©í‘œ ìˆ˜ìœ„(Target Level)** ë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤.
   ì´ ê°’ì€ ì¸¡ì •ëœ ì‹¤ì œ ìˆ˜ìœ„(`measured_level`)ì™€ ë¹„êµë˜ì–´,
   ì œì–´ ë£¨í”„(ì˜ˆ: íŒí”„ ON/OFF, ë°¸ë¸Œ ê°œí)ì˜ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤.

  ------

  ### âš™ï¸ 1. ë³€ìˆ˜ ì •ì˜

  ```
  float target_level = 100.0f;   // ëª©í‘œ ìˆ˜ìœ„ (mm ë‹¨ìœ„)
  float measured_level = 0.0f;   // ì„¼ì„œ ì¸¡ì •ê°’
  ```

  > ê¸°ë³¸ê°’ì€ 100 mm ë“± ì‹œìŠ¤í…œì— ë§ê²Œ ì´ˆê¸°í™”í•œë‹¤.
  >  ì´ ê°’ì€ EEPROM ë˜ëŠ” Flashì— ì €ì¥í•˜ì—¬ ì „ì› ì¬ì¸ê°€ ì‹œì—ë„ ìœ ì§€í•œë‹¤.

  ------

  ### ğŸ§© 2. ì…ë ¥ ë°©ë²•

  | ì…ë ¥ ë°©ì‹              | ì„¤ëª…                               | êµ¬í˜„ ë°©ì‹            |
  | ---------------------- | ---------------------------------- | -------------------- |
  | **UART ëª…ë ¹ ì…ë ¥**     | PC ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„°ì—ì„œ ëª…ë ¹ìœ¼ë¡œ ì„¤ì • | `SET LVL 120`        |
  | **OLED + ë²„íŠ¼ UI**     | ë²„íŠ¼ìœ¼ë¡œ ìˆ˜ìœ„ ì¡°ì •                 | Up/Down ë²„íŠ¼ ì…ë ¥    |
  | **BLE (ì•± ì—°ë™)**      | BLE Characteristic í†µí•´ ì„¤ì •       | ìŠ¤ë§ˆíŠ¸í° ì•± ì—°ë™     |
  | **EEPROM ì´ˆê¸°ê°’ ë¡œë“œ** | ë¶€íŒ… ì‹œ ì €ì¥ê°’ ë¡œë“œ                | `EEPROM_ReadFloat()` |

  ------

  ### ğŸ’¬ 3. UART ëª…ë ¹ ê¸°ë°˜ ì˜ˆì‹œ

  ```
  void UART_CommandHandler(char *cmd)
  {
      if (strncmp(cmd, "SET LVL", 7) == 0)
      {
          float val = atof(cmd + 8);
          if (val >= 0 && val <= 300)
          {
              target_level = val;
              EEPROM_WriteFloat(ADDR_TARGET_LEVEL, target_level);
              printf("Target Level set to %.1f mm\r\n", target_level);
          }
          else
          {
              printf("Invalid range (0â€“300 mm)\r\n");
          }
      }
      else if (strncmp(cmd, "GET LVL", 7) == 0)
      {
          printf("Target Level: %.1f mm\r\n", target_level);
      }
  }
  ```

  > ì‚¬ìš© ì˜ˆ:
  >
  > ```
  > > SET LVL 120
  > Target Level set to 120.0 mm
  > > GET LVL
  > Target Level: 120.0 mm
  > ```

  ------

  ### ğŸ“Ÿ 4. OLED + ë²„íŠ¼ ì¸í„°í˜ì´ìŠ¤ ì˜ˆì‹œ

  ```
  void Handle_LevelSetting(void)
  {
      static float temp_target = target_level;
  
      if (Button_Up_Pressed())    temp_target += 5.0f;
      if (Button_Down_Pressed())  temp_target -= 5.0f;
  
      if (temp_target < 0) temp_target = 0;
      if (temp_target > 300) temp_target = 300;
  
      OLED_ShowString(0, 0, "Set Level:");
      OLED_ShowFloat(80, 0, temp_target, 1);
      OLED_ShowString(120, 0, "mm");
  
      if (Button_OK_Pressed())
      {
          target_level = temp_target;
          EEPROM_WriteFloat(ADDR_TARGET_LEVEL, target_level);
          OLED_ShowString(0, 16, "Saved!");
      }
  }
  ```

  > ë²„íŠ¼ UI ì˜ˆì‹œ
  >
  > - â–² : +5 mm
  > - â–¼ : âˆ’5 mm
  > - OK : ì €ì¥

  ------

  ### ğŸ”„ 5. EEPROM ì €ì¥ ë° ë¡œë“œ

  ```
  #define ADDR_TARGET_LEVEL 0x10
  
  void Save_TargetLevel(void)
  {
      EEPROM_WriteFloat(ADDR_TARGET_LEVEL, target_level);
  }
  
  void Load_TargetLevel(void)
  {
      target_level = EEPROM_ReadFloat(ADDR_TARGET_LEVEL);
      if (isnan(target_level) || target_level <= 0)
          target_level = 100.0f; // ê¸°ë³¸ê°’
  }
  ```

  > EEPROM ì ‘ê·¼ ì‹œ `HAL_I2C_Mem_Write()` / `HAL_I2C_Mem_Read()` ì‚¬ìš©.

  ------

  ### ğŸ§  6. ì œì–´ ë£¨í”„ì—ì„œì˜ í™œìš©

  ```
  void ControlTask(void)
  {
      measured_level = Get_Level_mm();
  
      if (measured_level < target_level - 5)
          Pump_On();
      else if (measured_level > target_level + 5)
          Pump_Off();
  
      printf("Level: %.1f / %.1f mm\r\n", measured_level, target_level);
  }
  ```

  > Â±5 mmì˜ **íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(Hysteresis)** ë¥¼ ì ìš©í•´
  >  íŒí”„ì˜ ë¹ˆë²ˆí•œ On/Offë¥¼ ë°©ì§€í•œë‹¤.

  ------

  ### ğŸª« 7. ì˜ˆì‹œ ì‹œë‚˜ë¦¬ì˜¤

  | ìƒí™© | ì¸¡ì • ìˆ˜ìœ„ | ëª©í‘œ ìˆ˜ìœ„ | ì œì–´ ìƒíƒœ        |
  | ---- | --------- | --------- | ---------------- |
  | ì´ˆê¸° | 90 mm     | 100 mm    | Pump ON          |
  | ìƒìŠ¹ | 98 mm     | 100 mm    | ìœ ì§€             |
  | ë„ë‹¬ | 101 mm    | 100 mm    | Pump OFF         |
  | í•˜ê°• | 95 mm     | 100 mm    | Pump ON (ì¬ì‹œì‘) |

  ------

  ### âœ… ê²°ë¡ 

  ëª©í‘œ ìˆ˜ìœ„ ì…ë ¥ ê¸°ëŠ¥ì€

  - **ì‚¬ìš©ì ë§ì¶¤ ì œì–´ ì„¤ì •**
  - **EEPROM ì˜êµ¬ ì €ì¥**
  - **UI/ëª…ë ¹/BLE ì¸í„°í˜ì´ìŠ¤ í†µí•©**

  ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ë©°,
   ìë™ ê¸‰ìˆ˜Â·ë°°ìˆ˜ ì‹œìŠ¤í…œì˜ **ì¤‘ì¶” ì œì–´ ê¸°ì¤€**ìœ¼ë¡œ ì‘ë™í•œë‹¤.
  $$
  \boxed{\text{Target Level (User Input)} \;\Rightarrow\; \text{Control Reference (Pump/Valve Logic)}}
  $$

- ## PID ì œì–´ (ê°„ë‹¨ ë¹„ë¡€ì œì–´)

  ### ğŸ§­ ê°œìš”

  PID ì œì–´ëŠ” **ë¹„ë¡€(Proportional)**, **ì ë¶„(Integral)**, **ë¯¸ë¶„(Derivative)** ìš”ì†Œë¥¼ ì´ìš©í•´
   ëª©í‘œê°’ì— ë¹ ë¥´ê³  ì•ˆì •ì ìœ¼ë¡œ ë„ë‹¬í•˜ë„ë¡ ì œì–´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
   ì—¬ê¸°ì„œëŠ” ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì¸ **ë¹„ë¡€ì œì–´(P-ì œì–´)** ì¤‘ì‹¬ìœ¼ë¡œ êµ¬í˜„ì„ ë‹¤ë£¬ë‹¤.

  ìˆ˜ìœ„, ì••ë ¥, ì˜¨ë„, ì†ë„ ë“±ì˜ ì—°ì† ì œì–´ì— ì ìš© ê°€ëŠ¥í•˜ë©°
   ë³¸ ì‹œìŠ¤í…œì—ì„œëŠ” **ëª©í‘œ ìˆ˜ìœ„(target_level)** ì™€ **í˜„ì¬ ìˆ˜ìœ„(measured_level)** ì˜ ì°¨ì´ë¥¼
   ë¹„ë¡€ì ìœ¼ë¡œ íŒí”„ êµ¬ë™ëŸ‰(PWM Duty)ìœ¼ë¡œ í™˜ì‚°í•œë‹¤.

  ------

  ### âš™ï¸ 1. ê¸°ë³¸ ìˆ˜ì‹

  $$
  u(t) = K_p \cdot e(t)
  $$

  - $e(t) = \text{Target} - \text{Measured}$
  - $u(t)$: ì œì–´ ì¶œë ¥ (íŒí”„ PWM, ë°¸ë¸Œ ê°œë„ìœ¨ ë“±)
  - $K_p$: ë¹„ë¡€ ì´ë“ (Gain, ë¯¼ê°ë„ ì¡°ì ˆ)

  > P ì œì–´ì—ì„œëŠ” ì˜¤ì°¨ê°€ 0ì´ ë˜ì–´ì•¼ ì¶œë ¥ì´ 0ì´ ë˜ë¯€ë¡œ,
  >  ì”ë¥˜ ì˜¤ì°¨(Steady-state Error)ê°€ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

  ------

  ### âš¡ 2. ì œì–´ ë£¨í”„ êµ¬ì¡°

  ```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  ëª©í‘œ ìˆ˜ìœ„   â”‚â”€â”€â”
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ e(t)
                     â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  P ì œì–´ê¸° â”‚â”€â”€â–¶ PWM ì¶œë ¥ (u)
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  íŒí”„ / ë°¸ë¸Œ â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  ìˆ˜ìœ„ ì„¼ì„œ â”‚â”€â”€â”€ í”¼ë“œë°±
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ```

  ------

  ### ğŸ”§ 3. ë¹„ë¡€ì œì–´ êµ¬í˜„ ì˜ˆì‹œ

  ```
  float target_level = 100.0f;   // ëª©í‘œ ìˆ˜ìœ„ (mm)
  float measured_level = 0.0f;   // ì„¼ì„œ ì…ë ¥
  float Kp = 2.5f;               // ë¹„ë¡€ ì´ë“
  float control_output = 0.0f;   // PWM Duty (0~100%)
  
  void PID_Control(void)
  {
      float error = target_level - measured_level;
  
      // ë‹¨ìˆœ ë¹„ë¡€ì œì–´
      control_output = Kp * error;
  
      // PWM Duty ì œí•œ
      if (control_output > 100.0f)
          control_output = 100.0f;
      else if (control_output < 0.0f)
          control_output = 0.0f;
  
      Pump_SetPWM(control_output);
  }
  ```

  > ì˜ˆ:
  >
  > - `target_level = 120`, `measured_level = 100`, `Kp = 2.5` â†’ `output = 50%`
  > - ìˆ˜ìœ„ê°€ ê·¼ì ‘í• ìˆ˜ë¡ `error â†“`, íŒí”„ ì¶œë ¥ ìë™ ê°ì†Œ.

  ------

  ### âš™ï¸ 4. ì‹¤ì œ êµ¬ë™ ì‹œ ì£¼ê¸°ì  í˜¸ì¶œ

  ```
  void ControlTask(void *argument)
  {
      for (;;)
      {
          measured_level = Get_Level_mm();
          PID_Control();
          osDelay(500);  // 0.5ì´ˆ ê°„ê²© ì œì–´
      }
  }
  ```

  > FreeRTOS í™˜ê²½ì—ì„œëŠ” **ControlTask** ë‚´ì—ì„œ ì£¼ê¸°ì  ì‹¤í–‰.
  >  Sleep ëª¨ë“œ ê¸°ë°˜ ì‹œìŠ¤í…œì´ë¼ë©´ Wake-up í›„ 1íšŒ ìˆ˜í–‰ í›„ Sleep ì¬ì§„ì….

  ------

  ### ğŸ§  5. Gain íŠœë‹ (Kp ì„¤ì •)

  | Kp ê°’     | íŠ¹ì§•           | í˜„ìƒ                |
  | --------- | -------------- | ------------------- |
  | ë„ˆë¬´ ì‘ìŒ | ë°˜ì‘ ë‘”í•¨      | ëª©í‘œ ìˆ˜ìœ„ ë„ë‹¬ ëŠë¦¼ |
  | ì ì •      | ì•ˆì • ìˆ˜ë ´      | ì •ìƒ ì œì–´           |
  | ë„ˆë¬´ í¼   | ì§„ë™, ì˜¤ë²„ìŠˆíŠ¸ | ìˆ˜ìœ„ê°€ ë°˜ë³µ ë³€ë™    |

  > ì´ˆê¸°ì—ëŠ” ì‘ì€ ê°’(ì˜ˆ: 1.0)ë¶€í„° ì‹œì‘í•˜ì—¬ ì ì§„ì ìœ¼ë¡œ ì¡°ì •í•œë‹¤.
  >  ìµœì  KpëŠ” íŒí”„ ìœ ëŸ‰, íƒ±í¬ ìš©ëŸ‰, ì„¼ì„œ ì‘ë‹µì†ë„ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤.

  ------

  ### ğŸ§® 6. ì œì–´ ì¶œë ¥ ë³€í™˜ (PWM)

  ```
  void Pump_SetPWM(float duty)
  {
      __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, (uint16_t)(duty * 10));
  }
  ```

  - 0â€“100% Duty â†’ 0â€“1000 Timer Compare ê°’ìœ¼ë¡œ ë³€í™˜
  - PWM ì£¼íŒŒìˆ˜: 1~5 kHz ê¶Œì¥ (ëª¨í„° ì§„ë™ ìµœì†Œí™”)

  ------

  ### ğŸ“‰ 7. ë™ì‘ ì˜ˆì‹œ

  | ëª©í‘œ(mm) | ì‹¤ì œ(mm) | ì˜¤ì°¨(mm) | ì¶œë ¥(%) |
  | -------- | -------- | -------- | ------- |
  | 100      | 80       | 20       | 50      |
  | 100      | 90       | 10       | 25      |
  | 100      | 98       | 2        | 5       |
  | 100      | 100      | 0        | 0       |

  > ìˆ˜ìœ„ê°€ ëª©í‘œì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ íŒí”„ ì¶œë ¥ì´ ì ì§„ì ìœ¼ë¡œ ì¤„ì–´ë“œëŠ”
  >  **ì†Œí”„íŠ¸ ì œì–´(Smooth Control)** íŠ¹ì„±ì„ ê°–ëŠ”ë‹¤.

  ------

  ### âš™ï¸ 8. ê°œì„  ë°©í–¥

  | ì¶”ê°€ í•­ëª©        | ì—­í•              | íš¨ê³¼           |
  | ---------------- | ---------------- | -------------- |
  | **I (ì ë¶„ì œì–´)** | ëˆ„ì  ì˜¤ì°¨ ë³´ì •   | ì”ë¥˜ ì˜¤ì°¨ ì œê±° |
  | **D (ë¯¸ë¶„ì œì–´)** | ê¸‰ê²©í•œ ë³€í™” ì–µì œ | ì§„ë™ ì–µì œ      |
  | **Anti-Windup**  | ì ë¶„ ê³¼í¬í™” ë°©ì§€ | ì•ˆì •ì„± í–¥ìƒ    |
  | **Feedforward**  | ì™¸ë€ ì˜ˆì¸¡ ë³´ì •   | ì‘ë‹µì†ë„ ê°œì„   |

  > ì‹¤ì œ ì‚°ì—… ì œì–´ì—ì„œëŠ” PI ë˜ëŠ” PID í˜•íƒœë¡œ í™•ì¥í•˜ì—¬
  >  ì¥ê¸° ì•ˆì •ì„±ê³¼ ì‘ë‹µì„±ì„ í•¨ê»˜ í™•ë³´í•œë‹¤.

  ------

  ### âœ… ê²°ë¡ 

  ê°„ë‹¨í•œ ë¹„ë¡€ì œì–´(P-control)ëŠ”
   ì„¼ì„œ ì…ë ¥ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ íŒí”„/ë°¸ë¸Œ ì œì–´ì˜ **ê°€ì¥ ê¸°ë³¸ì ì´ê³  íš¨ê³¼ì ì¸ ì œì–´ ë°©ì‹**ì´ë‹¤.
   ì„¤ê³„ ì‹œì—ëŠ” Kp ê°’ê³¼ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ë²”ìœ„ë¥¼ ì¡°ì •í•´
   **ìˆ˜ìœ„ ì§„ë™ ìµœì†Œí™”, ì•ˆì •ì  ëª©í‘œ ë„ë‹¬**ì„ ë‹¬ì„±í•´ì•¼ í•œë‹¤.
  $$
  \boxed{u(t) = K_p \cdot (h_{\text{target}} - h_{\text{measured}})}
  $$

- ## íŒí”„ êµ¬ë™ ë° ì°¨ë‹¨

  ### âš™ï¸ ê°œìš”

  íŒí”„ êµ¬ë™(Pump Drive)ì€ **ìˆ˜ìœ„ ì œì–´ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë™ì‘ë¶€**ë¡œ,
   ì„¼ì„œì—ì„œ ì¸¡ì •í•œ ìˆ˜ìœ„ë¥¼ ë°”íƒ•ìœ¼ë¡œ ëª©í‘œ ìˆ˜ìœ„ì— ë§ê²Œ **ìë™ìœ¼ë¡œ ë¬¼ì„ ê³µê¸‰í•˜ê±°ë‚˜ ì°¨ë‹¨**í•œë‹¤.
   ì œì–´ ë°©ì‹ì€ ë‹¨ìˆœí•œ **ì„ê³„ê°’ ê¸°ë°˜ ì˜¨/ì˜¤í”„ ì œì–´** ë˜ëŠ” **ë¹„ë¡€ì œì–´(P-control)**ë¥¼ ì ìš©í•  ìˆ˜ ìˆë‹¤.

  ì‹¤ì œ í•˜ë“œì›¨ì–´ëŠ” **ë¦´ë ˆì´(ì €ì „ë ¥ êµ¬ë™)** ë˜ëŠ” **MOSFET(ê³ ì† ìŠ¤ìœ„ì¹­)** ìœ¼ë¡œ êµ¬ë™ëœë‹¤.

  ------

  ### ğŸ”Œ 1. í•˜ë“œì›¨ì–´ êµ¬ì„±

  | í•­ëª©      | ì„¤ëª…                                   | ë¹„ê³                   |
  | --------- | -------------------------------------- | --------------------- |
  | ì œì–´ í•€   | GPIO ì¶œë ¥                              | ì˜ˆ: PB12              |
  | êµ¬ë™ ì†Œì | NPN íŠ¸ëœì§€ìŠ¤í„°, MOSFET, SSR, ë¦´ë ˆì´ ë“± | ë¡œë“œ ì¢…ë¥˜ì— ë”°ë¼ ì„ íƒ |
  | ë³´í˜¸ ì†Œì | Flyback ë‹¤ì´ì˜¤ë“œ (ë¦´ë ˆì´ ì½”ì¼ ë³´í˜¸ìš©)  | ì—­ì „ì•• ë°©ì§€           |
  | ì „ì›      | 5 V / 12 V / 24 V                      | íŒí”„ ì •ê²©ì— ë”°ë¼ ì„ íƒ |

  **ë¦´ë ˆì´ êµ¬ë™ íšŒë¡œ ì˜ˆì‹œ**

  ```
  MCU GPIO â”€â”¬â”€> NPN íŠ¸ëœì§€ìŠ¤í„° â†’ ë¦´ë ˆì´ ì½”ì¼ â†’ +12V
             â””â”€> Flyback ë‹¤ì´ì˜¤ë“œ (ì—­ì „ì•• ë³´í˜¸)
  ```

  **MOSFET êµ¬ë™ íšŒë¡œ ì˜ˆì‹œ**

  ```
  MCU GPIO â†’ Gate
  Drain â†’ Pump(-)
  Source â†’ GND
  Pump(+) â†’ +12V
  ```

  ------

  ### ğŸ”§ 2. ì œì–´ ë¡œì§

  #### (1) ì„ê³„ê°’ ê¸°ë°˜ ON/OFF ì œì–´

  ```
  #define LEVEL_LOW_THRESHOLD   40.0f   // íŒí”„ ON ê¸°ì¤€(mm)
  #define LEVEL_HIGH_THRESHOLD  90.0f   // íŒí”„ OFF ê¸°ì¤€(mm)
  
  void Pump_Control(float current_level)
  {
      static uint8_t pump_state = 0; // 0:OFF, 1:ON
  
      if (current_level < LEVEL_LOW_THRESHOLD && pump_state == 0)
      {
          HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);  // íŒí”„ ON
          pump_state = 1;
      }
      else if (current_level > LEVEL_HIGH_THRESHOLD && pump_state == 1)
      {
          HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET); // íŒí”„ OFF
          pump_state = 0;
      }
  }
  ```

  > - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤(40 â†” 90 mm)ë¥¼ ë‘ì–´ íŒí”„ê°€ ì§§ì€ ì£¼ê¸°ë¡œ ë°˜ë³µ ON/OFFë˜ì§€ ì•Šë„ë¡ í•¨.
  > - `GPIO_PIN_SET` ìƒíƒœì—ì„œ ë¦´ë ˆì´/íŠ¸ëœì§€ìŠ¤í„°ê°€ êµ¬ë™ë˜ë„ë¡ ì„¤ê³„.

  ------

  #### (2) ë¹„ë¡€ ì œì–´ ê¸°ë°˜ PWM êµ¬ë™

  ```
  float Kp = 2.5f; // ë¹„ë¡€ ì´ë“
  float target_level = 100.0f;
  float control_output = 0.0f;
  
  void Pump_PWM_Control(float measured_level)
  {
      float error = target_level - measured_level;
      control_output = Kp * error;
  
      if (control_output < 0) control_output = 0;
      if (control_output > 100) control_output = 100;
  
      __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, (uint16_t)(control_output * 10)); 
  }
  ```

  > - PWMìœ¼ë¡œ íŒí”„ ì†ë„ë¥¼ ì œì–´í•˜ì—¬ **ìˆ˜ìœ„ ê·¼ì²˜ì—ì„œ ë¶€ë“œëŸ½ê²Œ ê°ì†** ê°€ëŠ¥.
  > - MOSFET ê¸°ë°˜ PWM ì œì–´ íšŒë¡œì—ì„œ ìœ ìš©.

  ------

  ### ğŸ§  3. FreeRTOS Task ì˜ˆì‹œ

  ```
  void PumpTask(void *argument)
  {
      for (;;)
      {
          float level = Get_Level_mm();
  
          #ifdef USE_PWM_CONTROL
              Pump_PWM_Control(level);
          #else
              Pump_Control(level);
          #endif
  
          osDelay(500); // 0.5ì´ˆ ì£¼ê¸°
      }
  }
  ```

  > ì£¼ê¸°ì ìœ¼ë¡œ ìˆ˜ìœ„ë¥¼ í™•ì¸í•˜ì—¬ ìë™ìœ¼ë¡œ êµ¬ë™/ì°¨ë‹¨ ì œì–´ ìˆ˜í–‰.

  ------

  ### âš¡ 4. ìˆ˜ë™ ì œì–´ ì¸í„°í˜ì´ìŠ¤

  UART ë˜ëŠ” BLE ëª…ë ¹ìœ¼ë¡œ ìˆ˜ë™ ì œì–´ ëª¨ë“œë¥¼ ì œê³µí•  ìˆ˜ ìˆë‹¤.

  ```
  void Pump_ManualControl(bool on)
  {
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, on ? GPIO_PIN_SET : GPIO_PIN_RESET);
  }
  ```

  - `"PUMP ON"`, `"PUMP OFF"` ëª…ë ¹ ìˆ˜ì‹  ì‹œ ì§ì ‘ êµ¬ë™
  - ë¹„ìƒ ìƒí™© ë˜ëŠ” ë””ë²„ê¹…ìš©ìœ¼ë¡œ ì‚¬ìš©

  ------

  ### ğŸ§© 5. ë³´í˜¸ ë° ì•ˆì „ ë¡œì§

  | í•­ëª©                   | ë‚´ìš©                                      |
  | ---------------------- | ----------------------------------------- |
  | **Dry-Run ë³´í˜¸**       | ì¼ì • ì‹œê°„ ë™ì•ˆ ìˆ˜ìœ„ ë³€í™” ì—†ìœ¼ë©´ íŒí”„ ì°¨ë‹¨ |
  | **Overcurrent ë³´í˜¸**   | ì „ë¥˜ ì„¼ì„œ ê¸°ë°˜ ê³¼ì „ë¥˜ ê°ì§€ ì‹œ ì°¨ë‹¨        |
  | **Timeout ë³´í˜¸**       | ì¼ì • ì‹œê°„ ì´ìƒ ì—°ì† êµ¬ë™ ì‹œ ìë™ ì •ì§€     |
  | **Low-Voltage Cutoff** | ì „ì› ê°•í•˜ ì‹œ êµ¬ë™ ê¸ˆì§€                    |

  ì˜ˆì‹œ:

  ```
  if (pump_state == 1 && run_time > MAX_PUMP_RUN_TIME)
  {
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
      pump_state = 0;
  }
  ```

  ------

  ### ğŸ“Š 6. ìƒíƒœ ëª¨ë‹ˆí„°ë§

  UART ë¡œê·¸ ë˜ëŠ” OLEDì— íŒí”„ ìƒíƒœ í‘œì‹œ

  ```
  printf("[PUMP] State: %s, Level: %.1f mm\r\n", 
          pump_state ? "ON" : "OFF", current_level);
  ```

  **OLED ì˜ˆì‹œ**

  ```
  PUMP STATUS
  ON
  LEVEL: 58.4mm
  ```

  ------

  ### âœ… ê²°ë¡ 

  íŒí”„ ì œì–´ëŠ”

  - ì„ê³„ê°’ ê¸°ë°˜ ì˜¨/ì˜¤í”„,
  - ë˜ëŠ” ë¹„ë¡€ì œì–´(PWM) ê¸°ë°˜ ì†ë„ ì œì–´ë¡œ êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤.

  ì•ˆì •ì„±ì„ ìœ„í•´ **íˆìŠ¤í…Œë¦¬ì‹œìŠ¤, íƒ€ì„ì•„ì›ƒ, ë³´í˜¸ë¡œì§**ì„ ë°˜ë“œì‹œ ì¶”ê°€í•´ì•¼ í•˜ë©°,
   FreeRTOS í™˜ê²½ì—ì„œëŠ” **PumpTask**ë¡œ ë¶„ë¦¬í•˜ì—¬ ë³‘ë ¬ ì œì–´ ë£¨í”„ë¥¼ êµ¬ì„±í•˜ëŠ” ê²ƒì´ ì´ìƒì ì´ë‹¤.
  $$
  \boxed{\text{Level â†’ Error â†’ Control Output â†’ Pump ON/OFF or PWM}}
  $$

- ## ê²½ë³´ / ìƒíƒœ ëª¨ë‹ˆí„°ë§

  ### âš™ï¸ ê°œìš”

  ê²½ë³´(Alarm) ë° ìƒíƒœ ëª¨ë‹ˆí„°ë§ì€ **ì„¼ì„œ ë°ì´í„° ì´ìƒ ê°ì§€, ì‹œìŠ¤í…œ ì˜¤ë¥˜, í•œê³„ê°’ ì´ˆê³¼ ìƒí™©ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì‹œí•˜ê³  ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ì„ ì œê³µ**í•˜ëŠ” ê¸°ëŠ¥ì´ë‹¤.
   ìˆ˜ìœ„, ë¬´ê²Œ, ì „ì›, í†µì‹  ë“± ë‹¤ì–‘í•œ ìš”ì†Œë¥¼ í†µí•©ì ìœ¼ë¡œ í™•ì¸í•˜ì—¬ **ì•ˆì „í•œ ìë™ì œì–´ ì‹œìŠ¤í…œ**ì„ ìœ ì§€í•œë‹¤.

  ------

  ### ğŸ” 1. ê²½ë³´ ì¡°ê±´ ì •ì˜

  | êµ¬ë¶„                         | ì¡°ê±´                            | ì„¤ëª…                     |
  | ---------------------------- | ------------------------------- | ------------------------ |
  | **ìˆ˜ìœ„ ê³¼ì €í•˜ (Low Level)**  | `level < MIN_LEVEL`             | íƒ±í¬ê°€ ë„ˆë¬´ ë¹„ì–´ ìˆìŒ    |
  | **ìˆ˜ìœ„ ê³¼ì¶©ë§Œ (High Level)** | `level > MAX_LEVEL`             | ì˜¤ë²„í”Œë¡œ ìœ„í—˜            |
  | **ì„¼ì„œ ì˜¤ë¥˜**                | IÂ²C, HX711 Timeout ë°œìƒ         | ì¸¡ì • ì‹¤íŒ¨ ë˜ëŠ” í†µì‹  ë¶ˆëŸ‰ |
  | **íŒí”„ ê³¼êµ¬ë™**              | íŒí”„ ë™ì‘ ì‹œê°„ > `MAX_RUN_TIME` | ë“œë¼ì´ëŸ° ë˜ëŠ” ê³ ì°© ìœ„í—˜  |
  | **RTC ì•ŒëŒ ë¯¸ë™ì‘**          | ì¼ì • ì£¼ê¸° ë‚´ ë¯¸ê¸°ë™             | íƒ€ì´ë¨¸ ì˜¤ë¥˜ ê°€ëŠ¥ì„±       |
  | **ì „ì› ë¶ˆì•ˆì •**              | ì „ì•• < 4.5V (ì˜ˆì‹œ)              | ì „ì› ë¶€ì¡±                |

  ------

  ### âš ï¸ 2. ê²½ë³´ ìƒíƒœ êµ¬ì¡°ì²´

  ```
  typedef struct {
      uint8_t low_level;
      uint8_t high_level;
      uint8_t sensor_error;
      uint8_t pump_timeout;
      uint8_t power_fault;
  } AlarmFlags_t;
  
  AlarmFlags_t alarm_flags = {0};
  ```

  > ê°œë³„ ê²½ë³´ëŠ” í”Œë˜ê·¸ ë‹¨ìœ„ë¡œ ê´€ë¦¬ë˜ì–´, LED, OLED, BLE ë“±ìœ¼ë¡œ ì†ì‰½ê²Œ í‘œì‹œ ê°€ëŠ¥.

  ------

  ### ğŸ§® 3. ê²½ë³´ íŒì • ë£¨í‹´

  ```
  #define MIN_LEVEL 20.0f
  #define MAX_LEVEL 120.0f
  #define MAX_PUMP_RUN_TIME 30000 // 30ì´ˆ
  
  void Alarm_Check(float level, uint8_t sensor_ok, uint32_t pump_run_time)
  {
      alarm_flags.low_level   = (level < MIN_LEVEL);
      alarm_flags.high_level  = (level > MAX_LEVEL);
      alarm_flags.sensor_error = !sensor_ok;
      alarm_flags.pump_timeout = (pump_run_time > MAX_PUMP_RUN_TIME);
  }
  ```

  > ë§¤ ì£¼ê¸°ë§ˆë‹¤ ì¸¡ì •ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ê²½ë³´ ì¡°ê±´ì„ ì¬í‰ê°€.

  ------

  ### ğŸ’¡ 4. ì‹œê°/ìŒì„± ì•Œë¦¼

  #### (1) LED í‘œì‹œ

  ```
  void LED_Alarm_Display(void)
  {
      if (alarm_flags.low_level)
          HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); // ë¹¨ê°• LED ON
      else
          HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
  
      if (alarm_flags.high_level)
          HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); // í™©ìƒ‰ LED ì ë©¸
  }
  ```

  #### (2) ë¶€ì € ê²½ë³´

  ```
  void Buzzer_Alarm(void)
  {
      if (alarm_flags.high_level || alarm_flags.sensor_error)
      {
          HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
          HAL_Delay(200);
          HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
      }
  }
  ```

  #### (3) OLED / UART ì¶œë ¥

  ```
  void Display_Alarm_Status(void)
  {
      printf("[ALARM] ");
      if (alarm_flags.low_level)   printf("LOW ");
      if (alarm_flags.high_level)  printf("HIGH ");
      if (alarm_flags.sensor_error) printf("SENSOR ");
      if (alarm_flags.pump_timeout) printf("TIMEOUT ");
      printf("\r\n");
  }
  ```

  **OLED ì˜ˆì‹œ í™”ë©´**

  ```
  ALARM STATUS
  HIGH LEVEL !!
  PUMP TIMEOUT
  ```

  ------

  ### ğŸ”„ 5. FreeRTOS ê¸°ë°˜ ëª¨ë‹ˆí„°ë§ Task

  ```
  void AlarmTask(void *argument)
  {
      for (;;)
      {
          float level = Get_Level_mm();
          uint8_t sensor_ok = Check_Sensor_Status();
          uint32_t pump_time = Get_Pump_RunTime();
  
          Alarm_Check(level, sensor_ok, pump_time);
          LED_Alarm_Display();
          Display_Alarm_Status();
  
          osDelay(1000); // 1ì´ˆ ì£¼ê¸° í™•ì¸
      }
  }
  ```

  > ê²½ë³´ íŒì •, ì‹œê°í™”, ë¡œê·¸ ì „ì†¡ì„ ì£¼ê¸°ì ìœ¼ë¡œ ìˆ˜í–‰.

  ------

  ### ğŸ“¶ 6. ì›ê²© ëª¨ë‹ˆí„°ë§ (BLE / UART / IoT ì—°ë™)

  #### (1) BLE / UART ì „ì†¡ í”„ë ˆì„ ì˜ˆì‹œ

  ```
  typedef struct {
      float level;
      float weight;
      uint8_t pump_state;
      AlarmFlags_t alarm;
  } SystemStatus_t;
  ```

  BLEë‚˜ UARTë¥¼ í†µí•´ ì‹¤ì‹œê°„ ìƒíƒœë¥¼ ì™¸ë¶€ë¡œ ì†¡ì‹ 

  ```
  [STATUS]
  LEVEL=58.3mm
  WEIGHT=4.12kg
  PUMP=ON
  ALARM=HIGH_LEVEL
  ```

  #### (2) IoT í™•ì¥ (MQTT or HTTP)

  - ESP32 ë˜ëŠ” STM32+ESP ëª¨ë“ˆì„ í†µí•´ í´ë¼ìš°ë“œë¡œ ì „ì†¡ ê°€ëŠ¥
  - ì£¼ê¸°ì  ìƒíƒœ ì—…ë¡œë“œ + ê²½ë³´ ì‹œ ì¦‰ì‹œ í‘¸ì‹œ ê°€ëŠ¥

  ------

  ### ğŸ§  7. ê²½ë³´ ë³µêµ¬ ë° ì´ˆê¸°í™”

  ê²½ë³´ê°€ í•´ì œë˜ë©´ ìë™ìœ¼ë¡œ ë³µê·€í•˜ê±°ë‚˜, ìˆ˜ë™ ë¦¬ì…‹ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„.

  ```
  void Alarm_Reset(void)
  {
      memset(&alarm_flags, 0, sizeof(alarm_flags));
  }
  ```

  > ì˜ˆ: ë²„íŠ¼ ì…ë ¥, BLE ëª…ë ¹ `"RESET ALARM"` ìˆ˜ì‹  ì‹œ í˜¸ì¶œ

  ------

  ### âœ… ê²°ë¡ 

  ê²½ë³´ ë° ìƒíƒœ ëª¨ë‹ˆí„°ë§ì€

  - **ì•ˆì „ì„± í™•ë³´**,
  - **ì‹¤ì‹œê°„ ì§„ë‹¨**,
  - **ì›ê²© ì•Œë¦¼ ì—°ê³„**ë¥¼ ìœ„í•œ í•µì‹¬ ìš”ì†Œì´ë‹¤.

  ë‹¤ìŒê³¼ ê°™ì€ íë¦„ìœ¼ë¡œ êµ¬ì„±ëœë‹¤:
  $$
  \boxed{
  ì„¼ì„œ ë°ì´í„° â†’ ì´ìƒ ê°ì§€ â†’ ê²½ë³´ í”Œë˜ê·¸ ì„¤ì • â†’ ì‹œê°/ìŒì„± ì•Œë¦¼ â†’ ì „ì†¡ â†’ ë³µêµ¬
  }
  $$

  ------

  ğŸ’¬ **ì¶”ì²œ í™•ì¥**

  - RTC ë¡œê·¸ì— ê²½ë³´ ë°œìƒ ì‹œê° ì €ì¥
  - OLED í™”ë©´ ìë™ ì „í™˜ (ì •ìƒ â†” ê²½ë³´ ìƒíƒœ)
  - BLE Notification ê¸°ëŠ¥ìœ¼ë¡œ ëª¨ë°”ì¼ ê²½ê³  ì—°ë™